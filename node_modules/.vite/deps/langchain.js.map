{
  "version": 3,
  "sources": ["browser-external:node:async_hooks", "../../langchain/dist/_virtual/rolldown_runtime.js", "../../@langchain/core/src/messages/transformers.ts", "../../@langchain/core/src/messages/content/tools.ts", "../../@langchain/core/src/messages/content/multimodal.ts", "../../@langchain/core/src/messages/content/index.ts", "../../@langchain/core/dist/messages/index.js", "../../@langchain/core/src/prompt_values.ts", "../../@langchain/core/src/utils/js-sha256/hash.ts", "../../@langchain/core/dist/utils/hash.js", "../../@langchain/core/src/caches/index.ts", "../../@langchain/core/src/language_models/base.ts", "../../@langchain/core/src/runnables/passthrough.ts", "../../@langchain/core/src/language_models/utils.ts", "../../@langchain/core/src/language_models/chat_models.ts", "../../@langchain/core/src/runnables/router.ts", "../../@langchain/core/src/runnables/branch.ts", "../../@langchain/core/src/runnables/history.ts", "../../@langchain/core/dist/runnables/index.js", "../../langchain/src/chat_models/universal.ts", "../../@langchain/langgraph/src/setup/async_local_storage.ts", "../../@langchain/langgraph/src/errors.ts", "../../@langchain/langgraph-checkpoint/src/id.ts", "../../@langchain/langgraph-checkpoint/src/serde/types.ts", "../../@langchain/langgraph-checkpoint/src/serde/utils/fast-safe-stringify/index.ts", "../../@langchain/core/src/load/import_constants.ts", "../../@langchain/core/dist/agents.js", "../../@langchain/core/src/chat_history.ts", "../../@langchain/core/src/embeddings.ts", "../../@langchain/core/dist/index.js", "../../@langchain/core/src/memory.ts", "../../@langchain/core/src/stores.ts", "../../@langchain/core/src/retrievers/index.ts", "../../@langchain/core/src/vectorstores.ts", "../../@langchain/core/src/document_loaders/base.ts", "../../@langchain/core/src/document_loaders/langsmith.ts", "../../@langchain/core/src/example_selectors/base.ts", "../../@langchain/core/src/example_selectors/conditional.ts", "../../@langchain/core/src/example_selectors/length_based.ts", "../../@langchain/core/src/example_selectors/semantic_similarity.ts", "../../@langchain/core/dist/example_selectors/index.js", "../../@langchain/core/src/indexing/record_manager.ts", "../../@langchain/core/src/indexing/base.ts", "../../@langchain/core/dist/indexing/index.js", "../../@langchain/core/src/language_models/llms.ts", "../../@langchain/core/dist/language_models/profile.js", "../../@langchain/core/dist/utils/json_patch.js", "../../@langchain/core/src/output_parsers/base.ts", "../../@langchain/core/src/output_parsers/transform.ts", "../../@langchain/core/src/output_parsers/bytes.ts", "../../@langchain/core/src/output_parsers/list.ts", "../../@langchain/core/src/output_parsers/string.ts", "../../@langchain/core/src/output_parsers/structured.ts", "../../@langchain/core/src/output_parsers/json.ts", "../../@langchain/core/src/utils/sax-js/sax.ts", "../../@langchain/core/src/output_parsers/xml.ts", "../../@langchain/core/dist/output_parsers/index.js", "../../@langchain/core/src/output_parsers/openai_functions/json_output_functions_parsers.ts", "../../@langchain/core/dist/output_parsers/openai_functions/index.js", "../../@langchain/core/src/output_parsers/openai_tools/json_output_tools_parsers.ts", "../../@langchain/core/dist/output_parsers/openai_tools/index.js", "../../@langchain/core/src/prompts/base.ts", "../../@langchain/core/src/prompts/string.ts", "../../mustache/mustache.mjs", "../../@langchain/core/src/prompts/template.ts", "../../@langchain/core/src/prompts/prompt.ts", "../../@langchain/core/src/prompts/image.ts", "../../@langchain/core/src/prompts/dict.ts", "../../@langchain/core/src/prompts/chat.ts", "../../@langchain/core/src/prompts/few_shot.ts", "../../@langchain/core/src/prompts/pipeline.ts", "../../@langchain/core/src/prompts/structured.ts", "../../@langchain/core/dist/prompts/index.js", "../../@langchain/core/src/retrievers/document_compressors/index.ts", "../../@langchain/core/src/structured_query/ir.ts", "../../@langchain/core/src/structured_query/utils.ts", "../../@langchain/core/src/structured_query/base.ts", "../../@langchain/core/src/structured_query/functional.ts", "../../@langchain/core/dist/structured_query/index.js", "../../@langchain/core/src/tools/types.ts", "../../zod/v4/classic/external.js", "../../zod/v4/classic/schemas.js", "../../zod/v4/classic/checks.js", "../../zod/v4/classic/iso.js", "../../zod/v4/classic/errors.js", "../../zod/v4/classic/parse.js", "../../zod/v4/classic/compat.js", "../../zod/v4/classic/from-json-schema.js", "../../zod/v4/classic/coerce.js", "../../@langchain/core/src/tools/index.ts", "../../@langchain/core/src/tracers/run_collector.ts", "../../@langchain/core/dist/types/stream.js", "../../@langchain/core/src/utils/chunk_array.ts", "../../@langchain/core/src/utils/context.ts", "../../@langchain/core/src/utils/event_source_parse.ts", "../../@langchain/core/dist/utils/format.js", "../../@langchain/core/src/utils/function_calling.ts", "../../@langchain/core/src/utils/ml-distance/similarities.ts", "../../@langchain/core/src/utils/ml-distance/distances.ts", "../../@langchain/core/src/utils/ml-distance-euclidean/euclidean.ts", "../../@langchain/core/src/utils/math.ts", "../../@langchain/core/src/utils/testing/chat_models.ts", "../../@langchain/core/src/utils/testing/embeddings.ts", "../../@langchain/core/src/utils/testing/llms.ts", "../../@langchain/core/src/utils/testing/message_history.ts", "../../@langchain/core/src/utils/testing/output_parsers.ts", "../../@langchain/core/src/utils/testing/retrievers.ts", "../../@langchain/core/src/utils/testing/runnables.ts", "../../@langchain/core/src/utils/testing/tools.ts", "../../@langchain/core/src/utils/testing/tracers.ts", "../../@langchain/core/src/utils/testing/vectorstores.ts", "../../@langchain/core/dist/utils/testing/index.js", "../../@langchain/core/dist/utils/types/index.js", "../../@langchain/core/dist/load/import_map.js", "../../@langchain/core/src/load/index.ts", "../../@langchain/langgraph-checkpoint/src/serde/jsonplus.ts", "../../@langchain/langgraph-checkpoint/src/base.ts", "../../@langchain/langgraph-checkpoint/src/store/base.ts", "../../@langchain/langgraph-checkpoint/src/store/batch.ts", "../../@langchain/langgraph-checkpoint/src/cache/base.ts", "../../@langchain/langgraph/src/channels/base.ts", "../../@langchain/langgraph/src/channels/binop.ts", "../../@langchain/langgraph/src/channels/last_value.ts", "../../@langchain/langgraph/src/graph/annotation.ts", "../../@langchain/langgraph/src/constants.ts", "../../@langchain/langgraph/src/pregel/utils/config.ts", "../../@langchain/langgraph/src/hash.ts", "../../@langchain/langgraph/src/interrupt.ts", "../../@langchain/langgraph/src/utils.ts", "../../@langchain/langgraph/src/pregel/write.ts", "../../@langchain/langgraph/src/pregel/read.ts", "../../@langchain/langgraph/src/pregel/utils/subgraph.ts", "../../@langchain/langgraph/src/pregel/io.ts", "../../@langchain/langgraph/src/pregel/utils/index.ts", "../../@langchain/langgraph/src/pregel/types.ts", "../../@langchain/langgraph/src/pregel/call.ts", "../../@langchain/langgraph/src/pregel/algo.ts", "../../@langchain/langgraph/src/pregel/debug.ts", "../../@langchain/langgraph/src/pregel/stream.ts", "../../@langchain/langgraph/src/pregel/loop.ts", "../../@langchain/langgraph/src/pregel/messages.ts", "../../@langchain/langgraph/src/pregel/retry.ts", "../../@langchain/langgraph/src/pregel/runner.ts", "../../@langchain/langgraph/src/pregel/validate.ts", "../../@langchain/langgraph/src/channels/topic.ts", "../../@langchain/langgraph/src/pregel/index.ts", "../../@langchain/langgraph/src/channels/ephemeral_value.ts", "../../@langchain/langgraph/src/graph/graph.ts", "../../@langchain/langgraph/src/state/types.ts", "../../@langchain/langgraph/src/state/adapter.ts", "../../@langchain/langgraph/src/channels/untracked_value.ts", "../../@langchain/langgraph/src/state/values/reduced.ts", "../../@langchain/langgraph/src/state/values/untracked.ts", "../../@langchain/langgraph/src/channels/named_barrier_value.ts", "../../@langchain/langgraph/src/state/schema.ts", "../../@langchain/langgraph/src/graph/messages_reducer.ts", "../../@langchain/langgraph/src/state/prebuilt/messages.ts", "../../@langchain/langgraph/src/graph/zod/meta.ts", "../../@langchain/langgraph/src/graph/types.ts", "../../@langchain/langgraph/src/graph/state.ts", "../../@langchain/langgraph/src/func/index.ts", "../../@langchain/langgraph/src/graph/messages_annotation.ts", "../../@langchain/langgraph/src/index.ts", "../../langchain/src/agents/errors.ts", "../../langchain/src/agents/model.ts", "../../langchain/src/agents/responses.ts", "../../langchain/src/agents/middleware/utils.ts", "../../langchain/src/agents/middleware/types.ts", "../../langchain/src/agents/middleware.ts", "../../langchain/src/agents/tests/utils.ts", "../../@langchain/langgraph/src/graph/zod/plugin.ts", "../../@langchain/langgraph/src/graph/zod/zod-registry.ts", "../../langchain/src/agents/annotation.ts", "../../langchain/src/agents/utils.ts", "../../langchain/src/agents/nodes/utils.ts", "../../langchain/src/agents/RunnableCallable.ts", "../../langchain/src/agents/withAgentName.ts", "../../langchain/src/agents/nodes/AgentNode.ts", "../../langchain/src/agents/nodes/ToolNode.ts", "../../langchain/src/agents/nodes/middleware.ts", "../../langchain/src/agents/nodes/BeforeAgentNode.ts", "../../langchain/src/agents/nodes/BeforeModelNode.ts", "../../langchain/src/agents/nodes/AfterModelNode.ts", "../../langchain/src/agents/nodes/AfterAgentNode.ts", "../../langchain/src/agents/state.ts", "../../langchain/src/agents/ReactAgent.ts", "../../langchain/src/agents/index.ts", "../../langchain/src/agents/middleware/hitl.ts", "../../langchain/src/agents/middleware/summarization.ts", "../../langchain/src/agents/middleware/dynamicSystemPrompt.ts", "../../langchain/src/agents/middleware/llmToolSelector.ts", "../../langchain/src/agents/middleware/pii.ts", "../../langchain/src/agents/middleware/piiRedaction.ts", "../../langchain/src/agents/middleware/contextEditing.ts", "../../langchain/src/agents/middleware/toolCallLimit.ts", "../../langchain/src/agents/middleware/todoListMiddleware.ts", "../../langchain/src/agents/middleware/modelCallLimit.ts", "../../langchain/src/agents/middleware/modelFallback.ts", "../../langchain/src/agents/middleware/constants.ts", "../../langchain/src/agents/middleware/error.ts", "../../langchain/src/agents/middleware/modelRetry.ts", "../../langchain/src/agents/middleware/toolRetry.ts", "../../langchain/src/agents/middleware/toolEmulator.ts", "../../langchain/src/agents/middleware/provider/openai/moderation.ts", "../../langchain/src/agents/middleware/provider/anthropic/promptCaching.ts", "../../langchain/dist/index.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"node:async_hooks\" has been externalized for browser compatibility. Cannot access \"node:async_hooks.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n\tfor (var name in all) __defProp(target, name, {\n\t\tget: all[name],\n\t\tenumerable: true\n\t});\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\tkey = keys[i];\n\t\tif (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t});\n\t}\n\treturn to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n//#endregion\nexport { __export, __reExport };", "import { BaseDocumentTransformer } from \"../documents/transformers.js\";\nimport { BaseLanguageModel } from \"../language_models/base.js\";\nimport { Runnable, RunnableLambda } from \"../runnables/base.js\";\nimport { AIMessage, AIMessageChunk, AIMessageChunkFields } from \"./ai.js\";\nimport {\n  BaseMessage,\n  BaseMessageChunk,\n  BaseMessageFields,\n  isBaseMessageChunk,\n} from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk, ChatMessageFields } from \"./chat.js\";\nimport {\n  FunctionMessage,\n  FunctionMessageChunk,\n  FunctionMessageFields,\n} from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { MessageType } from \"./message.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage, ToolMessageChunk, ToolMessageFields } from \"./tool.js\";\nimport { convertToChunk } from \"./utils.js\";\n\nexport type MessageUnion =\n  | typeof HumanMessage\n  | typeof AIMessage\n  | typeof SystemMessage\n  | typeof ChatMessage\n  | typeof FunctionMessage\n  | typeof ToolMessage\n  | typeof RemoveMessage;\nexport type MessageChunkUnion =\n  | typeof HumanMessageChunk\n  | typeof AIMessageChunk\n  | typeof SystemMessageChunk\n  | typeof FunctionMessageChunk\n  | typeof ToolMessageChunk\n  | typeof ChatMessageChunk\n  | typeof RemoveMessage; // RemoveMessage does not have a chunk class.\nexport type MessageTypeOrClass = MessageType | MessageUnion | MessageChunkUnion;\n\nconst _isMessageType = (msg: BaseMessage, types: MessageTypeOrClass[]) => {\n  const typesAsStrings = [\n    ...new Set<string>(\n      types?.map((t) => {\n        if (typeof t === \"string\") {\n          return t;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const instantiatedMsgClass = new (t as any)({});\n        if (\n          !(\"getType\" in instantiatedMsgClass) ||\n          typeof instantiatedMsgClass.getType !== \"function\"\n        ) {\n          throw new Error(\"Invalid type provided.\");\n        }\n        return instantiatedMsgClass.getType();\n      })\n    ),\n  ];\n  const msgType = msg.getType();\n  return typesAsStrings.some((t) => t === msgType);\n};\n\nexport interface FilterMessagesFields {\n  /**\n   * @param {string[] | undefined} includeNames Message names to include.\n   */\n  includeNames?: string[];\n  /**\n   * @param {string[] | undefined} excludeNames Messages names to exclude.\n   */\n  excludeNames?: string[];\n  /**\n   * @param {(MessageType | BaseMessage)[] | undefined} includeTypes Message types to include. Can be specified as string names (e.g.\n   *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n   *     SystemMessage, HumanMessage, AIMessage, ...).\n   */\n  includeTypes?: MessageTypeOrClass[];\n  /**\n   * @param {(MessageType | BaseMessage)[] | undefined} excludeTypes Message types to exclude. Can be specified as string names (e.g.\n   *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n   *     SystemMessage, HumanMessage, AIMessage, ...).\n   */\n  excludeTypes?: MessageTypeOrClass[];\n  /**\n   * @param {string[] | undefined} includeIds Message IDs to include.\n   */\n  includeIds?: string[];\n  /**\n   * @param {string[] | undefined} excludeIds Message IDs to exclude.\n   */\n  excludeIds?: string[];\n}\n\n/**\n * Filter messages based on name, type or id.\n *\n * @param {BaseMessage[] | FilterMessagesFields} messagesOrOptions - Either an array of BaseMessage objects to filter or the filtering options. If an array is provided, the `options` parameter should also be supplied. If filtering options are provided, a RunnableLambda is returned.\n * @param {FilterMessagesFields} [options] - Optional filtering options. Should only be provided if `messagesOrOptions` is an array of BaseMessage objects.\n * @returns A list of Messages that meets at least one of the include conditions and none\n *     of the exclude conditions, or a RunnableLambda which does the same. If no include conditions are specified then\n *     anything that is not explicitly excluded will be included.\n * @throws {Error} If two incompatible arguments are provided.\n *\n * @example\n * ```typescript\n * import { filterMessages, AIMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n *   new AIMessage({ content: \"steve-o\", id: \"bar\", name: \"example_assistant\" }),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"baz\" }),\n *   new AIMessage({ content: \"silicon blue\" , id: \"blah\" }),\n * ];\n *\n * filterMessages(messages, {\n *   includeNames: [\"example_user\", \"example_assistant\"],\n *   includeTypes: [\"system\"],\n *   excludeIds: [\"bar\"],\n * });\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n * ]\n * ```\n */\nexport function filterMessages(\n  options?: FilterMessagesFields\n): Runnable<BaseMessage[], BaseMessage[]>;\nexport function filterMessages(\n  messages: BaseMessage[],\n  options?: FilterMessagesFields\n): BaseMessage[];\nexport function filterMessages(\n  messagesOrOptions?: BaseMessage[] | FilterMessagesFields,\n  options?: FilterMessagesFields\n): BaseMessage[] | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messagesOrOptions)) {\n    return _filterMessages(messagesOrOptions, options);\n  }\n  return RunnableLambda.from((input: BaseMessage[]): BaseMessage[] => {\n    return _filterMessages(input, messagesOrOptions);\n  });\n}\n\nfunction _filterMessages(\n  messages: BaseMessage[],\n  options: FilterMessagesFields = {}\n): BaseMessage[] {\n  const {\n    includeNames,\n    excludeNames,\n    includeTypes,\n    excludeTypes,\n    includeIds,\n    excludeIds,\n  } = options;\n\n  const filtered: BaseMessage[] = [];\n\n  for (const msg of messages) {\n    if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n      continue;\n    } else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n      continue;\n    } else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n      continue;\n    }\n\n    // default to inclusion when no inclusion criteria given.\n    if (!(includeTypes || includeIds || includeNames)) {\n      filtered.push(msg);\n    } else if (\n      includeNames &&\n      msg.name &&\n      includeNames.some((iName) => iName === msg.name)\n    ) {\n      filtered.push(msg);\n    } else if (includeTypes && _isMessageType(msg, includeTypes)) {\n      filtered.push(msg);\n    } else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n      filtered.push(msg);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Merge consecutive Messages of the same type.\n *\n * **NOTE**: ToolMessages are not merged, as each has a distinct tool call id that\n * can't be merged.\n *\n * @param {BaseMessage[] | undefined} messages Sequence of Message-like objects to merge. Optional. If not provided, a RunnableLambda is returned.\n * @returns List of BaseMessages with consecutive runs of message types merged into single\n *     messages, or a RunnableLambda which returns a list of BaseMessages If two messages being merged both have string contents, the merged\n *     content is a concatenation of the two strings with a new-line separator. If at\n *     least one of the messages has a list of content blocks, the merged content is a\n *     list of content blocks.\n *\n * @example\n * ```typescript\n * import { mergeMessageRuns, AIMessage, HumanMessage, SystemMessage, ToolCall } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"foo\" }),\n *   new HumanMessage({ content: \"wait your favorite food\", id: \"bar\" }),\n *   new AIMessage({\n *     content: \"my favorite colo\",\n *     tool_calls: [{ name: \"blah_tool\", args: { x: 2 }, id: \"123\" }],\n *     id: \"baz\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"my favorite dish is lasagna\" }],\n *     tool_calls: [{ name: \"blah_tool\", args: { x: -10 }, id: \"456\" }],\n *     id: \"blur\",\n *   }),\n * ];\n *\n * mergeMessageRuns(messages);\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({\n *     content: \"what's your favorite colorwait your favorite food\",\n *     id: \"foo\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"my favorite colo\" },\n *       { type: \"text\", text: \"my favorite dish is lasagna\" },\n *     ],\n *     tool_calls: [\n *       { name: \"blah_tool\", args: { x: 2 }, id: \"123\" },\n *       { name: \"blah_tool\", args: { x: -10 }, id: \"456\" },\n *     ],\n *     id: \"baz\",\n *   }),\n * ]\n * ```\n */\nexport function mergeMessageRuns(): Runnable<BaseMessage[], BaseMessage[]>;\nexport function mergeMessageRuns(messages: BaseMessage[]): BaseMessage[];\nexport function mergeMessageRuns(\n  messages?: BaseMessage[]\n): BaseMessage[] | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messages)) {\n    return _mergeMessageRuns(messages);\n  }\n  return RunnableLambda.from(_mergeMessageRuns);\n}\n\nfunction _mergeMessageRuns(messages: BaseMessage[]): BaseMessage[] {\n  if (!messages.length) {\n    return [];\n  }\n  const merged: BaseMessage[] = [];\n  for (const msg of messages) {\n    const curr = msg;\n    const last = merged.pop();\n    if (!last) {\n      merged.push(curr);\n    } else if (\n      curr.getType() === \"tool\" ||\n      !(curr.getType() === last.getType())\n    ) {\n      merged.push(last, curr);\n    } else {\n      const lastChunk = convertToChunk(last) as BaseMessageChunk;\n      const currChunk = convertToChunk(curr) as BaseMessageChunk;\n      const mergedChunks = lastChunk.concat(currChunk);\n      if (\n        typeof lastChunk.content === \"string\" &&\n        typeof currChunk.content === \"string\"\n      ) {\n        mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n      }\n      merged.push(_chunkToMsg(mergedChunks));\n    }\n  }\n  return merged;\n}\n\n// Since we can not import from `@langchain/textsplitters` we need\n// to reconstruct the interface here.\ninterface _TextSplitterInterface extends BaseDocumentTransformer {\n  splitText(text: string): Promise<string[]>;\n}\n\nexport interface TrimMessagesFields {\n  /**\n   * @param {number} maxTokens Max token count of trimmed messages.\n   */\n  maxTokens: number;\n  /**\n   * @param {((messages: BaseMessage[]) => number) | ((messages: BaseMessage[]) => Promise<number>) | BaseLanguageModel} tokenCounter\n   * Function or LLM for counting tokens in an array of `BaseMessage`s.\n   * If a `BaseLanguageModel` is passed in then `BaseLanguageModel.getNumTokens()` will be used.\n   */\n  tokenCounter:\n    | ((messages: BaseMessage[]) => number)\n    | ((messages: BaseMessage[]) => Promise<number>)\n    | BaseLanguageModel;\n  /**\n   * @param {\"first\" | \"last\"} [strategy=\"last\"] Strategy for trimming.\n   * - \"first\": Keep the first <= n_count tokens of the messages.\n   * - \"last\": Keep the last <= n_count tokens of the messages.\n   * @default \"last\"\n   */\n  strategy?: \"first\" | \"last\";\n  /**\n   * @param {boolean} [allowPartial=false] Whether to split a message if only part of the message can be included.\n   * If `strategy: \"last\"` then the last partial contents of a message are included.\n   * If `strategy: \"first\"` then the first partial contents of a message are included.\n   * @default false\n   */\n  allowPartial?: boolean;\n  /**\n   * @param {MessageTypeOrClass | MessageTypeOrClass[]} [endOn] The message type to end on.\n   * If specified then every message after the last occurrence of this type is ignored.\n   * If `strategy === \"last\"` then this is done before we attempt to get the last `maxTokens`.\n   * If `strategy === \"first\"` then this is done after we get the first `maxTokens`.\n   * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n   * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n   */\n  endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  /**\n   * @param {MessageTypeOrClass | MessageTypeOrClass[]} [startOn] The message type to start on.\n   * Should only be specified if `strategy: \"last\"`. If specified then every message before the first occurrence\n   * of this type is ignored. This is done after we trim the initial messages to the last `maxTokens`.\n   * Does not apply to a `SystemMessage` at index 0 if `includeSystem: true`.\n   * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n   * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n   */\n  startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  /**\n   * @param {boolean} [includeSystem=false] Whether to keep the `SystemMessage` if there is one at index 0.\n   * Should only be specified if `strategy: \"last\"`.\n   * @default false\n   */\n  includeSystem?: boolean;\n  /**\n   * @param {((text: string) => string[]) | BaseDocumentTransformer} [textSplitter] Function or `BaseDocumentTransformer` for\n   * splitting the string contents of a message. Only used if `allowPartial: true`.\n   * If `strategy: \"last\"` then the last split tokens from a partial message will be included.\n   * If `strategy: \"first\"` then the first split tokens from a partial message will be included.\n   * Token splitter assumes that separators are kept, so that split contents can be directly concatenated\n   * to recreate the original text. Defaults to splitting on newlines.\n   */\n  textSplitter?:\n    | ((text: string) => string[])\n    | ((text: string) => Promise<string[]>)\n    | _TextSplitterInterface;\n}\n\n/**\n * Trim messages to be below a token count.\n *\n * @param {BaseMessage[]} messages Array of `BaseMessage` instances to trim.\n * @param {TrimMessagesFields} options Trimming options.\n * @returns An array of trimmed `BaseMessage`s or a `Runnable` that takes a sequence of `BaseMessage`-like objects and returns\n *     an array of trimmed `BaseMessage`s.\n * @throws {Error} If two incompatible arguments are specified or an unrecognized `strategy` is specified.\n *\n * @example\n * ```typescript\n * import { trimMessages, AIMessage, BaseMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"This is a 4 token text. The full message is 10 tokens.\"),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"This is the FIRST 4 token block.\" },\n *       { type: \"text\", text: \"This is the SECOND 4 token block.\" },\n *     ],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ];\n *\n * function dummyTokenCounter(messages: BaseMessage[]): number {\n *   // treat each message like it adds 3 default tokens at the beginning\n *   // of the message and at the end of the message. 3 + 4 + 3 = 10 tokens\n *   // per message.\n *\n *   const defaultContentLen = 4;\n *   const defaultMsgPrefixLen = 3;\n *   const defaultMsgSuffixLen = 3;\n *\n *   let count = 0;\n *   for (const msg of messages) {\n *     if (typeof msg.content === \"string\") {\n *       count += defaultMsgPrefixLen + defaultContentLen + defaultMsgSuffixLen;\n *     }\n *     if (Array.isArray(msg.content)) {\n *       count +=\n *         defaultMsgPrefixLen +\n *         msg.content.length * defaultContentLen +\n *         defaultMsgSuffixLen;\n *     }\n *   }\n *   return count;\n * }\n * ```\n *\n * First 30 tokens, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages, have to end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n *   endOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   includeSystem: true,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   allowPartial: true,\n *   includeSystem: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, allowing partial messages, end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   endOn: \"human\",\n *   includeSystem: true,\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages, start on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   includeSystem: true,\n *   allowPartial: true,\n *   startOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n */\nexport function trimMessages(\n  options: TrimMessagesFields\n): Runnable<BaseMessage[], BaseMessage[]>;\nexport function trimMessages(\n  messages: BaseMessage[],\n  options: TrimMessagesFields\n): Promise<BaseMessage[]>;\nexport function trimMessages(\n  messagesOrOptions: BaseMessage[] | TrimMessagesFields,\n  options?: TrimMessagesFields\n): Promise<BaseMessage[]> | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messagesOrOptions)) {\n    const messages = messagesOrOptions;\n    if (!options) {\n      throw new Error(\"Options parameter is required when providing messages.\");\n    }\n    return _trimMessagesHelper(messages, options);\n  } else {\n    const trimmerOptions = messagesOrOptions;\n    return RunnableLambda.from((input: BaseMessage[]) =>\n      _trimMessagesHelper(input, trimmerOptions)\n    ).withConfig({\n      runName: \"trim_messages\",\n    });\n  }\n}\n\nasync function _trimMessagesHelper(\n  messages: BaseMessage[],\n  options: TrimMessagesFields\n): Promise<Array<BaseMessage>> {\n  const {\n    maxTokens,\n    tokenCounter,\n    strategy = \"last\",\n    allowPartial = false,\n    endOn,\n    startOn,\n    includeSystem = false,\n    textSplitter,\n  } = options;\n  if (startOn && strategy === \"first\") {\n    throw new Error(\n      \"`startOn` should only be specified if `strategy` is 'last'.\"\n    );\n  }\n  if (includeSystem && strategy === \"first\") {\n    throw new Error(\n      \"`includeSystem` should only be specified if `strategy` is 'last'.\"\n    );\n  }\n\n  let listTokenCounter: (msgs: BaseMessage[]) => Promise<number>;\n  if (\"getNumTokens\" in tokenCounter) {\n    listTokenCounter = async (msgs: BaseMessage[]): Promise<number> => {\n      const tokenCounts = await Promise.all(\n        msgs.map((msg) => tokenCounter.getNumTokens(msg.content))\n      );\n      return tokenCounts.reduce((sum, count) => sum + count, 0);\n    };\n  } else {\n    listTokenCounter = async (msgs: BaseMessage[]): Promise<number> =>\n      tokenCounter(msgs);\n  }\n\n  let textSplitterFunc: (text: string) => Promise<string[]> =\n    defaultTextSplitter;\n  if (textSplitter) {\n    if (\"splitText\" in textSplitter) {\n      textSplitterFunc = textSplitter.splitText;\n    } else {\n      textSplitterFunc = async (text: string): Promise<string[]> =>\n        textSplitter(text);\n    }\n  }\n\n  if (strategy === \"first\") {\n    return _firstMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      partialStrategy: allowPartial ? \"first\" : undefined,\n      endOn,\n    });\n  } else if (strategy === \"last\") {\n    return _lastMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      allowPartial,\n      includeSystem,\n      startOn,\n      endOn,\n    });\n  } else {\n    throw new Error(\n      `Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`\n    );\n  }\n}\n\nasync function _firstMaxTokens(\n  messages: BaseMessage[],\n  options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    partialStrategy?: \"first\" | \"last\";\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }\n): Promise<BaseMessage[]> {\n  const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } =\n    options;\n  let messagesCopy = [...messages];\n  let idx = 0;\n  for (let i = 0; i < messagesCopy.length; i += 1) {\n    const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n    if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n      idx = messagesCopy.length - i;\n      break;\n    }\n  }\n  if (idx < messagesCopy.length && partialStrategy) {\n    let includedPartial = false;\n    if (Array.isArray(messagesCopy[idx].content)) {\n      const excluded = messagesCopy[idx];\n      if (typeof excluded.content === \"string\") {\n        throw new Error(\"Expected content to be an array.\");\n      }\n\n      const numBlock = excluded.content.length;\n      const reversedContent =\n        partialStrategy === \"last\"\n          ? [...excluded.content].reverse()\n          : excluded.content;\n      for (let i = 1; i <= numBlock; i += 1) {\n        const partialContent =\n          partialStrategy === \"first\"\n            ? reversedContent.slice(0, i)\n            : reversedContent.slice(-i);\n        const fields = Object.fromEntries(\n          Object.entries(excluded).filter(\n            ([k]) => k !== \"type\" && !k.startsWith(\"lc_\")\n          )\n        ) as BaseMessageFields;\n        const updatedMessage = _switchTypeToMessage(excluded.getType(), {\n          ...fields,\n          content: partialContent,\n        });\n        const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n        if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n          messagesCopy = slicedMessages;\n          idx += 1;\n          includedPartial = true;\n        } else {\n          break;\n        }\n      }\n      if (includedPartial && partialStrategy === \"last\") {\n        excluded.content = [...reversedContent].reverse();\n      }\n    }\n    if (!includedPartial) {\n      const excluded = messagesCopy[idx];\n      let text: string | undefined;\n      if (\n        Array.isArray(excluded.content) &&\n        excluded.content.some(\n          (block) => typeof block === \"string\" || block.type === \"text\"\n        )\n      ) {\n        const textBlock = excluded.content.find(\n          (block) => block.type === \"text\" && block.text\n        ) as { type: \"text\"; text: string } | undefined;\n        text = textBlock?.text;\n      } else if (typeof excluded.content === \"string\") {\n        text = excluded.content;\n      }\n      if (text) {\n        const splitTexts = await textSplitter(text);\n        const numSplits = splitTexts.length;\n        if (partialStrategy === \"last\") {\n          splitTexts.reverse();\n        }\n        for (let _ = 0; _ < numSplits - 1; _ += 1) {\n          splitTexts.pop();\n          excluded.content = splitTexts.join(\"\");\n          if (\n            (await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n            maxTokens\n          ) {\n            if (partialStrategy === \"last\") {\n              excluded.content = [...splitTexts].reverse().join(\"\");\n            }\n            messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n            idx += 1;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n      idx -= 1;\n    }\n  }\n\n  return messagesCopy.slice(0, idx);\n}\n\nasync function _lastMaxTokens(\n  messages: BaseMessage[],\n  options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    /**\n     * @default {false}\n     */\n    allowPartial?: boolean;\n    /**\n     * @default {false}\n     */\n    includeSystem?: boolean;\n    startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }\n): Promise<BaseMessage[]> {\n  const {\n    allowPartial = false,\n    includeSystem = false,\n    endOn,\n    startOn,\n    ...rest\n  } = options;\n\n  // Create a copy of messages to avoid mutation\n  let messagesCopy = messages.map((message) => {\n    const fields = Object.fromEntries(\n      Object.entries(message).filter(\n        ([k]) => k !== \"type\" && !k.startsWith(\"lc_\")\n      )\n    ) as BaseMessageFields;\n    return _switchTypeToMessage(\n      message.getType(),\n      fields,\n      isBaseMessageChunk(message)\n    );\n  });\n\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (\n      messagesCopy.length > 0 &&\n      !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)\n    ) {\n      messagesCopy = messagesCopy.slice(0, -1);\n    }\n  }\n\n  const swappedSystem =\n    includeSystem && messagesCopy[0]?.getType() === \"system\";\n  let reversed_ = swappedSystem\n    ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse())\n    : messagesCopy.reverse();\n\n  reversed_ = await _firstMaxTokens(reversed_, {\n    ...rest,\n    partialStrategy: allowPartial ? \"last\" : undefined,\n    endOn: startOn,\n  });\n\n  if (swappedSystem) {\n    return [reversed_[0], ...reversed_.slice(1).reverse()];\n  } else {\n    return reversed_.reverse();\n  }\n}\n\nconst _MSG_CHUNK_MAP: Record<\n  MessageType,\n  {\n    message: MessageUnion;\n    messageChunk: MessageChunkUnion;\n  }\n> = {\n  human: {\n    message: HumanMessage,\n    messageChunk: HumanMessageChunk,\n  },\n  ai: {\n    message: AIMessage,\n    messageChunk: AIMessageChunk,\n  },\n  system: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk,\n  },\n  developer: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk,\n  },\n  tool: {\n    message: ToolMessage,\n    messageChunk: ToolMessageChunk,\n  },\n  function: {\n    message: FunctionMessage,\n    messageChunk: FunctionMessageChunk,\n  },\n  generic: {\n    message: ChatMessage,\n    messageChunk: ChatMessageChunk,\n  },\n  remove: {\n    message: RemoveMessage,\n    messageChunk: RemoveMessage, // RemoveMessage does not have a chunk class.\n  },\n};\n\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields\n): BaseMessage;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk: true\n): BaseMessageChunk;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk?: boolean\n): BaseMessageChunk | BaseMessage;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk?: boolean\n): BaseMessageChunk | BaseMessage {\n  let chunk: BaseMessageChunk | undefined;\n  let msg: BaseMessage | undefined;\n\n  switch (messageType) {\n    case \"human\":\n      if (returnChunk) {\n        chunk = new HumanMessageChunk(fields);\n      } else {\n        msg = new HumanMessage(fields);\n      }\n      break;\n    case \"ai\":\n      if (returnChunk) {\n        let aiChunkFields: AIMessageChunkFields = {\n          ...fields,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n          aiChunkFields = {\n            ...aiChunkFields,\n            tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n              ...tc,\n              type: \"tool_call_chunk\",\n              index: undefined,\n              args: JSON.stringify(tc.args),\n            })),\n          };\n        }\n        chunk = new AIMessageChunk(aiChunkFields);\n      } else {\n        msg = new AIMessage(fields);\n      }\n      break;\n    case \"system\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk(fields);\n      } else {\n        msg = new SystemMessage(fields);\n      }\n      break;\n    case \"developer\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\",\n          },\n        });\n      } else {\n        msg = new SystemMessage({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\",\n          },\n        });\n      }\n      break;\n    case \"tool\":\n      if (\"tool_call_id\" in fields) {\n        if (returnChunk) {\n          chunk = new ToolMessageChunk(fields as ToolMessageFields);\n        } else {\n          msg = new ToolMessage(fields as ToolMessageFields);\n        }\n      } else {\n        throw new Error(\n          \"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\"\n        );\n      }\n      break;\n    case \"function\":\n      if (returnChunk) {\n        chunk = new FunctionMessageChunk(fields as FunctionMessageFields);\n      } else {\n        if (!fields.name) {\n          throw new Error(\"FunctionMessage must have a 'name' field\");\n        }\n        msg = new FunctionMessage(fields as FunctionMessageFields);\n      }\n      break;\n    case \"generic\":\n      if (\"role\" in fields) {\n        if (returnChunk) {\n          chunk = new ChatMessageChunk(fields as ChatMessageFields);\n        } else {\n          msg = new ChatMessage(fields as ChatMessageFields);\n        }\n      } else {\n        throw new Error(\n          \"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\"\n        );\n      }\n      break;\n    default:\n      throw new Error(`Unrecognized message type ${messageType}`);\n  }\n\n  if (returnChunk && chunk) {\n    return chunk;\n  }\n  if (msg) {\n    return msg;\n  }\n  throw new Error(`Unrecognized message type ${messageType}`);\n}\n\nfunction _chunkToMsg(chunk: BaseMessageChunk): BaseMessage {\n  const chunkType = chunk.getType();\n  let msg: BaseMessage | undefined;\n  const fields = Object.fromEntries(\n    Object.entries(chunk).filter(\n      ([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")\n    )\n  ) as BaseMessageFields;\n\n  if (chunkType in _MSG_CHUNK_MAP) {\n    msg = _switchTypeToMessage(chunkType, fields);\n  }\n\n  if (!msg) {\n    throw new Error(\n      `Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(\n        _MSG_CHUNK_MAP\n      )}`\n    );\n  }\n\n  return msg;\n}\n\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nexport function defaultTextSplitter(text: string): Promise<string[]> {\n  const splits = text.split(\"\\n\");\n  return Promise.resolve([\n    ...splits.slice(0, -1).map((s) => `${s}\\n`),\n    splits[splits.length - 1],\n  ]);\n}\n", "import { BaseContentBlock } from \"./base.js\";\n\nexport type Tools = never;\n\nexport const KNOWN_BLOCK_TYPES = [\n  \"tool_call\",\n  \"tool_call_chunk\",\n  \"invalid_tool_call\",\n  \"server_tool_call\",\n  \"server_tool_call_chunk\",\n  \"server_tool_call_result\",\n];\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace Tools {\n  /**\n   * Represents a request to call a tool.\n   *\n   * @example\n   * ```ts\n   * const toolCall: ToolCall = {\n   *     type: \"tool_call\",\n   *     name: \"foo\",\n   *     args: { a: 1 },\n   *     callId: \"123\"\n   * };\n   * ```\n   * This represents a request to call the tool named \"foo\" with arguments {\"a\": 1}\n   * and an identifier of \"123\".\n   */\n  export interface ToolCall<TName extends string = string, TArgs = unknown>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"tool_call\";\n    /**\n     * The name of the tool being called\n     */\n    name: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args: TArgs;\n  }\n\n  /** Content block to represent partial data of a tool call */\n  export interface ToolCallChunk<TName extends string = string>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"tool_call_chunk\";\n    /**\n     * The name of the tool being called\n     */\n    name?: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args?: string;\n    /**\n     * The index of the tool call chunk\n     */\n    index?: number;\n  }\n\n  /** Content block to represent an invalid tool call */\n  export interface InvalidToolCall<TName extends string = string>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"invalid_tool_call\";\n    /**\n     * The name of the tool being called\n     */\n    name?: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args?: string;\n    /**\n     * An error message associated with the tool call\n     */\n    error?: string;\n    /**\n     * Index of block in aggregate response\n     */\n    index?: string | number;\n  }\n\n  export interface ServerToolCall<\n    TName extends string = string,\n    TArgs = unknown,\n  > extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"server_tool_call\";\n    /**\n     * The name of the tool being called\n     */\n    name: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args: TArgs;\n  }\n\n  export interface ServerToolCallChunk<TName extends string = string>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"server_tool_call_chunk\";\n    /**\n     * The name of the tool being called\n     */\n    name?: TName;\n    /**\n     * The arguments to the tool call\n     */\n    args?: string;\n  }\n\n  export interface ServerToolCallResult<TOutput = Record<string, unknown>>\n    extends BaseContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"server_tool_call_result\";\n    /**\n     * The unique identifier of the tool call that this result corresponds to\n     */\n    toolCallId: string;\n    /**\n     * The status of the server tool call\n     */\n    status: \"success\" | \"error\";\n    /**\n     * The output of the server tool call\n     */\n    output: TOutput;\n  }\n\n  export type Standard =\n    | ToolCall\n    | ToolCallChunk\n    | InvalidToolCall\n    | ServerToolCall\n    | ServerToolCallChunk\n    | ServerToolCallResult;\n}\n", "import { BaseContentBlock } from \"./base.js\";\n\nexport type Multimodal = never;\n\nexport const KNOWN_BLOCK_TYPES = [\n  \"image\",\n  \"video\",\n  \"audio\",\n  \"text-plain\",\n  \"file\",\n];\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace Multimodal {\n  type BaseDataRecord = {\n    /**\n     * MIME type of the file.\n     *\n     * @see https://www.iana.org/assignments/media-types/media-types.xhtml#image\n     */\n    mimeType?: string | undefined;\n  };\n  type DataRecordFileId = BaseDataRecord & {\n    /**\n     * ID of the data file, e.g. from a provider's file api\n     */\n    fileId: string;\n    url?: never;\n    data?: never;\n  };\n  type DataRecordUrl = BaseDataRecord & {\n    fileId?: never;\n    /**\n     * URL of the data file\n     */\n    url: string;\n    data?: never;\n  };\n  type DataRecordBase64 = BaseDataRecord & {\n    fileId?: never;\n    url?: never;\n    /**\n     * MIME type of the file. Required for base64 encoding.\n     *\n     * @see https://www.iana.org/assignments/media-types/media-types.xhtml#image\n     */\n    mimeType: string;\n    /**\n     * Base64 encoded string or binary data of the data\n     */\n    data: string | Uint8Array;\n  };\n  type DataRecord = DataRecordFileId | DataRecordUrl | DataRecordBase64;\n\n  /** Content block for multimodal data */\n  export type Data<TMetadata = Record<string, unknown>> = BaseContentBlock &\n    DataRecord & {\n      /**\n       * MIME type of the file. Required for base64 encoding.\n       */\n      mimeType?: string;\n      /**\n       * Metadata of the file\n       */\n      metadata?: TMetadata;\n      /**\n       * Content block identifier for multimodal content, e.g. image, video, audio, file or plain text. This can be either:\n       *  - generated by the provider (e.g., an OpenAI block ID)\n       *  - generated by LangChain upon creation\n       */\n      id?: string;\n    };\n\n  /** Content block for image data */\n  export type Image = Data & {\n    /** Type of the content block */\n    readonly type: \"image\";\n  };\n  /** Content block for video data */\n  export type Video = Data & {\n    /** Type of the content block */\n    readonly type: \"video\";\n  };\n  /** Content block for audio data */\n  export type Audio = Data & {\n    /** Type of the content block */\n    readonly type: \"audio\";\n  };\n  /** Content block for plain text data */\n  export type PlainText = Data & {\n    /** Type of the content block */\n    readonly type: \"text-plain\";\n    /**\n     * Plaintext content. This is optional if the data is base64 encoded.\n     */\n    text?: string;\n    /**\n     * Title of the file, e.g. the title of a document\n     */\n    title?: string;\n    /**\n     * Context for the text, e.g. a description or a summary of the text's content\n     */\n    context?: string;\n  };\n\n  /** Content block for file data */\n  export type File = Data & {\n    /**\n     * Non-descript multimodal content block\n     *\n     * This block is intended for files that aren't covered by existing content block types.\n     */\n    readonly type: \"file\";\n  };\n\n  export type Standard = Image | Video | Audio | PlainText | File;\n}\n", "import type { BaseContentBlock } from \"./base.js\";\nimport {\n  KNOWN_BLOCK_TYPES as KNOWN_TOOL_BLOCK_TYPES,\n  type Tools,\n} from \"./tools.js\";\nimport {\n  KNOWN_BLOCK_TYPES as KNOWN_MULTIMODAL_BLOCK_TYPES,\n  type Multimodal,\n} from \"./multimodal.js\";\nimport { type Data } from \"./data.js\";\n\nexport interface ContentBlock extends BaseContentBlock {}\n\nexport const KNOWN_BLOCK_TYPES = [\n  \"text\",\n  \"reasoning\",\n  ...KNOWN_TOOL_BLOCK_TYPES,\n  ...KNOWN_MULTIMODAL_BLOCK_TYPES,\n];\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace ContentBlock {\n  /**\n   * Annotation for citing data from a document.\n   */\n  export interface Citation {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"citation\";\n    /**\n     * Source type for the citation.\n     */\n    source?: string;\n    /**\n     * URL of the document source\n     */\n    url?: string;\n    /**\n     * Source document title.\n     *\n     * For example, the page title for a web page or the title of a paper.\n     */\n    title?: string;\n    /**\n     * Start index of the **response text** for which the annotation applies.\n     *\n     * @see {Text}\n     */\n    startIndex?: number;\n    /**\n     * End index of the **response text** for which the annotation applies.\n     *\n     * @see {Text}\n     */\n    endIndex?: number;\n    /**\n     * Excerpt of source text being cited.\n     */\n    citedText?: string;\n  }\n\n  /**\n   * Text output from a LLM.\n   *\n   * This typically represents the main text content of a message, such as the response\n   * from a language model or the text of a user message.\n   */\n  export interface Text extends ContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"text\";\n    /**\n     * Block text.\n     */\n    text: string;\n    /**\n     * Index of block in aggregate response. Used during streaming.\n     */\n    index?: number;\n    /**\n     * Citations and other annotations.\n     */\n    annotations?: Array<Citation | BaseContentBlock>;\n  }\n\n  /**\n   * Reasoning output from a LLM.\n   */\n  export interface Reasoning extends ContentBlock {\n    /**\n     * Type of the content block\n     */\n    readonly type: \"reasoning\";\n    /**\n     * Reasoning text.\n     *\n     * Either the thought summary or the raw reasoning text itself.\n     * This is often parsed from `<think>` tags in the model's response.\n     */\n    reasoning: string;\n    /**\n     * Index of block in aggregate response. Used during streaming.\n     */\n    index?: number;\n  }\n\n  /**\n   * Provider-specific content block.\n   *\n   * This is used to represent content blocks that are not part of the standard LangChain content model.\n   * If a provider's non-standard output includes reasoning and tool calls, it should be\n   * the adapter's job to parse that payload and emit the corresponding standard reasoning and tool call blocks.\n   */\n  export interface NonStandard<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    TValue extends Record<string, any> = Record<string, any>,\n  > extends ContentBlock {\n    /**\n     * Type of the content block\n     */\n    type: \"non_standard\";\n    /**\n     * Provider-specific data\n     */\n    value: TValue;\n  }\n\n  export { Tools };\n  export { Multimodal };\n  export { Data };\n\n  export type Standard =\n    | Text\n    | Reasoning\n    | NonStandard\n    | Tools.Standard\n    | Multimodal.Standard;\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { convertToOpenAIImageBlock, convertToProviderContentBlock, isBase64ContentBlock, isDataContentBlock, isIDContentBlock, isPlainTextContentBlock, isURLContentBlock, parseBase64DataUrl, parseMimeType } from \"./content/data.js\";\nimport { isMessage } from \"./message.js\";\nimport { BaseMessage, BaseMessageChunk, DEFAULT_MERGE_IGNORE_KEYS, _isMessageFieldWithRole, _mergeDicts, _mergeLists, _mergeObj, _mergeStatus, isBaseMessage, isBaseMessageChunk, isOpenAIToolCallArray, mergeContent } from \"./base.js\";\nimport { mergeResponseMetadata, mergeUsageMetadata } from \"./metadata.js\";\nimport { ToolMessage, ToolMessageChunk, defaultToolCallParser, isDirectToolOutput, isToolMessage, isToolMessageChunk } from \"./tool.js\";\nimport { ChatMessage, ChatMessageChunk, isChatMessage, isChatMessageChunk } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk, isFunctionMessage, isFunctionMessageChunk } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk, isHumanMessage, isHumanMessageChunk } from \"./human.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk, isSystemMessage, isSystemMessageChunk } from \"./system.js\";\nimport { coerceMessageLikeToMessage, collapseToolCallChunks, convertToChunk, getBufferString, iife, mapChatMessagesToStoredMessages, mapStoredMessageToChatMessage, mapStoredMessagesToChatMessages } from \"./utils.js\";\nimport { AIMessage, AIMessageChunk, isAIMessage, isAIMessageChunk } from \"./ai.js\";\nimport { defaultTextSplitter, filterMessages, mergeMessageRuns, trimMessages } from \"./transformers.js\";\nimport { KNOWN_BLOCK_TYPES } from \"./content/index.js\";\n\n//#region src/messages/index.ts\nvar messages_exports = {};\n__export(messages_exports, {\n\tAIMessage: () => AIMessage,\n\tAIMessageChunk: () => AIMessageChunk,\n\tBaseMessage: () => BaseMessage,\n\tBaseMessageChunk: () => BaseMessageChunk,\n\tChatMessage: () => ChatMessage,\n\tChatMessageChunk: () => ChatMessageChunk,\n\tDEFAULT_MERGE_IGNORE_KEYS: () => DEFAULT_MERGE_IGNORE_KEYS,\n\tFunctionMessage: () => FunctionMessage,\n\tFunctionMessageChunk: () => FunctionMessageChunk,\n\tHumanMessage: () => HumanMessage,\n\tHumanMessageChunk: () => HumanMessageChunk,\n\tKNOWN_BLOCK_TYPES: () => KNOWN_BLOCK_TYPES,\n\tRemoveMessage: () => RemoveMessage,\n\tSystemMessage: () => SystemMessage,\n\tSystemMessageChunk: () => SystemMessageChunk,\n\tToolMessage: () => ToolMessage,\n\tToolMessageChunk: () => ToolMessageChunk,\n\t_isMessageFieldWithRole: () => _isMessageFieldWithRole,\n\t_mergeDicts: () => _mergeDicts,\n\t_mergeLists: () => _mergeLists,\n\t_mergeObj: () => _mergeObj,\n\t_mergeStatus: () => _mergeStatus,\n\tcoerceMessageLikeToMessage: () => coerceMessageLikeToMessage,\n\tcollapseToolCallChunks: () => collapseToolCallChunks,\n\tconvertToChunk: () => convertToChunk,\n\tconvertToOpenAIImageBlock: () => convertToOpenAIImageBlock,\n\tconvertToProviderContentBlock: () => convertToProviderContentBlock,\n\tdefaultTextSplitter: () => defaultTextSplitter,\n\tdefaultToolCallParser: () => defaultToolCallParser,\n\tfilterMessages: () => filterMessages,\n\tgetBufferString: () => getBufferString,\n\tiife: () => iife,\n\tisAIMessage: () => isAIMessage,\n\tisAIMessageChunk: () => isAIMessageChunk,\n\tisBase64ContentBlock: () => isBase64ContentBlock,\n\tisBaseMessage: () => isBaseMessage,\n\tisBaseMessageChunk: () => isBaseMessageChunk,\n\tisChatMessage: () => isChatMessage,\n\tisChatMessageChunk: () => isChatMessageChunk,\n\tisDataContentBlock: () => isDataContentBlock,\n\tisDirectToolOutput: () => isDirectToolOutput,\n\tisFunctionMessage: () => isFunctionMessage,\n\tisFunctionMessageChunk: () => isFunctionMessageChunk,\n\tisHumanMessage: () => isHumanMessage,\n\tisHumanMessageChunk: () => isHumanMessageChunk,\n\tisIDContentBlock: () => isIDContentBlock,\n\tisMessage: () => isMessage,\n\tisOpenAIToolCallArray: () => isOpenAIToolCallArray,\n\tisPlainTextContentBlock: () => isPlainTextContentBlock,\n\tisSystemMessage: () => isSystemMessage,\n\tisSystemMessageChunk: () => isSystemMessageChunk,\n\tisToolMessage: () => isToolMessage,\n\tisToolMessageChunk: () => isToolMessageChunk,\n\tisURLContentBlock: () => isURLContentBlock,\n\tmapChatMessagesToStoredMessages: () => mapChatMessagesToStoredMessages,\n\tmapStoredMessageToChatMessage: () => mapStoredMessageToChatMessage,\n\tmapStoredMessagesToChatMessages: () => mapStoredMessagesToChatMessages,\n\tmergeContent: () => mergeContent,\n\tmergeMessageRuns: () => mergeMessageRuns,\n\tmergeResponseMetadata: () => mergeResponseMetadata,\n\tmergeUsageMetadata: () => mergeUsageMetadata,\n\tparseBase64DataUrl: () => parseBase64DataUrl,\n\tparseMimeType: () => parseMimeType,\n\ttrimMessages: () => trimMessages\n});\n\n//#endregion\nexport { AIMessage, AIMessageChunk, BaseMessage, BaseMessageChunk, ChatMessage, ChatMessageChunk, DEFAULT_MERGE_IGNORE_KEYS, FunctionMessage, FunctionMessageChunk, HumanMessage, HumanMessageChunk, KNOWN_BLOCK_TYPES, RemoveMessage, SystemMessage, SystemMessageChunk, ToolMessage, ToolMessageChunk, _isMessageFieldWithRole, _mergeDicts, _mergeLists, _mergeObj, _mergeStatus, coerceMessageLikeToMessage, collapseToolCallChunks, convertToChunk, convertToOpenAIImageBlock, convertToProviderContentBlock, defaultTextSplitter, defaultToolCallParser, filterMessages, getBufferString, iife, isAIMessage, isAIMessageChunk, isBase64ContentBlock, isBaseMessage, isBaseMessageChunk, isChatMessage, isChatMessageChunk, isDataContentBlock, isDirectToolOutput, isFunctionMessage, isFunctionMessageChunk, isHumanMessage, isHumanMessageChunk, isIDContentBlock, isMessage, isOpenAIToolCallArray, isPlainTextContentBlock, isSystemMessage, isSystemMessageChunk, isToolMessage, isToolMessageChunk, isURLContentBlock, mapChatMessagesToStoredMessages, mapStoredMessageToChatMessage, mapStoredMessagesToChatMessages, mergeContent, mergeMessageRuns, mergeResponseMetadata, mergeUsageMetadata, messages_exports, parseBase64DataUrl, parseMimeType, trimMessages };\n//# sourceMappingURL=index.js.map", "import { Serializable } from \"./load/serializable.js\";\nimport { type BaseMessage } from \"./messages/base.js\";\nimport { HumanMessage } from \"./messages/human.js\";\nimport { getBufferString } from \"./messages/utils.js\";\n\nexport interface BasePromptValueInterface extends Serializable {\n  toString(): string;\n\n  toChatMessages(): BaseMessage[];\n}\n\nexport interface StringPromptValueInterface extends BasePromptValueInterface {\n  value: string;\n}\n\nexport interface ChatPromptValueInterface extends BasePromptValueInterface {\n  messages: BaseMessage[];\n}\n\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nexport abstract class BasePromptValue\n  extends Serializable\n  implements BasePromptValueInterface\n{\n  abstract toString(): string;\n\n  abstract toChatMessages(): BaseMessage[];\n}\n\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nexport class StringPromptValue\n  extends BasePromptValue\n  implements StringPromptValueInterface\n{\n  static lc_name(): string {\n    return \"StringPromptValue\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  value: string;\n\n  constructor(value: string) {\n    super({ value });\n    this.value = value;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  toChatMessages() {\n    return [new HumanMessage(this.value)];\n  }\n}\n\n/**\n * Interface for the fields of a ChatPromptValue.\n */\nexport interface ChatPromptValueFields {\n  messages: BaseMessage[];\n}\n\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nexport class ChatPromptValue\n  extends BasePromptValue\n  implements ChatPromptValueInterface\n{\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ChatPromptValue\";\n  }\n\n  messages: BaseMessage[];\n\n  constructor(messages: BaseMessage[]);\n\n  constructor(fields: ChatPromptValueFields);\n\n  constructor(fields: BaseMessage[] | ChatPromptValueFields) {\n    if (Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { messages: fields };\n    }\n\n    super(fields);\n    this.messages = fields.messages;\n  }\n\n  toString() {\n    return getBufferString(this.messages);\n  }\n\n  toChatMessages() {\n    return this.messages;\n  }\n}\n\nexport type ImageContent = {\n  /** Specifies the detail level of the image. */\n  detail?: \"auto\" | \"low\" | \"high\";\n\n  /** Either a URL of the image or the base64 encoded image data. */\n  url: string;\n};\n\nexport interface ImagePromptValueFields {\n  imageUrl: ImageContent;\n}\n\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nexport class ImagePromptValue extends BasePromptValue {\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ImagePromptValue\";\n  }\n\n  imageUrl: ImageContent;\n\n  /** @ignore */\n  value: string;\n\n  constructor(fields: ImagePromptValueFields);\n\n  constructor(fields: ImageContent);\n\n  constructor(fields: ImageContent | ImagePromptValueFields) {\n    if (!(\"imageUrl\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { imageUrl: fields };\n    }\n\n    super(fields);\n    this.imageUrl = fields.imageUrl;\n  }\n\n  toString() {\n    return this.imageUrl.url;\n  }\n\n  toChatMessages() {\n    return [\n      new HumanMessage({\n        content: [\n          {\n            type: \"image_url\",\n            image_url: {\n              detail: this.imageUrl.detail,\n              url: this.imageUrl.url,\n            },\n          },\n        ],\n      }),\n    ];\n  }\n}\n", "// @ts-nocheck\n\n// Inlined to deal with portability issues with importing crypto module\n\n/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.11.1\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2025\n * @license MIT\n */\n/*jslint bitwise: true */\n\"use strict\";\n\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n  0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n  0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n  0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n  0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n  0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\n\nvar blocks = [];\n\nfunction Sha256(is224, sharedMemory) {\n  if (sharedMemory) {\n    blocks[0] =\n      blocks[16] =\n      blocks[1] =\n      blocks[2] =\n      blocks[3] =\n      blocks[4] =\n      blocks[5] =\n      blocks[6] =\n      blocks[7] =\n      blocks[8] =\n      blocks[9] =\n      blocks[10] =\n      blocks[11] =\n      blocks[12] =\n      blocks[13] =\n      blocks[14] =\n      blocks[15] =\n        0;\n    this.blocks = blocks;\n  } else {\n    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  }\n\n  if (is224) {\n    this.h0 = 0xc1059ed8;\n    this.h1 = 0x367cd507;\n    this.h2 = 0x3070dd17;\n    this.h3 = 0xf70e5939;\n    this.h4 = 0xffc00b31;\n    this.h5 = 0x68581511;\n    this.h6 = 0x64f98fa7;\n    this.h7 = 0xbefa4fa4;\n  } else {\n    // 256\n    this.h0 = 0x6a09e667;\n    this.h1 = 0xbb67ae85;\n    this.h2 = 0x3c6ef372;\n    this.h3 = 0xa54ff53a;\n    this.h4 = 0x510e527f;\n    this.h5 = 0x9b05688c;\n    this.h6 = 0x1f83d9ab;\n    this.h7 = 0x5be0cd19;\n  }\n\n  this.block = this.start = this.bytes = this.hBytes = 0;\n  this.finalized = this.hashed = false;\n  this.first = true;\n  this.is224 = is224;\n}\n\nSha256.prototype.update = function (message) {\n  if (this.finalized) {\n    return;\n  }\n  var notString,\n    type = typeof message;\n  if (type !== \"string\") {\n    if (type === \"object\") {\n      if (message === null) {\n        throw new Error(ERROR);\n      } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n        message = new Uint8Array(message);\n      } else if (!Array.isArray(message)) {\n        if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n          throw new Error(ERROR);\n        }\n      }\n    } else {\n      throw new Error(ERROR);\n    }\n    notString = true;\n  }\n  var code,\n    index = 0,\n    i,\n    length = message.length,\n    blocks = this.blocks;\n  while (index < length) {\n    if (this.hashed) {\n      this.hashed = false;\n      blocks[0] = this.block;\n      this.block =\n        blocks[16] =\n        blocks[1] =\n        blocks[2] =\n        blocks[3] =\n        blocks[4] =\n        blocks[5] =\n        blocks[6] =\n        blocks[7] =\n        blocks[8] =\n        blocks[9] =\n        blocks[10] =\n        blocks[11] =\n        blocks[12] =\n        blocks[13] =\n        blocks[14] =\n        blocks[15] =\n          0;\n    }\n\n    if (notString) {\n      for (i = this.start; index < length && i < 64; ++index) {\n        blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];\n      }\n    } else {\n      for (i = this.start; index < length && i < 64; ++index) {\n        code = message.charCodeAt(index);\n        if (code < 0x80) {\n          blocks[i >>> 2] |= code << SHIFT[i++ & 3];\n        } else if (code < 0x800) {\n          blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n        } else if (code < 0xd800 || code >= 0xe000) {\n          blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n        } else {\n          code =\n            0x10000 +\n            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n          blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n        }\n      }\n    }\n\n    this.lastByteIndex = i;\n    this.bytes += i - this.start;\n    if (i >= 64) {\n      this.block = blocks[16];\n      this.start = i - 64;\n      this.hash();\n      this.hashed = true;\n    } else {\n      this.start = i;\n    }\n  }\n  if (this.bytes > 4294967295) {\n    this.hBytes += (this.bytes / 4294967296) << 0;\n    this.bytes = this.bytes % 4294967296;\n  }\n  return this;\n};\n\nSha256.prototype.finalize = function () {\n  if (this.finalized) {\n    return;\n  }\n  this.finalized = true;\n  var blocks = this.blocks,\n    i = this.lastByteIndex;\n  blocks[16] = this.block;\n  blocks[i >>> 2] |= EXTRA[i & 3];\n  this.block = blocks[16];\n  if (i >= 56) {\n    if (!this.hashed) {\n      this.hash();\n    }\n    blocks[0] = this.block;\n    blocks[16] =\n      blocks[1] =\n      blocks[2] =\n      blocks[3] =\n      blocks[4] =\n      blocks[5] =\n      blocks[6] =\n      blocks[7] =\n      blocks[8] =\n      blocks[9] =\n      blocks[10] =\n      blocks[11] =\n      blocks[12] =\n      blocks[13] =\n      blocks[14] =\n      blocks[15] =\n        0;\n  }\n  blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n  blocks[15] = this.bytes << 3;\n  this.hash();\n};\n\nSha256.prototype.hash = function () {\n  var a = this.h0,\n    b = this.h1,\n    c = this.h2,\n    d = this.h3,\n    e = this.h4,\n    f = this.h5,\n    g = this.h6,\n    h = this.h7,\n    blocks = this.blocks,\n    j,\n    s0,\n    s1,\n    maj,\n    t1,\n    t2,\n    ch,\n    ab,\n    da,\n    cd,\n    bc;\n\n  for (j = 16; j < 64; ++j) {\n    // rightrotate\n    t1 = blocks[j - 15];\n    s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n    t1 = blocks[j - 2];\n    s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n    blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;\n  }\n\n  bc = b & c;\n  for (j = 0; j < 64; j += 4) {\n    if (this.first) {\n      if (this.is224) {\n        ab = 300032;\n        t1 = blocks[0] - 1413257819;\n        h = (t1 - 150054599) << 0;\n        d = (t1 + 24177077) << 0;\n      } else {\n        ab = 704751109;\n        t1 = blocks[0] - 210244248;\n        h = (t1 - 1521486534) << 0;\n        d = (t1 + 143694565) << 0;\n      }\n      this.first = false;\n    } else {\n      s0 =\n        ((a >>> 2) | (a << 30)) ^\n        ((a >>> 13) | (a << 19)) ^\n        ((a >>> 22) | (a << 10));\n      s1 =\n        ((e >>> 6) | (e << 26)) ^\n        ((e >>> 11) | (e << 21)) ^\n        ((e >>> 25) | (e << 7));\n      ab = a & b;\n      maj = ab ^ (a & c) ^ bc;\n      ch = (e & f) ^ (~e & g);\n      t1 = h + s1 + ch + K[j] + blocks[j];\n      t2 = s0 + maj;\n      h = (d + t1) << 0;\n      d = (t1 + t2) << 0;\n    }\n    s0 =\n      ((d >>> 2) | (d << 30)) ^\n      ((d >>> 13) | (d << 19)) ^\n      ((d >>> 22) | (d << 10));\n    s1 =\n      ((h >>> 6) | (h << 26)) ^\n      ((h >>> 11) | (h << 21)) ^\n      ((h >>> 25) | (h << 7));\n    da = d & a;\n    maj = da ^ (d & b) ^ ab;\n    ch = (g & h) ^ (~g & e);\n    t1 = f + s1 + ch + K[j + 1] + blocks[j + 1];\n    t2 = s0 + maj;\n    g = (c + t1) << 0;\n    c = (t1 + t2) << 0;\n    s0 =\n      ((c >>> 2) | (c << 30)) ^\n      ((c >>> 13) | (c << 19)) ^\n      ((c >>> 22) | (c << 10));\n    s1 =\n      ((g >>> 6) | (g << 26)) ^\n      ((g >>> 11) | (g << 21)) ^\n      ((g >>> 25) | (g << 7));\n    cd = c & d;\n    maj = cd ^ (c & a) ^ da;\n    ch = (f & g) ^ (~f & h);\n    t1 = e + s1 + ch + K[j + 2] + blocks[j + 2];\n    t2 = s0 + maj;\n    f = (b + t1) << 0;\n    b = (t1 + t2) << 0;\n    s0 =\n      ((b >>> 2) | (b << 30)) ^\n      ((b >>> 13) | (b << 19)) ^\n      ((b >>> 22) | (b << 10));\n    s1 =\n      ((f >>> 6) | (f << 26)) ^\n      ((f >>> 11) | (f << 21)) ^\n      ((f >>> 25) | (f << 7));\n    bc = b & c;\n    maj = bc ^ (b & d) ^ cd;\n    ch = (f & g) ^ (~f & h);\n    t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n    t2 = s0 + maj;\n    e = (a + t1) << 0;\n    a = (t1 + t2) << 0;\n    this.chromeBugWorkAround = true;\n  }\n\n  this.h0 = (this.h0 + a) << 0;\n  this.h1 = (this.h1 + b) << 0;\n  this.h2 = (this.h2 + c) << 0;\n  this.h3 = (this.h3 + d) << 0;\n  this.h4 = (this.h4 + e) << 0;\n  this.h5 = (this.h5 + f) << 0;\n  this.h6 = (this.h6 + g) << 0;\n  this.h7 = (this.h7 + h) << 0;\n};\n\nSha256.prototype.hex = function () {\n  this.finalize();\n\n  var h0 = this.h0,\n    h1 = this.h1,\n    h2 = this.h2,\n    h3 = this.h3,\n    h4 = this.h4,\n    h5 = this.h5,\n    h6 = this.h6,\n    h7 = this.h7;\n\n  var hex =\n    HEX_CHARS[(h0 >>> 28) & 0x0f] +\n    HEX_CHARS[(h0 >>> 24) & 0x0f] +\n    HEX_CHARS[(h0 >>> 20) & 0x0f] +\n    HEX_CHARS[(h0 >>> 16) & 0x0f] +\n    HEX_CHARS[(h0 >>> 12) & 0x0f] +\n    HEX_CHARS[(h0 >>> 8) & 0x0f] +\n    HEX_CHARS[(h0 >>> 4) & 0x0f] +\n    HEX_CHARS[h0 & 0x0f] +\n    HEX_CHARS[(h1 >>> 28) & 0x0f] +\n    HEX_CHARS[(h1 >>> 24) & 0x0f] +\n    HEX_CHARS[(h1 >>> 20) & 0x0f] +\n    HEX_CHARS[(h1 >>> 16) & 0x0f] +\n    HEX_CHARS[(h1 >>> 12) & 0x0f] +\n    HEX_CHARS[(h1 >>> 8) & 0x0f] +\n    HEX_CHARS[(h1 >>> 4) & 0x0f] +\n    HEX_CHARS[h1 & 0x0f] +\n    HEX_CHARS[(h2 >>> 28) & 0x0f] +\n    HEX_CHARS[(h2 >>> 24) & 0x0f] +\n    HEX_CHARS[(h2 >>> 20) & 0x0f] +\n    HEX_CHARS[(h2 >>> 16) & 0x0f] +\n    HEX_CHARS[(h2 >>> 12) & 0x0f] +\n    HEX_CHARS[(h2 >>> 8) & 0x0f] +\n    HEX_CHARS[(h2 >>> 4) & 0x0f] +\n    HEX_CHARS[h2 & 0x0f] +\n    HEX_CHARS[(h3 >>> 28) & 0x0f] +\n    HEX_CHARS[(h3 >>> 24) & 0x0f] +\n    HEX_CHARS[(h3 >>> 20) & 0x0f] +\n    HEX_CHARS[(h3 >>> 16) & 0x0f] +\n    HEX_CHARS[(h3 >>> 12) & 0x0f] +\n    HEX_CHARS[(h3 >>> 8) & 0x0f] +\n    HEX_CHARS[(h3 >>> 4) & 0x0f] +\n    HEX_CHARS[h3 & 0x0f] +\n    HEX_CHARS[(h4 >>> 28) & 0x0f] +\n    HEX_CHARS[(h4 >>> 24) & 0x0f] +\n    HEX_CHARS[(h4 >>> 20) & 0x0f] +\n    HEX_CHARS[(h4 >>> 16) & 0x0f] +\n    HEX_CHARS[(h4 >>> 12) & 0x0f] +\n    HEX_CHARS[(h4 >>> 8) & 0x0f] +\n    HEX_CHARS[(h4 >>> 4) & 0x0f] +\n    HEX_CHARS[h4 & 0x0f] +\n    HEX_CHARS[(h5 >>> 28) & 0x0f] +\n    HEX_CHARS[(h5 >>> 24) & 0x0f] +\n    HEX_CHARS[(h5 >>> 20) & 0x0f] +\n    HEX_CHARS[(h5 >>> 16) & 0x0f] +\n    HEX_CHARS[(h5 >>> 12) & 0x0f] +\n    HEX_CHARS[(h5 >>> 8) & 0x0f] +\n    HEX_CHARS[(h5 >>> 4) & 0x0f] +\n    HEX_CHARS[h5 & 0x0f] +\n    HEX_CHARS[(h6 >>> 28) & 0x0f] +\n    HEX_CHARS[(h6 >>> 24) & 0x0f] +\n    HEX_CHARS[(h6 >>> 20) & 0x0f] +\n    HEX_CHARS[(h6 >>> 16) & 0x0f] +\n    HEX_CHARS[(h6 >>> 12) & 0x0f] +\n    HEX_CHARS[(h6 >>> 8) & 0x0f] +\n    HEX_CHARS[(h6 >>> 4) & 0x0f] +\n    HEX_CHARS[h6 & 0x0f];\n  if (!this.is224) {\n    hex +=\n      HEX_CHARS[(h7 >>> 28) & 0x0f] +\n      HEX_CHARS[(h7 >>> 24) & 0x0f] +\n      HEX_CHARS[(h7 >>> 20) & 0x0f] +\n      HEX_CHARS[(h7 >>> 16) & 0x0f] +\n      HEX_CHARS[(h7 >>> 12) & 0x0f] +\n      HEX_CHARS[(h7 >>> 8) & 0x0f] +\n      HEX_CHARS[(h7 >>> 4) & 0x0f] +\n      HEX_CHARS[h7 & 0x0f];\n  }\n  return hex;\n};\n\nSha256.prototype.toString = Sha256.prototype.hex;\n\nSha256.prototype.digest = function () {\n  this.finalize();\n\n  var h0 = this.h0,\n    h1 = this.h1,\n    h2 = this.h2,\n    h3 = this.h3,\n    h4 = this.h4,\n    h5 = this.h5,\n    h6 = this.h6,\n    h7 = this.h7;\n\n  var arr = [\n    (h0 >>> 24) & 0xff,\n    (h0 >>> 16) & 0xff,\n    (h0 >>> 8) & 0xff,\n    h0 & 0xff,\n    (h1 >>> 24) & 0xff,\n    (h1 >>> 16) & 0xff,\n    (h1 >>> 8) & 0xff,\n    h1 & 0xff,\n    (h2 >>> 24) & 0xff,\n    (h2 >>> 16) & 0xff,\n    (h2 >>> 8) & 0xff,\n    h2 & 0xff,\n    (h3 >>> 24) & 0xff,\n    (h3 >>> 16) & 0xff,\n    (h3 >>> 8) & 0xff,\n    h3 & 0xff,\n    (h4 >>> 24) & 0xff,\n    (h4 >>> 16) & 0xff,\n    (h4 >>> 8) & 0xff,\n    h4 & 0xff,\n    (h5 >>> 24) & 0xff,\n    (h5 >>> 16) & 0xff,\n    (h5 >>> 8) & 0xff,\n    h5 & 0xff,\n    (h6 >>> 24) & 0xff,\n    (h6 >>> 16) & 0xff,\n    (h6 >>> 8) & 0xff,\n    h6 & 0xff,\n  ];\n  if (!this.is224) {\n    arr.push(\n      (h7 >>> 24) & 0xff,\n      (h7 >>> 16) & 0xff,\n      (h7 >>> 8) & 0xff,\n      h7 & 0xff\n    );\n  }\n  return arr;\n};\n\nSha256.prototype.array = Sha256.prototype.digest;\n\nSha256.prototype.arrayBuffer = function () {\n  this.finalize();\n\n  var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n  var dataView = new DataView(buffer);\n  dataView.setUint32(0, this.h0);\n  dataView.setUint32(4, this.h1);\n  dataView.setUint32(8, this.h2);\n  dataView.setUint32(12, this.h3);\n  dataView.setUint32(16, this.h4);\n  dataView.setUint32(20, this.h5);\n  dataView.setUint32(24, this.h6);\n  if (!this.is224) {\n    dataView.setUint32(28, this.h7);\n  }\n  return buffer;\n};\n\nexport const sha256 = (...strings: string[]) => {\n  return new Sha256(false, true).update(strings.join(\"\")).hex();\n};\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { sha256 } from \"./js-sha256/hash.js\";\n\n//#region src/utils/hash.ts\nvar hash_exports = {};\n__export(hash_exports, { sha256: () => sha256 });\n\n//#endregion\nexport { hash_exports, sha256 };\n//# sourceMappingURL=hash.js.map", "import { sha256, type HashKeyEncoder } from \"../utils/hash.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { mapStoredMessageToChatMessage } from \"../messages/utils.js\";\nimport { type StoredGeneration } from \"../messages/base.js\";\n\nexport const defaultHashKeyEncoder: HashKeyEncoder = (...strings) =>\n  sha256(strings.join(\"_\"));\n\nexport function deserializeStoredGeneration(\n  storedGeneration: StoredGeneration\n) {\n  if (storedGeneration.message !== undefined) {\n    return {\n      text: storedGeneration.text,\n      message: mapStoredMessageToChatMessage(storedGeneration.message),\n    };\n  } else {\n    return { text: storedGeneration.text };\n  }\n}\n\nexport function serializeGeneration(generation: Generation) {\n  const serializedValue: StoredGeneration = {\n    text: generation.text,\n  };\n  if ((generation as ChatGeneration).message !== undefined) {\n    serializedValue.message = (generation as ChatGeneration).message.toDict();\n  }\n  return serializedValue;\n}\n\n/**\n * Base class for all caches. All caches should extend this class.\n */\nexport abstract class BaseCache<T = Generation[]> {\n  protected keyEncoder: HashKeyEncoder = defaultHashKeyEncoder;\n\n  /**\n   * Sets a custom key encoder function for the cache.\n   * This function should take a prompt and an LLM key and return a string\n   * that will be used as the cache key.\n   * @param keyEncoderFn The custom key encoder function.\n   */\n  makeDefaultKeyEncoder(keyEncoderFn: HashKeyEncoder): void {\n    this.keyEncoder = keyEncoderFn;\n  }\n\n  abstract lookup(prompt: string, llmKey: string): Promise<T | null>;\n\n  abstract update(prompt: string, llmKey: string, value: T): Promise<void>;\n}\n\nconst GLOBAL_MAP = new Map();\n\n/**\n * A cache for storing LLM generations that stores data in memory.\n */\nexport class InMemoryCache<T = Generation[]> extends BaseCache<T> {\n  private cache: Map<string, T>;\n\n  constructor(map?: Map<string, T>) {\n    super();\n    this.cache = map ?? new Map();\n  }\n\n  /**\n   * Retrieves data from the cache using a prompt and an LLM key. If the\n   * data is not found, it returns null.\n   * @param prompt The prompt used to find the data.\n   * @param llmKey The LLM key used to find the data.\n   * @returns The data corresponding to the prompt and LLM key, or null if not found.\n   */\n  lookup(prompt: string, llmKey: string): Promise<T | null> {\n    return Promise.resolve(\n      this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null\n    );\n  }\n\n  /**\n   * Updates the cache with new data using a prompt and an LLM key.\n   * @param prompt The prompt used to store the data.\n   * @param llmKey The LLM key used to store the data.\n   * @param value The data to be stored.\n   */\n  async update(prompt: string, llmKey: string, value: T): Promise<void> {\n    this.cache.set(this.keyEncoder(prompt, llmKey), value);\n  }\n\n  /**\n   * Returns a global instance of InMemoryCache using a predefined global\n   * map as the initial cache.\n   * @returns A global instance of InMemoryCache.\n   */\n  static global(): InMemoryCache {\n    return new InMemoryCache(GLOBAL_MAP);\n  }\n}\n", "import type { Tiktoken, TiktokenModel } from \"js-tiktoken/lite\";\nimport type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\n\nimport { type BaseCache, InMemoryCache } from \"../caches/index.js\";\nimport {\n  type BasePromptValueInterface,\n  StringPromptValue,\n  ChatPromptValue,\n} from \"../prompt_values.js\";\nimport {\n  type BaseMessage,\n  type BaseMessageLike,\n  type MessageContent,\n} from \"../messages/base.js\";\nimport { coerceMessageLikeToMessage } from \"../messages/utils.js\";\nimport { type LLMResult } from \"../outputs.js\";\nimport { CallbackManager, Callbacks } from \"../callbacks/manager.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"../utils/async_caller.js\";\nimport { encodingForModel } from \"../utils/tiktoken.js\";\nimport { Runnable, type RunnableInterface } from \"../runnables/base.js\";\nimport { RunnableConfig } from \"../runnables/config.js\";\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport {\n  InferInteropZodOutput,\n  InteropZodObject,\n  InteropZodType,\n} from \"../utils/types/zod.js\";\nimport { ModelProfile } from \"./profile.js\";\n\n// https://www.npmjs.com/package/js-tiktoken\n\nexport const getModelNameForTiktoken = (modelName: string): TiktokenModel => {\n  if (modelName.startsWith(\"gpt-5\")) {\n    return \"gpt-5\" as TiktokenModel;\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n    return \"gpt-3.5-turbo-16k\";\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n    return \"gpt-3.5-turbo\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-32k\")) {\n    return \"gpt-4-32k\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-\")) {\n    return \"gpt-4\";\n  }\n\n  if (modelName.startsWith(\"gpt-4o\")) {\n    return \"gpt-4o\";\n  }\n\n  return modelName as TiktokenModel;\n};\n\nexport const getEmbeddingContextSize = (modelName?: string): number => {\n  switch (modelName) {\n    case \"text-embedding-ada-002\":\n      return 8191;\n    default:\n      return 2046;\n  }\n};\n\n/**\n * Get the context window size (max input tokens) for a given model.\n *\n * Context window sizes are sourced from official model documentation:\n * - OpenAI: https://platform.openai.com/docs/models\n * - Anthropic: https://docs.anthropic.com/claude/docs/models-overview\n * - Google: https://ai.google.dev/gemini/docs/models/gemini\n *\n * @param modelName - The name of the model\n * @returns The context window size in tokens\n */\nexport const getModelContextSize = (modelName: string): number => {\n  const normalizedName = getModelNameForTiktoken(modelName) as string;\n\n  switch (normalizedName) {\n    // GPT-5 series\n    case \"gpt-5\":\n    case \"gpt-5-turbo\":\n    case \"gpt-5-turbo-preview\":\n      return 400000;\n\n    // GPT-4o series\n    case \"gpt-4o\":\n    case \"gpt-4o-mini\":\n    case \"gpt-4o-2024-05-13\":\n    case \"gpt-4o-2024-08-06\":\n      return 128000;\n\n    // GPT-4 Turbo series\n    case \"gpt-4-turbo\":\n    case \"gpt-4-turbo-preview\":\n    case \"gpt-4-turbo-2024-04-09\":\n    case \"gpt-4-0125-preview\":\n    case \"gpt-4-1106-preview\":\n      return 128000;\n\n    // GPT-4 series\n    case \"gpt-4-32k\":\n    case \"gpt-4-32k-0314\":\n    case \"gpt-4-32k-0613\":\n      return 32768;\n    case \"gpt-4\":\n    case \"gpt-4-0314\":\n    case \"gpt-4-0613\":\n      return 8192;\n\n    // GPT-3.5 Turbo series\n    case \"gpt-3.5-turbo-16k\":\n    case \"gpt-3.5-turbo-16k-0613\":\n      return 16384;\n    case \"gpt-3.5-turbo\":\n    case \"gpt-3.5-turbo-0301\":\n    case \"gpt-3.5-turbo-0613\":\n    case \"gpt-3.5-turbo-1106\":\n    case \"gpt-3.5-turbo-0125\":\n      return 4096;\n\n    // Legacy GPT-3 models\n    case \"text-davinci-003\":\n    case \"text-davinci-002\":\n      return 4097;\n    case \"text-davinci-001\":\n      return 2049;\n    case \"text-curie-001\":\n    case \"text-babbage-001\":\n    case \"text-ada-001\":\n      return 2048;\n\n    // Code models\n    case \"code-davinci-002\":\n    case \"code-davinci-001\":\n      return 8000;\n    case \"code-cushman-001\":\n      return 2048;\n\n    // Claude models (Anthropic)\n    case \"claude-3-5-sonnet-20241022\":\n    case \"claude-3-5-sonnet-20240620\":\n    case \"claude-3-opus-20240229\":\n    case \"claude-3-sonnet-20240229\":\n    case \"claude-3-haiku-20240307\":\n    case \"claude-2.1\":\n      return 200000;\n    case \"claude-2.0\":\n    case \"claude-instant-1.2\":\n      return 100000;\n\n    // Gemini models (Google)\n    case \"gemini-1.5-pro\":\n    case \"gemini-1.5-pro-latest\":\n    case \"gemini-1.5-flash\":\n    case \"gemini-1.5-flash-latest\":\n      return 1000000; // 1M tokens\n    case \"gemini-pro\":\n    case \"gemini-pro-vision\":\n      return 32768;\n\n    default:\n      return 4097;\n  }\n};\n\n/**\n * Whether or not the input matches the OpenAI tool definition.\n * @param {unknown} tool The input to check.\n * @returns {boolean} Whether the input is an OpenAI tool definition.\n */\nexport function isOpenAITool(tool: unknown): tool is ToolDefinition {\n  if (typeof tool !== \"object\" || !tool) return false;\n  if (\n    \"type\" in tool &&\n    tool.type === \"function\" &&\n    \"function\" in tool &&\n    typeof tool.function === \"object\" &&\n    tool.function &&\n    \"name\" in tool.function &&\n    \"parameters\" in tool.function\n  ) {\n    return true;\n  }\n  return false;\n}\n\ninterface CalculateMaxTokenProps {\n  prompt: string;\n  modelName: TiktokenModel;\n}\n\nexport const calculateMaxTokens = async ({\n  prompt,\n  modelName,\n}: CalculateMaxTokenProps) => {\n  let numTokens;\n\n  try {\n    numTokens = (\n      await encodingForModel(getModelNameForTiktoken(modelName))\n    ).encode(prompt).length;\n  } catch {\n    console.warn(\n      \"Failed to calculate number of tokens, falling back to approximate count\"\n    );\n\n    // fallback to approximate calculation if tiktoken is not available\n    // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n    numTokens = Math.ceil(prompt.length / 4);\n  }\n\n  const maxTokens = getModelContextSize(modelName);\n  return maxTokens - numTokens;\n};\n\nconst getVerbosity = () => false;\n\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport interface BaseLangChainParams {\n  verbose?: boolean;\n  callbacks?: Callbacks;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Base class for language models, chains, tools.\n */\nexport abstract class BaseLangChain<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig,\n  >\n  extends Runnable<RunInput, RunOutput, CallOptions>\n  implements BaseLangChainParams\n{\n  /**\n   * Whether to print out response text.\n   */\n  verbose: boolean;\n\n  callbacks?: Callbacks;\n\n  tags?: string[];\n\n  metadata?: Record<string, unknown>;\n\n  get lc_attributes(): { [key: string]: undefined } | undefined {\n    return {\n      callbacks: undefined,\n      verbose: undefined,\n    };\n  }\n\n  constructor(params: BaseLangChainParams) {\n    super(params);\n    this.verbose = params.verbose ?? getVerbosity();\n    this.callbacks = params.callbacks;\n    this.tags = params.tags ?? [];\n    this.metadata = params.metadata ?? {};\n  }\n}\n\n/**\n * Base interface for language model parameters.\n * A subclass of {@link BaseLanguageModel} should have a constructor that\n * takes in a parameter that extends this interface.\n */\nexport interface BaseLanguageModelParams\n  extends AsyncCallerParams,\n    BaseLangChainParams {\n  /**\n   * @deprecated Use `callbacks` instead\n   */\n  callbackManager?: CallbackManager;\n\n  cache?: BaseCache | boolean;\n}\n\nexport interface BaseLanguageModelTracingCallOptions {\n  /**\n   * Describes the format of structured outputs.\n   * This should be provided if an output is considered to be structured\n   */\n  ls_structured_output_format?: {\n    /**\n     * An object containing the method used for structured output (e.g., \"jsonMode\").\n     */\n    kwargs: { method: string };\n    /**\n     * The JSON schema describing the expected output structure.\n     */\n    schema?: JSONSchema;\n  };\n}\n\nexport interface BaseLanguageModelCallOptions\n  extends RunnableConfig,\n    BaseLanguageModelTracingCallOptions {\n  /**\n   * Stop tokens to use for this call.\n   * If not provided, the default stop tokens for the model will be used.\n   */\n  stop?: string[];\n}\n\nexport interface FunctionDefinition {\n  /**\n   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain\n   * underscores and dashes, with a maximum length of 64.\n   */\n  name: string;\n\n  /**\n   * The parameters the functions accepts, described as a JSON Schema object. See the\n   * [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for\n   * examples, and the\n   * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\n   * documentation about the format.\n   *\n   * To describe a function that accepts no parameters, provide the value\n   * `{\"type\": \"object\", \"properties\": {}}`.\n   */\n  parameters: Record<string, unknown> | JSONSchema;\n\n  /**\n   * A description of what the function does, used by the model to choose when and\n   * how to call the function.\n   */\n  description?: string;\n}\n\nexport interface ToolDefinition {\n  type: \"function\";\n  function: FunctionDefinition;\n}\n\nexport type FunctionCallOption = {\n  name: string;\n};\n\nexport interface BaseFunctionCallOptions extends BaseLanguageModelCallOptions {\n  function_call?: FunctionCallOption;\n  functions?: FunctionDefinition[];\n}\n\nexport type BaseLanguageModelInput =\n  | BasePromptValueInterface\n  | string\n  | BaseMessageLike[];\n\nexport type StructuredOutputType = InferInteropZodOutput<InteropZodObject>;\n\nexport type StructuredOutputMethodOptions<IncludeRaw extends boolean = false> =\n  {\n    name?: string;\n    method?: \"functionCalling\" | \"jsonMode\" | \"jsonSchema\" | string;\n    includeRaw?: IncludeRaw;\n    /** Whether to use strict mode. Currently only supported by OpenAI models. */\n    strict?: boolean;\n  };\n\n/** @deprecated Use StructuredOutputMethodOptions instead */\nexport type StructuredOutputMethodParams<\n  RunOutput,\n  IncludeRaw extends boolean = false,\n> = {\n  /** @deprecated Pass schema in as the first argument */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: InteropZodType<RunOutput> | Record<string, any>;\n  name?: string;\n  method?: \"functionCalling\" | \"jsonMode\";\n  includeRaw?: IncludeRaw;\n};\n\nexport interface BaseLanguageModelInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends\n    BaseLanguageModelCallOptions = BaseLanguageModelCallOptions,\n> extends RunnableInterface<BaseLanguageModelInput, RunOutput, CallOptions> {\n  get callKeys(): string[];\n\n  generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  _modelType(): string;\n\n  _llmType(): string;\n\n  getNumTokens(content: MessageContent): Promise<number>;\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any>;\n\n  serialize(): SerializedLLM;\n}\n\nexport type LanguageModelOutput = BaseMessage | string;\n\nexport type LanguageModelLike = Runnable<\n  BaseLanguageModelInput,\n  LanguageModelOutput\n>;\n\n/**\n * Base class for language models.\n */\nexport abstract class BaseLanguageModel<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput = any,\n    CallOptions extends\n      BaseLanguageModelCallOptions = BaseLanguageModelCallOptions,\n  >\n  extends BaseLangChain<BaseLanguageModelInput, RunOutput, CallOptions>\n  implements\n    BaseLanguageModelParams,\n    BaseLanguageModelInterface<RunOutput, CallOptions>\n{\n  /**\n   * Keys that the language model accepts as call options.\n   */\n  get callKeys(): string[] {\n    return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n  }\n\n  /**\n   * The async caller should be used by subclasses to make any async calls,\n   * which will thus benefit from the concurrency and retry logic.\n   */\n  caller: AsyncCaller;\n\n  cache?: BaseCache;\n\n  constructor({\n    callbacks,\n    callbackManager,\n    ...params\n  }: BaseLanguageModelParams) {\n    const { cache, ...rest } = params;\n    super({\n      callbacks: callbacks ?? callbackManager,\n      ...rest,\n    });\n    if (typeof cache === \"object\") {\n      this.cache = cache;\n    } else if (cache) {\n      this.cache = InMemoryCache.global();\n    } else {\n      this.cache = undefined;\n    }\n    this.caller = new AsyncCaller(params ?? {});\n  }\n\n  abstract generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  abstract _modelType(): string;\n\n  abstract _llmType(): string;\n\n  private _encoding?: Tiktoken;\n\n  /**\n   * Get the number of tokens in the content.\n   * @param content The content to get the number of tokens for.\n   * @returns The number of tokens in the content.\n   */\n  async getNumTokens(content: MessageContent) {\n    // Extract text content from MessageContent\n    let textContent: string;\n    if (typeof content === \"string\") {\n      textContent = content;\n    } else {\n      /**\n       * Content is an array of ContentBlock\n       *\n       * ToDo(@christian-bromann): This is a temporary fix to get the number of tokens for the content.\n       * We need to find a better way to do this.\n       * @see https://github.com/langchain-ai/langchainjs/pull/8341#pullrequestreview-2933713116\n       */\n      textContent = content\n        .map((item) => {\n          if (typeof item === \"string\") return item;\n          if (item.type === \"text\" && \"text\" in item) return item.text;\n          return \"\";\n        })\n        .join(\"\");\n    }\n\n    // fallback to approximate calculation if tiktoken is not available\n    let numTokens = Math.ceil(textContent.length / 4);\n\n    if (!this._encoding) {\n      try {\n        this._encoding = await encodingForModel(\n          \"modelName\" in this\n            ? getModelNameForTiktoken(this.modelName as string)\n            : \"gpt2\"\n        );\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    if (this._encoding) {\n      try {\n        numTokens = this._encoding.encode(textContent).length;\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    return numTokens;\n  }\n\n  protected static _convertInputToPromptValue(\n    input: BaseLanguageModelInput\n  ): BasePromptValueInterface {\n    if (typeof input === \"string\") {\n      return new StringPromptValue(input);\n    } else if (Array.isArray(input)) {\n      return new ChatPromptValue(input.map(coerceMessageLikeToMessage));\n    } else {\n      return input;\n    }\n  }\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any> {\n    return {};\n  }\n\n  /**\n   * Create a unique cache key for a specific call to a specific language model.\n   * @param callOptions Call options for the model\n   * @returns A unique cache key.\n   */\n  _getSerializedCacheKeyParametersForCall(\n    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n    { config, ...callOptions }: CallOptions & { config?: RunnableConfig }\n  ): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const params: Record<string, any> = {\n      ...this._identifyingParams(),\n      ...callOptions,\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n    const filteredEntries = Object.entries(params).filter(\n      ([_, value]) => value !== undefined\n    );\n    const serializedEntries = filteredEntries\n      .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n      .sort()\n      .join(\",\");\n    return serializedEntries;\n  }\n\n  /**\n   * @deprecated\n   * Return a json-like object representing this LLM.\n   */\n  serialize(): SerializedLLM {\n    return {\n      ...this._identifyingParams(),\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n  }\n\n  /**\n   * @deprecated\n   * Load an LLM from a json-like object describing it.\n   */\n  static async deserialize(_data: SerializedLLM): Promise<BaseLanguageModel> {\n    throw new Error(\"Use .toJSON() instead\");\n  }\n\n  /**\n   * Return profiling information for the model.\n   *\n   * @returns {ModelProfile} An object describing the model's capabilities and constraints\n   */\n  get profile(): ModelProfile {\n    return {};\n  }\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  /**\n   * Model wrapper that returns outputs formatted to match the given schema.\n   *\n   * @template {BaseLanguageModelInput} RunInput The input type for the Runnable, expected to be the same input for the LLM.\n   * @template {Record<string, any>} RunOutput The output type for the Runnable, expected to be a Zod schema object for structured output validation.\n   *\n   * @param {InteropZodType<RunOutput>} schema The schema for the structured output. Either as a Zod schema or a valid JSON schema object.\n   *   If a Zod schema is passed, the returned attributes will be validated, whereas with JSON schema they will not be.\n   * @param {string} name The name of the function to call.\n   * @param {\"functionCalling\" | \"jsonMode\"} [method=functionCalling] The method to use for getting the structured output. Defaults to \"functionCalling\".\n   * @param {boolean | undefined} [includeRaw=false] Whether to include the raw output in the result. Defaults to false.\n   * @returns {Runnable<RunInput, RunOutput> | Runnable<RunInput, { raw: BaseMessage; parsed: RunOutput }>} A new runnable that calls the LLM with structured output.\n   */\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      >;\n}\n\n/**\n * Shared interface for token usage\n * return type from LLM calls.\n */\nexport interface TokenUsage {\n  completionTokens?: number;\n  promptTokens?: number;\n  totalTokens?: number;\n}\n", "import { concat } from \"../utils/stream.js\";\nimport {\n  Runnable,\n  RunnableAssign,\n  RunnableMap,\n  RunnableMapLike,\n} from \"./base.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RunnablePassthroughFunc<RunInput = any> =\n  | ((input: RunInput) => void)\n  | ((input: RunInput, config?: RunnableConfig) => void)\n  | ((input: RunInput) => Promise<void>)\n  | ((input: RunInput, config?: RunnableConfig) => Promise<void>);\n\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnablePassthrough<RunInput = any> extends Runnable<\n  RunInput,\n  RunInput\n> {\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  func?: RunnablePassthroughFunc<RunInput>;\n\n  constructor(fields?: { func?: RunnablePassthroughFunc<RunInput> }) {\n    super(fields);\n    if (fields) {\n      this.func = fields.func;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunInput> {\n    const config = ensureConfig(options);\n    if (this.func) {\n      await this.func(input, config);\n    }\n\n    return this._callWithConfig(\n      (input: RunInput) => Promise.resolve(input),\n      input,\n      config\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<RunnableConfig>\n  ): AsyncGenerator<RunInput> {\n    const config = ensureConfig(options);\n    let finalOutput: RunInput | undefined;\n    let finalOutputSupported = true;\n\n    for await (const chunk of this._transformStreamWithConfig(\n      generator,\n      (input: AsyncGenerator<RunInput>) => input,\n      config\n    )) {\n      yield chunk;\n      if (finalOutputSupported) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            finalOutput = concat(finalOutput, chunk as any);\n          } catch {\n            finalOutput = undefined;\n            finalOutputSupported = false;\n          }\n        }\n      }\n    }\n\n    if (this.func && finalOutput !== undefined) {\n      await this.func(finalOutput, config);\n    }\n  }\n\n  /**\n   * A runnable that assigns key-value pairs to the input.\n   *\n   * The example below shows how you could use it with an inline function.\n   *\n   * @example\n   * ```typescript\n   * const prompt =\n   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n   * Question: {question}\n   * SQL Query:`);\n   *\n   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n   * // In this case, we're passing the schema.\n   * const sqlQueryGeneratorChain = RunnableSequence.from([\n   *   RunnablePassthrough.assign({\n   *     schema: async () => db.getTableInfo(),\n   *   }),\n   *   prompt,\n   *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n   *   new StringOutputParser(),\n   * ]);\n   * const result = await sqlQueryGeneratorChain.invoke({\n   *   question: \"How many employees are there?\",\n   * });\n   * ```\n   */\n  static assign<\n    RunInput extends Record<string, unknown> = Record<string, unknown>,\n    RunOutput extends Record<string, unknown> = Record<string, unknown>,\n  >(\n    mapping: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableAssign<RunInput, RunInput & RunOutput> {\n    return new RunnableAssign(new RunnableMap({ steps: mapping }));\n  }\n}\n", "import { BaseMessage } from \"../messages/base.js\";\n\ntype Constructor<T> = new (...args: unknown[]) => T;\n\nexport const iife = <T>(fn: () => T): T => fn();\n\nfunction castStandardMessageContent<T extends BaseMessage>(message: T) {\n  const Cls = message.constructor as Constructor<T>;\n  return new Cls({\n    ...message,\n    content: message.contentBlocks,\n    response_metadata: {\n      ...message.response_metadata,\n      output_version: \"v1\",\n    },\n  });\n}\n\nexport { castStandardMessageContent };\n", "import type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\nimport {\n  AIMessage,\n  type BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageLike,\n  coerceMessageLikeToMessage,\n  AIMessageChunk,\n  isAIMessageChunk,\n  isBaseMessage,\n  isAIMessage,\n  MessageOutputVersion,\n} from \"../messages/index.js\";\nimport {\n  convertToOpenAIImageBlock,\n  isURLContentBlock,\n  isBase64ContentBlock,\n} from \"../messages/content/data.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport {\n  LLMResult,\n  RUN_KEY,\n  type ChatGeneration,\n  ChatGenerationChunk,\n  type ChatResult,\n  type Generation,\n} from \"../outputs.js\";\nimport {\n  BaseLanguageModel,\n  type StructuredOutputMethodOptions,\n  type ToolDefinition,\n  type BaseLanguageModelCallOptions,\n  type BaseLanguageModelInput,\n  type BaseLanguageModelParams,\n} from \"./base.js\";\nimport {\n  CallbackManager,\n  type CallbackManagerForLLMRun,\n  type Callbacks,\n} from \"../callbacks/manager.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BaseCache } from \"../caches/index.js\";\nimport {\n  StructuredToolInterface,\n  StructuredToolParams,\n} from \"../tools/index.js\";\nimport {\n  Runnable,\n  RunnableLambda,\n  RunnableSequence,\n  RunnableToolLike,\n} from \"../runnables/base.js\";\nimport { concat } from \"../utils/stream.js\";\nimport { RunnablePassthrough } from \"../runnables/passthrough.js\";\nimport {\n  getSchemaDescription,\n  InteropZodType,\n  isInteropZodSchema,\n} from \"../utils/types/zod.js\";\nimport { callbackHandlerPrefersStreaming } from \"../callbacks/base.js\";\nimport { toJsonSchema } from \"../utils/json_schema.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { castStandardMessageContent, iife } from \"./utils.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolChoice = string | Record<string, any> | \"auto\" | \"any\";\n\n/**\n * Represents a serialized chat model.\n */\nexport type SerializedChatModel = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n// todo?\n/**\n * Represents a serialized large language model.\n */\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n/**\n * Represents the parameters for a base chat model.\n */\nexport type BaseChatModelParams = BaseLanguageModelParams & {\n  /**\n   * Whether to disable streaming.\n   *\n   * If streaming is bypassed, then `stream()` will defer to\n   * `invoke()`.\n   *\n   * - If true, will always bypass streaming case.\n   * - If false (default), will always use streaming case if available.\n   */\n  disableStreaming?: boolean;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\n/**\n * Represents the call options for a base chat model.\n */\nexport type BaseChatModelCallOptions = BaseLanguageModelCallOptions & {\n  /**\n   * Specifies how the chat model should use tools.\n   * @default undefined\n   *\n   * Possible values:\n   * - \"auto\": The model may choose to use any of the provided tools, or none.\n   * - \"any\": The model must use one of the provided tools.\n   * - \"none\": The model must not use any tools.\n   * - A string (not \"auto\", \"any\", or \"none\"): The name of a specific tool the model must use.\n   * - An object: A custom schema specifying tool choice parameters. Specific to the provider.\n   *\n   * Note: Not all providers support tool_choice. An error will be thrown\n   * if used with an unsupported model.\n   */\n  tool_choice?: ToolChoice;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\nfunction _formatForTracing(messages: BaseMessage[]): BaseMessage[] {\n  const messagesToTrace: BaseMessage[] = [];\n  for (const message of messages) {\n    let messageToTrace = message;\n    if (Array.isArray(message.content)) {\n      for (let idx = 0; idx < message.content.length; idx++) {\n        const block = message.content[idx];\n        if (isURLContentBlock(block) || isBase64ContentBlock(block)) {\n          if (messageToTrace === message) {\n            // Also shallow-copy content\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            messageToTrace = new (message.constructor as any)({\n              ...messageToTrace,\n              content: [\n                ...message.content.slice(0, idx),\n                convertToOpenAIImageBlock(block),\n                ...message.content.slice(idx + 1),\n              ],\n            });\n          }\n        }\n      }\n    }\n    messagesToTrace.push(messageToTrace);\n  }\n  return messagesToTrace;\n}\n\nexport type LangSmithParams = {\n  ls_provider?: string;\n  ls_model_name?: string;\n  ls_model_type: \"chat\";\n  ls_temperature?: number;\n  ls_max_tokens?: number;\n  ls_stop?: Array<string>;\n};\n\nexport type BindToolsInput =\n  | StructuredToolInterface\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | Record<string, any>\n  | ToolDefinition\n  | RunnableToolLike\n  | StructuredToolParams;\n\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nexport abstract class BaseChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions,\n  // TODO: Fix the parameter order on the next minor version.\n  OutputMessageType extends BaseMessageChunk = AIMessageChunk,\n> extends BaseLanguageModel<OutputMessageType, CallOptions> {\n  // Backwards compatibility since fields have been moved to RunnableConfig\n  declare ParsedCallOptions: Omit<\n    CallOptions,\n    Exclude<keyof RunnableConfig, \"signal\" | \"timeout\" | \"maxConcurrency\">\n  >;\n\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"chat_models\", this._llmType()];\n\n  disableStreaming = false;\n\n  outputVersion?: MessageOutputVersion;\n\n  get callKeys(): string[] {\n    return [...super.callKeys, \"outputVersion\"];\n  }\n\n  constructor(fields: BaseChatModelParams) {\n    super(fields);\n    this.outputVersion = iife(() => {\n      const outputVersion =\n        fields.outputVersion ?? getEnvironmentVariable(\"LC_OUTPUT_VERSION\");\n      if (outputVersion && [\"v0\", \"v1\"].includes(outputVersion)) {\n        return outputVersion as \"v0\" | \"v1\";\n      }\n      return \"v0\";\n    });\n  }\n\n  _combineLLMOutput?(\n    ...llmOutputs: LLMResult[\"llmOutput\"][]\n  ): LLMResult[\"llmOutput\"];\n\n  protected _separateRunnableConfigFromCallOptionsCompat(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, this[\"ParsedCallOptions\"]] {\n    // For backwards compat, keep `signal` in both runnableConfig and callOptions\n    const [runnableConfig, callOptions] =\n      super._separateRunnableConfigFromCallOptions(options);\n    (callOptions as this[\"ParsedCallOptions\"]).signal = runnableConfig.signal;\n    return [runnableConfig, callOptions as this[\"ParsedCallOptions\"]];\n  }\n\n  /**\n   * Bind tool-like objects to this chat model.\n   *\n   * @param tools A list of tool definitions to bind to this chat model.\n   * Can be a structured tool, an OpenAI formatted tool, or an object\n   * matching the provider's specific tool schema.\n   * @param kwargs Any additional parameters to bind.\n   */\n  bindTools?(\n    tools: BindToolsInput[],\n    kwargs?: Partial<CallOptions>\n  ): Runnable<BaseLanguageModelInput, OutputMessageType, CallOptions>;\n\n  /**\n   * Invokes the chat model with a single input.\n   * @param input The input for the language model.\n   * @param options The call options.\n   * @returns A Promise that resolves to a BaseMessageChunk.\n   */\n  async invoke(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): Promise<OutputMessageType> {\n    const promptValue = BaseChatModel._convertInputToPromptValue(input);\n    const result = await this.generatePrompt(\n      [promptValue],\n      options,\n      options?.callbacks\n    );\n    const chatGeneration = result.generations[0][0] as ChatGeneration;\n    // TODO: Remove cast after figuring out inheritance\n    return chatGeneration.message as OutputMessageType;\n  }\n\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(\n    _messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async *_streamIterator(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): AsyncGenerator<OutputMessageType> {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (\n      this._streamResponseChunks ===\n        BaseChatModel.prototype._streamResponseChunks ||\n      this.disableStreaming\n    ) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseChatModel._convertInputToPromptValue(input);\n      const messages = prompt.toChatMessages();\n      const [runnableConfig, callOptions] =\n        this._separateRunnableConfigFromCallOptionsCompat(options);\n\n      const inheritableMetadata = {\n        ...runnableConfig.metadata,\n        ...this.getLsParams(callOptions),\n      };\n      const callbackManager_ = await CallbackManager.configure(\n        runnableConfig.callbacks,\n        this.callbacks,\n        runnableConfig.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1,\n      };\n      const outputVersion = callOptions.outputVersion ?? this.outputVersion;\n      const runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        [_formatForTracing(messages)],\n        runnableConfig.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        runnableConfig.runName\n      );\n      let generationChunk: ChatGenerationChunk | undefined;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let llmOutput: Record<string, any> | undefined;\n      try {\n        for await (const chunk of this._streamResponseChunks(\n          messages,\n          callOptions,\n          runManagers?.[0]\n        )) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          chunk.message.response_metadata = {\n            ...chunk.generationInfo,\n            ...chunk.message.response_metadata,\n          };\n          if (outputVersion === \"v1\") {\n            yield castStandardMessageContent(\n              chunk.message\n            ) as OutputMessageType;\n          } else {\n            yield chunk.message as OutputMessageType;\n          }\n          if (!generationChunk) {\n            generationChunk = chunk;\n          } else {\n            generationChunk = generationChunk.concat(chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n      await Promise.all(\n        (runManagers ?? []).map((runManager) =>\n          runManager?.handleLLMEnd({\n            // TODO: Remove cast after figuring out inheritance\n            generations: [[generationChunk as ChatGeneration]],\n            llmOutput,\n          })\n        )\n      );\n    }\n  }\n\n  getLsParams(options: this[\"ParsedCallOptions\"]): LangSmithParams {\n    const providerName = this.getName().startsWith(\"Chat\")\n      ? this.getName().replace(\"Chat\", \"\")\n      : this.getName();\n\n    return {\n      ls_model_type: \"chat\",\n      ls_stop: options.stop,\n      ls_provider: providerName,\n    };\n  }\n\n  /** @ignore */\n  async _generateUncached(\n    messages: BaseMessageLike[][],\n    parsedOptions: this[\"ParsedCallOptions\"],\n    handledOptions: RunnableConfig,\n    startedRunManagers?: CallbackManagerForLLMRun[]\n  ): Promise<LLMResult> {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    let runManagers: CallbackManagerForLLMRun[] | undefined;\n    if (\n      startedRunManagers !== undefined &&\n      startedRunManagers.length === baseMessages.length\n    ) {\n      runManagers = startedRunManagers;\n    } else {\n      const inheritableMetadata = {\n        ...handledOptions.metadata,\n        ...this.getLsParams(parsedOptions),\n      };\n      // create callback manager and start run\n      const callbackManager_ = await CallbackManager.configure(\n        handledOptions.callbacks,\n        this.callbacks,\n        handledOptions.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: parsedOptions,\n        invocation_params: this?.invocationParams(parsedOptions),\n        batch_size: 1,\n      };\n      runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        baseMessages.map(_formatForTracing),\n        handledOptions.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        handledOptions.runName\n      );\n    }\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: ChatGeneration[][] = [];\n    const llmOutputs: LLMResult[\"llmOutput\"][] = [];\n    // Even if stream is not explicitly called, check if model is implicitly\n    // called from streamEvents() or streamLog() to get all streamed events.\n    // Bail out if _streamResponseChunks not overridden\n    const hasStreamingHandler = !!runManagers?.[0].handlers.find(\n      callbackHandlerPrefersStreaming\n    );\n    if (\n      hasStreamingHandler &&\n      !this.disableStreaming &&\n      baseMessages.length === 1 &&\n      this._streamResponseChunks !==\n        BaseChatModel.prototype._streamResponseChunks\n    ) {\n      try {\n        const stream = await this._streamResponseChunks(\n          baseMessages[0],\n          parsedOptions,\n          runManagers?.[0]\n        );\n        let aggregated;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let llmOutput: Record<string, any> | undefined;\n        for await (const chunk of stream) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          if (aggregated === undefined) {\n            aggregated = chunk;\n          } else {\n            aggregated = concat(aggregated, chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n        if (aggregated === undefined) {\n          throw new Error(\"Received empty response from chat model call.\");\n        }\n        generations.push([aggregated]);\n        await runManagers?.[0].handleLLMEnd({\n          generations,\n          llmOutput,\n        });\n      } catch (e) {\n        await runManagers?.[0].handleLLMError(e);\n        throw e;\n      }\n    } else {\n      // generate results\n      const results = await Promise.allSettled(\n        baseMessages.map(async (messageList, i) => {\n          const generateResults = await this._generate(\n            messageList,\n            { ...parsedOptions, promptIndex: i },\n            runManagers?.[i]\n          );\n          if (outputVersion === \"v1\") {\n            for (const generation of generateResults.generations) {\n              generation.message = castStandardMessageContent(\n                generation.message\n              );\n            }\n          }\n          return generateResults;\n        })\n      );\n      // handle results\n      await Promise.all(\n        results.map(async (pResult, i) => {\n          if (pResult.status === \"fulfilled\") {\n            const result = pResult.value;\n            for (const generation of result.generations) {\n              if (generation.message.id == null) {\n                const runId = runManagers?.at(0)?.runId;\n                if (runId != null) generation.message._updateId(`run-${runId}`);\n              }\n              generation.message.response_metadata = {\n                ...generation.generationInfo,\n                ...generation.message.response_metadata,\n              };\n            }\n            if (result.generations.length === 1) {\n              result.generations[0].message.response_metadata = {\n                ...result.llmOutput,\n                ...result.generations[0].message.response_metadata,\n              };\n            }\n            generations[i] = result.generations;\n            llmOutputs[i] = result.llmOutput;\n            return runManagers?.[i]?.handleLLMEnd({\n              generations: [result.generations],\n              llmOutput: result.llmOutput,\n            });\n          } else {\n            // status === \"rejected\"\n            await runManagers?.[i]?.handleLLMError(pResult.reason);\n            return Promise.reject(pResult.reason);\n          }\n        })\n      );\n    }\n    // create combined output\n    const output: LLMResult = {\n      generations,\n      llmOutput: llmOutputs.length\n        ? this._combineLLMOutput?.(...llmOutputs)\n        : undefined,\n    };\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n    return output;\n  }\n\n  async _generateCached({\n    messages,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions,\n  }: {\n    messages: BaseMessageLike[][];\n    cache: BaseCache<Generation[]>;\n    llmStringKey: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parsedOptions: any;\n    handledOptions: RunnableConfig;\n  }): Promise<\n    LLMResult & {\n      missingPromptIndices: number[];\n      startedRunManagers?: CallbackManagerForLLMRun[];\n    }\n  > {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const inheritableMetadata = {\n      ...handledOptions.metadata,\n      ...this.getLsParams(parsedOptions),\n    };\n    // create callback manager and start run\n    const callbackManager_ = await CallbackManager.configure(\n      handledOptions.callbacks,\n      this.callbacks,\n      handledOptions.tags,\n      this.tags,\n      inheritableMetadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: 1,\n    };\n    const runManagers = await callbackManager_?.handleChatModelStart(\n      this.toJSON(),\n      baseMessages.map(_formatForTracing),\n      handledOptions.runId,\n      undefined,\n      extra,\n      undefined,\n      undefined,\n      handledOptions.runName\n    );\n\n    // generate results\n    const missingPromptIndices: number[] = [];\n    const results = await Promise.allSettled(\n      baseMessages.map(async (baseMessage, index) => {\n        // Join all content into one string for the prompt index\n        const prompt =\n          BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n        const result = await cache.lookup(prompt, llmStringKey);\n\n        if (result == null) {\n          missingPromptIndices.push(index);\n        }\n\n        return result;\n      })\n    );\n\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results\n      .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n      .filter(\n        ({ result }) =>\n          (result.status === \"fulfilled\" && result.value != null) ||\n          result.status === \"rejected\"\n      );\n\n    // Handle results and call run managers\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: Generation[][] = [];\n    await Promise.all(\n      cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n        if (promiseResult.status === \"fulfilled\") {\n          const result = promiseResult.value as Generation[];\n          generations[i] = result.map((result) => {\n            if (\n              \"message\" in result &&\n              isBaseMessage(result.message) &&\n              isAIMessage(result.message)\n            ) {\n              result.message.usage_metadata = {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n              };\n              if (outputVersion === \"v1\") {\n                result.message = castStandardMessageContent(result.message);\n              }\n            }\n            result.generationInfo = {\n              ...result.generationInfo,\n              tokenUsage: {},\n            };\n            return result;\n          });\n          if (result.length) {\n            await runManager?.handleLLMNewToken(result[0].text);\n          }\n          return runManager?.handleLLMEnd(\n            {\n              generations: [result],\n            },\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n        } else {\n          // status === \"rejected\"\n          await runManager?.handleLLMError(\n            promiseResult.reason,\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n          return Promise.reject(promiseResult.reason);\n        }\n      })\n    );\n\n    const output = {\n      generations,\n      missingPromptIndices,\n      startedRunManagers: runManagers,\n    };\n\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n\n    return output;\n  }\n\n  /**\n   * Generates chat based on the input messages.\n   * @param messages An array of arrays of BaseMessage instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generate(\n    messages: BaseMessageLike[][],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    // parse call options\n    let parsedOptions: CallOptions | undefined;\n    if (Array.isArray(options)) {\n      parsedOptions = { stop: options } as CallOptions;\n    } else {\n      parsedOptions = options;\n    }\n\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const [runnableConfig, callOptions] =\n      this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n\n    if (!this.cache) {\n      return this._generateUncached(baseMessages, callOptions, runnableConfig);\n    }\n\n    const { cache } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(\n      callOptions as CallOptions\n    );\n\n    const { generations, missingPromptIndices, startedRunManagers } =\n      await this._generateCached({\n        messages: baseMessages,\n        cache,\n        llmStringKey,\n        parsedOptions: callOptions,\n        handledOptions: runnableConfig,\n      });\n\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(\n        missingPromptIndices.map((i) => baseMessages[i]),\n        callOptions,\n        runnableConfig,\n        startedRunManagers !== undefined\n          ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n          : undefined\n      );\n      await Promise.all(\n        results.generations.map(async (generation, index) => {\n          const promptIndex = missingPromptIndices[index];\n          generations[promptIndex] = generation;\n          // Join all content into one string for the prompt index\n          const prompt = BaseChatModel._convertInputToPromptValue(\n            baseMessages[promptIndex]\n          ).toString();\n          return cache.update(prompt, llmStringKey, generation);\n        })\n      );\n      llmOutput = results.llmOutput ?? {};\n    }\n\n    return { generations, llmOutput } as LLMResult;\n  }\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options?: this[\"ParsedCallOptions\"]): any {\n    return {};\n  }\n\n  _modelType(): string {\n    return \"base_chat_model\" as const;\n  }\n\n  abstract _llmType(): string;\n\n  /**\n   * Generates a prompt based on the input prompt values.\n   * @param promptValues An array of BasePromptValue instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    const promptMessages: BaseMessage[][] = promptValues.map((promptValue) =>\n      promptValue.toChatMessages()\n    );\n    return this.generate(promptMessages, options, callbacks);\n  }\n\n  abstract _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      > {\n    if (typeof this.bindTools !== \"function\") {\n      throw new Error(\n        `Chat model must implement \".bindTools()\" to use withStructuredOutput.`\n      );\n    }\n    if (config?.strict) {\n      throw new Error(\n        `\"strict\" mode is not supported for this model by default.`\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const schema: Record<string, any> | InteropZodType<RunOutput> =\n      outputSchema;\n    const name = config?.name;\n    const description =\n      getSchemaDescription(schema) ?? \"A function available to call.\";\n    const method = config?.method;\n    const includeRaw = config?.includeRaw;\n    if (method === \"jsonMode\") {\n      throw new Error(\n        `Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`\n      );\n    }\n\n    let functionName = name ?? \"extract\";\n    let tools: ToolDefinition[];\n    if (isInteropZodSchema(schema)) {\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: toJsonSchema(schema),\n          },\n        },\n      ];\n    } else {\n      if (\"name\" in schema) {\n        functionName = schema.name;\n      }\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: schema,\n          },\n        },\n      ];\n    }\n\n    const llm = this.bindTools(tools);\n    const outputParser = RunnableLambda.from<OutputMessageType, RunOutput>(\n      (input: BaseMessageChunk): RunOutput => {\n        if (!AIMessageChunk.isInstance(input)) {\n          throw new Error(\"Input is not an AIMessageChunk.\");\n        }\n        if (!input.tool_calls || input.tool_calls.length === 0) {\n          throw new Error(\"No tool calls found in the response.\");\n        }\n        const toolCall = input.tool_calls.find(\n          (tc) => tc.name === functionName\n        );\n        if (!toolCall) {\n          throw new Error(`No tool call found with name ${functionName}.`);\n        }\n        return toolCall.args as RunOutput;\n      }\n    );\n\n    if (!includeRaw) {\n      return llm.pipe(outputParser).withConfig({\n        runName: \"StructuredOutput\",\n      }) as Runnable<BaseLanguageModelInput, RunOutput>;\n    }\n\n    const parserAssign = RunnablePassthrough.assign({\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parsed: (input: any, config) => outputParser.invoke(input.raw, config),\n    });\n    const parserNone = RunnablePassthrough.assign({\n      parsed: () => null,\n    });\n    const parsedWithFallback = parserAssign.withFallbacks({\n      fallbacks: [parserNone],\n    });\n    return RunnableSequence.from<\n      BaseLanguageModelInput,\n      { raw: BaseMessage; parsed: RunOutput }\n    >([\n      {\n        raw: llm,\n      },\n      parsedWithFallback,\n    ]).withConfig({\n      runName: \"StructuredOutputRunnable\",\n    });\n  }\n}\n\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nexport abstract class SimpleChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions,\n> extends BaseChatModel<CallOptions> {\n  abstract _call(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string>;\n\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const text = await this._call(messages, options, runManager);\n    const message = new AIMessage(text);\n    if (typeof message.content !== \"string\") {\n      throw new Error(\n        \"Cannot generate with a simple chat model when output is not a string.\"\n      );\n    }\n    return {\n      generations: [\n        {\n          text: message.content,\n          message,\n        },\n      ],\n    };\n  }\n}\n", "import { Runnable, type RunnableBatchOptions } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\nexport type RouterInput = {\n  key: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any;\n};\n\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nexport class RouterRunnable<\n  RunInput extends RouterInput,\n  RunnableInput,\n  RunOutput,\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n\n  constructor(fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }) {\n    super(fields);\n    this.runnables = fields.runnables;\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.invoke(actualInput, ensureConfig(options));\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const keys = inputs.map((input) => input.key);\n    const actualInputs = inputs.map((input) => input.input);\n    const missingKey = keys.find((key) => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(`One or more keys do not have a corresponding runnable.`);\n    }\n    const runnables = keys.map((key) => this.runnables[key]);\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency =\n      optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const batchSize =\n      maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs\n        .slice(i, i + batchSize)\n        .map((actualInput, i) =>\n          runnables[i].invoke(actualInput, optionsList[i])\n        );\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.stream(actualInput, options);\n  }\n}\n", "import {\n  Runnable,\n  RunnableLike,\n  _coerceToDict,\n  _coerceToRunnable,\n} from \"./base.js\";\nimport {\n  RunnableConfig,\n  getCallbackManagerForConfig,\n  patchConfig,\n} from \"./config.js\";\nimport { CallbackManagerForChainRun } from \"../callbacks/manager.js\";\nimport { concat } from \"../utils/stream.js\";\n\n/**\n * Type for a branch in the RunnableBranch. It consists of a condition\n * runnable and a branch runnable. The condition runnable is used to\n * determine whether the branch should be executed, and the branch runnable\n * is executed if the condition is true.\n */\nexport type Branch<RunInput, RunOutput> = [\n  Runnable<RunInput, boolean>,\n  Runnable<RunInput, RunOutput>,\n];\n\nexport type BranchLike<RunInput, RunOutput> = [\n  RunnableLike<RunInput, boolean>,\n  RunnableLike<RunInput, RunOutput>,\n];\n\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch<RunInput = any, RunOutput = any> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  static lc_name() {\n    return \"RunnableBranch\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  default: Runnable<RunInput, RunOutput>;\n\n  branches: Branch<RunInput, RunOutput>[];\n\n  constructor(fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }) {\n    super(fields);\n    this.branches = fields.branches;\n    this.default = fields.default;\n  }\n\n  /**\n   * Convenience method for instantiating a RunnableBranch from\n   * RunnableLikes (objects, functions, or Runnables).\n   *\n   * Each item in the input except for the last one should be a\n   * tuple with two items. The first is a \"condition\" RunnableLike that\n   * returns \"true\" if the second RunnableLike in the tuple should run.\n   *\n   * The final item in the input should be a RunnableLike that acts as a\n   * default branch if no other branches match.\n   *\n   * @example\n   * ```ts\n   * import { RunnableBranch } from \"@langchain/core/runnables\";\n   *\n   * const branch = RunnableBranch.from([\n   *   [(x: number) => x > 0, (x: number) => x + 1],\n   *   [(x: number) => x < 0, (x: number) => x - 1],\n   *   (x: number) => x\n   * ]);\n   * ```\n   * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n   *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n   * @returns A new RunnableBranch.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from<RunInput = any, RunOutput = any>(\n    branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>,\n    ]\n  ) {\n    if (branches.length < 1) {\n      throw new Error(\"RunnableBranch requires at least one branch\");\n    }\n    const branchLikes = branches.slice(0, -1) as BranchLike<\n      RunInput,\n      RunOutput\n    >[];\n    const coercedBranches: Branch<RunInput, RunOutput>[] = branchLikes.map(\n      ([condition, runnable]) => [\n        _coerceToRunnable(condition),\n        _coerceToRunnable(runnable),\n      ]\n    );\n    const defaultBranch = _coerceToRunnable(\n      branches[branches.length - 1] as RunnableLike<RunInput, RunOutput>\n    );\n    return new this({\n      branches: coercedBranches,\n      default: defaultBranch,\n    });\n  }\n\n  async _invoke(\n    input: RunInput,\n    config?: Partial<RunnableConfig>,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutput> {\n    let result;\n    for (let i = 0; i < this.branches.length; i += 1) {\n      const [condition, branchRunnable] = this.branches[i];\n      const conditionValue = await condition.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(`condition:${i + 1}`),\n        })\n      );\n      if (conditionValue) {\n        result = await branchRunnable.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`branch:${i + 1}`),\n          })\n        );\n        break;\n      }\n    }\n    if (!result) {\n      result = await this.default.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(\"branch:default\"),\n        })\n      );\n    }\n    return result;\n  }\n\n  async invoke(\n    input: RunInput,\n    config: RunnableConfig = {}\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n\n  async *_streamIterator(input: RunInput, config?: Partial<RunnableConfig>) {\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config?.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    let finalOutput;\n    let finalOutputSupported = true;\n    let stream;\n    try {\n      for (let i = 0; i < this.branches.length; i += 1) {\n        const [condition, branchRunnable] = this.branches[i];\n        const conditionValue = await condition.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`condition:${i + 1}`),\n          })\n        );\n        if (conditionValue) {\n          stream = await branchRunnable.stream(\n            input,\n            patchConfig(config, {\n              callbacks: runManager?.getChild(`branch:${i + 1}`),\n            })\n          );\n          for await (const chunk of stream) {\n            yield chunk;\n            if (finalOutputSupported) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                try {\n                  finalOutput = concat(finalOutput, chunk);\n                } catch {\n                  finalOutput = undefined;\n                  finalOutputSupported = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (stream === undefined) {\n        stream = await this.default.stream(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(\"branch:default\"),\n          })\n        );\n        for await (const chunk of stream) {\n          yield chunk;\n          if (finalOutputSupported) {\n            if (finalOutput === undefined) {\n              finalOutput = chunk;\n            } else {\n              try {\n                finalOutput = concat(finalOutput, chunk as RunOutput);\n              } catch {\n                finalOutput = undefined;\n                finalOutputSupported = false;\n              }\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {});\n  }\n}\n", "import {\n  BaseChatMessageHistory,\n  BaseListChatMessageHistory,\n} from \"../chat_history.js\";\nimport {\n  AIMessage,\n  BaseMessage,\n  HumanMessage,\n  isBaseMessage,\n} from \"../messages/index.js\";\nimport { Run } from \"../tracers/base.js\";\nimport {\n  Runnable,\n  RunnableBinding,\n  type RunnableBindingArgs,\n  RunnableLambda,\n} from \"./base.js\";\nimport { RunnableConfig } from \"./config.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n\ntype GetSessionHistoryCallable = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: Array<any>\n) =>\n  | Promise<BaseChatMessageHistory | BaseListChatMessageHistory>\n  | BaseChatMessageHistory\n  | BaseListChatMessageHistory;\n\nexport interface RunnableWithMessageHistoryInputs<RunInput, RunOutput>\n  extends Omit<RunnableBindingArgs<RunInput, RunOutput>, \"bound\" | \"config\"> {\n  runnable: Runnable<RunInput, RunOutput>;\n  getMessageHistory: GetSessionHistoryCallable;\n  inputMessagesKey?: string;\n  outputMessagesKey?: string;\n  historyMessagesKey?: string;\n  config?: RunnableConfig;\n}\n\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // pnpm install @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"@langchain/classic/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory<\n  RunInput,\n  RunOutput,\n> extends RunnableBinding<RunInput, RunOutput> {\n  runnable: Runnable<RunInput, RunOutput>;\n\n  inputMessagesKey?: string;\n\n  outputMessagesKey?: string;\n\n  historyMessagesKey?: string;\n\n  getMessageHistory: GetSessionHistoryCallable;\n\n  constructor(fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>) {\n    let historyChain: Runnable = RunnableLambda.from((input, options) =>\n      this._enterHistory(input, options ?? {})\n    ).withConfig({ runName: \"loadHistory\" });\n\n    const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n    if (messagesKey) {\n      historyChain = RunnablePassthrough.assign({\n        [messagesKey]: historyChain,\n      }).withConfig({ runName: \"insertHistory\" });\n    }\n\n    const bound = historyChain\n      .pipe(\n        fields.runnable.withListeners({\n          onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        })\n      )\n      .withConfig({ runName: \"RunnableWithMessageHistory\" });\n\n    const config = fields.config ?? {};\n\n    super({\n      ...fields,\n      config,\n      bound,\n    });\n    this.runnable = fields.runnable;\n    this.getMessageHistory = fields.getMessageHistory;\n    this.inputMessagesKey = fields.inputMessagesKey;\n    this.outputMessagesKey = fields.outputMessagesKey;\n    this.historyMessagesKey = fields.historyMessagesKey;\n  }\n\n  _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedInputValue;\n    if (\n      typeof inputValue === \"object\" &&\n      !Array.isArray(inputValue) &&\n      !isBaseMessage(inputValue)\n    ) {\n      let key;\n      if (this.inputMessagesKey) {\n        key = this.inputMessagesKey;\n      } else if (Object.keys(inputValue).length === 1) {\n        key = Object.keys(inputValue)[0];\n      } else {\n        key = \"input\";\n      }\n      if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n        parsedInputValue = inputValue[key][0];\n      } else {\n        parsedInputValue = inputValue[key];\n      }\n    } else {\n      parsedInputValue = inputValue;\n    }\n    if (typeof parsedInputValue === \"string\") {\n      return [new HumanMessage(parsedInputValue)];\n    } else if (Array.isArray(parsedInputValue)) {\n      return parsedInputValue;\n    } else if (isBaseMessage(parsedInputValue)) {\n      return [parsedInputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(\n          parsedInputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedOutputValue;\n    if (\n      !Array.isArray(outputValue) &&\n      !isBaseMessage(outputValue) &&\n      typeof outputValue !== \"string\"\n    ) {\n      let key;\n      if (this.outputMessagesKey !== undefined) {\n        key = this.outputMessagesKey;\n      } else if (Object.keys(outputValue).length === 1) {\n        key = Object.keys(outputValue)[0];\n      } else {\n        key = \"output\";\n      }\n      // If you are wrapping a chat model directly\n      // The output is actually this weird generations object\n      if (outputValue.generations !== undefined) {\n        parsedOutputValue = outputValue.generations[0][0].message;\n      } else {\n        parsedOutputValue = outputValue[key];\n      }\n    } else {\n      parsedOutputValue = outputValue;\n    }\n\n    if (typeof parsedOutputValue === \"string\") {\n      return [new AIMessage(parsedOutputValue)];\n    } else if (Array.isArray(parsedOutputValue)) {\n      return parsedOutputValue;\n    } else if (isBaseMessage(parsedOutputValue)) {\n      return [parsedOutputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(\n          parsedOutputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: any,\n    kwargs?: RunnableConfig\n  ): Promise<BaseMessage[]> {\n    const history = kwargs?.configurable?.messageHistory;\n    const messages = await history.getMessages();\n    if (this.historyMessagesKey === undefined) {\n      return messages.concat(this._getInputMessages(input));\n    }\n    return messages;\n  }\n\n  async _exitHistory(run: Run, config: RunnableConfig): Promise<void> {\n    const history = config.configurable?.messageHistory;\n\n    // Get input messages\n    let inputs;\n    // Chat model inputs are nested arrays\n    if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n      inputs = run.inputs[0];\n    } else {\n      inputs = run.inputs;\n    }\n    let inputMessages = this._getInputMessages(inputs);\n    // If historic messages were prepended to the input messages, remove them to\n    // avoid adding duplicate messages to history.\n    if (this.historyMessagesKey === undefined) {\n      const existingMessages = await history.getMessages();\n      inputMessages = inputMessages.slice(existingMessages.length);\n    }\n    // Get output messages\n    const outputValue = run.outputs;\n    if (!outputValue) {\n      throw new Error(\n        `Output values from 'Run' undefined. Run: ${JSON.stringify(\n          run,\n          null,\n          2\n        )}`\n      );\n    }\n    const outputMessages = this._getOutputMessages(outputValue);\n    await history.addMessages([...inputMessages, ...outputMessages]);\n  }\n\n  async _mergeConfig(...configs: Array<RunnableConfig | undefined>) {\n    const config = await super._mergeConfig(...configs);\n    // Extract sessionId\n    if (!config.configurable || !config.configurable.sessionId) {\n      const exampleInput = {\n        [this.inputMessagesKey ?? \"input\"]: \"foo\",\n      };\n      const exampleConfig = { configurable: { sessionId: \"123\" } };\n      throw new Error(\n        `sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n          `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(\n            exampleConfig\n          )})`\n      );\n    }\n    // attach messageHistory\n    const { sessionId } = config.configurable;\n    config.configurable.messageHistory =\n      await this.getMessageHistory(sessionId);\n    return config;\n  }\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys } from \"./config.js\";\nimport { raceWithSignal } from \"../utils/signal.js\";\nimport { Runnable, RunnableAssign, RunnableBinding, RunnableEach, RunnableLambda, RunnableMap, RunnableParallel, RunnablePick, RunnableRetry, RunnableSequence, RunnableToolLike, RunnableWithFallbacks, _coerceToRunnable } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\nimport { RouterRunnable } from \"./router.js\";\nimport { RunnableBranch } from \"./branch.js\";\nimport { RunnableWithMessageHistory } from \"./history.js\";\n\n//#region src/runnables/index.ts\nvar runnables_exports = {};\n__export(runnables_exports, {\n\tRouterRunnable: () => RouterRunnable,\n\tRunnable: () => Runnable,\n\tRunnableAssign: () => RunnableAssign,\n\tRunnableBinding: () => RunnableBinding,\n\tRunnableBranch: () => RunnableBranch,\n\tRunnableEach: () => RunnableEach,\n\tRunnableLambda: () => RunnableLambda,\n\tRunnableMap: () => RunnableMap,\n\tRunnableParallel: () => RunnableParallel,\n\tRunnablePassthrough: () => RunnablePassthrough,\n\tRunnablePick: () => RunnablePick,\n\tRunnableRetry: () => RunnableRetry,\n\tRunnableSequence: () => RunnableSequence,\n\tRunnableToolLike: () => RunnableToolLike,\n\tRunnableWithFallbacks: () => RunnableWithFallbacks,\n\tRunnableWithMessageHistory: () => RunnableWithMessageHistory,\n\t_coerceToRunnable: () => _coerceToRunnable,\n\tensureConfig: () => ensureConfig,\n\tgetCallbackManagerForConfig: () => getCallbackManagerForConfig,\n\tmergeConfigs: () => mergeConfigs,\n\tpatchConfig: () => patchConfig,\n\tpickRunnableConfigKeys: () => pickRunnableConfigKeys,\n\traceWithSignal: () => raceWithSignal\n});\n\n//#endregion\nexport { RouterRunnable, Runnable, RunnableAssign, RunnableBinding, RunnableBranch, RunnableEach, RunnableLambda, RunnableMap, RunnableParallel, RunnablePassthrough, RunnablePick, RunnableRetry, RunnableSequence, RunnableToolLike, RunnableWithFallbacks, RunnableWithMessageHistory, _coerceToRunnable, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys, raceWithSignal, runnables_exports };\n//# sourceMappingURL=index.js.map", "import {\n  BaseLanguageModelInput,\n  ToolDefinition,\n} from \"@langchain/core/language_models/base\";\nimport {\n  BaseChatModel,\n  BaseChatModelParams,\n  BindToolsInput,\n  type BaseChatModelCallOptions,\n} from \"@langchain/core/language_models/chat_models\";\nimport {\n  BaseMessage,\n  type AIMessageChunk,\n  MessageStructure,\n} from \"@langchain/core/messages\";\nimport {\n  type RunnableBatchOptions,\n  RunnableBinding,\n  type RunnableConfig,\n  type RunnableToolLike,\n  ensureConfig,\n} from \"@langchain/core/runnables\";\nimport {\n  AsyncGeneratorWithSetup,\n  IterableReadableStream,\n} from \"@langchain/core/utils/stream\";\nimport {\n  type LogStreamCallbackHandlerInput,\n  type RunLogPatch,\n  type StreamEvent,\n} from \"@langchain/core/tracers/log_stream\";\nimport { type StructuredToolInterface } from \"@langchain/core/tools\";\nimport { CallbackManagerForLLMRun } from \"@langchain/core/callbacks/manager\";\nimport { ChatResult } from \"@langchain/core/outputs\";\nimport { ModelProfile } from \"@langchain/core/language_models/profile\";\n\n// TODO: remove once `EventStreamCallbackHandlerInput` is exposed in core\ninterface EventStreamCallbackHandlerInput\n  extends Omit<LogStreamCallbackHandlerInput, \"_schemaFormat\"> {}\n\nexport interface ConfigurableChatModelCallOptions\n  extends BaseChatModelCallOptions {\n  tools?: (\n    | StructuredToolInterface\n    | Record<string, unknown>\n    | ToolDefinition\n    | RunnableToolLike\n  )[];\n}\n\n// Configuration map for model providers\nexport const MODEL_PROVIDER_CONFIG = {\n  openai: {\n    package: \"@langchain/openai\",\n    className: \"ChatOpenAI\",\n  },\n  anthropic: {\n    package: \"@langchain/anthropic\",\n    className: \"ChatAnthropic\",\n  },\n  azure_openai: {\n    package: \"@langchain/openai\",\n    className: \"AzureChatOpenAI\",\n  },\n  cohere: {\n    package: \"@langchain/cohere\",\n    className: \"ChatCohere\",\n  },\n  \"google-vertexai\": {\n    package: \"@langchain/google-vertexai\",\n    className: \"ChatVertexAI\",\n  },\n  \"google-vertexai-web\": {\n    package: \"@langchain/google-vertexai-web\",\n    className: \"ChatVertexAI\",\n  },\n  \"google-genai\": {\n    package: \"@langchain/google-genai\",\n    className: \"ChatGoogleGenerativeAI\",\n  },\n  ollama: {\n    package: \"@langchain/ollama\",\n    className: \"ChatOllama\",\n  },\n  mistralai: {\n    package: \"@langchain/mistralai\",\n    className: \"ChatMistralAI\",\n  },\n  mistral: {\n    package: \"@langchain/mistralai\",\n    className: \"ChatMistralAI\",\n  },\n  groq: {\n    package: \"@langchain/groq\",\n    className: \"ChatGroq\",\n  },\n  cerebras: {\n    package: \"@langchain/cerebras\",\n    className: \"ChatCerebras\",\n  },\n  bedrock: {\n    package: \"@langchain/aws\",\n    className: \"ChatBedrockConverse\",\n  },\n  deepseek: {\n    package: \"@langchain/deepseek\",\n    className: \"ChatDeepSeek\",\n  },\n  xai: {\n    package: \"@langchain/xai\",\n    className: \"ChatXAI\",\n  },\n  fireworks: {\n    package: \"@langchain/community/chat_models/fireworks\",\n    className: \"ChatFireworks\",\n    hasCircularDependency: true,\n  },\n  together: {\n    package: \"@langchain/community/chat_models/togetherai\",\n    className: \"ChatTogetherAI\",\n    hasCircularDependency: true,\n  },\n  perplexity: {\n    package: \"@langchain/community/chat_models/perplexity\",\n    className: \"ChatPerplexity\",\n    hasCircularDependency: true,\n  },\n} as const;\n\nconst SUPPORTED_PROVIDERS = Object.keys(\n  MODEL_PROVIDER_CONFIG\n) as (keyof typeof MODEL_PROVIDER_CONFIG)[];\nexport type ChatModelProvider = keyof typeof MODEL_PROVIDER_CONFIG;\ntype ModelProviderConfig = {\n  package: string;\n  className: string;\n  hasCircularDependency?: boolean;\n};\n\n/**\n * Helper function to get a chat model class by its class name\n * @param className The class name (e.g., \"ChatOpenAI\", \"ChatAnthropic\")\n * @returns The imported model class or undefined if not found\n */\nexport async function getChatModelByClassName(className: string) {\n  // Find the provider config that matches the class name\n  const providerEntry = Object.entries(MODEL_PROVIDER_CONFIG).find(\n    ([, config]) => config.className === className\n  );\n\n  if (!providerEntry) {\n    return undefined;\n  }\n\n  const [, config] = providerEntry;\n  try {\n    const module = await import(config.package);\n    return module[config.className];\n  } catch (e: unknown) {\n    const err = e as Error;\n    if (\n      \"code\" in err &&\n      err.code?.toString().includes(\"ERR_MODULE_NOT_FOUND\") &&\n      \"message\" in err &&\n      typeof err.message === \"string\"\n    ) {\n      const msg = err.message.startsWith(\"Error: \")\n        ? err.message.slice(\"Error: \".length)\n        : err.message;\n      const attemptedPackage = msg\n        .split(\"Cannot find package '\")[1]\n        .split(\"'\")[0];\n      throw new Error(\n        `Unable to import ${attemptedPackage}. Please install with ` +\n          `\\`npm install ${attemptedPackage}\\` or \\`pnpm install ${attemptedPackage}\\``\n      );\n    }\n    throw e;\n  }\n}\n\nasync function _initChatModelHelper(\n  model: string,\n  modelProvider?: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  params: Record<string, any> = {}\n): Promise<BaseChatModel> {\n  const modelProviderCopy = modelProvider || _inferModelProvider(model);\n  if (!modelProviderCopy) {\n    throw new Error(\n      `Unable to infer model provider for { model: ${model} }, please specify modelProvider directly.`\n    );\n  }\n\n  const config = MODEL_PROVIDER_CONFIG[\n    modelProviderCopy as keyof typeof MODEL_PROVIDER_CONFIG\n  ] as ModelProviderConfig;\n  if (!config) {\n    const supported = SUPPORTED_PROVIDERS.join(\", \");\n    throw new Error(\n      `Unsupported { modelProvider: ${modelProviderCopy} }.\\n\\nSupported model providers are: ${supported}`\n    );\n  }\n\n  const { modelProvider: _unused, ...passedParams } = params;\n  const ProviderClass = await getChatModelByClassName(config.className);\n  return new ProviderClass({ model, ...passedParams });\n}\n\n/**\n * Attempts to infer the model provider based on the given model name.\n *\n * @param {string} modelName - The name of the model to infer the provider for.\n * @returns {string | undefined} The inferred model provider name, or undefined if unable to infer.\n *\n * @example\n * _inferModelProvider(\"gpt-4\"); // returns \"openai\"\n * _inferModelProvider(\"claude-2\"); // returns \"anthropic\"\n * _inferModelProvider(\"unknown-model\"); // returns undefined\n */\nexport function _inferModelProvider(modelName: string): string | undefined {\n  if (\n    modelName.startsWith(\"gpt-3\") ||\n    modelName.startsWith(\"gpt-4\") ||\n    modelName.startsWith(\"gpt-5\") ||\n    modelName.startsWith(\"o1\") ||\n    modelName.startsWith(\"o3\") ||\n    modelName.startsWith(\"o4\")\n  ) {\n    return \"openai\";\n  } else if (modelName.startsWith(\"claude\")) {\n    return \"anthropic\";\n  } else if (modelName.startsWith(\"command\")) {\n    return \"cohere\";\n  } else if (modelName.startsWith(\"accounts/fireworks\")) {\n    return \"fireworks\";\n  } else if (modelName.startsWith(\"gemini\")) {\n    return \"google-vertexai\";\n  } else if (modelName.startsWith(\"amazon.\")) {\n    return \"bedrock\";\n  } else if (modelName.startsWith(\"mistral\")) {\n    return \"mistralai\";\n  } else if (modelName.startsWith(\"sonar\") || modelName.startsWith(\"pplx\")) {\n    return \"perplexity\";\n  } else {\n    return undefined;\n  }\n}\n\ninterface ConfigurableModelFields extends BaseChatModelParams {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  defaultConfig?: Record<string, any>;\n  /**\n   * @default \"any\"\n   */\n  configurableFields?: string[] | \"any\";\n  /**\n   * @default \"\"\n   */\n  configPrefix?: string;\n  /**\n   * Methods which should be called after the model is initialized.\n   * The key will be the method name, and the value will be the arguments.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  queuedMethodOperations?: Record<string, any>;\n  /**\n   * Overrides the profiling information for the model. If not provided,\n   * the profile will be inferred from the inner model instance.\n   */\n  profile?: ModelProfile;\n}\n\n/**\n * Internal class used to create chat models.\n *\n * @internal\n */\nexport class ConfigurableModel<\n  RunInput extends BaseLanguageModelInput = BaseLanguageModelInput,\n  CallOptions extends\n    ConfigurableChatModelCallOptions = ConfigurableChatModelCallOptions,\n> extends BaseChatModel<CallOptions, AIMessageChunk> {\n  _llmType(): string {\n    return \"chat_model\";\n  }\n\n  lc_namespace = [\"langchain\", \"chat_models\"];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _defaultConfig?: Record<string, any> = {};\n\n  /**\n   * @default \"any\"\n   */\n  _configurableFields: string[] | \"any\" = \"any\";\n\n  /**\n   * @default \"\"\n   */\n  _configPrefix: string;\n\n  /**\n   * Methods which should be called after the model is initialized.\n   * The key will be the method name, and the value will be the arguments.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _queuedMethodOperations: Record<string, any> = {};\n\n  /** @internal */\n  private _modelInstanceCache = new Map<\n    string,\n    BaseChatModel<BaseChatModelCallOptions, AIMessageChunk<MessageStructure>>\n  >();\n\n  /** @internal */\n  private _profile?: ModelProfile;\n\n  constructor(fields: ConfigurableModelFields) {\n    super(fields);\n    this._defaultConfig = fields.defaultConfig ?? {};\n\n    if (fields.configurableFields === \"any\") {\n      this._configurableFields = \"any\";\n    } else {\n      this._configurableFields = fields.configurableFields ?? [\n        \"model\",\n        \"modelProvider\",\n      ];\n    }\n\n    if (fields.configPrefix) {\n      this._configPrefix = fields.configPrefix.endsWith(\"_\")\n        ? fields.configPrefix\n        : `${fields.configPrefix}_`;\n    } else {\n      this._configPrefix = \"\";\n    }\n\n    this._queuedMethodOperations =\n      fields.queuedMethodOperations ?? this._queuedMethodOperations;\n\n    this._profile = fields.profile ?? undefined;\n  }\n\n  async _getModelInstance(\n    config?: RunnableConfig\n  ): Promise<\n    BaseChatModel<BaseChatModelCallOptions, AIMessageChunk<MessageStructure>>\n  > {\n    // Check cache first\n    const cacheKey = JSON.stringify(config ?? {});\n    const cachedModel = this._modelInstanceCache.get(cacheKey);\n    if (cachedModel) {\n      return cachedModel;\n    }\n\n    // Initialize model with merged params\n    const params = { ...this._defaultConfig, ...this._modelParams(config) };\n    let initializedModel = await _initChatModelHelper(\n      params.model,\n      params.modelProvider,\n      params\n    );\n\n    // Apply queued method operations in sequence\n    for (const [method, args] of Object.entries(this._queuedMethodOperations)) {\n      if (\n        method in initializedModel &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof (initializedModel as any)[method] === \"function\"\n      ) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        initializedModel = await (initializedModel as any)[method](...args);\n      }\n    }\n\n    // Cache and return the initialized model\n    this._modelInstanceCache.set(cacheKey, initializedModel);\n    return initializedModel;\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    options?: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const model = await this._getModelInstance(options);\n    return model._generate(messages, options ?? {}, runManager);\n  }\n\n  override bindTools(\n    tools: BindToolsInput[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    params?: Record<string, any>\n  ): ConfigurableModel<RunInput, CallOptions> {\n    const newQueuedOperations = { ...this._queuedMethodOperations };\n    newQueuedOperations.bindTools = [tools, params];\n    return new ConfigurableModel<RunInput, CallOptions>({\n      defaultConfig: this._defaultConfig,\n      configurableFields: this._configurableFields,\n      configPrefix: this._configPrefix,\n      queuedMethodOperations: newQueuedOperations,\n    });\n  }\n\n  // Extract the input types from the `BaseModel` class.\n  withStructuredOutput: BaseChatModel[\"withStructuredOutput\"] = (\n    schema,\n    ...args\n  ): ReturnType<BaseChatModel[\"withStructuredOutput\"]> => {\n    const newQueuedOperations = { ...this._queuedMethodOperations };\n    newQueuedOperations.withStructuredOutput = [schema, ...args];\n    return new ConfigurableModel<RunInput, CallOptions>({\n      defaultConfig: this._defaultConfig,\n      configurableFields: this._configurableFields,\n      configPrefix: this._configPrefix,\n      queuedMethodOperations: newQueuedOperations,\n    }) as unknown as ReturnType<BaseChatModel[\"withStructuredOutput\"]>;\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _modelParams(config?: RunnableConfig): Record<string, any> {\n    const configurable = config?.configurable ?? {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let modelParams: Record<string, any> = {};\n\n    for (const [key, value] of Object.entries(configurable)) {\n      if (key.startsWith(this._configPrefix)) {\n        const strippedKey = this._removePrefix(key, this._configPrefix);\n        modelParams[strippedKey] = value;\n      }\n    }\n\n    if (this._configurableFields !== \"any\") {\n      modelParams = Object.fromEntries(\n        Object.entries(modelParams).filter(([key]) =>\n          this._configurableFields.includes(key)\n        )\n      );\n    }\n\n    return modelParams;\n  }\n\n  _removePrefix(str: string, prefix: string): string {\n    return str.startsWith(prefix) ? str.slice(prefix.length) : str;\n  }\n\n  /**\n   * Bind config to a Runnable, returning a new Runnable.\n   * @param {RunnableConfig | undefined} [config] - The config to bind.\n   * @returns {RunnableBinding<RunInput, RunOutput, CallOptions>} A new RunnableBinding with the bound config.\n   */\n  withConfig(\n    config?: RunnableConfig\n  ): RunnableBinding<RunInput, AIMessageChunk, CallOptions> {\n    const mergedConfig: RunnableConfig = { ...(config || {}) };\n    const modelParams = this._modelParams(mergedConfig);\n\n    const remainingConfig: RunnableConfig = Object.fromEntries(\n      Object.entries(mergedConfig).filter(([k]) => k !== \"configurable\")\n    );\n\n    remainingConfig.configurable = Object.fromEntries(\n      Object.entries(mergedConfig.configurable || {}).filter(\n        ([k]) =>\n          this._configPrefix &&\n          !Object.keys(modelParams).includes(\n            this._removePrefix(k, this._configPrefix)\n          )\n      )\n    );\n\n    const newConfigurableModel = new ConfigurableModel<RunInput, CallOptions>({\n      defaultConfig: { ...this._defaultConfig, ...modelParams },\n      configurableFields: Array.isArray(this._configurableFields)\n        ? [...this._configurableFields]\n        : this._configurableFields,\n      configPrefix: this._configPrefix,\n      queuedMethodOperations: this._queuedMethodOperations,\n    });\n\n    return new RunnableBinding<RunInput, AIMessageChunk, CallOptions>({\n      config: mergedConfig,\n      bound: newConfigurableModel,\n    });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: CallOptions\n  ): Promise<AIMessageChunk> {\n    const model = await this._getModelInstance(options);\n    const config = ensureConfig(options);\n    return model.invoke(input, config);\n  }\n\n  async stream(\n    input: RunInput,\n    options?: CallOptions\n  ): Promise<IterableReadableStream<AIMessageChunk>> {\n    const model = await this._getModelInstance(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: await model.stream(input, options),\n      config: options,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<AIMessageChunk[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(AIMessageChunk | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(AIMessageChunk | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(AIMessageChunk | Error)[]> {\n    // We can super this since the base runnable implementation of\n    // `.batch` will call `.invoke` on each input.\n    return super.batch(inputs, options, batchOptions);\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: CallOptions\n  ): AsyncGenerator<AIMessageChunk> {\n    const model = await this._getModelInstance(options);\n    const config = ensureConfig(options);\n\n    yield* model.transform(generator, config);\n  }\n\n  async *streamLog(\n    input: RunInput,\n    options?: Partial<CallOptions>,\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<RunLogPatch> {\n    const model = await this._getModelInstance(options);\n    const config = ensureConfig(options);\n\n    yield* model.streamLog(input, config, {\n      ...streamOptions,\n      _schemaFormat: \"original\",\n      includeNames: streamOptions?.includeNames,\n      includeTypes: streamOptions?.includeTypes,\n      includeTags: streamOptions?.includeTags,\n      excludeNames: streamOptions?.excludeNames,\n      excludeTypes: streamOptions?.excludeTypes,\n      excludeTags: streamOptions?.excludeTags,\n    });\n  }\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<Uint8Array>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    const outerThis = this;\n    async function* wrappedGenerator() {\n      const model = await outerThis._getModelInstance(options);\n      const config = ensureConfig(options);\n      const eventStream = model.streamEvents(input, config, streamOptions);\n\n      for await (const chunk of eventStream) {\n        yield chunk;\n      }\n    }\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator());\n  }\n\n  /**\n   * Return profiling information for the model.\n   *\n   * @returns {ModelProfile} An object describing the model's capabilities and constraints\n   */\n  get profile(): ModelProfile {\n    if (this._profile) {\n      return this._profile;\n    }\n    const cacheKey = JSON.stringify({});\n    const instance = this._modelInstanceCache.get(cacheKey);\n    return instance?.profile ?? {};\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface InitChatModelFields extends Partial<Record<string, any>> {\n  modelProvider?: string;\n  configurableFields?: string[] | \"any\";\n  configPrefix?: string;\n}\n\nexport type ConfigurableFields = \"any\" | string[];\n\nexport async function initChatModel<\n  RunInput extends BaseLanguageModelInput = BaseLanguageModelInput,\n  CallOptions extends\n    ConfigurableChatModelCallOptions = ConfigurableChatModelCallOptions,\n>(\n  model: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  fields?: Partial<Record<string, any>> & {\n    modelProvider?: string;\n    configurableFields?: never;\n    configPrefix?: string;\n  }\n): Promise<ConfigurableModel<RunInput, CallOptions>>;\n\nexport async function initChatModel<\n  RunInput extends BaseLanguageModelInput = BaseLanguageModelInput,\n  CallOptions extends\n    ConfigurableChatModelCallOptions = ConfigurableChatModelCallOptions,\n>(\n  model: never,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  options?: Partial<Record<string, any>> & {\n    modelProvider?: string;\n    configurableFields?: never;\n    configPrefix?: string;\n    profile?: ModelProfile;\n  }\n): Promise<ConfigurableModel<RunInput, CallOptions>>;\n\nexport async function initChatModel<\n  RunInput extends BaseLanguageModelInput = BaseLanguageModelInput,\n  CallOptions extends\n    ConfigurableChatModelCallOptions = ConfigurableChatModelCallOptions,\n>(\n  model?: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  options?: Partial<Record<string, any>> & {\n    modelProvider?: string;\n    configurableFields?: ConfigurableFields;\n    configPrefix?: string;\n    profile?: ModelProfile;\n  }\n): Promise<ConfigurableModel<RunInput, CallOptions>>;\n\n// ################################# FOR CONTRIBUTORS #################################\n//\n// If adding support for a new provider, please append the provider\n// name to the supported list in the docstring below.\n//\n// ####################################################################################\n\n/**\n * Initialize a ChatModel from the model name and provider.\n * Must have the integration package corresponding to the model provider installed.\n *\n * @template {extends BaseLanguageModelInput = BaseLanguageModelInput} RunInput - The input type for the model.\n * @template {extends ConfigurableChatModelCallOptions = ConfigurableChatModelCallOptions} CallOptions - Call options for the model.\n *\n * @param {string | ChatModelProvider} [model] - The name of the model, e.g. \"gpt-4\", \"claude-3-opus-20240229\".\n *   Can be prefixed with the model provider, e.g. \"openai:gpt-4\", \"anthropic:claude-3-opus-20240229\".\n * @param {Object} [fields] - Additional configuration options.\n * @param {string} [fields.modelProvider] - The model provider. Supported values include:\n *   - openai (@langchain/openai)\n *   - anthropic (@langchain/anthropic)\n *   - azure_openai (@langchain/openai)\n *   - google-vertexai (@langchain/google-vertexai)\n *   - google-vertexai-web (@langchain/google-vertexai-web)\n *   - google-genai (@langchain/google-genai)\n *   - bedrock (@langchain/aws)\n *   - cohere (@langchain/cohere)\n *   - fireworks (@langchain/community/chat_models/fireworks)\n *   - together (@langchain/community/chat_models/togetherai)\n *   - mistralai (@langchain/mistralai)\n *   - groq (@langchain/groq)\n *   - ollama (@langchain/ollama)\n *   - perplexity (@langchain/community/chat_models/perplexity)\n *   - cerebras (@langchain/cerebras)\n *   - deepseek (@langchain/deepseek)\n *   - xai (@langchain/xai)\n * @param {string[] | \"any\"} [fields.configurableFields] - Which model parameters are configurable:\n *   - undefined: No configurable fields.\n *   - \"any\": All fields are configurable. (See Security Note in description)\n *   - string[]: Specified fields are configurable.\n * @param {string} [fields.configPrefix] - Prefix for configurable fields at runtime.\n * @param {ModelProfile} [fields.profile] - Overrides the profiling information for the model. If not provided,\n *   the profile will be inferred from the inner model instance.\n * @param {Record<string, any>} [fields.params] - Additional keyword args to pass to the ChatModel constructor.\n * @returns {Promise<ConfigurableModel<RunInput, CallOptions>>} A class which extends BaseChatModel.\n * @throws {Error} If modelProvider cannot be inferred or isn't supported.\n * @throws {Error} If the model provider integration package is not installed.\n *\n * @example Initialize non-configurable models\n * ```typescript\n * import { initChatModel } from \"langchain/chat_models/universal\";\n *\n * const gpt4 = await initChatModel(\"openai:gpt-4\", {\n *   temperature: 0.25,\n * });\n * const gpt4Result = await gpt4.invoke(\"what's your name\");\n *\n * const claude = await initChatModel(\"anthropic:claude-3-opus-20240229\", {\n *   temperature: 0.25,\n * });\n * const claudeResult = await claude.invoke(\"what's your name\");\n *\n * const gemini = await initChatModel(\"gemini-1.5-pro\", {\n *   modelProvider: \"google-vertexai\",\n *   temperature: 0.25,\n * });\n * const geminiResult = await gemini.invoke(\"what's your name\");\n * ```\n *\n * @example Create a partially configurable model with no default model\n * ```typescript\n * import { initChatModel } from \"langchain/chat_models/universal\";\n *\n * const configurableModel = await initChatModel(undefined, {\n *   temperature: 0,\n *   configurableFields: [\"model\", \"apiKey\"],\n * });\n *\n * const gpt4Result = await configurableModel.invoke(\"what's your name\", {\n *   configurable: {\n *     model: \"gpt-4\",\n *   },\n * });\n *\n * const claudeResult = await configurableModel.invoke(\"what's your name\", {\n *   configurable: {\n *     model: \"claude-3-5-sonnet-20240620\",\n *   },\n * });\n * ```\n *\n * @example Create a fully configurable model with a default model and a config prefix\n * ```typescript\n * import { initChatModel } from \"langchain/chat_models/universal\";\n *\n * const configurableModelWithDefault = await initChatModel(\"gpt-4\", {\n *   modelProvider: \"openai\",\n *   configurableFields: \"any\",\n *   configPrefix: \"foo\",\n *   temperature: 0,\n * });\n *\n * const openaiResult = await configurableModelWithDefault.invoke(\n *   \"what's your name\",\n *   {\n *     configurable: {\n *       foo_apiKey: process.env.OPENAI_API_KEY,\n *     },\n *   }\n * );\n *\n * const claudeResult = await configurableModelWithDefault.invoke(\n *   \"what's your name\",\n *   {\n *     configurable: {\n *       foo_model: \"claude-3-5-sonnet-20240620\",\n *       foo_modelProvider: \"anthropic\",\n *       foo_temperature: 0.6,\n *       foo_apiKey: process.env.ANTHROPIC_API_KEY,\n *     },\n *   }\n * );\n * ```\n *\n * @example Bind tools to a configurable model:\n * ```typescript\n * import { initChatModel } from \"langchain/chat_models/universal\";\n * import { z } from \"zod/v3\";\n * import { tool } from \"@langchain/core/tools\";\n *\n * const getWeatherTool = tool(\n *   (input) => {\n *     // Do something with the input\n *     return JSON.stringify(input);\n *   },\n *   {\n *     schema: z\n *       .object({\n *         location: z\n *           .string()\n *           .describe(\"The city and state, e.g. San Francisco, CA\"),\n *       })\n *       .describe(\"Get the current weather in a given location\"),\n *     name: \"GetWeather\",\n *     description: \"Get the current weather in a given location\",\n *   }\n * );\n *\n * const getPopulationTool = tool(\n *   (input) => {\n *     // Do something with the input\n *     return JSON.stringify(input);\n *   },\n *   {\n *     schema: z\n *       .object({\n *         location: z\n *           .string()\n *           .describe(\"The city and state, e.g. San Francisco, CA\"),\n *       })\n *       .describe(\"Get the current population in a given location\"),\n *     name: \"GetPopulation\",\n *     description: \"Get the current population in a given location\",\n *   }\n * );\n *\n * const configurableModel = await initChatModel(\"gpt-4\", {\n *   configurableFields: [\"model\", \"modelProvider\", \"apiKey\"],\n *   temperature: 0,\n * });\n *\n * const configurableModelWithTools = configurableModel.bindTools([\n *   getWeatherTool,\n *   getPopulationTool,\n * ]);\n *\n * const configurableToolResult = await configurableModelWithTools.invoke(\n *   \"Which city is hotter today and which is bigger: LA or NY?\",\n *   {\n *     configurable: {\n *       apiKey: process.env.OPENAI_API_KEY,\n *     },\n *   }\n * );\n *\n * const configurableToolResult2 = await configurableModelWithTools.invoke(\n *   \"Which city is hotter today and which is bigger: LA or NY?\",\n *   {\n *     configurable: {\n *       model: \"claude-3-5-sonnet-20240620\",\n *       apiKey: process.env.ANTHROPIC_API_KEY,\n *     },\n *   }\n * );\n * ```\n *\n * @example Initialize a model with a custom profile\n * ```typescript\n * import { initChatModel } from \"langchain/chat_models/universal\";\n *\n * const model = await initChatModel(\"gpt-4o-mini\", {\n *   profile: {\n *     maxInputTokens: 100000,\n *   },\n * });\n *\n * @description\n * This function initializes a ChatModel based on the provided model name and provider.\n * It supports various model providers and allows for runtime configuration of model parameters.\n *\n * Security Note: Setting `configurableFields` to \"any\" means fields like apiKey, baseUrl, etc.\n * can be altered at runtime, potentially redirecting model requests to a different service/user.\n * Make sure that if you're accepting untrusted configurations, you enumerate the\n * `configurableFields` explicitly.\n *\n * The function will attempt to infer the model provider from the model name if not specified.\n * Certain model name prefixes are associated with specific providers:\n * - gpt-3... or gpt-4... -> openai\n * - claude... -> anthropic\n * - amazon.... -> bedrock\n * - gemini... -> google-vertexai\n * - command... -> cohere\n * - accounts/fireworks... -> fireworks\n *\n * @since 0.2.11\n * @version 0.2.11\n */\nexport async function initChatModel<\n  RunInput extends BaseLanguageModelInput = BaseLanguageModelInput,\n  CallOptions extends\n    ConfigurableChatModelCallOptions = ConfigurableChatModelCallOptions,\n>(\n  model?: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  fields?: Partial<Record<string, any>> & {\n    modelProvider?: string;\n    configurableFields?: string[] | \"any\";\n    configPrefix?: string;\n    profile?: ModelProfile;\n  }\n): Promise<ConfigurableModel<RunInput, CallOptions>> {\n  // eslint-disable-next-line prefer-const\n  let { configurableFields, configPrefix, modelProvider, profile, ...params } =\n    {\n      configPrefix: \"\",\n      ...(fields ?? {}),\n    };\n  if (modelProvider === undefined && model?.includes(\":\")) {\n    const [provider, ...remainingParts] = model.split(\":\");\n    const modelComponents =\n      remainingParts.length === 0\n        ? [provider]\n        : [provider, remainingParts.join(\":\")];\n    if (SUPPORTED_PROVIDERS.includes(modelComponents[0] as ChatModelProvider)) {\n      // eslint-disable-next-line no-param-reassign\n      [modelProvider, model] = modelComponents;\n    }\n  }\n  let configurableFieldsCopy = Array.isArray(configurableFields)\n    ? [...configurableFields]\n    : configurableFields;\n\n  if (!model && configurableFieldsCopy === undefined) {\n    configurableFieldsCopy = [\"model\", \"modelProvider\"];\n  }\n  if (configPrefix && configurableFieldsCopy === undefined) {\n    console.warn(\n      `{ configPrefix: ${configPrefix} } has been set but no fields are configurable. Set ` +\n        `{ configurableFields: [...] } to specify the model params that are ` +\n        `configurable.`\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const paramsCopy: Record<string, any> = { ...params };\n\n  let configurableModel: ConfigurableModel<RunInput, CallOptions>;\n\n  if (configurableFieldsCopy === undefined) {\n    configurableModel = new ConfigurableModel<RunInput, CallOptions>({\n      defaultConfig: {\n        ...paramsCopy,\n        model,\n        modelProvider,\n      },\n      configPrefix,\n      profile,\n    });\n  } else {\n    if (model) {\n      paramsCopy.model = model;\n    }\n    if (modelProvider) {\n      paramsCopy.modelProvider = modelProvider;\n    }\n    configurableModel = new ConfigurableModel<RunInput, CallOptions>({\n      defaultConfig: paramsCopy,\n      configPrefix,\n      configurableFields: configurableFieldsCopy,\n      profile,\n    });\n  }\n\n  // Initialize the model instance to make sure a profile is available\n  await configurableModel._getModelInstance();\n  return configurableModel;\n}\n", "import { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\n\nexport function initializeAsyncLocalStorageSingleton() {\n  AsyncLocalStorageProviderSingleton.initializeGlobalInstance(\n    new AsyncLocalStorage()\n  );\n}\n", "import { Command, Interrupt } from \"./constants.js\";\n\n// When editing, make sure to update the index found here:\n// https://langchain-ai.github.io/langgraphjs/troubleshooting/errors/\nexport type BaseLangGraphErrorFields = {\n  lc_error_code?:\n    | \"GRAPH_RECURSION_LIMIT\"\n    | \"INVALID_CONCURRENT_GRAPH_UPDATE\"\n    | \"INVALID_GRAPH_NODE_RETURN_VALUE\"\n    | \"MISSING_CHECKPOINTER\"\n    | \"MULTIPLE_SUBGRAPHS\"\n    | \"UNREACHABLE_NODE\";\n};\n\n// TODO: Merge with base LangChain error class when we drop support for core@0.2.0\n/** @category Errors */\nexport class BaseLangGraphError extends Error {\n  lc_error_code?: string;\n\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    let finalMessage = message ?? \"\";\n    if (fields?.lc_error_code) {\n      finalMessage = `${finalMessage}\\n\\nTroubleshooting URL: https://docs.langchain.com/oss/javascript/langgraph/${fields.lc_error_code}/\\n`;\n    }\n    super(finalMessage);\n    this.lc_error_code = fields?.lc_error_code;\n  }\n}\n\nexport class GraphBubbleUp extends BaseLangGraphError {\n  get is_bubble_up() {\n    return true;\n  }\n}\n\nexport class GraphRecursionError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"GraphRecursionError\";\n  }\n\n  static get unminifiable_name() {\n    return \"GraphRecursionError\";\n  }\n}\n\nexport class GraphValueError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"GraphValueError\";\n  }\n\n  static get unminifiable_name() {\n    return \"GraphValueError\";\n  }\n}\n\nexport class GraphInterrupt extends GraphBubbleUp {\n  interrupts: Interrupt[];\n\n  constructor(interrupts?: Interrupt[], fields?: BaseLangGraphErrorFields) {\n    super(JSON.stringify(interrupts, null, 2), fields);\n    this.name = \"GraphInterrupt\";\n    this.interrupts = interrupts ?? [];\n  }\n\n  static get unminifiable_name() {\n    return \"GraphInterrupt\";\n  }\n}\n\n/** Raised by a node to interrupt execution. */\nexport class NodeInterrupt extends GraphInterrupt {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(message: any, fields?: BaseLangGraphErrorFields) {\n    super([{ value: message }], fields);\n    this.name = \"NodeInterrupt\";\n  }\n\n  static get unminifiable_name() {\n    return \"NodeInterrupt\";\n  }\n}\n\nexport class ParentCommand extends GraphBubbleUp {\n  command: Command;\n\n  constructor(command: Command) {\n    super();\n    this.name = \"ParentCommand\";\n    this.command = command;\n  }\n\n  static get unminifiable_name() {\n    return \"ParentCommand\";\n  }\n}\n\nexport function isParentCommand(e?: unknown): e is ParentCommand {\n  return (\n    e !== undefined &&\n    (e as ParentCommand).name === ParentCommand.unminifiable_name\n  );\n}\n\nexport function isGraphBubbleUp(e?: unknown): e is GraphBubbleUp {\n  return e !== undefined && (e as GraphBubbleUp).is_bubble_up === true;\n}\n\nexport function isGraphInterrupt(e?: unknown): e is GraphInterrupt {\n  return (\n    e !== undefined &&\n    [\n      GraphInterrupt.unminifiable_name,\n      NodeInterrupt.unminifiable_name,\n    ].includes((e as Error).name)\n  );\n}\n\nexport class EmptyInputError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"EmptyInputError\";\n  }\n\n  static get unminifiable_name() {\n    return \"EmptyInputError\";\n  }\n}\n\nexport class EmptyChannelError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"EmptyChannelError\";\n  }\n\n  static get unminifiable_name() {\n    return \"EmptyChannelError\";\n  }\n}\n\nexport class InvalidUpdateError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"InvalidUpdateError\";\n  }\n\n  static get unminifiable_name() {\n    return \"InvalidUpdateError\";\n  }\n}\n\n/**\n * @deprecated This exception type is no longer thrown.\n */\nexport class MultipleSubgraphsError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"MultipleSubgraphError\";\n  }\n\n  static get unminifiable_name() {\n    return \"MultipleSubgraphError\";\n  }\n}\n\nexport class UnreachableNodeError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"UnreachableNodeError\";\n  }\n\n  static get unminifiable_name() {\n    return \"UnreachableNodeError\";\n  }\n}\n\n/**\n * Exception raised when an error occurs in the remote graph.\n */\nexport class RemoteException extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"RemoteException\";\n  }\n\n  static get unminifiable_name() {\n    return \"RemoteException\";\n  }\n}\n\n/**\n * Error thrown when invalid input is provided to a StateGraph.\n *\n * This typically means that the input to the StateGraph constructor or builder\n * did not match the required types. A valid input should be a\n * StateDefinition, an Annotation.Root, or a Zod schema.\n *\n * @example\n * // Example of incorrect usage:\n * try {\n *   new StateGraph({ foo: \"bar\" }); // Not a valid input\n * } catch (err) {\n *   if (err instanceof StateGraphInputError) {\n *     console.error(err.message);\n *   }\n * }\n */\nexport class StateGraphInputError extends BaseLangGraphError {\n  /**\n   * Create a new StateGraphInputError.\n   * @param message - Optional custom error message.\n   * @param fields - Optional additional error fields.\n   */\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"StateGraphInputError\";\n    this.message =\n      \"Invalid StateGraph input. Make sure to pass a valid StateDefinition, Annotation.Root, or Zod schema.\";\n  }\n\n  /**\n   * The unminifiable (static, human-readable) error name for this error class.\n   */\n  static get unminifiable_name() {\n    return \"StateGraphInputError\";\n  }\n}\n\n/**\n * Used for subgraph detection.\n */\nexport const getSubgraphsSeenSet = () => {\n  if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (globalThis as any)[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")] === undefined\n  ) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (globalThis as any)[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")] = new Set();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (globalThis as any)[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")];\n};\n", "import { v5, v6 } from \"uuid\";\n\nexport function uuid6(clockseq: number): string {\n  return v6({ clockseq });\n}\n\n// Skip UUID validation check, since UUID6s\n// generated with negative clockseq are not\n// technically compliant, but still work.\n// See: https://github.com/uuidjs/uuid/issues/511\nexport function uuid5(name: string, namespace: string): string {\n  const namespaceBytes = namespace\n    .replace(/-/g, \"\")\n    .match(/.{2}/g)!\n    .map((byte) => parseInt(byte, 16));\n  return v5(name, new Uint8Array(namespaceBytes));\n}\n", "export const TASKS = \"__pregel_tasks\";\nexport const ERROR = \"__error__\";\nexport const SCHEDULED = \"__scheduled__\";\nexport const INTERRUPT = \"__interrupt__\";\nexport const RESUME = \"__resume__\";\n\n// Mirrors BaseChannel in \"@langchain/langgraph\"\nexport interface ChannelProtocol<\n  ValueType = unknown,\n  UpdateType = unknown,\n  CheckpointType = unknown\n> {\n  ValueType: ValueType;\n\n  UpdateType: UpdateType;\n\n  /**\n   * The name of the channel.\n   */\n  lc_graph_name: string;\n\n  /**\n   * Return a new identical channel, optionally initialized from a checkpoint.\n   * Can be thought of as a \"restoration\" from a checkpoint which is a \"snapshot\" of the channel's state.\n   *\n   * @param {CheckpointType | undefined} checkpoint\n   * @returns {this}\n   */\n  fromCheckpoint(checkpoint?: CheckpointType): this;\n\n  /**\n   * Update the channel's value with the given sequence of updates.\n   * The order of the updates in the sequence is arbitrary.\n   *\n   * @throws {InvalidUpdateError} if the sequence of updates is invalid.\n   * @param {Array<UpdateType>} values\n   * @returns {void}\n   */\n  update(values: UpdateType[]): void;\n\n  /**\n   * Return the current value of the channel.\n   *\n   * @throws {EmptyChannelError} if the channel is empty (never updated yet).\n   * @returns {ValueType}\n   */\n  get(): ValueType;\n\n  /**\n   * Return a string representation of the channel's current state.\n   *\n   * @throws {EmptyChannelError} if the channel is empty (never updated yet), or doesn't support checkpoints.\n   * @returns {CheckpointType | undefined}\n   */\n  checkpoint(): CheckpointType | undefined;\n}\n\n// Mirrors SendInterface in \"@langchain/langgraph\"\nexport interface SendProtocol {\n  node: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: any;\n}\n", "/* eslint-disable */\n// @ts-nocheck\n\n// Stringify that can handle circular references.\n// Inlined due to ESM import issues\n// Source: https://www.npmjs.com/package/fast-safe-stringify\n\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = \"[Circular]\";\n\nvar arr = [];\nvar replacerStack = [];\n\nfunction defaultOptions() {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER,\n  };\n}\n\n// Regular stringify\nexport function stringify(obj, replacer?, spacer?, options?) {\n  if (typeof options === \"undefined\") {\n    options = defaultOptions();\n  }\n\n  decirc(obj, \"\", 0, [], undefined, 0, options);\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer);\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify(\n      \"[unable to serialize, circular reference is too complex to analyze]\"\n    );\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\n\nfunction setReplace(replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace });\n      arr.push([parent, k, val, propertyDescriptor]);\n    } else {\n      replacerStack.push([val, k, replace]);\n    }\n  } else {\n    parent[k] = replace;\n    arr.push([parent, k, val]);\n  }\n}\n\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (typeof val === \"object\" && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== \"undefined\" &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    if (\n      typeof options.edgesLimit !== \"undefined\" &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      var keys = Object.keys(val);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        decirc(val[key], key, i, stack, val, depth, options);\n      }\n    }\n    stack.pop();\n  }\n}\n\n// Stable-stringify\nfunction compareFunction(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction deterministicStringify(obj, replacer, spacer, options) {\n  if (typeof options === \"undefined\") {\n    options = defaultOptions();\n  }\n\n  var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer);\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify(\n      \"[unable to serialize, circular reference is too complex to analyze]\"\n    );\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\n\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (typeof val === \"object\" && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    try {\n      if (typeof val.toJSON === \"function\") {\n        return;\n      }\n    } catch (_) {\n      return;\n    }\n\n    if (\n      typeof options.depthLimit !== \"undefined\" &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    if (\n      typeof options.edgesLimit !== \"undefined\" &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {};\n      var keys = Object.keys(val).sort(compareFunction);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        deterministicDecirc(val[key], key, i, stack, val, depth, options);\n        tmp[key] = val[key];\n      }\n      if (typeof parent !== \"undefined\") {\n        arr.push([parent, k, val]);\n        parent[k] = tmp;\n      } else {\n        return tmp;\n      }\n    }\n    stack.pop();\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n  replacer =\n    typeof replacer !== \"undefined\"\n      ? replacer\n      : function (k, v) {\n          return v;\n        };\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i];\n        if (part[1] === key && part[0] === val) {\n          val = part[2];\n          replacerStack.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return replacer.call(this, key, val);\n  };\n}\n", "/** Auto-generated by import-constants plugin. Do not edit manually */\n\nexport const optionalImportEntrypoints: string[] = [];\n", "//#region src/agents.ts\nvar agents_exports = {};\n\n//#endregion\nexport { agents_exports };\n//# sourceMappingURL=agents.js.map", "import { Serializable } from \"./load/serializable.js\";\nimport { type BaseMessage, HumanMessage, AIMessage } from \"./messages/index.js\";\n\n// TODO: Combine into one class for 0.2\n\n/**\n * Base class for all chat message histories. All chat message histories\n * should extend this class.\n */\nexport abstract class BaseChatMessageHistory extends Serializable {\n  public abstract getMessages(): Promise<BaseMessage[]>;\n\n  public abstract addMessage(message: BaseMessage): Promise<void>;\n\n  public abstract addUserMessage(message: string): Promise<void>;\n\n  public abstract addAIMessage(message: string): Promise<void>;\n\n  /**\n   * Add a list of messages.\n   *\n   * Implementations should override this method to handle bulk addition of messages\n   * in an efficient manner to avoid unnecessary round-trips to the underlying store.\n   *\n   * @param messages - A list of BaseMessage objects to store.\n   */\n  public async addMessages(messages: BaseMessage[]): Promise<void> {\n    for (const message of messages) {\n      await this.addMessage(message);\n    }\n  }\n\n  public abstract clear(): Promise<void>;\n}\n\n/**\n * Base class for all list chat message histories. All list chat message\n * histories should extend this class.\n */\nexport abstract class BaseListChatMessageHistory extends Serializable {\n  /** Returns a list of messages stored in the store. */\n  public abstract getMessages(): Promise<BaseMessage[]>;\n\n  /**\n   * Add a message object to the store.\n   */\n  public abstract addMessage(message: BaseMessage): Promise<void>;\n\n  /**\n   * This is a convenience method for adding a human message string to the store.\n   * Please note that this is a convenience method. Code should favor the\n   * bulk addMessages interface instead to save on round-trips to the underlying\n   * persistence layer.\n   * This method may be deprecated in a future release.\n   */\n  public addUserMessage(message: string): Promise<void> {\n    return this.addMessage(new HumanMessage(message));\n  }\n\n  /**\n   * This is a convenience method for adding an AI message string to the store.\n   * Please note that this is a convenience method. Code should favor the bulk\n   * addMessages interface instead to save on round-trips to the underlying\n   * persistence layer.\n   * This method may be deprecated in a future release.\n   */\n  public addAIMessage(message: string): Promise<void> {\n    return this.addMessage(new AIMessage(message));\n  }\n\n  /**\n   * Add a list of messages.\n   *\n   * Implementations should override this method to handle bulk addition of messages\n   * in an efficient manner to avoid unnecessary round-trips to the underlying store.\n   *\n   * @param messages - A list of BaseMessage objects to store.\n   */\n  public async addMessages(messages: BaseMessage[]): Promise<void> {\n    for (const message of messages) {\n      await this.addMessage(message);\n    }\n  }\n\n  /**\n   * Remove all messages from the store.\n   */\n  public clear(): Promise<void> {\n    throw new Error(\"Not implemented.\");\n  }\n}\n\n/**\n * Class for storing chat message history in-memory. It extends the\n * BaseListChatMessageHistory class and provides methods to get, add, and\n * clear messages.\n */\nexport class InMemoryChatMessageHistory extends BaseListChatMessageHistory {\n  lc_namespace = [\"langchain\", \"stores\", \"message\", \"in_memory\"];\n\n  private messages: BaseMessage[] = [];\n\n  constructor(messages?: BaseMessage[]) {\n    super(...arguments);\n    this.messages = messages ?? [];\n  }\n\n  /**\n   * Method to get all the messages stored in the ChatMessageHistory\n   * instance.\n   * @returns Array of stored BaseMessage instances.\n   */\n  async getMessages(): Promise<BaseMessage[]> {\n    return this.messages;\n  }\n\n  /**\n   * Method to add a new message to the ChatMessageHistory instance.\n   * @param message The BaseMessage instance to add.\n   * @returns A promise that resolves when the message has been added.\n   */\n  async addMessage(message: BaseMessage) {\n    this.messages.push(message);\n  }\n\n  /**\n   * Method to clear all the messages from the ChatMessageHistory instance.\n   * @returns A promise that resolves when all messages have been cleared.\n   */\n  async clear() {\n    this.messages = [];\n  }\n}\n", "import { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\n\n/**\n * The parameters required to initialize an instance of the Embeddings\n * class.\n */\nexport type EmbeddingsParams = AsyncCallerParams;\n\nexport interface EmbeddingsInterface<TOutput = number[]> {\n  /**\n   * An abstract method that takes an array of documents as input and\n   * returns a promise that resolves to an array of vectors for each\n   * document.\n   * @param documents An array of documents to be embedded.\n   * @returns A promise that resolves to an array of vectors for each document.\n   */\n  embedDocuments(documents: string[]): Promise<TOutput[]>;\n\n  /**\n   * An abstract method that takes a single document as input and returns a\n   * promise that resolves to a vector for the query document.\n   * @param document A single document to be embedded.\n   * @returns A promise that resolves to a vector for the query document.\n   */\n  embedQuery(document: string): Promise<TOutput>;\n}\n\n/**\n * An abstract class that provides methods for embedding documents and\n * queries using LangChain.\n */\nexport abstract class Embeddings<TOutput = number[]>\n  implements EmbeddingsInterface<TOutput>\n{\n  /**\n   * The async caller should be used by subclasses to make any async calls,\n   * which will thus benefit from the concurrency and retry logic.\n   */\n  caller: AsyncCaller;\n\n  constructor(params: EmbeddingsParams) {\n    this.caller = new AsyncCaller(params ?? {});\n  }\n\n  /**\n   * An abstract method that takes an array of documents as input and\n   * returns a promise that resolves to an array of vectors for each\n   * document.\n   * @param documents An array of documents to be embedded.\n   * @returns A promise that resolves to an array of vectors for each document.\n   */\n  abstract embedDocuments(documents: string[]): Promise<TOutput[]>;\n\n  /**\n   * An abstract method that takes a single document as input and returns a\n   * promise that resolves to a vector for the query document.\n   * @param document A single document to be embedded.\n   * @returns A promise that resolves to a vector for the query document.\n   */\n  abstract embedQuery(document: string): Promise<TOutput>;\n}\n", "//#region src/index.ts\nvar src_exports = {};\n\n//#endregion\nexport { src_exports };\n//# sourceMappingURL=index.js.map", "/**\n * Type alias for a record where the keys are strings and the values can\n * be any type. This is used to represent the input values for a Chain.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type InputValues = Record<string, any>;\n\n/**\n * Type alias for a record where the keys are strings and the values can\n * be any type. This is used to represent the output values from a Chain.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type OutputValues = Record<string, any>;\n\n/**\n * Type alias for a record where the keys are strings and the values can\n * be any type. This is used to represent the memory variables in a Chain.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type MemoryVariables = Record<string, any>;\n\n/**\n * Abstract base class for memory in LangChain's Chains. Memory refers to\n * the state in Chains. It can be used to store information about past\n * executions of a Chain and inject that information into the inputs of\n * future executions of the Chain.\n */\nexport abstract class BaseMemory {\n  abstract get memoryKeys(): string[];\n\n  /**\n   * Abstract method that should take an object of input values and return a\n   * Promise that resolves with an object of memory variables. The\n   * implementation of this method should load the memory variables from the\n   * provided input values.\n   * @param values An object of input values.\n   * @returns Promise that resolves with an object of memory variables.\n   */\n  abstract loadMemoryVariables(values: InputValues): Promise<MemoryVariables>;\n\n  /**\n   * Abstract method that should take two objects, one of input values and\n   * one of output values, and return a Promise that resolves when the\n   * context has been saved. The implementation of this method should save\n   * the context based on the provided input and output values.\n   * @param inputValues An object of input values.\n   * @param outputValues An object of output values.\n   * @returns Promise that resolves when the context has been saved.\n   */\n  abstract saveContext(\n    inputValues: InputValues,\n    outputValues: OutputValues\n  ): Promise<void>;\n}\n\nconst getValue = (values: InputValues | OutputValues, key?: string) => {\n  if (key !== undefined) {\n    return values[key];\n  }\n  const keys = Object.keys(values);\n  if (keys.length === 1) {\n    return values[keys[0]];\n  }\n};\n\n/**\n * This function is used by memory classes to select the input value\n * to use for the memory. If there is only one input value, it is used.\n * If there are multiple input values, the inputKey must be specified.\n */\nexport const getInputValue = (inputValues: InputValues, inputKey?: string) => {\n  const value = getValue(inputValues, inputKey);\n  if (!value) {\n    const keys = Object.keys(inputValues);\n    throw new Error(\n      `input values have ${keys.length} keys, you must specify an input key or pass only 1 key as input`\n    );\n  }\n  return value;\n};\n\n/**\n * This function is used by memory classes to select the output value\n * to use for the memory. If there is only one output value, it is used.\n * If there are multiple output values, the outputKey must be specified.\n * If no outputKey is specified, an error is thrown.\n */\nexport const getOutputValue = (\n  outputValues: OutputValues,\n  outputKey?: string\n) => {\n  const value = getValue(outputValues, outputKey);\n  if (!value && value !== \"\") {\n    const keys = Object.keys(outputValues);\n    throw new Error(\n      `output values have ${keys.length} keys, you must specify an output key or pass only 1 key as output`\n    );\n  }\n  return value;\n};\n\n/**\n * Function used by memory classes to get the key of the prompt input,\n * excluding any keys that are memory variables or the \"stop\" key. If\n * there is not exactly one prompt input key, an error is thrown.\n */\nexport function getPromptInputKey(\n  inputs: Record<string, unknown>,\n  memoryVariables: string[]\n): string {\n  const promptInputKeys = Object.keys(inputs).filter(\n    (key) => !memoryVariables.includes(key) && key !== \"stop\"\n  );\n  if (promptInputKeys.length !== 1) {\n    throw new Error(\n      `One input key expected, but got ${promptInputKeys.length}`\n    );\n  }\n  return promptInputKeys[0];\n}\n", "import { Serializable } from \"./load/serializable.js\";\n\n/**\n * Abstract interface for a key-value store.\n */\nexport abstract class BaseStore<K, V> extends Serializable {\n  /**\n   * Abstract method to get multiple values for a set of keys.\n   * @param {K[]} keys - An array of keys.\n   * @returns {Promise<(V | undefined)[]>} - A Promise that resolves with array of values or undefined if key not found.\n   */\n  abstract mget(keys: K[]): Promise<(V | undefined)[]>;\n\n  /**\n   * Abstract method to set a value for multiple keys.\n   * @param {[K, V][]} keyValuePairs - An array of key-value pairs.\n   * @returns {Promise<void>} - A Promise that resolves when the operation is complete.\n   */\n  abstract mset(keyValuePairs: [K, V][]): Promise<void>;\n\n  /**\n   * Abstract method to delete multiple keys.\n   * @param {K[]} keys - An array of keys to delete.\n   * @returns {Promise<void>} - A Promise that resolves when the operation is complete.\n   */\n  abstract mdelete(keys: K[]): Promise<void>;\n\n  /**\n   * Abstract method to yield keys optionally based on a prefix.\n   * @param {string} prefix - Optional prefix to filter keys.\n   * @returns {AsyncGenerator<K | string>} - An asynchronous generator that yields keys on iteration.\n   */\n  abstract yieldKeys(prefix?: string): AsyncGenerator<K | string>;\n}\n\n/**\n * In-memory implementation of the BaseStore using a dictionary. Used for\n * storing key-value pairs in memory.\n * @example\n * ```typescript\n * const store = new InMemoryStore<BaseMessage>();\n * await store.mset(\n *   Array.from({ length: 5 }).map((_, index) => [\n *     `message:id:${index}`,\n *     index % 2 === 0\n *       ? new AIMessage(\"ai stuff...\")\n *       : new HumanMessage(\"human stuff...\"),\n *   ]),\n * );\n *\n * const retrievedMessages = await store.mget([\"message:id:0\", \"message:id:1\"]);\n * await store.mdelete(await store.yieldKeys(\"message:id:\").toArray());\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class InMemoryStore<T = any> extends BaseStore<string, T> {\n  lc_namespace = [\"langchain\", \"storage\"];\n\n  protected store: Record<string, T> = {};\n\n  /**\n   * Retrieves the values associated with the given keys from the store.\n   * @param keys Keys to retrieve values for.\n   * @returns Array of values associated with the given keys.\n   */\n  async mget(keys: string[]) {\n    return keys.map((key) => this.store[key]);\n  }\n\n  /**\n   * Sets the values for the given keys in the store.\n   * @param keyValuePairs Array of key-value pairs to set in the store.\n   * @returns Promise that resolves when all key-value pairs have been set.\n   */\n  async mset(keyValuePairs: [string, T][]): Promise<void> {\n    for (const [key, value] of keyValuePairs) {\n      this.store[key] = value;\n    }\n  }\n\n  /**\n   * Deletes the given keys and their associated values from the store.\n   * @param keys Keys to delete from the store.\n   * @returns Promise that resolves when all keys have been deleted.\n   */\n  async mdelete(keys: string[]): Promise<void> {\n    for (const key of keys) {\n      delete this.store[key];\n    }\n  }\n\n  /**\n   * Asynchronous generator that yields keys from the store. If a prefix is\n   * provided, it only yields keys that start with the prefix.\n   * @param prefix Optional prefix to filter keys.\n   * @returns AsyncGenerator that yields keys from the store.\n   */\n  async *yieldKeys(prefix?: string | undefined): AsyncGenerator<string> {\n    const keys = Object.keys(this.store);\n    for (const key of keys) {\n      if (prefix === undefined || key.startsWith(prefix)) {\n        yield key;\n      }\n    }\n  }\n}\n", "import {\n  CallbackManager,\n  CallbackManagerForRetrieverRun,\n  Callbacks,\n  parseCallbackConfigArg,\n} from \"../callbacks/manager.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { Runnable, type RunnableInterface } from \"../runnables/base.js\";\nimport { RunnableConfig, ensureConfig } from \"../runnables/config.js\";\n\n/**\n * Input configuration options for initializing a retriever that extends\n * the `BaseRetriever` class. This interface provides base properties\n * common to all retrievers, allowing customization of callback functions,\n * tagging, metadata, and logging verbosity.\n *\n * Fields:\n * - `callbacks` (optional): An array of callback functions that handle various\n *   events during retrieval, such as logging, error handling, or progress updates.\n *\n * - `tags` (optional): An array of strings used to add contextual tags to\n *   retrieval operations, allowing for easier categorization and tracking.\n *\n * - `metadata` (optional): A record of key-value pairs to store additional\n *   contextual information for retrieval operations, which can be useful\n *   for logging or auditing purposes.\n *\n * - `verbose` (optional): A boolean flag that, if set to `true`, enables\n *   detailed logging and output during the retrieval process. Defaults to `false`.\n */\nexport interface BaseRetrieverInput {\n  callbacks?: Callbacks;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n  verbose?: boolean;\n}\n\n/**\n * Interface for a base retriever that defines core functionality for\n * retrieving relevant documents from a source based on a query.\n *\n * The `BaseRetrieverInterface` standardizes the `getRelevantDocuments` method,\n * enabling retrieval of documents that match the query criteria.\n *\n * @template Metadata - The type of metadata associated with each document,\n *                      defaulting to `Record<string, any>`.\n */\nexport interface BaseRetrieverInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Metadata extends Record<string, any> = Record<string, any>,\n> extends RunnableInterface<string, DocumentInterface<Metadata>[]> {}\n\n/**\n * Abstract base class for a document retrieval system, designed to\n * process string queries and return the most relevant documents from a source.\n *\n * `BaseRetriever` provides common properties and methods for derived retrievers,\n * such as callbacks, tagging, and verbose logging. Custom retrieval systems\n * should extend this class and implement `_getRelevantDocuments` to define\n * the specific retrieval logic.\n *\n * @template Metadata - The type of metadata associated with each document,\n *                      defaulting to `Record<string, any>`.\n */\nexport abstract class BaseRetriever<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Metadata extends Record<string, any> = Record<string, any>,\n  >\n  extends Runnable<string, DocumentInterface<Metadata>[]>\n  implements BaseRetrieverInterface\n{\n  /**\n   * Optional callbacks to handle various events in the retrieval process.\n   */\n  callbacks?: Callbacks;\n\n  /**\n   * Tags to label or categorize the retrieval operation.\n   */\n  tags?: string[];\n\n  /**\n   * Metadata to provide additional context or information about the retrieval\n   * operation.\n   */\n  metadata?: Record<string, unknown>;\n\n  /**\n   * If set to `true`, enables verbose logging for the retrieval process.\n   */\n  verbose?: boolean;\n\n  /**\n   * Constructs a new `BaseRetriever` instance with optional configuration fields.\n   *\n   * @param fields - Optional input configuration that can include `callbacks`,\n   *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.\n   */\n  constructor(fields?: BaseRetrieverInput) {\n    super(fields);\n    this.callbacks = fields?.callbacks;\n    this.tags = fields?.tags ?? [];\n    this.metadata = fields?.metadata ?? {};\n    this.verbose = fields?.verbose ?? false;\n  }\n\n  /**\n   * TODO: This should be an abstract method, but we'd like to avoid breaking\n   * changes to people currently using subclassed custom retrievers.\n   * Change it on next major release.\n   */\n  /**\n   * Placeholder method for retrieving relevant documents based on a query.\n   *\n   * This method is intended to be implemented by subclasses and will be\n   * converted to an abstract method in the next major release. Currently, it\n   * throws an error if not implemented, ensuring that custom retrievers define\n   * the specific retrieval logic.\n   *\n   * @param _query - The query string used to search for relevant documents.\n   * @param _callbacks - (optional) Callback manager for managing callbacks\n   *                     during retrieval.\n   * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.\n   * @throws {Error} Throws an error indicating the method is not implemented.\n   */\n  _getRelevantDocuments(\n    _query: string,\n    _callbacks?: CallbackManagerForRetrieverRun\n  ): Promise<DocumentInterface<Metadata>[]> {\n    throw new Error(\"Not implemented!\");\n  }\n\n  /**\n   * Executes a retrieval operation.\n   *\n   * @param input - The query string used to search for relevant documents.\n   * @param options - (optional) Configuration options for the retrieval run,\n   *                  which may include callbacks, tags, and metadata.\n   * @returns A promise that resolves to an array of `DocumentInterface` instances\n   *          representing the most relevant documents to the query.\n   */\n  async invoke(\n    input: string,\n    options?: RunnableConfig\n  ): Promise<DocumentInterface<Metadata>[]> {\n    const parsedConfig = ensureConfig(parseCallbackConfigArg(options));\n    const callbackManager_ = await CallbackManager.configure(\n      parsedConfig.callbacks,\n      this.callbacks,\n      parsedConfig.tags,\n      this.tags,\n      parsedConfig.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const runManager = await callbackManager_?.handleRetrieverStart(\n      this.toJSON(),\n      input,\n      parsedConfig.runId,\n      undefined,\n      undefined,\n      undefined,\n      parsedConfig.runName\n    );\n    try {\n      const results = await this._getRelevantDocuments(input, runManager);\n      await runManager?.handleRetrieverEnd(results);\n      return results;\n    } catch (error) {\n      await runManager?.handleRetrieverError(error);\n      throw error;\n    }\n  }\n}\n", "import type { EmbeddingsInterface } from \"./embeddings.js\";\nimport type { DocumentInterface } from \"./documents/document.js\";\nimport {\n  BaseRetriever,\n  BaseRetrieverInterface,\n  type BaseRetrieverInput,\n} from \"./retrievers/index.js\";\nimport { Serializable } from \"./load/serializable.js\";\nimport {\n  CallbackManagerForRetrieverRun,\n  Callbacks,\n} from \"./callbacks/manager.js\";\n\n/**\n * Type for options when adding a document to the VectorStore.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AddDocumentOptions = Record<string, any>;\n\n/**\n * Options for configuring a maximal marginal relevance (MMR) search.\n *\n * MMR search optimizes for both similarity to the query and diversity\n * among the results, balancing the retrieval of relevant documents\n * with variation in the content returned.\n *\n * Fields:\n *\n * - `fetchK` (optional): The initial number of documents to retrieve from the\n *   vector store before applying the MMR algorithm. This larger set provides a\n *   pool of documents from which the algorithm can select the most diverse\n *   results based on relevance to the query.\n *\n * - `filter` (optional): A filter of type `FilterType` to refine the search\n *   results, allowing additional conditions to target specific subsets\n *   of documents.\n *\n * - `k`: The number of documents to return in the final results. This is the\n *   primary count of documents that are most relevant to the query.\n *\n * - `lambda` (optional): A value between 0 and 1 that determines the balance\n *   between relevance and diversity:\n *   - A `lambda` of 0 emphasizes diversity, maximizing content variation.\n *   - A `lambda` of 1 emphasizes similarity to the query, focusing on relevance.\n *    Values between 0 and 1 provide a mix of relevance and diversity.\n *\n * @template FilterType - The type used for filtering results, as defined\n *                        by the vector store.\n */\nexport type MaxMarginalRelevanceSearchOptions<FilterType> = {\n  k: number;\n  fetchK?: number;\n  lambda?: number;\n  filter?: FilterType;\n};\n\n/**\n * Options for configuring a maximal marginal relevance (MMR) search\n * when using the `VectorStoreRetriever`.\n *\n * These parameters control how the MMR algorithm balances relevance to the\n * query and diversity among the retrieved documents.\n *\n * Fields:\n * - `fetchK` (optional): Specifies the initial number of documents to fetch\n *   before applying the MMR algorithm. This larger set provides a pool of\n *   documents from which the algorithm can select the most diverse results\n *   based on relevance to the query.\n *\n * - `lambda` (optional): A value between 0 and 1 that determines the balance\n *   between relevance and diversity:\n *   - A `lambda` of 0 maximizes diversity among the results, prioritizing varied content.\n *   - A `lambda` of 1 maximizes similarity to the query, prioritizing relevance.\n *   Values between 0 and 1 provide a mix of relevance and diversity.\n */\nexport type VectorStoreRetrieverMMRSearchKwargs = {\n  fetchK?: number;\n  lambda?: number;\n};\n\n/**\n * Input configuration options for creating a `VectorStoreRetriever` instance.\n *\n * This type combines properties from `BaseRetrieverInput` with specific settings\n * for the `VectorStoreRetriever`, including options for similarity or maximal\n * marginal relevance (MMR) search types.\n *\n * Fields:\n *\n * - `callbacks` (optional): An array of callback functions that handle various\n *   events during retrieval, such as logging, error handling, or progress updates.\n *\n * - `tags` (optional): An array of strings used to add contextual tags to\n *   retrieval operations, allowing for easier categorization and tracking.\n *\n * - `metadata` (optional): A record of key-value pairs to store additional\n *   contextual information for retrieval operations, which can be useful\n *   for logging or auditing purposes.\n *\n * - `verbose` (optional): A boolean flag that, if set to `true`, enables\n *   detailed logging and output during the retrieval process. Defaults to `false`.\n *\n * - `vectorStore`: The `VectorStore` instance implementing `VectorStoreInterface`\n *   that will be used for document storage and retrieval.\n *\n * - `k` (optional): Specifies the number of documents to retrieve per search\n *   query. Defaults to 4 if not specified.\n *\n * - `filter` (optional): A filter of type `FilterType` (defined by the vector store)\n *   to refine the set of documents returned, allowing for targeted search results.\n *\n * - `searchType`: Determines the type of search to perform:\n *   - `\"similarity\"`: Executes a similarity search, retrieving documents based purely\n *     on vector similarity to the query.\n *   - `\"mmr\"`: Executes a maximal marginal relevance (MMR) search, balancing similarity\n *     and diversity in the search results.\n *\n * - `searchKwargs` (optional): Used only if `searchType` is `\"mmr\"`, this object\n *   provides additional options for MMR search, including:\n *   - `fetchK`: Specifies the number of documents to initially fetch before applying\n *     the MMR algorithm, providing a pool from which the most diverse results are selected.\n *   - `lambda`: A diversity parameter, where 0 emphasizes diversity and 1 emphasizes\n *     relevance to the query. Values between 0 and 1 provide a balance of relevance and diversity.\n *\n * @template V - The type of vector store implementing `VectorStoreInterface`.\n */\nexport type VectorStoreRetrieverInput<V extends VectorStoreInterface> =\n  BaseRetrieverInput &\n    (\n      | {\n          vectorStore: V;\n          k?: number;\n          filter?: V[\"FilterType\"];\n          searchType?: \"similarity\";\n        }\n      | {\n          vectorStore: V;\n          k?: number;\n          filter?: V[\"FilterType\"];\n          searchType: \"mmr\";\n          searchKwargs?: VectorStoreRetrieverMMRSearchKwargs;\n        }\n    );\n\n/**\n * Interface for a retriever that uses a vector store to store and retrieve\n * document embeddings. This retriever interface allows for adding documents\n * to the underlying vector store and conducting retrieval operations.\n *\n * `VectorStoreRetrieverInterface` extends `BaseRetrieverInterface` to provide\n * document retrieval capabilities based on vector similarity.\n *\n * @interface VectorStoreRetrieverInterface\n * @extends BaseRetrieverInterface\n */\nexport interface VectorStoreRetrieverInterface<\n  V extends VectorStoreInterface = VectorStoreInterface,\n> extends BaseRetrieverInterface {\n  vectorStore: V;\n\n  /**\n   * Adds an array of documents to the vector store.\n   *\n   * This method embeds the provided documents and stores them within the\n   * vector store. Additional options can be specified for custom behavior\n   * during the addition process.\n   *\n   * @param documents - An array of documents to embed and add to the vector store.\n   * @param options - Optional settings to customize document addition.\n   * @returns A promise that resolves to an array of document IDs or `void`,\n   *          depending on the implementation.\n   */\n  addDocuments(\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n}\n\n/**\n * Class for retrieving documents from a `VectorStore` based on vector similarity\n * or maximal marginal relevance (MMR).\n *\n * `VectorStoreRetriever` extends `BaseRetriever`, implementing methods for\n * adding documents to the underlying vector store and performing document\n * retrieval with optional configurations.\n *\n * @class VectorStoreRetriever\n * @extends BaseRetriever\n * @implements VectorStoreRetrieverInterface\n * @template V - Type of vector store implementing `VectorStoreInterface`.\n */\nexport class VectorStoreRetriever<\n    V extends VectorStoreInterface = VectorStoreInterface,\n  >\n  extends BaseRetriever\n  implements VectorStoreRetrieverInterface\n{\n  static lc_name() {\n    return \"VectorStoreRetriever\";\n  }\n\n  get lc_namespace() {\n    return [\"langchain_core\", \"vectorstores\"];\n  }\n\n  /**\n   * The instance of `VectorStore` used for storing and retrieving document embeddings.\n   * This vector store must implement the `VectorStoreInterface` to be compatible\n   * with the retrievers operations.\n   */\n  vectorStore: V;\n\n  /**\n   * Specifies the number of documents to retrieve for each search query.\n   * Defaults to 4 if not specified, providing a basic result count for similarity or MMR searches.\n   */\n  k = 4;\n\n  /**\n   * Determines the type of search operation to perform on the vector store.\n   *\n   * - `\"similarity\"` (default): Conducts a similarity search based purely on vector similarity\n   *   to the query.\n   * - `\"mmr\"`: Executes a maximal marginal relevance (MMR) search, balancing relevance and\n   *   diversity in the retrieved results.\n   */\n  searchType = \"similarity\";\n\n  /**\n   * Additional options specific to maximal marginal relevance (MMR) search, applicable\n   * only if `searchType` is set to `\"mmr\"`.\n   *\n   * Includes:\n   * - `fetchK`: The initial number of documents fetched before applying the MMR algorithm,\n   *   allowing for a larger selection from which to choose the most diverse results.\n   * - `lambda`: A parameter between 0 and 1 to adjust the relevance-diversity balance,\n   *   where 0 prioritizes diversity and 1 prioritizes relevance.\n   */\n  searchKwargs?: VectorStoreRetrieverMMRSearchKwargs;\n\n  /**\n   * Optional filter applied to search results, defined by the `FilterType` of the vector store.\n   * Allows for refined, targeted results by restricting the returned documents based\n   * on specified filter criteria.\n   */\n  filter?: V[\"FilterType\"];\n\n  /**\n   * Returns the type of vector store, as defined by the `vectorStore` instance.\n   *\n   * @returns {string} The vector store type.\n   */\n  _vectorstoreType(): string {\n    return this.vectorStore._vectorstoreType();\n  }\n\n  /**\n   * Initializes a new instance of `VectorStoreRetriever` with the specified configuration.\n   *\n   * This constructor configures the retriever to interact with a given `VectorStore`\n   * and supports different retrieval strategies, including similarity search and maximal\n   * marginal relevance (MMR) search. Various options allow customization of the number\n   * of documents retrieved per query, filtering based on conditions, and fine-tuning\n   * MMR-specific parameters.\n   *\n   * @param fields - Configuration options for setting up the retriever:\n   *\n   *   - `vectorStore` (required): The `VectorStore` instance implementing `VectorStoreInterface`\n   *     that will be used to store and retrieve document embeddings. This is the core component\n   *     of the retriever, enabling vector-based similarity and MMR searches.\n   *\n   *   - `k` (optional): Specifies the number of documents to retrieve per search query. If not\n   *     provided, defaults to 4. This count determines the number of most relevant documents returned\n   *     for each search operation, balancing performance with comprehensiveness.\n   *\n   *   - `searchType` (optional): Defines the search approach used by the retriever, allowing for\n   *     flexibility between two methods:\n   *       - `\"similarity\"` (default): A similarity-based search, retrieving documents with high vector\n   *         similarity to the query. This type prioritizes relevance and is often used when diversity\n   *         among results is less critical.\n   *       - `\"mmr\"`: Maximal Marginal Relevance search, which combines relevance with diversity. MMR\n   *         is useful for scenarios where varied content is essential, as it selects results that\n   *         both match the query and introduce content diversity.\n   *\n   *   - `filter` (optional): A filter of type `FilterType`, defined by the vector store, that allows\n   *     for refined and targeted search results. This filter applies specified conditions to limit\n   *     which documents are eligible for retrieval, offering control over the scope of results.\n   *\n   *   - `searchKwargs` (optional, applicable only if `searchType` is `\"mmr\"`): Additional settings\n   *     for configuring MMR-specific behavior. These parameters allow further tuning of the MMR\n   *     search process:\n   *       - `fetchK`: The initial number of documents fetched from the vector store before the MMR\n   *         algorithm is applied. Fetching a larger set enables the algorithm to select a more\n   *         diverse subset of documents.\n   *       - `lambda`: A parameter controlling the relevance-diversity balance, where 0 emphasizes\n   *         diversity and 1 prioritizes relevance. Intermediate values provide a blend of the two,\n   *         allowing customization based on the importance of content variety relative to query relevance.\n   */\n  constructor(fields: VectorStoreRetrieverInput<V>) {\n    super(fields);\n    this.vectorStore = fields.vectorStore;\n    this.k = fields.k ?? this.k;\n    this.searchType = fields.searchType ?? this.searchType;\n    this.filter = fields.filter;\n    if (fields.searchType === \"mmr\") {\n      this.searchKwargs = fields.searchKwargs;\n    }\n  }\n\n  /**\n   * Retrieves relevant documents based on the specified query, using either\n   * similarity or maximal marginal relevance (MMR) search.\n   *\n   * If `searchType` is set to `\"mmr\"`, performs an MMR search to balance\n   * similarity and diversity among results. If `searchType` is `\"similarity\"`,\n   * retrieves results purely based on similarity to the query.\n   *\n   * @param query - The query string used to find relevant documents.\n   * @param runManager - Optional callback manager for tracking retrieval progress.\n   * @returns A promise that resolves to an array of `DocumentInterface` instances\n   *          representing the most relevant documents to the query.\n   * @throws {Error} Throws an error if MMR search is requested but not supported\n   *                 by the vector store.\n   * @protected\n   */\n  async _getRelevantDocuments(\n    query: string,\n    runManager?: CallbackManagerForRetrieverRun\n  ): Promise<DocumentInterface[]> {\n    if (this.searchType === \"mmr\") {\n      if (typeof this.vectorStore.maxMarginalRelevanceSearch !== \"function\") {\n        throw new Error(\n          `The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`\n        );\n      }\n      return this.vectorStore.maxMarginalRelevanceSearch(\n        query,\n        {\n          k: this.k,\n          filter: this.filter,\n          ...this.searchKwargs,\n        },\n        runManager?.getChild(\"vectorstore\")\n      );\n    }\n    return this.vectorStore.similaritySearch(\n      query,\n      this.k,\n      this.filter,\n      runManager?.getChild(\"vectorstore\")\n    );\n  }\n\n  /**\n   * Adds an array of documents to the vector store, embedding them as part of\n   * the storage process.\n   *\n   * This method delegates document embedding and storage to the `addDocuments`\n   * method of the underlying vector store.\n   *\n   * @param documents - An array of documents to embed and add to the vector store.\n   * @param options - Optional settings to customize document addition.\n   * @returns A promise that resolves to an array of document IDs or `void`,\n   *          depending on the vector store's implementation.\n   */\n  async addDocuments(\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void> {\n    return this.vectorStore.addDocuments(documents, options);\n  }\n}\n\n/**\n * Interface defining the structure and operations of a vector store, which\n * facilitates the storage, retrieval, and similarity search of document vectors.\n *\n * `VectorStoreInterface` provides methods for adding, deleting, and searching\n * documents based on vector embeddings, including support for similarity\n * search with optional filtering and relevance-based retrieval.\n *\n * @extends Serializable\n */\nexport interface VectorStoreInterface extends Serializable {\n  /**\n   * Defines the filter type used in search and delete operations. Can be an\n   * object for structured conditions or a string for simpler filtering.\n   */\n  FilterType: object | string;\n\n  /**\n   * Instance of `EmbeddingsInterface` used to generate vector embeddings for\n   * documents, enabling vector-based search operations.\n   */\n  embeddings: EmbeddingsInterface;\n\n  /**\n   * Returns a string identifying the type of vector store implementation,\n   * useful for distinguishing between different vector storage backends.\n   *\n   * @returns {string} A string indicating the vector store type.\n   */\n  _vectorstoreType(): string;\n\n  /**\n   * Adds precomputed vectors and their corresponding documents to the vector store.\n   *\n   * @param vectors - An array of vectors, with each vector representing a document.\n   * @param documents - An array of `DocumentInterface` instances corresponding to each vector.\n   * @param options - Optional configurations for adding documents, potentially covering indexing or metadata handling.\n   * @returns A promise that resolves to an array of document IDs or void, depending on implementation.\n   */\n  addVectors(\n    vectors: number[][],\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n\n  /**\n   * Adds an array of documents to the vector store.\n   *\n   * @param documents - An array of documents to be embedded and stored in the vector store.\n   * @param options - Optional configurations for embedding and storage operations.\n   * @returns A promise that resolves to an array of document IDs or void, depending on implementation.\n   */\n  addDocuments(\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n\n  /**\n   * Deletes documents from the vector store based on the specified parameters.\n   *\n   * @param _params - A flexible object containing key-value pairs that define\n   *                  the conditions for selecting documents to delete.\n   * @returns A promise that resolves once the deletion operation is complete.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  delete(_params?: Record<string, any>): Promise<void>;\n\n  /**\n   * Searches for documents similar to a given vector query and returns them\n   * with similarity scores.\n   *\n   * @param query - A vector representing the query for similarity search.\n   * @param k - The number of similar documents to return.\n   * @param filter - Optional filter based on `FilterType` to restrict results.\n   * @returns A promise that resolves to an array of tuples, each containing a\n   *          `DocumentInterface` and its corresponding similarity score.\n   */\n  similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[DocumentInterface, number][]>;\n\n  /**\n   * Searches for documents similar to a text query, embedding the query\n   * and retrieving documents based on vector similarity.\n   *\n   * @param query - The text query to search for.\n   * @param k - Optional number of similar documents to return.\n   * @param filter - Optional filter based on `FilterType` to restrict results.\n   * @param callbacks - Optional callbacks for tracking progress or events\n   *                    during the search process.\n   * @returns A promise that resolves to an array of `DocumentInterface`\n   *          instances representing similar documents.\n   */\n  similaritySearch(\n    query: string,\n    k?: number,\n    filter?: this[\"FilterType\"],\n    callbacks?: Callbacks\n  ): Promise<DocumentInterface[]>;\n\n  /**\n   * Searches for documents similar to a text query and includes similarity\n   * scores in the result.\n   *\n   * @param query - The text query to search for.\n   * @param k - Optional number of similar documents to return.\n   * @param filter - Optional filter based on `FilterType` to restrict results.\n   * @param callbacks - Optional callbacks for tracking progress or events\n   *                    during the search process.\n   * @returns A promise that resolves to an array of tuples, each containing\n   *          a `DocumentInterface` and its similarity score.\n   */\n  similaritySearchWithScore(\n    query: string,\n    k?: number,\n    filter?: this[\"FilterType\"],\n    callbacks?: Callbacks\n  ): Promise<[DocumentInterface, number][]>;\n\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND diversity\n   * among selected documents.\n   *\n   * @param {string} query - Text to look up documents similar to.\n   * @param {number} options.k - Number of documents to return.\n   * @param {number} options.fetchK - Number of documents to fetch before passing to the MMR algorithm.\n   * @param {number} options.lambda - Number between 0 and 1 that determines the degree of diversity among the results,\n   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n   * @param {this[\"FilterType\"]} options.filter - Optional filter\n   * @param _callbacks\n   *\n   * @returns {Promise<DocumentInterface[]>} - List of documents selected by maximal marginal relevance.\n   */\n  maxMarginalRelevanceSearch?(\n    query: string,\n    options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>,\n    callbacks: Callbacks | undefined\n  ): Promise<DocumentInterface[]>;\n\n  /**\n   * Converts the vector store into a retriever, making it suitable for use in\n   * retrieval-based workflows and allowing additional configuration.\n   *\n   * @param kOrFields - Optional parameter for specifying either the number of\n   *                    documents to retrieve or partial retriever configurations.\n   * @param filter - Optional filter based on `FilterType` for retrieval restriction.\n   * @param callbacks - Optional callbacks for tracking retrieval events or progress.\n   * @param tags - General-purpose tags to add contextual information to the retriever.\n   * @param metadata - General-purpose metadata providing additional context\n   *                   for retrieval.\n   * @param verbose - If `true`, enables detailed logging during retrieval.\n   * @returns An instance of `VectorStoreRetriever` configured with the specified options.\n   */\n  asRetriever(\n    kOrFields?: number | Partial<VectorStoreRetrieverInput<this>>,\n    filter?: this[\"FilterType\"],\n    callbacks?: Callbacks,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    verbose?: boolean\n  ): VectorStoreRetriever<this>;\n}\n\n/**\n * Abstract class representing a vector storage system for performing\n * similarity searches on embedded documents.\n *\n * `VectorStore` provides methods for adding precomputed vectors or documents,\n * removing documents based on criteria, and performing similarity searches\n * with optional scoring. Subclasses are responsible for implementing specific\n * storage mechanisms and the exact behavior of certain abstract methods.\n *\n * @abstract\n * @extends Serializable\n * @implements VectorStoreInterface\n */\nexport abstract class VectorStore\n  extends Serializable\n  implements VectorStoreInterface\n{\n  declare FilterType: object | string;\n\n  /**\n   * Namespace within LangChain to uniquely identify this vector store's\n   * location, based on the vector store type.\n   *\n   * @internal\n   */\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"vectorstores\", this._vectorstoreType()];\n\n  /**\n   * Embeddings interface for generating vector embeddings from text queries,\n   * enabling vector-based similarity searches.\n   */\n  embeddings: EmbeddingsInterface;\n\n  /**\n   * Initializes a new vector store with embeddings and database configuration.\n   *\n   * @param embeddings - Instance of `EmbeddingsInterface` used to embed queries.\n   * @param dbConfig - Configuration settings for the database or storage system.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(embeddings: EmbeddingsInterface, dbConfig: Record<string, any>) {\n    super(dbConfig);\n    this.embeddings = embeddings;\n  }\n\n  /**\n   * Returns a string representing the type of vector store, which subclasses\n   * must implement to identify their specific vector storage type.\n   *\n   * @returns {string} A string indicating the vector store type.\n   * @abstract\n   */\n  abstract _vectorstoreType(): string;\n\n  /**\n   * Adds precomputed vectors and corresponding documents to the vector store.\n   *\n   * @param vectors - An array of vectors representing each document.\n   * @param documents - Array of documents associated with each vector.\n   * @param options - Optional configuration for adding vectors, such as indexing.\n   * @returns A promise resolving to an array of document IDs or void, based on implementation.\n   * @abstract\n   */\n  abstract addVectors(\n    vectors: number[][],\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n\n  /**\n   * Adds documents to the vector store, embedding them first through the\n   * `embeddings` instance.\n   *\n   * @param documents - Array of documents to embed and add.\n   * @param options - Optional configuration for embedding and storing documents.\n   * @returns A promise resolving to an array of document IDs or void, based on implementation.\n   * @abstract\n   */\n  abstract addDocuments(\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n\n  /**\n   * Deletes documents from the vector store based on the specified parameters.\n   *\n   * @param _params - Flexible key-value pairs defining conditions for document deletion.\n   * @returns A promise that resolves once the deletion is complete.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async delete(_params?: Record<string, any>): Promise<void> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  /**\n   * Performs a similarity search using a vector query and returns results\n   * along with their similarity scores.\n   *\n   * @param query - Vector representing the search query.\n   * @param k - Number of similar results to return.\n   * @param filter - Optional filter based on `FilterType` to restrict results.\n   * @returns A promise resolving to an array of tuples containing documents and their similarity scores.\n   * @abstract\n   */\n  abstract similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[DocumentInterface, number][]>;\n\n  /**\n   * Searches for documents similar to a text query by embedding the query and\n   * performing a similarity search on the resulting vector.\n   *\n   * @param query - Text query for finding similar documents.\n   * @param k - Number of similar results to return. Defaults to 4.\n   * @param filter - Optional filter based on `FilterType`.\n   * @param _callbacks - Optional callbacks for monitoring search progress\n   * @returns A promise resolving to an array of `DocumentInterface` instances representing similar documents.\n   */\n  async similaritySearch(\n    query: string,\n    k = 4,\n    filter: this[\"FilterType\"] | undefined = undefined,\n    _callbacks: Callbacks | undefined = undefined // implement passing to embedQuery later\n  ): Promise<DocumentInterface[]> {\n    const results = await this.similaritySearchVectorWithScore(\n      await this.embeddings.embedQuery(query),\n      k,\n      filter\n    );\n\n    return results.map((result) => result[0]);\n  }\n\n  /**\n   * Searches for documents similar to a text query by embedding the query,\n   * and returns results with similarity scores.\n   *\n   * @param query - Text query for finding similar documents.\n   * @param k - Number of similar results to return. Defaults to 4.\n   * @param filter - Optional filter based on `FilterType`.\n   * @param _callbacks - Optional callbacks for monitoring search progress\n   * @returns A promise resolving to an array of tuples, each containing a\n   *          document and its similarity score.\n   */\n  async similaritySearchWithScore(\n    query: string,\n    k = 4,\n    filter: this[\"FilterType\"] | undefined = undefined,\n    _callbacks: Callbacks | undefined = undefined // implement passing to embedQuery later\n  ): Promise<[DocumentInterface, number][]> {\n    return this.similaritySearchVectorWithScore(\n      await this.embeddings.embedQuery(query),\n      k,\n      filter\n    );\n  }\n\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND diversity\n   * among selected documents.\n   *\n   * @param {string} query - Text to look up documents similar to.\n   * @param {number} options.k - Number of documents to return.\n   * @param {number} options.fetchK - Number of documents to fetch before passing to the MMR algorithm.\n   * @param {number} options.lambda - Number between 0 and 1 that determines the degree of diversity among the results,\n   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n   * @param {this[\"FilterType\"]} options.filter - Optional filter\n   * @param _callbacks\n   *\n   * @returns {Promise<DocumentInterface[]>} - List of documents selected by maximal marginal relevance.\n   */\n  async maxMarginalRelevanceSearch?(\n    query: string,\n    options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>,\n    _callbacks: Callbacks | undefined // implement passing to embedQuery later\n  ): Promise<DocumentInterface[]>;\n\n  /**\n   * Creates a `VectorStore` instance from an array of text strings and optional\n   * metadata, using the specified embeddings and database configuration.\n   *\n   * Subclasses must implement this method to define how text and metadata\n   * are embedded and stored in the vector store. Throws an error if not overridden.\n   *\n   * @param _texts - Array of strings representing the text documents to be stored.\n   * @param _metadatas - Metadata for the texts, either as an array (one for each text)\n   *                     or a single object (applied to all texts).\n   * @param _embeddings - Instance of `EmbeddingsInterface` to embed the texts.\n   * @param _dbConfig - Database configuration settings.\n   * @returns A promise that resolves to a new `VectorStore` instance.\n   * @throws {Error} Throws an error if this method is not overridden by a subclass.\n   */\n  static fromTexts(\n    _texts: string[],\n    _metadatas: object[] | object,\n    _embeddings: EmbeddingsInterface,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _dbConfig: Record<string, any>\n  ): Promise<VectorStore> {\n    throw new Error(\n      \"the Langchain vectorstore implementation you are using forgot to override this, please report a bug\"\n    );\n  }\n\n  /**\n   * Creates a `VectorStore` instance from an array of documents, using the specified\n   * embeddings and database configuration.\n   *\n   * Subclasses must implement this method to define how documents are embedded\n   * and stored. Throws an error if not overridden.\n   *\n   * @param _docs - Array of `DocumentInterface` instances representing the documents to be stored.\n   * @param _embeddings - Instance of `EmbeddingsInterface` to embed the documents.\n   * @param _dbConfig - Database configuration settings.\n   * @returns A promise that resolves to a new `VectorStore` instance.\n   * @throws {Error} Throws an error if this method is not overridden by a subclass.\n   */\n  static fromDocuments(\n    _docs: DocumentInterface[],\n    _embeddings: EmbeddingsInterface,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _dbConfig: Record<string, any>\n  ): Promise<VectorStore> {\n    throw new Error(\n      \"the Langchain vectorstore implementation you are using forgot to override this, please report a bug\"\n    );\n  }\n\n  /**\n   * Creates a `VectorStoreRetriever` instance with flexible configuration options.\n   *\n   * @param kOrFields\n   *    - If a number is provided, it sets the `k` parameter (number of items to retrieve).\n   *    - If an object is provided, it should contain various configuration options.\n   * @param filter\n   *    - Optional filter criteria to limit the items retrieved based on the specified filter type.\n   * @param callbacks\n   *    - Optional callbacks that may be triggered at specific stages of the retrieval process.\n   * @param tags\n   *    - Tags to categorize or label the `VectorStoreRetriever`. Defaults to an empty array if not provided.\n   * @param metadata\n   *    - Additional metadata as key-value pairs to add contextual information for the retrieval process.\n   * @param verbose\n   *    - If `true`, enables detailed logging for the retrieval process. Defaults to `false`.\n   *\n   * @returns\n   *    - A configured `VectorStoreRetriever` instance based on the provided parameters.\n   *\n   * @example\n   * Basic usage with a `k` value:\n   * ```typescript\n   * const retriever = myVectorStore.asRetriever(5);\n   * ```\n   *\n   * Usage with a configuration object:\n   * ```typescript\n   * const retriever = myVectorStore.asRetriever({\n   *   k: 10,\n   *   filter: myFilter,\n   *   tags: ['example', 'test'],\n   *   verbose: true,\n   *   searchType: 'mmr',\n   *   searchKwargs: { alpha: 0.5 },\n   * });\n   * ```\n   */\n  asRetriever(\n    kOrFields?: number | Partial<VectorStoreRetrieverInput<this>>,\n    filter?: this[\"FilterType\"],\n    callbacks?: Callbacks,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    verbose?: boolean\n  ): VectorStoreRetriever<this> {\n    if (typeof kOrFields === \"number\") {\n      return new VectorStoreRetriever({\n        vectorStore: this,\n        k: kOrFields,\n        filter,\n        tags: [...(tags ?? []), this._vectorstoreType()],\n        metadata,\n        verbose,\n        callbacks,\n      });\n    } else {\n      const params = {\n        vectorStore: this,\n        k: kOrFields?.k,\n        filter: kOrFields?.filter,\n        tags: [...(kOrFields?.tags ?? []), this._vectorstoreType()],\n        metadata: kOrFields?.metadata,\n        verbose: kOrFields?.verbose,\n        callbacks: kOrFields?.callbacks,\n        searchType: kOrFields?.searchType,\n      };\n      if (kOrFields?.searchType === \"mmr\") {\n        return new VectorStoreRetriever({\n          ...params,\n          searchKwargs: kOrFields.searchKwargs,\n        });\n      }\n      return new VectorStoreRetriever({ ...params });\n    }\n  }\n}\n\n/**\n * Abstract class extending `VectorStore` that defines a contract for saving\n * and loading vector store instances.\n *\n * The `SaveableVectorStore` class allows vector store implementations to\n * persist their data and retrieve it when needed.The format for saving and\n * loading data is left to the implementing subclass.\n *\n * Subclasses must implement the `save` method to handle their custom\n * serialization logic, while the `load` method enables reconstruction of a\n * vector store from saved data, requiring compatible embeddings through the\n * `EmbeddingsInterface`.\n *\n * @abstract\n * @extends VectorStore\n */\nexport abstract class SaveableVectorStore extends VectorStore {\n  /**\n   * Saves the current state of the vector store to the specified directory.\n   *\n   * This method must be implemented by subclasses to define their own\n   * serialization process for persisting vector data. The implementation\n   * determines the structure and format of the saved data.\n   *\n   * @param directory - The directory path where the vector store data\n   * will be saved.\n   * @abstract\n   */\n  abstract save(directory: string): Promise<void>;\n\n  /**\n   * Loads a vector store instance from the specified directory, using the\n   * provided embeddings to ensure compatibility.\n   *\n   * This static method reconstructs a `SaveableVectorStore` from previously\n   * saved data. Implementations should interpret the saved data format to\n   * recreate the vector store instance.\n   *\n   * @param _directory - The directory path from which the vector store\n   * data will be loaded.\n   * @param _embeddings - An instance of `EmbeddingsInterface` to align\n   * the embeddings with the loaded vector data.\n   * @returns A promise that resolves to a `SaveableVectorStore` instance\n   * constructed from the saved data.\n   */\n  static load(\n    _directory: string,\n    _embeddings: EmbeddingsInterface\n  ): Promise<SaveableVectorStore> {\n    throw new Error(\"Not implemented\");\n  }\n}\n", "import { Document } from \"../documents/document.js\";\n\n/**\n * Interface that defines the methods for loading and splitting documents.\n */\nexport interface DocumentLoader {\n  load(): Promise<Document[]>;\n}\n\n/**\n * Abstract class that provides a default implementation for the\n * loadAndSplit() method from the DocumentLoader interface. The load()\n * method is left abstract and needs to be implemented by subclasses.\n */\nexport abstract class BaseDocumentLoader implements DocumentLoader {\n  /**\n   * Loads the documents.\n   * @returns A Promise that resolves with an array of Document instances.\n   */\n  abstract load(): Promise<Document[]>;\n}\n", "import { KVMap } from \"langsmith/schemas\";\nimport { Client } from \"langsmith\";\nimport { Document, DocumentInterface } from \"../documents/document.js\";\nimport { AsyncCallerParams } from \"../utils/async_caller.js\";\nimport { BaseDocumentLoader } from \"./base.js\";\n\n// TODO: Replace with import from `langsmith` once exposed.\ninterface ClientConfig {\n  apiUrl?: string;\n  apiKey?: string;\n  callerOptions?: AsyncCallerParams;\n  timeout_ms?: number;\n  webUrl?: string;\n  anonymizer?: (values: KVMap) => KVMap;\n  hideInputs?: boolean | ((inputs: KVMap) => KVMap);\n  hideOutputs?: boolean | ((outputs: KVMap) => KVMap);\n  autoBatchTracing?: boolean;\n  pendingAutoBatchedRunLimit?: number;\n  fetchOptions?: RequestInit;\n}\n\nexport interface LangSmithLoaderFields {\n  datasetId?: string;\n  datasetName?: string;\n  exampleIds?: Array<string>;\n  asOf?: Date | string;\n  splits?: string[];\n  inlineS3Urls?: boolean;\n  offset?: number;\n  limit?: number;\n  metadata?: KVMap;\n  filter?: string;\n  contentKey?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  formatContent?: (content: any) => string;\n  client?: Client;\n  clientConfig?: ClientConfig;\n}\n\n/**\n * Document loader integration with LangSmith.\n *\n * ## [Constructor args](https://api.js.langchain.com/interfaces/_langchain_core.document_loaders_langsmith.LangSmithLoaderFields.html)\n *\n * <details open>\n * <summary><strong>Load</strong></summary>\n *\n * ```typescript\n * import { LangSmithLoader } from '@langchain/core/document_loaders/langsmith';\n * import { Client } from 'langsmith';\n *\n * const langSmithClient = new Client({\n *   apiKey: process.env.LANGSMITH_API_KEY,\n * })\n *\n * const loader = new LangSmithLoader({\n *   datasetId: \"9a3b36f7-b308-40a5-9b46-6613853b6330\",\n *   limit: 1,\n * });\n *\n * const docs = await loader.load();\n * ```\n *\n * ```txt\n * [\n *   {\n *     pageContent: '{\\n  \"input_key_str\": \"string\",\\n  \"input_key_bool\": true\\n}',\n *     metadata: {\n *       id: '8523d9e9-c123-4b23-9b46-21021nds289e',\n *       created_at: '2024-08-19T17:09:14.806441+00:00',\n *       modified_at: '2024-08-19T17:09:14.806441+00:00',\n *       name: '#8517 @ brace-test-dataset',\n *       dataset_id: '9a3b36f7-b308-40a5-9b46-6613853b6330',\n *       source_run_id: null,\n *       metadata: [Object],\n *       inputs: [Object],\n *       outputs: [Object]\n *     }\n *   }\n * ]\n * ```\n * </details>\n */\nexport class LangSmithLoader extends BaseDocumentLoader {\n  datasetId?: string;\n\n  datasetName?: string;\n\n  exampleIds?: Array<string>;\n\n  asOf?: Date | string;\n\n  splits?: string[];\n\n  inlineS3Urls?: boolean;\n\n  offset?: number;\n\n  limit?: number;\n\n  metadata?: KVMap;\n\n  filter?: string;\n\n  contentKey: string[];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  formatContent: (content: any) => string;\n\n  client: Client;\n\n  constructor(fields: LangSmithLoaderFields) {\n    super();\n\n    if (fields.client && fields.clientConfig) {\n      throw new Error(\"client and clientConfig cannot both be provided.\");\n    }\n    this.client = fields.client ?? new Client(fields?.clientConfig);\n    this.contentKey = fields.contentKey ? fields.contentKey.split(\".\") : [];\n    this.formatContent = fields.formatContent ?? _stringify;\n    this.datasetId = fields.datasetId;\n    this.datasetName = fields.datasetName;\n    this.exampleIds = fields.exampleIds;\n    this.asOf = fields.asOf;\n    this.splits = fields.splits;\n    this.inlineS3Urls = fields.inlineS3Urls;\n    this.offset = fields.offset;\n    this.limit = fields.limit;\n    this.metadata = fields.metadata;\n    this.filter = fields.filter;\n  }\n\n  async load(): Promise<Document[]> {\n    const documents: DocumentInterface[] = [];\n    for await (const example of this.client.listExamples({\n      datasetId: this.datasetId,\n      datasetName: this.datasetName,\n      exampleIds: this.exampleIds,\n      asOf: this.asOf,\n      splits: this.splits,\n      inlineS3Urls: this.inlineS3Urls,\n      offset: this.offset,\n      limit: this.limit,\n      metadata: this.metadata,\n      filter: this.filter,\n    })) {\n      let content = example.inputs;\n      for (const key of this.contentKey) {\n        content = content[key];\n      }\n      const contentStr = this.formatContent(content);\n\n      const metadata: KVMap = example;\n      [\"created_at\", \"modified_at\"].forEach((k) => {\n        if (k in metadata) {\n          if (typeof metadata[k] === \"object\") {\n            // Dates are of type `object`, we want to convert them to strings.\n            metadata[k] = metadata[k].toString();\n          }\n        }\n      });\n\n      documents.push({\n        pageContent: contentStr,\n        metadata,\n      });\n    }\n    return documents;\n  }\n}\n\nfunction _stringify(x: string | KVMap): string {\n  if (typeof x === \"string\") {\n    return x;\n  } else {\n    try {\n      return JSON.stringify(x, null, 2);\n    } catch {\n      return String(x);\n    }\n  }\n}\n", "import { Serializable } from \"../load/serializable.js\";\nimport type { Example } from \"../prompts/base.js\";\n\n/**\n * Base class for example selectors.\n */\nexport abstract class BaseExampleSelector extends Serializable {\n  lc_namespace = [\"langchain_core\", \"example_selectors\", \"base\"];\n\n  /**\n   * Adds an example to the example selector.\n   * @param example The example to add to the example selector.\n   * @returns A Promise that resolves to void or a string.\n   */\n  abstract addExample(example: Example): Promise<void | string>;\n\n  /**\n   * Selects examples from the example selector given the input variables.\n   * @param input_variables The input variables to select examples with.\n   * @returns A Promise that resolves to an array of selected examples.\n   */\n  abstract selectExamples(input_variables: Example): Promise<Example[]>;\n}\n", "import type { BaseChatModel } from \"../language_models/chat_models.js\";\nimport type { BasePromptTemplate } from \"../prompts/base.js\";\nimport type { BaseLanguageModelInterface } from \"../language_models/base.js\";\nimport type { BaseLLM } from \"../language_models/llms.js\";\nimport type { PartialValues } from \"../utils/types/index.js\";\n\nexport type BaseGetPromptAsyncOptions = {\n  partialVariables?: PartialValues;\n};\n\n/**\n * Abstract class that defines the interface for selecting a prompt for a\n * given language model.\n */\nexport abstract class BasePromptSelector {\n  /**\n   * Abstract method that must be implemented by any class that extends\n   * `BasePromptSelector`. It takes a language model as an argument and\n   * returns a prompt template.\n   * @param llm The language model for which to get a prompt.\n   * @returns A prompt template.\n   */\n  abstract getPrompt(llm: BaseLanguageModelInterface): BasePromptTemplate;\n\n  /**\n   * Asynchronous version of `getPrompt` that also accepts an options object\n   * for partial variables.\n   * @param llm The language model for which to get a prompt.\n   * @param options Optional object for partial variables.\n   * @returns A Promise that resolves to a prompt template.\n   */\n  async getPromptAsync(\n    llm: BaseLanguageModelInterface,\n    options?: BaseGetPromptAsyncOptions\n  ): Promise<BasePromptTemplate> {\n    const prompt = this.getPrompt(llm);\n    return prompt.partial(options?.partialVariables ?? {});\n  }\n}\n\n/**\n * Concrete implementation of `BasePromptSelector` that selects a prompt\n * based on a set of conditions. It has a default prompt that it returns\n * if none of the conditions are met.\n */\nexport class ConditionalPromptSelector extends BasePromptSelector {\n  defaultPrompt: BasePromptTemplate;\n\n  conditionals: Array<\n    [\n      condition: (llm: BaseLanguageModelInterface) => boolean,\n      prompt: BasePromptTemplate,\n    ]\n  >;\n\n  constructor(\n    default_prompt: BasePromptTemplate,\n    conditionals: Array<\n      [\n        condition: (llm: BaseLanguageModelInterface) => boolean,\n        prompt: BasePromptTemplate,\n      ]\n    > = []\n  ) {\n    super();\n    this.defaultPrompt = default_prompt;\n    this.conditionals = conditionals;\n  }\n\n  /**\n   * Method that selects a prompt based on a set of conditions. If none of\n   * the conditions are met, it returns the default prompt.\n   * @param llm The language model for which to get a prompt.\n   * @returns A prompt template.\n   */\n  getPrompt(llm: BaseLanguageModelInterface): BasePromptTemplate {\n    for (const [condition, prompt] of this.conditionals) {\n      if (condition(llm)) {\n        return prompt;\n      }\n    }\n    return this.defaultPrompt;\n  }\n}\n\n/**\n * Type guard function that checks if a given language model is of type\n * `BaseLLM`.\n */\nexport function isLLM(llm: BaseLanguageModelInterface): llm is BaseLLM {\n  return llm._modelType() === \"base_llm\";\n}\n\n/**\n * Type guard function that checks if a given language model is of type\n * `BaseChatModel`.\n */\nexport function isChatModel(\n  llm: BaseLanguageModelInterface\n): llm is BaseChatModel {\n  return llm._modelType() === \"base_chat_model\";\n}\n", "import { Example } from \"../prompts/base.js\";\nimport { BaseExampleSelector } from \"./base.js\";\nimport { PromptTemplate } from \"../prompts/prompt.js\";\n\n/**\n * Calculates the length of a text based on the number of words and lines.\n */\nfunction getLengthBased(text: string): number {\n  return text.split(/\\n| /).length;\n}\n\n/**\n * Interface for the input parameters of the LengthBasedExampleSelector\n * class.\n */\nexport interface LengthBasedExampleSelectorInput {\n  examplePrompt: PromptTemplate;\n  maxLength?: number;\n  getTextLength?: (text: string) => number;\n}\n\n/**\n * A specialized example selector that selects examples based on their\n * length, ensuring that the total length of the selected examples does\n * not exceed a specified maximum length.\n * @example\n * ```typescript\n * const exampleSelector = new LengthBasedExampleSelector(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   {\n *     examplePrompt: new PromptTemplate({\n *       inputVariables: [\"input\", \"output\"],\n *       template: \"Input: {input}\\nOutput: {output}\",\n *     }),\n *     maxLength: 25,\n *   },\n * );\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt: new PromptTemplate({\n *     inputVariables: [\"input\", \"output\"],\n *     template: \"Input: {input}\\nOutput: {output}\",\n *   }),\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n * console.log(dynamicPrompt.format({ adjective: \"big\" }));\n * console.log(\n *   dynamicPrompt.format({\n *     adjective:\n *       \"big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else\",\n *   }),\n * );\n * ```\n */\nexport class LengthBasedExampleSelector extends BaseExampleSelector {\n  protected examples: Example[] = [];\n\n  examplePrompt!: PromptTemplate;\n\n  getTextLength: (text: string) => number = getLengthBased;\n\n  maxLength = 2048;\n\n  exampleTextLengths: number[] = [];\n\n  constructor(data: LengthBasedExampleSelectorInput) {\n    super(data);\n    this.examplePrompt = data.examplePrompt;\n    this.maxLength = data.maxLength ?? 2048;\n    this.getTextLength = data.getTextLength ?? getLengthBased;\n  }\n\n  /**\n   * Adds an example to the list of examples and calculates its length.\n   * @param example The example to be added.\n   * @returns Promise that resolves when the example has been added and its length calculated.\n   */\n  async addExample(example: Example): Promise<void> {\n    this.examples.push(example);\n    const stringExample = await this.examplePrompt.format(example);\n    this.exampleTextLengths.push(this.getTextLength(stringExample));\n  }\n\n  /**\n   * Calculates the lengths of the examples.\n   * @param v Array of lengths of the examples.\n   * @param values Instance of LengthBasedExampleSelector.\n   * @returns Promise that resolves with an array of lengths of the examples.\n   */\n  async calculateExampleTextLengths(\n    v: number[],\n    values: LengthBasedExampleSelector\n  ): Promise<number[]> {\n    if (v.length > 0) {\n      return v;\n    }\n\n    const { examples, examplePrompt } = values;\n    const stringExamples = await Promise.all(\n      examples.map((eg: Example) => examplePrompt.format(eg))\n    );\n    return stringExamples.map((eg: string) => this.getTextLength(eg));\n  }\n\n  /**\n   * Selects examples until the total length of the selected examples\n   * reaches the maxLength.\n   * @param inputVariables The input variables for the examples.\n   * @returns Promise that resolves with an array of selected examples.\n   */\n  async selectExamples(inputVariables: Example): Promise<Example[]> {\n    const inputs = Object.values(inputVariables).join(\" \");\n    let remainingLength = this.maxLength - this.getTextLength(inputs);\n    let i = 0;\n    const examples: Example[] = [];\n\n    while (remainingLength > 0 && i < this.examples.length) {\n      const newLength = remainingLength - this.exampleTextLengths[i];\n      if (newLength < 0) {\n        break;\n      } else {\n        examples.push(this.examples[i]);\n        remainingLength = newLength;\n      }\n      i += 1;\n    }\n\n    return examples;\n  }\n\n  /**\n   * Creates a new instance of LengthBasedExampleSelector and adds a list of\n   * examples to it.\n   * @param examples Array of examples to be added.\n   * @param args Input parameters for the LengthBasedExampleSelector.\n   * @returns Promise that resolves with a new instance of LengthBasedExampleSelector with the examples added.\n   */\n  static async fromExamples(\n    examples: Example[],\n    args: LengthBasedExampleSelectorInput\n  ) {\n    const selector = new LengthBasedExampleSelector(args);\n    await Promise.all(examples.map((eg) => selector.addExample(eg)));\n    return selector;\n  }\n}\n", "import type { Embeddings } from \"../embeddings.js\";\nimport type {\n  VectorStoreInterface,\n  VectorStoreRetrieverInterface,\n  VectorStore,\n} from \"../vectorstores.js\";\nimport type { Example } from \"../prompts/base.js\";\nimport { Document } from \"../documents/document.js\";\nimport { BaseExampleSelector } from \"./base.js\";\n\nfunction sortedValues<T>(values: Record<string, T>): T[] {\n  return Object.keys(values)\n    .sort()\n    .map((key) => values[key]);\n}\n\n/**\n * Interface for the input data of the SemanticSimilarityExampleSelector\n * class.\n */\nexport type SemanticSimilarityExampleSelectorInput<\n  V extends VectorStoreInterface = VectorStoreInterface,\n> =\n  | {\n      vectorStore: V;\n      k?: number;\n      filter?: V[\"FilterType\"];\n      exampleKeys?: string[];\n      inputKeys?: string[];\n      vectorStoreRetriever?: never;\n    }\n  | {\n      vectorStoreRetriever: VectorStoreRetrieverInterface<V>;\n      exampleKeys?: string[];\n      inputKeys?: string[];\n      vectorStore?: never;\n      k?: never;\n      filter?: never;\n    };\n\n/**\n * Class that selects examples based on semantic similarity. It extends\n * the BaseExampleSelector class.\n * @example\n * ```typescript\n * const exampleSelector = await SemanticSimilarityExampleSelector.fromExamples(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   new OpenAIEmbeddings(),\n *   HNSWLib,\n *   { k: 1 },\n * );\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt: PromptTemplate.fromTemplate(\n *     \"Input: {input}\\nOutput: {output}\",\n *   ),\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n * console.log(await dynamicPrompt.format({ adjective: \"rainy\" }));\n * ```\n */\nexport class SemanticSimilarityExampleSelector<\n  V extends VectorStoreInterface = VectorStoreInterface,\n> extends BaseExampleSelector {\n  vectorStoreRetriever: VectorStoreRetrieverInterface<V>;\n\n  exampleKeys?: string[];\n\n  inputKeys?: string[];\n\n  constructor(data: SemanticSimilarityExampleSelectorInput<V>) {\n    super(data);\n    this.exampleKeys = data.exampleKeys;\n    this.inputKeys = data.inputKeys;\n    if (data.vectorStore !== undefined) {\n      this.vectorStoreRetriever = data.vectorStore.asRetriever({\n        k: data.k ?? 4,\n        filter: data.filter,\n      });\n    } else if (data.vectorStoreRetriever) {\n      this.vectorStoreRetriever = data.vectorStoreRetriever;\n    } else {\n      throw new Error(\n        `You must specify one of \"vectorStore\" and \"vectorStoreRetriever\".`\n      );\n    }\n  }\n\n  /**\n   * Method that adds a new example to the vectorStore. The example is\n   * converted to a string and added to the vectorStore as a document.\n   * @param example The example to be added to the vectorStore.\n   * @returns Promise that resolves when the example has been added to the vectorStore.\n   */\n  async addExample(example: Example): Promise<void> {\n    const inputKeys = this.inputKeys ?? Object.keys(example);\n    const stringExample = sortedValues(\n      inputKeys.reduce(\n        (acc, key) => ({ ...acc, [key]: example[key] }),\n        {} as Example\n      )\n    ).join(\" \");\n\n    await this.vectorStoreRetriever.addDocuments([\n      new Document({\n        pageContent: stringExample,\n        metadata: example,\n      }),\n    ]);\n  }\n\n  /**\n   * Method that selects which examples to use based on semantic similarity.\n   * It performs a similarity search in the vectorStore using the input\n   * variables and returns the examples with the highest similarity.\n   * @param inputVariables The input variables used for the similarity search.\n   * @returns Promise that resolves with an array of the selected examples.\n   */\n  async selectExamples<T>(\n    inputVariables: Record<string, T>\n  ): Promise<Example[]> {\n    const inputKeys = this.inputKeys ?? Object.keys(inputVariables);\n    const query = sortedValues(\n      inputKeys.reduce(\n        (acc, key) => ({ ...acc, [key]: inputVariables[key] }),\n        {} as Record<string, T>\n      )\n    ).join(\" \");\n\n    const exampleDocs = await this.vectorStoreRetriever.invoke(query);\n\n    const examples = exampleDocs.map((doc) => doc.metadata);\n    if (this.exampleKeys) {\n      // If example keys are provided, filter examples to those keys.\n      return examples.map((example) =>\n        (this.exampleKeys as string[]).reduce(\n          (acc, key) => ({ ...acc, [key]: example[key] }),\n          {}\n        )\n      );\n    }\n    return examples;\n  }\n\n  /**\n   * Static method that creates a new instance of\n   * SemanticSimilarityExampleSelector. It takes a list of examples, an\n   * instance of Embeddings, a VectorStore class, and an options object as\n   * parameters. It converts the examples to strings, creates a VectorStore\n   * from the strings and the embeddings, and returns a new\n   * SemanticSimilarityExampleSelector with the created VectorStore and the\n   * options provided.\n   * @param examples The list of examples to be used.\n   * @param embeddings The instance of Embeddings to be used.\n   * @param vectorStoreCls The VectorStore class to be used.\n   * @param options The options object for the SemanticSimilarityExampleSelector.\n   * @returns Promise that resolves with a new instance of SemanticSimilarityExampleSelector.\n   */\n  static async fromExamples<C extends typeof VectorStore>(\n    examples: Record<string, string>[],\n    embeddings: Embeddings,\n    vectorStoreCls: C,\n    options: {\n      k?: number;\n      inputKeys?: string[];\n    } & Parameters<C[\"fromTexts\"]>[3] = {}\n  ): Promise<SemanticSimilarityExampleSelector> {\n    const inputKeys = options.inputKeys ?? null;\n    const stringExamples = examples.map((example) =>\n      sortedValues(\n        inputKeys\n          ? inputKeys.reduce(\n              (acc, key) => ({ ...acc, [key]: example[key] }),\n              {} as Record<string, string>\n            )\n          : example\n      ).join(\" \")\n    );\n\n    const vectorStore = await vectorStoreCls.fromTexts(\n      stringExamples,\n      examples, // metadatas\n      embeddings,\n      options\n    );\n\n    return new SemanticSimilarityExampleSelector({\n      vectorStore,\n      k: options.k ?? 4,\n      exampleKeys: options.exampleKeys,\n      inputKeys: options.inputKeys,\n    });\n  }\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { BaseExampleSelector } from \"./base.js\";\nimport { BasePromptSelector, ConditionalPromptSelector, isChatModel, isLLM } from \"./conditional.js\";\nimport { LengthBasedExampleSelector } from \"./length_based.js\";\nimport { SemanticSimilarityExampleSelector } from \"./semantic_similarity.js\";\n\n//#region src/example_selectors/index.ts\nvar example_selectors_exports = {};\n__export(example_selectors_exports, {\n\tBaseExampleSelector: () => BaseExampleSelector,\n\tBasePromptSelector: () => BasePromptSelector,\n\tConditionalPromptSelector: () => ConditionalPromptSelector,\n\tLengthBasedExampleSelector: () => LengthBasedExampleSelector,\n\tSemanticSimilarityExampleSelector: () => SemanticSimilarityExampleSelector,\n\tisChatModel: () => isChatModel,\n\tisLLM: () => isLLM\n});\n\n//#endregion\nexport { BaseExampleSelector, BasePromptSelector, ConditionalPromptSelector, LengthBasedExampleSelector, SemanticSimilarityExampleSelector, example_selectors_exports, isChatModel, isLLM };\n//# sourceMappingURL=index.js.map", "import { Serializable } from \"../load/serializable.js\";\n\n// Arbitrary value, used for generating namespaced UUIDs.\nexport const UUIDV5_NAMESPACE = \"10f90ea3-90a4-4962-bf75-83a0f3c1c62a\";\n\nexport type UpdateOptions = {\n  groupIds?: (string | null)[];\n  timeAtLeast?: number;\n};\n\nexport type ListKeyOptions = {\n  before?: number;\n  after?: number;\n  groupIds?: (string | null)[];\n  limit?: number;\n};\n\nexport interface RecordManagerInterface {\n  /**\n   * Creates schema in the record manager.\n   * @returns Promise\n   */\n  createSchema(): Promise<void>;\n  /**\n   * Returns current time from the record manager.\n   * @returns Current time\n   */\n  getTime(): Promise<number>;\n  /**\n   * Updates keys in the record manager.\n   * @param keys List of keys to update\n   * @param groupIds List of groupIds to update\n   * @param timeAtLeast Update only if current time is at least this value\n   * @returns Promise\n   * @throws Error if timeAtLeast is provided and current time is less than timeAtLeast\n   * @throws Error if number of keys does not match number of groupIds\n   */\n  update(keys: string[], updateOptions: UpdateOptions): Promise<void>;\n  /**\n   * Checks if keys exist in the record manager.\n   * @param keys List of keys to check\n   * @returns List of booleans indicating if key exists in same order as provided keys\n   */\n  exists(keys: string[]): Promise<boolean[]>;\n  /**\n   * Lists keys from the record manager.\n   * @param before List keys before this timestamp\n   * @param after List keys after this timestamp\n   * @param groupIds List keys with these groupIds\n   * @param limit Limit the number of keys returned\n   * @returns List of keys\n   *\n   */\n  listKeys(options: ListKeyOptions): Promise<string[]>;\n  /**\n   * Deletes keys from the record manager.\n   * @param keys List of keys to delete\n   */\n  deleteKeys(keys: string[]): Promise<void>;\n}\n\nexport abstract class RecordManager\n  extends Serializable\n  implements RecordManagerInterface\n{\n  lc_namespace = [\"langchain\", \"recordmanagers\"];\n\n  abstract createSchema(): Promise<void>;\n\n  abstract getTime(): Promise<number>;\n\n  abstract update(keys: string[], updateOptions?: UpdateOptions): Promise<void>;\n\n  abstract exists(keys: string[]): Promise<boolean[]>;\n\n  abstract listKeys(options?: ListKeyOptions): Promise<string[]>;\n\n  abstract deleteKeys(keys: string[]): Promise<void>;\n}\n", "import { v5 as uuidv5 } from \"uuid\";\nimport { VectorStore } from \"../vectorstores.js\";\nimport { RecordManagerInterface, UUIDV5_NAMESPACE } from \"./record_manager.js\";\nimport { sha256, type HashKeyEncoder } from \"../utils/hash.js\";\nimport { DocumentInterface, Document } from \"../documents/document.js\";\nimport { BaseDocumentLoader } from \"../document_loaders/base.js\";\n\ntype Metadata = Record<string, unknown>;\n\ntype IndexingResult = {\n  numAdded: number;\n  numDeleted: number;\n  numUpdated: number;\n  numSkipped: number;\n};\n\ntype StringOrDocFunc = string | ((doc: DocumentInterface) => string);\n\nexport interface HashedDocumentInterface extends DocumentInterface {\n  uid: string;\n  hash_?: string;\n  contentHash?: string;\n  metadataHash?: string;\n  pageContent: string;\n  metadata: Metadata;\n  calculateHashes(): void;\n  toDocument(): DocumentInterface;\n}\n\ninterface HashedDocumentArgs {\n  pageContent: string;\n  metadata: Metadata;\n  uid: string;\n}\n\n/**\n * HashedDocument is a Document with hashes calculated.\n * Hashes are calculated based on page content and metadata.\n * It is used for indexing.\n */\nexport class _HashedDocument implements HashedDocumentInterface {\n  uid: string;\n\n  hash_?: string;\n\n  contentHash?: string;\n\n  metadataHash?: string;\n\n  pageContent: string;\n\n  metadata: Metadata;\n\n  private keyEncoder: HashKeyEncoder = sha256;\n\n  constructor(fields: HashedDocumentArgs) {\n    this.uid = fields.uid;\n    this.pageContent = fields.pageContent;\n    this.metadata = fields.metadata;\n  }\n\n  makeDefaultKeyEncoder(keyEncoderFn: HashKeyEncoder): void {\n    this.keyEncoder = keyEncoderFn;\n  }\n\n  calculateHashes(): void {\n    const forbiddenKeys = [\"hash_\", \"content_hash\", \"metadata_hash\"];\n\n    for (const key of forbiddenKeys) {\n      if (key in this.metadata) {\n        throw new Error(\n          `Metadata cannot contain key ${key} as it is reserved for internal use. Restricted keys: [${forbiddenKeys.join(\n            \", \"\n          )}]`\n        );\n      }\n    }\n\n    const contentHash = this._hashStringToUUID(this.pageContent);\n\n    try {\n      const metadataHash = this._hashNestedDictToUUID(this.metadata);\n      this.contentHash = contentHash;\n      this.metadataHash = metadataHash;\n    } catch (e) {\n      throw new Error(\n        `Failed to hash metadata: ${e}. Please use a dict that can be serialized using json.`\n      );\n    }\n\n    this.hash_ = this._hashStringToUUID(this.contentHash + this.metadataHash);\n\n    if (!this.uid) {\n      this.uid = this.hash_;\n    }\n  }\n\n  toDocument(): DocumentInterface {\n    return new Document({\n      pageContent: this.pageContent,\n      metadata: this.metadata,\n    });\n  }\n\n  static fromDocument(\n    document: DocumentInterface,\n    uid?: string\n  ): _HashedDocument {\n    const doc = new this({\n      pageContent: document.pageContent,\n      metadata: document.metadata,\n      uid: uid || (document as DocumentInterface & { uid: string }).uid,\n    });\n    doc.calculateHashes();\n    return doc;\n  }\n\n  private _hashStringToUUID(inputString: string): string {\n    const hash_value = this.keyEncoder(inputString);\n    return uuidv5(hash_value, UUIDV5_NAMESPACE);\n  }\n\n  private _hashNestedDictToUUID(data: Record<string, unknown>): string {\n    const serialized_data = JSON.stringify(data, Object.keys(data).sort());\n    const hash_value = this.keyEncoder(serialized_data);\n    return uuidv5(hash_value, UUIDV5_NAMESPACE);\n  }\n}\n\nexport type CleanupMode = \"full\" | \"incremental\";\n\nexport type IndexOptions = {\n  /**\n   * The number of documents to index in one batch.\n   */\n  batchSize?: number;\n  /**\n   * The cleanup mode to use. Can be \"full\", \"incremental\" or undefined.\n   * - **Incremental**: Cleans up all documents that haven't been updated AND\n   *   that are associated with source ids that were seen\n   *   during indexing.\n   *   Clean up is done continuously during indexing helping\n   *   to minimize the probability of users seeing duplicated\n   *   content.\n   * - **Full**: Delete all documents that haven to been returned by the loader.\n   *   Clean up runs after all documents have been indexed.\n   *   This means that users may see duplicated content during indexing.\n   * - **undefined**: Do not delete any documents.\n   */\n  cleanup?: CleanupMode;\n  /**\n   * Optional key that helps identify the original source of the document.\n   * Must either be a string representing the key of the source in the metadata\n   * or a function that takes a document and returns a string representing the source.\n   * **Required when cleanup is incremental**.\n   */\n  sourceIdKey?: StringOrDocFunc;\n  /**\n   * Batch size to use when cleaning up documents.\n   */\n  cleanupBatchSize?: number;\n  /**\n   * Force update documents even if they are present in the\n   * record manager. Useful if you are re-indexing with updated embeddings.\n   */\n  forceUpdate?: boolean;\n};\n\nexport function _batch<T>(size: number, iterable: T[]): T[][] {\n  const batches: T[][] = [];\n  let currentBatch: T[] = [];\n\n  iterable.forEach((item) => {\n    currentBatch.push(item);\n\n    if (currentBatch.length >= size) {\n      batches.push(currentBatch);\n      currentBatch = [];\n    }\n  });\n\n  if (currentBatch.length > 0) {\n    batches.push(currentBatch);\n  }\n\n  return batches;\n}\n\nexport function _deduplicateInOrder(\n  hashedDocuments: HashedDocumentInterface[]\n): HashedDocumentInterface[] {\n  const seen = new Set<string>();\n  const deduplicated: HashedDocumentInterface[] = [];\n\n  for (const hashedDoc of hashedDocuments) {\n    if (!hashedDoc.hash_) {\n      throw new Error(\"Hashed document does not have a hash\");\n    }\n\n    if (!seen.has(hashedDoc.hash_)) {\n      seen.add(hashedDoc.hash_);\n      deduplicated.push(hashedDoc);\n    }\n  }\n  return deduplicated;\n}\n\nexport function _getSourceIdAssigner(\n  sourceIdKey: StringOrDocFunc | null\n): (doc: DocumentInterface) => string | null {\n  if (sourceIdKey === null) {\n    return (_doc: DocumentInterface) => null;\n  } else if (typeof sourceIdKey === \"string\") {\n    return (doc: DocumentInterface) => doc.metadata[sourceIdKey];\n  } else if (typeof sourceIdKey === \"function\") {\n    return sourceIdKey;\n  } else {\n    throw new Error(\n      `sourceIdKey should be null, a string or a function, got ${typeof sourceIdKey}`\n    );\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const _isBaseDocumentLoader = (arg: any): arg is BaseDocumentLoader => {\n  if (\n    \"load\" in arg &&\n    typeof arg.load === \"function\" &&\n    \"loadAndSplit\" in arg &&\n    typeof arg.loadAndSplit === \"function\"\n  ) {\n    return true;\n  }\n  return false;\n};\n\ninterface IndexArgs {\n  docsSource: BaseDocumentLoader | DocumentInterface[];\n  recordManager: RecordManagerInterface;\n  vectorStore: VectorStore;\n  options?: IndexOptions;\n}\n\n/**\n * Index data from the doc source into the vector store.\n *\n * Indexing functionality uses a manager to keep track of which documents\n * are in the vector store.\n *\n * This allows us to keep track of which documents were updated, and which\n * documents were deleted, which documents should be skipped.\n *\n * For the time being, documents are indexed using their hashes, and users\n *  are not able to specify the uid of the document.\n *\n * @param {IndexArgs} args\n * @param {BaseDocumentLoader | DocumentInterface[]} args.docsSource The source of documents to index. Can be a DocumentLoader or a list of Documents.\n * @param {RecordManagerInterface} args.recordManager The record manager to use for keeping track of indexed documents.\n * @param {VectorStore} args.vectorStore The vector store to use for storing the documents.\n * @param {IndexOptions | undefined} args.options Options for indexing.\n * @returns {Promise<IndexingResult>}\n */\nexport async function index(args: IndexArgs): Promise<IndexingResult> {\n  const { docsSource, recordManager, vectorStore, options } = args;\n  const {\n    batchSize = 100,\n    cleanup,\n    sourceIdKey,\n    cleanupBatchSize = 1000,\n    forceUpdate = false,\n  } = options ?? {};\n\n  if (cleanup === \"incremental\" && !sourceIdKey) {\n    throw new Error(\n      \"sourceIdKey is required when cleanup mode is incremental. Please provide through 'options.sourceIdKey'.\"\n    );\n  }\n\n  const docs = _isBaseDocumentLoader(docsSource)\n    ? await docsSource.load()\n    : docsSource;\n\n  const sourceIdAssigner = _getSourceIdAssigner(sourceIdKey ?? null);\n\n  const indexStartDt = await recordManager.getTime();\n  let numAdded = 0;\n  let numDeleted = 0;\n  let numUpdated = 0;\n  let numSkipped = 0;\n\n  const batches = _batch<DocumentInterface>(batchSize ?? 100, docs);\n\n  for (const batch of batches) {\n    const hashedDocs = _deduplicateInOrder(\n      batch.map((doc) => _HashedDocument.fromDocument(doc))\n    );\n\n    const sourceIds = hashedDocs.map((doc) => sourceIdAssigner(doc));\n\n    if (cleanup === \"incremental\") {\n      hashedDocs.forEach((_hashedDoc, index) => {\n        const source = sourceIds[index];\n        if (source === null) {\n          throw new Error(\n            \"sourceIdKey must be provided when cleanup is incremental\"\n          );\n        }\n      });\n    }\n\n    const batchExists = await recordManager.exists(\n      hashedDocs.map((doc) => doc.uid)\n    );\n\n    const uids: string[] = [];\n    const docsToIndex: DocumentInterface[] = [];\n    const docsToUpdate: string[] = [];\n    const seenDocs = new Set<string>();\n    hashedDocs.forEach((hashedDoc, i) => {\n      const docExists = batchExists[i];\n      if (docExists) {\n        if (forceUpdate) {\n          seenDocs.add(hashedDoc.uid);\n        } else {\n          docsToUpdate.push(hashedDoc.uid);\n          return;\n        }\n      }\n      uids.push(hashedDoc.uid);\n      docsToIndex.push(hashedDoc.toDocument());\n    });\n\n    if (docsToUpdate.length > 0) {\n      await recordManager.update(docsToUpdate, { timeAtLeast: indexStartDt });\n      numSkipped += docsToUpdate.length;\n    }\n\n    if (docsToIndex.length > 0) {\n      await vectorStore.addDocuments(docsToIndex, { ids: uids });\n      numAdded += docsToIndex.length - seenDocs.size;\n      numUpdated += seenDocs.size;\n    }\n\n    await recordManager.update(\n      hashedDocs.map((doc) => doc.uid),\n      { timeAtLeast: indexStartDt, groupIds: sourceIds }\n    );\n\n    if (cleanup === \"incremental\") {\n      sourceIds.forEach((sourceId) => {\n        if (!sourceId) throw new Error(\"Source id cannot be null\");\n      });\n      const uidsToDelete = await recordManager.listKeys({\n        before: indexStartDt,\n        groupIds: sourceIds,\n      });\n\n      if (uidsToDelete.length > 0) {\n        await vectorStore.delete({ ids: uidsToDelete });\n        await recordManager.deleteKeys(uidsToDelete);\n        numDeleted += uidsToDelete.length;\n      }\n    }\n  }\n\n  if (cleanup === \"full\") {\n    let uidsToDelete = await recordManager.listKeys({\n      before: indexStartDt,\n      limit: cleanupBatchSize,\n    });\n    while (uidsToDelete.length > 0) {\n      await vectorStore.delete({ ids: uidsToDelete });\n      await recordManager.deleteKeys(uidsToDelete);\n      numDeleted += uidsToDelete.length;\n      uidsToDelete = await recordManager.listKeys({\n        before: indexStartDt,\n        limit: cleanupBatchSize,\n      });\n    }\n  }\n\n  return {\n    numAdded,\n    numDeleted,\n    numUpdated,\n    numSkipped,\n  };\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { RecordManager, UUIDV5_NAMESPACE } from \"./record_manager.js\";\nimport { _HashedDocument, _batch, _deduplicateInOrder, _getSourceIdAssigner, _isBaseDocumentLoader, index } from \"./base.js\";\n\n//#region src/indexing/index.ts\nvar indexing_exports = {};\n__export(indexing_exports, {\n\tRecordManager: () => RecordManager,\n\tUUIDV5_NAMESPACE: () => UUIDV5_NAMESPACE,\n\t_HashedDocument: () => _HashedDocument,\n\t_batch: () => _batch,\n\t_deduplicateInOrder: () => _deduplicateInOrder,\n\t_getSourceIdAssigner: () => _getSourceIdAssigner,\n\t_isBaseDocumentLoader: () => _isBaseDocumentLoader,\n\tindex: () => index\n});\n\n//#endregion\nexport { RecordManager, UUIDV5_NAMESPACE, _HashedDocument, _batch, _deduplicateInOrder, _getSourceIdAssigner, _isBaseDocumentLoader, index, indexing_exports };\n//# sourceMappingURL=index.js.map", "import type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport {\n  type LLMResult,\n  RUN_KEY,\n  type Generation,\n  GenerationChunk,\n} from \"../outputs.js\";\nimport {\n  type BaseCallbackConfig,\n  CallbackManager,\n  type CallbackManagerForLLMRun,\n  type Callbacks,\n} from \"../callbacks/manager.js\";\nimport {\n  BaseLanguageModel,\n  type BaseLanguageModelCallOptions,\n  type BaseLanguageModelInput,\n  type BaseLanguageModelParams,\n} from \"./base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BaseCache } from \"../caches/index.js\";\nimport { concat } from \"../utils/stream.js\";\nimport { callbackHandlerPrefersStreaming } from \"../callbacks/base.js\";\n\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport interface BaseLLMParams extends BaseLanguageModelParams {}\n\nexport interface BaseLLMCallOptions extends BaseLanguageModelCallOptions {}\n\n/**\n * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n */\nexport abstract class BaseLLM<\n  CallOptions extends BaseLLMCallOptions = BaseLLMCallOptions,\n> extends BaseLanguageModel<string, CallOptions> {\n  // Backwards compatibility since fields have been moved to RunnableConfig\n  declare ParsedCallOptions: Omit<\n    CallOptions,\n    Exclude<keyof RunnableConfig, \"signal\" | \"timeout\" | \"maxConcurrency\">\n  >;\n\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"llms\", this._llmType()];\n\n  /**\n   * This method takes an input and options, and returns a string. It\n   * converts the input to a prompt value and generates a result based on\n   * the prompt.\n   * @param input Input for the LLM.\n   * @param options Options for the LLM call.\n   * @returns A string result based on the prompt.\n   */\n  async invoke(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): Promise<string> {\n    const promptValue = BaseLLM._convertInputToPromptValue(input);\n    const result = await this.generatePrompt(\n      [promptValue],\n      options,\n      options?.callbacks\n    );\n    return result.generations[0][0].text;\n  }\n\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(\n    _input: string,\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<GenerationChunk> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  protected _separateRunnableConfigFromCallOptionsCompat(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, this[\"ParsedCallOptions\"]] {\n    // For backwards compat, keep `signal` in both runnableConfig and callOptions\n    const [runnableConfig, callOptions] =\n      super._separateRunnableConfigFromCallOptions(options);\n    (callOptions as this[\"ParsedCallOptions\"]).signal = runnableConfig.signal;\n    return [runnableConfig, callOptions as this[\"ParsedCallOptions\"]];\n  }\n\n  async *_streamIterator(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): AsyncGenerator<string> {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (\n      this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks\n    ) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseLLM._convertInputToPromptValue(input);\n      const [runnableConfig, callOptions] =\n        this._separateRunnableConfigFromCallOptionsCompat(options);\n      const callbackManager_ = await CallbackManager.configure(\n        runnableConfig.callbacks,\n        this.callbacks,\n        runnableConfig.tags,\n        this.tags,\n        runnableConfig.metadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1,\n      };\n      const runManagers = await callbackManager_?.handleLLMStart(\n        this.toJSON(),\n        [prompt.toString()],\n        runnableConfig.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        runnableConfig.runName\n      );\n      let generation = new GenerationChunk({\n        text: \"\",\n      });\n      try {\n        for await (const chunk of this._streamResponseChunks(\n          prompt.toString(),\n          callOptions,\n          runManagers?.[0]\n        )) {\n          if (!generation) {\n            generation = chunk;\n          } else {\n            generation = generation.concat(chunk);\n          }\n          if (typeof chunk.text === \"string\") {\n            yield chunk.text;\n          }\n        }\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n      await Promise.all(\n        (runManagers ?? []).map((runManager) =>\n          runManager?.handleLLMEnd({\n            generations: [[generation]],\n          })\n        )\n      );\n    }\n  }\n\n  /**\n   * This method takes prompt values, options, and callbacks, and generates\n   * a result based on the prompts.\n   * @param promptValues Prompt values for the LLM.\n   * @param options Options for the LLM call.\n   * @param callbacks Callbacks for the LLM call.\n   * @returns An LLMResult based on the prompts.\n   */\n  async generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    const prompts: string[] = promptValues.map((promptValue) =>\n      promptValue.toString()\n    );\n    return this.generate(prompts, options, callbacks);\n  }\n\n  /**\n   * Run the LLM on the given prompts and input.\n   */\n  abstract _generate(\n    prompts: string[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<LLMResult>;\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options?: this[\"ParsedCallOptions\"]): any {\n    return {};\n  }\n\n  _flattenLLMResult(llmResult: LLMResult): LLMResult[] {\n    const llmResults: LLMResult[] = [];\n\n    for (let i = 0; i < llmResult.generations.length; i += 1) {\n      const genList = llmResult.generations[i];\n\n      if (i === 0) {\n        llmResults.push({\n          generations: [genList],\n          llmOutput: llmResult.llmOutput,\n        });\n      } else {\n        const llmOutput = llmResult.llmOutput\n          ? { ...llmResult.llmOutput, tokenUsage: {} }\n          : undefined;\n\n        llmResults.push({\n          generations: [genList],\n          llmOutput,\n        });\n      }\n    }\n\n    return llmResults;\n  }\n\n  /** @ignore */\n  async _generateUncached(\n    prompts: string[],\n    parsedOptions: this[\"ParsedCallOptions\"],\n    handledOptions: BaseCallbackConfig,\n    startedRunManagers?: CallbackManagerForLLMRun[]\n  ): Promise<LLMResult> {\n    let runManagers: CallbackManagerForLLMRun[] | undefined;\n    if (\n      startedRunManagers !== undefined &&\n      startedRunManagers.length === prompts.length\n    ) {\n      runManagers = startedRunManagers;\n    } else {\n      const callbackManager_ = await CallbackManager.configure(\n        handledOptions.callbacks,\n        this.callbacks,\n        handledOptions.tags,\n        this.tags,\n        handledOptions.metadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: parsedOptions,\n        invocation_params: this?.invocationParams(parsedOptions),\n        batch_size: prompts.length,\n      };\n      runManagers = await callbackManager_?.handleLLMStart(\n        this.toJSON(),\n        prompts,\n        handledOptions.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        handledOptions?.runName\n      );\n    }\n    // Even if stream is not explicitly called, check if model is implicitly\n    // called from streamEvents() or streamLog() to get all streamed events.\n    // Bail out if _streamResponseChunks not overridden\n    const hasStreamingHandler = !!runManagers?.[0].handlers.find(\n      callbackHandlerPrefersStreaming\n    );\n    let output: LLMResult;\n    if (\n      hasStreamingHandler &&\n      prompts.length === 1 &&\n      this._streamResponseChunks !== BaseLLM.prototype._streamResponseChunks\n    ) {\n      try {\n        const stream = await this._streamResponseChunks(\n          prompts[0],\n          parsedOptions,\n          runManagers?.[0]\n        );\n        let aggregated;\n        for await (const chunk of stream) {\n          if (aggregated === undefined) {\n            aggregated = chunk;\n          } else {\n            aggregated = concat(aggregated, chunk);\n          }\n        }\n        if (aggregated === undefined) {\n          throw new Error(\"Received empty response from chat model call.\");\n        }\n        output = { generations: [[aggregated]], llmOutput: {} };\n        await runManagers?.[0].handleLLMEnd(output);\n      } catch (e) {\n        await runManagers?.[0].handleLLMError(e);\n        throw e;\n      }\n    } else {\n      try {\n        output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n\n      const flattenedOutputs: LLMResult[] = this._flattenLLMResult(output);\n      await Promise.all(\n        (runManagers ?? []).map((runManager, i) =>\n          runManager?.handleLLMEnd(flattenedOutputs[i])\n        )\n      );\n    }\n    const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runIds ? { runIds } : undefined,\n      configurable: true,\n    });\n    return output;\n  }\n\n  async _generateCached({\n    prompts,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions,\n    runId,\n  }: {\n    prompts: string[];\n    cache: BaseCache<Generation[]>;\n    llmStringKey: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parsedOptions: any;\n    handledOptions: RunnableConfig;\n    runId?: string;\n  }): Promise<\n    LLMResult & {\n      missingPromptIndices: number[];\n      startedRunManagers?: CallbackManagerForLLMRun[];\n    }\n  > {\n    const callbackManager_ = await CallbackManager.configure(\n      handledOptions.callbacks,\n      this.callbacks,\n      handledOptions.tags,\n      this.tags,\n      handledOptions.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: prompts.length,\n    };\n    const runManagers = await callbackManager_?.handleLLMStart(\n      this.toJSON(),\n      prompts,\n      runId,\n      undefined,\n      extra,\n      undefined,\n      undefined,\n      handledOptions?.runName\n    );\n\n    // generate results\n    const missingPromptIndices: number[] = [];\n    const results = await Promise.allSettled(\n      prompts.map(async (prompt, index) => {\n        const result = await cache.lookup(prompt, llmStringKey);\n        if (result == null) {\n          missingPromptIndices.push(index);\n        }\n        return result;\n      })\n    );\n\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results\n      .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n      .filter(\n        ({ result }) =>\n          (result.status === \"fulfilled\" && result.value != null) ||\n          result.status === \"rejected\"\n      );\n\n    // Handle results and call run managers\n    const generations: Generation[][] = [];\n    await Promise.all(\n      cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n        if (promiseResult.status === \"fulfilled\") {\n          const result = promiseResult.value as Generation[];\n          generations[i] = result.map((result) => {\n            result.generationInfo = {\n              ...result.generationInfo,\n              tokenUsage: {},\n            };\n            return result;\n          });\n          if (result.length) {\n            await runManager?.handleLLMNewToken(result[0].text);\n          }\n          return runManager?.handleLLMEnd(\n            {\n              generations: [result],\n            },\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n        } else {\n          // status === \"rejected\"\n          await runManager?.handleLLMError(\n            promiseResult.reason,\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n          return Promise.reject(promiseResult.reason);\n        }\n      })\n    );\n\n    const output = {\n      generations,\n      missingPromptIndices,\n      startedRunManagers: runManagers,\n    };\n\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n\n    return output;\n  }\n\n  /**\n   * Run the LLM on the given prompts and input, handling caching.\n   */\n  async generate(\n    prompts: string[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    if (!Array.isArray(prompts)) {\n      throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n    }\n\n    let parsedOptions: CallOptions | undefined;\n    if (Array.isArray(options)) {\n      parsedOptions = { stop: options } as CallOptions;\n    } else {\n      parsedOptions = options;\n    }\n\n    const [runnableConfig, callOptions] =\n      this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n\n    if (!this.cache) {\n      return this._generateUncached(prompts, callOptions, runnableConfig);\n    }\n\n    const { cache } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(\n      callOptions as CallOptions\n    );\n    const { generations, missingPromptIndices, startedRunManagers } =\n      await this._generateCached({\n        prompts,\n        cache,\n        llmStringKey,\n        parsedOptions: callOptions,\n        handledOptions: runnableConfig,\n        runId: runnableConfig.runId,\n      });\n\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(\n        missingPromptIndices.map((i) => prompts[i]),\n        callOptions,\n        runnableConfig,\n        startedRunManagers !== undefined\n          ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n          : undefined\n      );\n      await Promise.all(\n        results.generations.map(async (generation, index) => {\n          const promptIndex = missingPromptIndices[index];\n          generations[promptIndex] = generation;\n          return cache.update(prompts[promptIndex], llmStringKey, generation);\n        })\n      );\n      llmOutput = results.llmOutput ?? {};\n    }\n\n    return { generations, llmOutput } as LLMResult;\n  }\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any> {\n    return {};\n  }\n\n  /**\n   * Return the string type key uniquely identifying this class of LLM.\n   */\n  abstract _llmType(): string;\n\n  _modelType(): string {\n    return \"base_llm\" as const;\n  }\n}\n\n/**\n * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n *\n * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n *\n * @augments BaseLLM\n */\nexport abstract class LLM<\n  CallOptions extends BaseLLMCallOptions = BaseLLMCallOptions,\n> extends BaseLLM<CallOptions> {\n  /**\n   * Run the LLM on the given prompt and input.\n   */\n  abstract _call(\n    prompt: string,\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string>;\n\n  async _generate(\n    prompts: string[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<LLMResult> {\n    const generations: Generation[][] = await Promise.all(\n      prompts.map((prompt, promptIndex) =>\n        this._call(prompt, { ...options, promptIndex }, runManager).then(\n          (text) => [{ text }]\n        )\n      )\n    );\n    return { generations };\n  }\n}\n", "//#region src/language_models/profile.ts\nvar profile_exports = {};\n\n//#endregion\nexport { profile_exports };\n//# sourceMappingURL=profile.js.map", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { applyPatch } from \"./fast-json-patch/src/core.js\";\nimport { compare } from \"./fast-json-patch/src/duplex.js\";\nimport \"./fast-json-patch/index.js\";\n\n//#region src/utils/json_patch.ts\nvar json_patch_exports = {};\n__export(json_patch_exports, {\n\tapplyPatch: () => applyPatch,\n\tcompare: () => compare\n});\n\n//#endregion\nexport { applyPatch, compare, json_patch_exports };\n//# sourceMappingURL=json_patch.js.map", "import { Runnable } from \"../runnables/index.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport type { BaseMessage, ContentBlock } from \"../messages/index.js\";\nimport type { Callbacks } from \"../callbacks/manager.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n\n/**\n * Options for formatting instructions.\n */\nexport interface FormatInstructionsOptions {}\n\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport abstract class BaseLLMOutputParser<T = unknown> extends Runnable<\n  string | BaseMessage,\n  T\n> {\n  /**\n   * Parses the result of an LLM call. This method is meant to be\n   * implemented by subclasses to define how the output from the LLM should\n   * be parsed.\n   * @param generations The generations from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  abstract parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T>;\n\n  /**\n   * Parses the result of an LLM call with a given prompt. By default, it\n   * simply calls `parseResult`.\n   * @param generations The generations from an LLM call.\n   * @param _prompt The prompt used in the LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parseResultWithPrompt(\n    generations: Generation[] | ChatGeneration[],\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parseResult(generations, callbacks);\n  }\n\n  protected _baseMessageToString(message: BaseMessage): string {\n    return typeof message.content === \"string\"\n      ? message.content\n      : this._baseMessageContentToString(message.content);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return JSON.stringify(content);\n  }\n\n  /**\n   * Calls the parser with a given input and optional configuration options.\n   * If the input is a string, it creates a generation with the input as\n   * text and calls `parseResult`. If the input is a `BaseMessage`, it\n   * creates a generation with the input as a message and the content of the\n   * input as text, and then calls `parseResult`.\n   * @param input The input to the parser, which can be a string or a `BaseMessage`.\n   * @param options Optional configuration options.\n   * @returns A promise of the parsed output.\n   */\n  async invoke(\n    input: string | BaseMessage,\n    options?: RunnableConfig\n  ): Promise<T> {\n    if (typeof input === \"string\") {\n      return this._callWithConfig(\n        async (input: string, options): Promise<T> =>\n          this.parseResult([{ text: input }], options?.callbacks),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    } else {\n      return this._callWithConfig(\n        async (input: BaseMessage, options): Promise<T> =>\n          this.parseResult(\n            [\n              {\n                message: input,\n                text: this._baseMessageToString(input),\n              },\n            ],\n            options?.callbacks\n          ),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call.\n */\nexport abstract class BaseOutputParser<\n  T = unknown,\n> extends BaseLLMOutputParser<T> {\n  parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(generations[0].text, callbacks);\n  }\n\n  /**\n   * Parse the output of an LLM call.\n   *\n   * @param text - LLM output to parse.\n   * @returns Parsed output.\n   */\n  abstract parse(text: string, callbacks?: Callbacks): Promise<T>;\n\n  async parseWithPrompt(\n    text: string,\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(text, callbacks);\n  }\n\n  /**\n   * Return a string describing the format of the output.\n   * @returns Format instructions.\n   * @param options - Options for formatting instructions.\n   * @example\n   * ```json\n   * {\n   *  \"foo\": \"bar\"\n   * }\n   * ```\n   */\n  abstract getFormatInstructions(options?: FormatInstructionsOptions): string;\n\n  /**\n   * Return the string type key uniquely identifying this class of parser\n   */\n  _type(): string {\n    throw new Error(\"_type not implemented\");\n  }\n}\n\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nexport class OutputParserException extends Error {\n  llmOutput?: string;\n\n  observation?: string;\n\n  sendToLLM: boolean;\n\n  constructor(\n    message: string,\n    llmOutput?: string,\n    observation?: string,\n    sendToLLM = false\n  ) {\n    super(message);\n    this.llmOutput = llmOutput;\n    this.observation = observation;\n    this.sendToLLM = sendToLLM;\n\n    if (sendToLLM) {\n      if (observation === undefined || llmOutput === undefined) {\n        throw new Error(\n          \"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\"\n        );\n      }\n    }\n\n    addLangChainErrorFields(this, \"OUTPUT_PARSING_FAILURE\");\n  }\n}\n", "import { deepCompareStrict } from \"@cfworker/json-schema\";\nimport { BaseOutputParser } from \"./base.js\";\nimport {\n  type BaseMessage,\n  isBaseMessage,\n  isBaseMessageChunk,\n} from \"../messages/base.js\";\nimport { convertToChunk } from \"../messages/utils.js\";\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  type Generation,\n  type ChatGeneration,\n  GenerationChunk,\n  ChatGenerationChunk,\n} from \"../outputs.js\";\n\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport abstract class BaseTransformOutputParser<\n  T = unknown,\n> extends BaseOutputParser<T> {\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{ text: chunk }]);\n      } else {\n        yield this.parseResult([\n          {\n            message: chunk,\n            text: this._baseMessageToString(chunk),\n          },\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>,\n    options: BaseCallbackConfig\n  ): AsyncGenerator<T> {\n    yield* this._transformStreamWithConfig(\n      inputGenerator,\n      this._transform.bind(this),\n      {\n        ...options,\n        runType: \"parser\",\n      }\n    );\n  }\n}\n\nexport type BaseCumulativeTransformOutputParserInput = { diff?: boolean };\n\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport abstract class BaseCumulativeTransformOutputParser<\n  T = unknown,\n> extends BaseTransformOutputParser<T> {\n  protected diff = false;\n\n  constructor(fields?: BaseCumulativeTransformOutputParserInput) {\n    super(fields);\n    this.diff = fields?.diff ?? this.diff;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected abstract _diff(prev: any | undefined, next: any): any;\n\n  abstract parsePartialResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<T | undefined>;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    let prevParsed: T | undefined;\n    let accGen: GenerationChunk | undefined;\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n        throw new Error(\"Cannot handle non-string output.\");\n      }\n      let chunkGen: GenerationChunk;\n      if (isBaseMessageChunk(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk,\n          text: chunk.content,\n        });\n      } else if (isBaseMessage(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: convertToChunk(chunk),\n          text: chunk.content,\n        });\n      } else {\n        chunkGen = new GenerationChunk({ text: chunk });\n      }\n\n      if (accGen === undefined) {\n        accGen = chunkGen;\n      } else {\n        accGen = accGen.concat(chunkGen);\n      }\n\n      const parsed = await this.parsePartialResult([accGen]);\n      if (\n        parsed !== undefined &&\n        parsed !== null &&\n        !deepCompareStrict(parsed, prevParsed)\n      ) {\n        if (this.diff) {\n          yield this._diff(prevParsed, parsed);\n        } else {\n          yield parsed;\n        }\n        prevParsed = parsed;\n      }\n    }\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n", "import { BaseTransformOutputParser } from \"./transform.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nexport class BytesOutputParser extends BaseTransformOutputParser<Uint8Array> {\n  static lc_name() {\n    return \"BytesOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"bytes\"];\n\n  lc_serializable = true;\n\n  protected textEncoder: InstanceType<typeof TextEncoder> = new TextEncoder();\n\n  parse(text: string): Promise<Uint8Array> {\n    return Promise.resolve(this.textEncoder.encode(text));\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n", "import { BaseMessage } from \"../messages/index.js\";\nimport { OutputParserException } from \"./base.js\";\nimport { BaseTransformOutputParser } from \"./transform.js\";\n\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nexport abstract class ListOutputParser extends BaseTransformOutputParser<\n  string[]\n> {\n  re?: RegExp;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<string[]> {\n    let buffer = \"\";\n    for await (const input of inputGenerator) {\n      if (typeof input === \"string\") {\n        // add current chunk to buffer\n        buffer += input;\n      } else {\n        // extract message content and add to buffer\n        buffer += input.content;\n      }\n      // get parts in buffer\n      if (!this.re) {\n        const parts = await this.parse(buffer);\n        if (parts.length > 1) {\n          // if there are multiple parts, yield all but the last one\n          for (const part of parts.slice(0, -1)) {\n            yield [part];\n          }\n          // keep the last part in the buffer\n          buffer = parts[parts.length - 1];\n        }\n      } else {\n        // if there is a regex, get all matches\n        const matches = [...buffer.matchAll(this.re)];\n        if (matches.length > 1) {\n          let doneIdx = 0;\n          // if there are multiple matches, yield all but the last one\n          for (const match of matches.slice(0, -1)) {\n            yield [match[1]];\n            doneIdx += (match.index ?? 0) + match[0].length;\n          }\n          // keep the last match in the buffer\n          buffer = buffer.slice(doneIdx);\n        }\n      }\n    }\n\n    // yield the last part\n    for (const part of await this.parse(buffer)) {\n      yield [part];\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nexport class CommaSeparatedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"CommaSeparatedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses the given text into an array of strings, using a comma as the\n   * separator. If the parsing fails, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each comma.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      return text\n        .trim()\n        .split(\",\")\n        .map((s) => s.trim());\n    } catch {\n      throw new OutputParserException(`Could not parse output: ${text}`, text);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CommaSeparatedListOutputParser.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n  }\n}\n\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nexport class CustomListOutputParser extends ListOutputParser {\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  private length: number | undefined;\n\n  private separator: string;\n\n  constructor({ length, separator }: { length?: number; separator?: string }) {\n    super(...arguments);\n    this.length = length;\n    this.separator = separator || \",\";\n  }\n\n  /**\n   * Parses the given text into an array of strings, using the specified\n   * separator. If the parsing fails or the number of items in the list\n   * doesn't match the expected length, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      const items = text\n        .trim()\n        .split(this.separator)\n        .map((s) => s.trim());\n      if (this.length !== undefined && items.length !== this.length) {\n        throw new OutputParserException(\n          `Incorrect number of items. Expected ${this.length}, got ${items.length}.`\n        );\n      }\n      return items;\n    } catch (e) {\n      if (Object.getPrototypeOf(e) === OutputParserException.prototype) {\n        throw e;\n      }\n      throw new OutputParserException(`Could not parse output: ${text}`);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CustomListOutputParser, including the number of items and the\n   * separator.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of ${\n      this.length === undefined ? \"\" : `${this.length} `\n    }items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${\n      this.separator\n    } baz\\`)`;\n  }\n}\n\nexport class NumberedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /\\d+\\.\\s([^\\n]+)/g;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n\nexport class MarkdownListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /^\\s*[-*]\\s([^\\n]+)$/gm;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n", "import { BaseTransformOutputParser } from \"./transform.js\";\nimport { ContentBlock } from \"../messages/index.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nexport class StringOutputParser extends BaseTransformOutputParser<string> {\n  static lc_name() {\n    return \"StrOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"string\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses a string output from an LLM call. This method is meant to be\n   * implemented by subclasses to define how a string output from an LLM\n   * should be parsed.\n   * @param text The string output from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parse(text: string): Promise<string> {\n    return Promise.resolve(text);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n\n  protected _textContentToString(content: ContentBlock.Text): string {\n    return content.text;\n  }\n\n  protected _imageUrlContentToString(\n    _content: ContentBlock.Data.URLContentBlock\n  ): string {\n    throw new Error(\n      `Cannot coerce a multimodal \"image_url\" message part into a string.`\n    );\n  }\n\n  protected _messageContentToString(content: ContentBlock): string {\n    switch (content.type) {\n      case \"text\":\n      case \"text_delta\":\n        if (\"text\" in content) {\n          // Type guard for MessageContentText\n          return this._textContentToString(content as ContentBlock.Text);\n        }\n        break;\n      case \"image_url\":\n        if (\"image_url\" in content) {\n          // Type guard for MessageContentImageUrl\n          return this._imageUrlContentToString(\n            content as ContentBlock.Data.URLContentBlock\n          );\n        }\n        break;\n      default:\n        throw new Error(\n          `Cannot coerce \"${content.type}\" message part into a string.`\n        );\n    }\n    throw new Error(`Invalid content type: ${content.type}`);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return content.reduce(\n      (acc: string, item: ContentBlock) =>\n        acc + this._messageContentToString(item),\n      \"\"\n    );\n  }\n}\n", "import { z } from \"zod/v3\";\nimport {\n  BaseOutputParser,\n  FormatInstructionsOptions,\n  OutputParserException,\n} from \"./base.js\";\nimport {\n  type InteropZodType,\n  type InferInteropZodOutput,\n  interopParseAsync,\n} from \"../utils/types/zod.js\";\nimport {\n  toJsonSchema,\n  type JsonSchema7Type,\n  type JsonSchema7ArrayType,\n  type JsonSchema7ObjectType,\n  type JsonSchema7StringType,\n  type JsonSchema7NumberType,\n  type JsonSchema7NullableType,\n} from \"../utils/json_schema.js\";\n\nexport type JsonMarkdownStructuredOutputParserInput = {\n  interpolationDepth?: number;\n};\n\nexport interface JsonMarkdownFormatInstructionsOptions\n  extends FormatInstructionsOptions {\n  interpolationDepth?: number;\n}\n\nexport class StructuredOutputParser<\n  T extends InteropZodType,\n> extends BaseOutputParser<InferInteropZodOutput<T>> {\n  static lc_name() {\n    return \"StructuredOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"structured\"];\n\n  toJSON() {\n    return this.toJSONNotImplemented();\n  }\n\n  constructor(public schema: T) {\n    super(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a Zod schema.\n   * @param schema The Zod schema which the output should match\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a set of names and\n   * descriptions.\n   * @param schemas An object where each key is a name and each value is a description\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this(zodSchema);\n  }\n\n  /**\n   * Returns a markdown code snippet with a JSON object formatted according\n   * to the schema.\n   * @param options Optional. The options for formatting the instructions\n   * @returns A markdown code snippet with a JSON object formatted according to the schema.\n   */\n  getFormatInstructions(): string {\n    return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(toJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n  }\n\n  /**\n   * Parses the given text according to the schema.\n   * @param text The text to parse\n   * @returns The parsed output.\n   */\n  async parse(text: string): Promise<InferInteropZodOutput<T>> {\n    try {\n      const trimmedText = text.trim();\n\n      const json =\n        // first case: if back ticks appear at the start of the text\n        trimmedText.match(/^```(?:json)?\\s*([\\s\\S]*?)```/)?.[1] ||\n        // second case: if back ticks with `json` appear anywhere in the text\n        trimmedText.match(/```json\\s*([\\s\\S]*?)```/)?.[1] ||\n        // otherwise, return the trimmed text\n        trimmedText;\n\n      const escapedJson = json\n        .replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n          const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n          return `\"${escapedInsideQuotes}\"`;\n        })\n        .replace(/\\n/g, \"\");\n\n      return await interopParseAsync(this.schema, JSON.parse(escapedJson));\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n  }\n}\n\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser<\n  T extends InteropZodType,\n> extends StructuredOutputParser<T> {\n  static lc_name() {\n    return \"JsonMarkdownStructuredOutputParser\";\n  }\n\n  getFormatInstructions(\n    options?: JsonMarkdownFormatInstructionsOptions\n  ): string {\n    const interpolationDepth = options?.interpolationDepth ?? 1;\n    if (interpolationDepth < 1) {\n      throw new Error(\"f string interpolation depth must be at least 1\");\n    }\n\n    return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(\n      toJsonSchema(this.schema)\n    )\n      .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n      .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n  }\n\n  private _schemaToInstruction(\n    schemaInput: JsonSchema7Type,\n    indent = 2\n  ): string {\n    const schema = schemaInput as Extract<\n      JsonSchema7Type,\n      | JsonSchema7ObjectType\n      | JsonSchema7ArrayType\n      | JsonSchema7StringType\n      | JsonSchema7NumberType\n      | JsonSchema7NullableType\n    >;\n\n    if (\"type\" in schema) {\n      let nullable = false;\n      let type: string;\n      if (Array.isArray(schema.type)) {\n        const nullIdx = schema.type.findIndex((type) => type === \"null\");\n        if (nullIdx !== -1) {\n          nullable = true;\n          schema.type.splice(nullIdx, 1);\n        }\n        type = schema.type.join(\" | \") as string;\n      } else {\n        type = schema.type;\n      }\n\n      if (schema.type === \"object\" && schema.properties) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        const properties = Object.entries(schema.properties)\n          .map(([key, value]) => {\n            const isOptional = schema.required?.includes(key)\n              ? \"\"\n              : \" (optional)\";\n            return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(\n              value,\n              indent + 2\n            )}${isOptional}`;\n          })\n          .join(\"\\n\");\n        return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n      }\n      if (schema.type === \"array\" && schema.items) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(\n          schema.items,\n          indent + 2\n        )}\\n${\" \".repeat(indent - 2)}] ${description}`;\n      }\n      const isNullable = nullable ? \" (nullable)\" : \"\";\n      const description = schema.description ? ` // ${schema.description}` : \"\";\n      return `${type}${description}${isNullable}`;\n    }\n\n    if (\"anyOf\" in schema) {\n      return schema.anyOf\n        .map((s) => this._schemaToInstruction(s, indent))\n        .join(`\\n${\" \".repeat(indent - 2)}`);\n    }\n\n    throw new Error(\"unsupported schema type\");\n  }\n\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this<T>(schema);\n  }\n\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this<typeof zodSchema>(zodSchema);\n  }\n}\n\nexport interface AsymmetricStructuredOutputParserFields<\n  T extends InteropZodType,\n> {\n  inputSchema: T;\n}\n\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport abstract class AsymmetricStructuredOutputParser<\n  T extends InteropZodType,\n  Y = unknown,\n> extends BaseOutputParser<Y> {\n  private structuredInputParser: JsonMarkdownStructuredOutputParser<T>;\n\n  constructor({ inputSchema }: AsymmetricStructuredOutputParserFields<T>) {\n    super(...arguments);\n    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(\n      inputSchema\n    );\n  }\n\n  /**\n   * Processes the parsed input into the desired output format. Must be\n   * implemented by subclasses.\n   * @param input The parsed input\n   * @returns The processed output.\n   */\n  abstract outputProcessor(input: InferInteropZodOutput<T>): Promise<Y>;\n\n  async parse(text: string): Promise<Y> {\n    let parsedInput;\n    try {\n      parsedInput = await this.structuredInputParser.parse(text);\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n\n    return this.outputProcessor(parsedInput);\n  }\n\n  getFormatInstructions(): string {\n    return this.structuredInputParser.getFormatInstructions();\n  }\n}\n", "import { BaseCumulativeTransformOutputParser } from \"./transform.js\";\nimport { Operation, compare } from \"../utils/json_patch.js\";\nimport { ChatGeneration, Generation } from \"../outputs.js\";\nimport { parseJsonMarkdown, parsePartialJson } from \"../utils/json.js\";\nimport type { BaseMessage } from \"../messages/index.js\";\n\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nexport class JsonOutputParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  /** @internal */\n  override _concatOutputChunks<T>(first: T, second: T): T {\n    if (this.diff) {\n      return super._concatOutputChunks(first, second);\n    }\n    return second;\n  }\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): Operation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{ op: \"replace\", path: \"\", value: next }];\n    }\n    return compare(prev, next);\n  }\n\n  // This should actually return Partial<T>, but there's no way\n  // to specify emitted chunks as instances separate from the main output type.\n  async parsePartialResult(\n    generations: ChatGeneration[] | Generation[]\n  ): Promise<T | undefined> {\n    return parseJsonMarkdown(generations[0].text) as T | undefined;\n  }\n\n  async parse(text: string): Promise<T> {\n    return parseJsonMarkdown(text, JSON.parse) as T;\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n\n  /**\n   * Extracts text content from a message for JSON parsing.\n   * Uses the message's `.text` accessor which properly handles both\n   * string content and ContentBlock[] arrays (extracting text from text blocks).\n   * @param message The message to extract text from\n   * @returns The text content of the message\n   */\n  protected _baseMessageToString(message: BaseMessage): string {\n    return message.text;\n  }\n}\n\nexport { parsePartialJson, parseJsonMarkdown };\n", "// @ts-nocheck\n\n// Inlined to deal with portability issues\n// Originally from: https://github.com/isaacs/sax-js\n\nconst initializeSax = function () {\n  const sax: any = {};\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream;\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n\n  const buffers = [\n    \"comment\",\n    \"sgmlDecl\",\n    \"textNode\",\n    \"tagName\",\n    \"doctype\",\n    \"procInstName\",\n    \"procInstBody\",\n    \"entity\",\n    \"attribName\",\n    \"attribValue\",\n    \"cdata\",\n    \"script\",\n  ];\n\n  sax.EVENTS = [\n    \"text\",\n    \"processinginstruction\",\n    \"sgmldeclaration\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"opencdata\",\n    \"cdata\",\n    \"closecdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n    \"script\",\n    \"opennamespace\",\n    \"closenamespace\",\n  ];\n\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt);\n    }\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.strictEntities = parser.opt.strictEntities;\n    parser.ENTITIES = parser.strictEntities\n      ? Object.create(sax.XML_ENTITIES)\n      : Object.create(sax.ENTITIES);\n    parser.attribList = [];\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS);\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false;\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0;\n    }\n    emit(parser, \"onready\");\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F() {}\n      F.prototype = o;\n      var newf = new F();\n      return newf;\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n    var maxActual = 0;\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case \"textNode\":\n            closeText(parser);\n            break;\n\n          case \"cdata\":\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n            break;\n\n          case \"script\":\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n            break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n    parser.bufferCheckPosition = m + parser.position;\n  }\n\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = \"\";\n    }\n  }\n\n  function flushBuffers(parser) {\n    closeText(parser);\n    if (parser.cdata !== \"\") {\n      emitNode(parser, \"oncdata\", parser.cdata);\n      parser.cdata = \"\";\n    }\n    if (parser.script !== \"\") {\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () {\n      end(this);\n    },\n    write: write,\n    resume: function () {\n      this.error = null;\n      return this;\n    },\n    close: function () {\n      return this.write(null);\n    },\n    flush: function () {\n      flushBuffers(this);\n    },\n  };\n\n  var Stream = ReadableStream;\n  if (!Stream) Stream = function () {};\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== \"error\" && ev !== \"end\";\n  });\n\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt);\n    }\n\n    Stream.apply(this);\n\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n\n    var me = this;\n\n    this._parser.onend = function () {\n      me.emit(\"end\");\n    };\n\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null;\n    };\n\n    this._decoder = null;\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev, {\n        get: function () {\n          return me._parser[\"on\" + ev];\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            me._parser[\"on\" + ev] = h;\n            return h;\n          }\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false,\n      });\n    });\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream,\n    },\n  });\n\n  SAXStream.prototype.write = function (data) {\n    this._parser.write(data.toString());\n    this.emit(\"data\", data);\n    return true;\n  };\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk);\n    }\n    this._parser.end();\n    return true;\n  };\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\" + ev] = function () {\n        var args =\n          arguments.length === 1\n            ? [arguments[0]]\n            : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = \"[CDATA[\";\n  var DOCTYPE = \"DOCTYPE\";\n  var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n  var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n\n  var nameBody =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n  var entityStart =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var entityBody =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n  function isWhitespace(c) {\n    return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n  }\n\n  function isQuote(c) {\n    return c === '\"' || c === \"'\";\n  }\n\n  function isAttribEnd(c) {\n    return c === \">\" || isWhitespace(c);\n  }\n\n  function isMatch(regex, c) {\n    return regex.test(c);\n  }\n\n  function notMatch(regex, c) {\n    return !isMatch(regex, c);\n  }\n\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++, // <script> ... <\n  };\n\n  sax.XML_ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\",\n  };\n\n  sax.ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\",\n    AElig: 198,\n    Aacute: 193,\n    Acirc: 194,\n    Agrave: 192,\n    Aring: 197,\n    Atilde: 195,\n    Auml: 196,\n    Ccedil: 199,\n    ETH: 208,\n    Eacute: 201,\n    Ecirc: 202,\n    Egrave: 200,\n    Euml: 203,\n    Iacute: 205,\n    Icirc: 206,\n    Igrave: 204,\n    Iuml: 207,\n    Ntilde: 209,\n    Oacute: 211,\n    Ocirc: 212,\n    Ograve: 210,\n    Oslash: 216,\n    Otilde: 213,\n    Ouml: 214,\n    THORN: 222,\n    Uacute: 218,\n    Ucirc: 219,\n    Ugrave: 217,\n    Uuml: 220,\n    Yacute: 221,\n    aacute: 225,\n    acirc: 226,\n    aelig: 230,\n    agrave: 224,\n    aring: 229,\n    atilde: 227,\n    auml: 228,\n    ccedil: 231,\n    eacute: 233,\n    ecirc: 234,\n    egrave: 232,\n    eth: 240,\n    euml: 235,\n    iacute: 237,\n    icirc: 238,\n    igrave: 236,\n    iuml: 239,\n    ntilde: 241,\n    oacute: 243,\n    ocirc: 244,\n    ograve: 242,\n    oslash: 248,\n    otilde: 245,\n    ouml: 246,\n    szlig: 223,\n    thorn: 254,\n    uacute: 250,\n    ucirc: 251,\n    ugrave: 249,\n    uuml: 252,\n    yacute: 253,\n    yuml: 255,\n    copy: 169,\n    reg: 174,\n    nbsp: 160,\n    iexcl: 161,\n    cent: 162,\n    pound: 163,\n    curren: 164,\n    yen: 165,\n    brvbar: 166,\n    sect: 167,\n    uml: 168,\n    ordf: 170,\n    laquo: 171,\n    not: 172,\n    shy: 173,\n    macr: 175,\n    deg: 176,\n    plusmn: 177,\n    sup1: 185,\n    sup2: 178,\n    sup3: 179,\n    acute: 180,\n    micro: 181,\n    para: 182,\n    middot: 183,\n    cedil: 184,\n    ordm: 186,\n    raquo: 187,\n    frac14: 188,\n    frac12: 189,\n    frac34: 190,\n    iquest: 191,\n    times: 215,\n    divide: 247,\n    OElig: 338,\n    oelig: 339,\n    Scaron: 352,\n    scaron: 353,\n    Yuml: 376,\n    fnof: 402,\n    circ: 710,\n    tilde: 732,\n    Alpha: 913,\n    Beta: 914,\n    Gamma: 915,\n    Delta: 916,\n    Epsilon: 917,\n    Zeta: 918,\n    Eta: 919,\n    Theta: 920,\n    Iota: 921,\n    Kappa: 922,\n    Lambda: 923,\n    Mu: 924,\n    Nu: 925,\n    Xi: 926,\n    Omicron: 927,\n    Pi: 928,\n    Rho: 929,\n    Sigma: 931,\n    Tau: 932,\n    Upsilon: 933,\n    Phi: 934,\n    Chi: 935,\n    Psi: 936,\n    Omega: 937,\n    alpha: 945,\n    beta: 946,\n    gamma: 947,\n    delta: 948,\n    epsilon: 949,\n    zeta: 950,\n    eta: 951,\n    theta: 952,\n    iota: 953,\n    kappa: 954,\n    lambda: 955,\n    mu: 956,\n    nu: 957,\n    xi: 958,\n    omicron: 959,\n    pi: 960,\n    rho: 961,\n    sigmaf: 962,\n    sigma: 963,\n    tau: 964,\n    upsilon: 965,\n    phi: 966,\n    chi: 967,\n    psi: 968,\n    omega: 969,\n    thetasym: 977,\n    upsih: 978,\n    piv: 982,\n    ensp: 8194,\n    emsp: 8195,\n    thinsp: 8201,\n    zwnj: 8204,\n    zwj: 8205,\n    lrm: 8206,\n    rlm: 8207,\n    ndash: 8211,\n    mdash: 8212,\n    lsquo: 8216,\n    rsquo: 8217,\n    sbquo: 8218,\n    ldquo: 8220,\n    rdquo: 8221,\n    bdquo: 8222,\n    dagger: 8224,\n    Dagger: 8225,\n    bull: 8226,\n    hellip: 8230,\n    permil: 8240,\n    prime: 8242,\n    Prime: 8243,\n    lsaquo: 8249,\n    rsaquo: 8250,\n    oline: 8254,\n    frasl: 8260,\n    euro: 8364,\n    image: 8465,\n    weierp: 8472,\n    real: 8476,\n    trade: 8482,\n    alefsym: 8501,\n    larr: 8592,\n    uarr: 8593,\n    rarr: 8594,\n    darr: 8595,\n    harr: 8596,\n    crarr: 8629,\n    lArr: 8656,\n    uArr: 8657,\n    rArr: 8658,\n    dArr: 8659,\n    hArr: 8660,\n    forall: 8704,\n    part: 8706,\n    exist: 8707,\n    empty: 8709,\n    nabla: 8711,\n    isin: 8712,\n    notin: 8713,\n    ni: 8715,\n    prod: 8719,\n    sum: 8721,\n    minus: 8722,\n    lowast: 8727,\n    radic: 8730,\n    prop: 8733,\n    infin: 8734,\n    ang: 8736,\n    and: 8743,\n    or: 8744,\n    cap: 8745,\n    cup: 8746,\n    int: 8747,\n    there4: 8756,\n    sim: 8764,\n    cong: 8773,\n    asymp: 8776,\n    ne: 8800,\n    equiv: 8801,\n    le: 8804,\n    ge: 8805,\n    sub: 8834,\n    sup: 8835,\n    nsub: 8836,\n    sube: 8838,\n    supe: 8839,\n    oplus: 8853,\n    otimes: 8855,\n    perp: 8869,\n    sdot: 8901,\n    lceil: 8968,\n    rceil: 8969,\n    lfloor: 8970,\n    rfloor: 8971,\n    lang: 9001,\n    rang: 9002,\n    loz: 9674,\n    spades: 9824,\n    clubs: 9827,\n    hearts: 9829,\n    diams: 9830,\n  };\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key];\n    var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n    sax.ENTITIES[key] = s;\n  });\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s;\n  }\n\n  // shorthand\n  S = sax.STATE;\n\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n    parser.textNode = \"\";\n  }\n\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error(parser, er) {\n    closeText(parser);\n    if (parser.trackPosition) {\n      er +=\n        \"\\nLine: \" +\n        parser.line +\n        \"\\nColumn: \" +\n        parser.column +\n        \"\\nChar: \" +\n        parser.c;\n    }\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.sawRoot && !parser.closedRoot)\n      strictFail(parser, \"Unclosed root tag\");\n    if (\n      parser.state !== S.BEGIN &&\n      parser.state !== S.BEGIN_WHITESPACE &&\n      parser.state !== S.TEXT\n    ) {\n      error(parser, \"Unexpected end\");\n    }\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n\n  function strictFail(parser, message) {\n    if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n      throw new Error(\"bad call to strictFail\");\n    }\n    if (parser.strict) {\n      error(parser, message);\n    }\n  }\n\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser;\n    var tag = (parser.tag = { name: parser.tagName, attributes: {} });\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns;\n    }\n    parser.attribList.length = 0;\n    emitNode(parser, \"onopentagstart\", tag);\n  }\n\n  function qname(name, attribute) {\n    var i = name.indexOf(\":\");\n    var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n    var prefix = qualName[0];\n    var local = qualName[1];\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === \"xmlns\") {\n      prefix = \"xmlns\";\n      local = \"\";\n    }\n\n    return { prefix: prefix, local: local };\n  }\n\n  function attrib(parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]();\n    }\n\n    if (\n      parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)\n    ) {\n      parser.attribName = parser.attribValue = \"\";\n      return;\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true);\n      var prefix = qn.prefix;\n      var local = qn.local;\n\n      if (prefix === \"xmlns\") {\n        // namespace binding attribute. push the binding into scope\n        if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(\n            parser,\n            \"xml: prefix must be bound to \" +\n              XML_NAMESPACE +\n              \"\\n\" +\n              \"Actual: \" +\n              parser.attribValue\n          );\n        } else if (\n          local === \"xmlns\" &&\n          parser.attribValue !== XMLNS_NAMESPACE\n        ) {\n          strictFail(\n            parser,\n            \"xmlns: prefix must be bound to \" +\n              XMLNS_NAMESPACE +\n              \"\\n\" +\n              \"Actual: \" +\n              parser.attribValue\n          );\n        } else {\n          var tag = parser.tag;\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n          tag.ns[local] = parser.attribValue;\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, \"onattribute\", {\n        name: parser.attribName,\n        value: parser.attribValue,\n      });\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n  }\n\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag;\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || \"\";\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(\n          parser,\n          \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName)\n        );\n        tag.uri = qn.prefix;\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, \"onopennamespace\", {\n            prefix: p,\n            uri: tag.ns[p],\n          });\n        });\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0];\n        var value = nv[1];\n        var qualName = qname(name, true);\n        var prefix = qualName.prefix;\n        var local = qualName.local;\n        var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri,\n        };\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== \"xmlns\" && !uri) {\n          strictFail(\n            parser,\n            \"Unbound namespace prefix: \" + JSON.stringify(prefix)\n          );\n          a.uri = prefix;\n        }\n        parser.tag.attributes[name] = a;\n        emitNode(parser, \"onattribute\", a);\n      }\n      parser.attribList.length = 0;\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing;\n\n    // process the tag\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n      parser.tag = null;\n      parser.tagName = \"\";\n    }\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n  }\n\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, \"Weird empty close tag.\");\n      parser.textNode += \"</>\";\n      parser.state = S.TEXT;\n      return;\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== \"script\") {\n        parser.script += \"</\" + parser.tagName + \">\";\n        parser.tagName = \"\";\n        parser.state = S.SCRIPT;\n        return;\n      }\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]();\n    }\n    var closeTo = tagName;\n    while (t--) {\n      var close = parser.tags[t];\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, \"Unexpected close tag\");\n      } else {\n        break;\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n      parser.textNode += \"</\" + parser.tagName + \">\";\n      parser.state = S.TEXT;\n      return;\n    }\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n    while (s-- > t) {\n      var tag = (parser.tag = parser.tags.pop());\n      parser.tagName = parser.tag.name;\n      emitNode(parser, \"onclosetag\", parser.tagName);\n\n      var x = {};\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i];\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n        });\n      }\n    }\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n\n  function parseEntity(parser) {\n    var entity = parser.entity;\n    var entityLC = entity.toLowerCase();\n    var num;\n    var numStr = \"\";\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity];\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC];\n    }\n    entity = entityLC;\n    if (entity.charAt(0) === \"#\") {\n      if (entity.charAt(1) === \"x\") {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n    entity = entity.replace(/^0+/, \"\");\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, \"Invalid character entity\");\n      return \"&\" + parser.entity + \";\";\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n  function beginWhiteSpace(parser, c) {\n    if (c === \"<\") {\n      parser.state = S.OPEN_WAKA;\n      parser.startTagPosition = parser.position;\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, \"Non-whitespace before first tag.\");\n      parser.textNode = c;\n      parser.state = S.TEXT;\n    }\n  }\n\n  function charAt(chunk, i) {\n    var result = \"\";\n    if (i < chunk.length) {\n      result = chunk.charAt(i);\n    }\n    return result;\n  }\n\n  function write(chunk) {\n    var parser = this;\n    if (this.error) {\n      throw this.error;\n    }\n    if (parser.closed) {\n      return error(\n        parser,\n        \"Cannot write after close. Assign an onready handler.\"\n      );\n    }\n    if (chunk === null) {\n      return end(parser);\n    }\n    if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    }\n    var i = 0;\n    var c = \"\";\n    while (true) {\n      c = charAt(chunk, i++);\n      parser.c = c;\n\n      if (!c) {\n        break;\n      }\n\n      if (parser.trackPosition) {\n        parser.position++;\n        if (c === \"\\n\") {\n          parser.line++;\n          parser.column = 0;\n        } else {\n          parser.column++;\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE;\n          if (c === \"\\uFEFF\") {\n            continue;\n          }\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n            while (c && c !== \"<\" && c !== \"&\") {\n              c = charAt(chunk, i++);\n              if (c && parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                  parser.line++;\n                  parser.column = 0;\n                } else {\n                  parser.column++;\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n          if (\n            c === \"<\" &&\n            !(parser.sawRoot && parser.closedRoot && !parser.strict)\n          ) {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, \"Text data outside of root node.\");\n            }\n            if (c === \"&\") {\n              parser.state = S.TEXT_ENTITY;\n            } else {\n              parser.textNode += c;\n            }\n          }\n          continue;\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === \"<\") {\n            parser.state = S.SCRIPT_ENDING;\n          } else {\n            parser.script += c;\n          }\n          continue;\n\n        case S.SCRIPT_ENDING:\n          if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n          } else {\n            parser.script += \"<\" + c;\n            parser.state = S.SCRIPT;\n          }\n          continue;\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === \"!\") {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = \"\";\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = \"\";\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = \"\";\n          } else {\n            strictFail(parser, \"Unencoded <\");\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition;\n              c = new Array(pad).join(\" \") + c;\n            }\n            parser.textNode += \"<\" + c;\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, \"onopencdata\");\n            parser.state = S.CDATA;\n            parser.sgmlDecl = \"\";\n            parser.cdata = \"\";\n          } else if (parser.sgmlDecl + c === \"--\") {\n            parser.state = S.COMMENT;\n            parser.comment = \"\";\n            parser.sgmlDecl = \"\";\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser, \"Inappropriately located doctype declaration\");\n            }\n            parser.doctype = \"\";\n            parser.sgmlDecl = \"\";\n          } else if (c === \">\") {\n            emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n            parser.sgmlDecl = \"\";\n            parser.state = S.TEXT;\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else {\n            parser.sgmlDecl += c;\n          }\n          continue;\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = \"\";\n          }\n          parser.sgmlDecl += c;\n          continue;\n\n        case S.DOCTYPE:\n          if (c === \">\") {\n            parser.state = S.TEXT;\n            emitNode(parser, \"ondoctype\", parser.doctype);\n            parser.doctype = true; // just remember that we saw it.\n          } else {\n            parser.doctype += c;\n            if (c === \"[\") {\n              parser.state = S.DOCTYPE_DTD;\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n          continue;\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.q = \"\";\n            parser.state = S.DOCTYPE;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n          if (c === \"]\") {\n            parser.state = S.DOCTYPE;\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = \"\";\n          }\n          continue;\n\n        case S.COMMENT:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDING;\n          } else {\n            parser.comment += c;\n          }\n          continue;\n\n        case S.COMMENT_ENDING:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n            if (parser.comment) {\n              emitNode(parser, \"oncomment\", parser.comment);\n            }\n            parser.comment = \"\";\n          } else {\n            parser.comment += \"-\" + c;\n            parser.state = S.COMMENT;\n          }\n          continue;\n\n        case S.COMMENT_ENDED:\n          if (c !== \">\") {\n            strictFail(parser, \"Malformed comment\");\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += \"--\" + c;\n            parser.state = S.COMMENT;\n          } else {\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.CDATA:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING;\n          } else {\n            parser.cdata += c;\n          }\n          continue;\n\n        case S.CDATA_ENDING:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING_2;\n          } else {\n            parser.cdata += \"]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.CDATA_ENDING_2:\n          if (c === \">\") {\n            if (parser.cdata) {\n              emitNode(parser, \"oncdata\", parser.cdata);\n            }\n            emitNode(parser, \"onclosecdata\");\n            parser.cdata = \"\";\n            parser.state = S.TEXT;\n          } else if (c === \"]\") {\n            parser.cdata += \"]\";\n          } else {\n            parser.cdata += \"]]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.PROC_INST:\n          if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY;\n          } else {\n            parser.procInstName += c;\n          }\n          continue;\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue;\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else {\n            parser.procInstBody += c;\n          }\n          continue;\n\n        case S.PROC_INST_ENDING:\n          if (c === \">\") {\n            emitNode(parser, \"onprocessinginstruction\", {\n              name: parser.procInstName,\n              body: parser.procInstBody,\n            });\n            parser.procInstName = parser.procInstBody = \"\";\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += \"?\" + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n          continue;\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else {\n            newTag(parser);\n            if (c === \">\") {\n              openTag(parser);\n            } else if (c === \"/\") {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, \"Invalid character in tag name\");\n              }\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.OPEN_TAG_SLASH:\n          if (c === \">\") {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(\n              parser,\n              \"Forward-slash in opening tag not followed by >\"\n            );\n            parser.state = S.ATTRIB;\n          }\n          continue;\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_NAME:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (c === \">\") {\n            strictFail(parser, \"Attribute without value\");\n            parser.attribValue = parser.attribName;\n            attrib(parser);\n            openTag(parser);\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE;\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (isWhitespace(c)) {\n            continue;\n          } else {\n            strictFail(parser, \"Attribute without value\");\n            parser.tag.attributes[parser.attribName] = \"\";\n            parser.attribValue = \"\";\n            emitNode(parser, \"onattribute\", {\n              name: parser.attribName,\n              value: \"\",\n            });\n            parser.attribName = \"\";\n            if (c === \">\") {\n              openTag(parser);\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, \"Invalid attribute name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue;\n          } else if (isQuote(c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, \"Unquoted attribute value\");\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          parser.q = \"\";\n          parser.state = S.ATTRIB_VALUE_CLOSED;\n          continue;\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, \"No whitespace between attributes\");\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          if (c === \">\") {\n            openTag(parser);\n          } else {\n            parser.state = S.ATTRIB;\n          }\n          continue;\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue;\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += \"</\" + c;\n                parser.state = S.SCRIPT;\n              } else {\n                strictFail(parser, \"Invalid tagname in closing tag.\");\n              }\n            } else {\n              parser.tagName = c;\n            }\n          } else if (c === \">\") {\n            closeTag(parser);\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else if (parser.script) {\n            parser.script += \"</\" + parser.tagName;\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, \"Invalid tagname in closing tag\");\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n          continue;\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue;\n          }\n          if (c === \">\") {\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Invalid characters in closing tag\");\n          }\n          continue;\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState;\n          var buffer;\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT;\n              buffer = \"textNode\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED;\n              buffer = \"attribValue\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED;\n              buffer = \"attribValue\";\n              break;\n          }\n\n          if (c === \";\") {\n            if (parser.opt.unparsedEntities) {\n              var parsedEntity = parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n              parser.write(parsedEntity);\n            } else {\n              parser[buffer] += parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n            }\n          } else if (\n            isMatch(parser.entity.length ? entityBody : entityStart, c)\n          ) {\n            parser.entity += c;\n          } else {\n            strictFail(parser, \"Invalid character in entity name\");\n            parser[buffer] += \"&\" + parser.entity + c;\n            parser.entity = \"\";\n            parser.state = returnState;\n          }\n\n          continue;\n\n        default: /* istanbul ignore next */ {\n          throw new Error(parser, \"Unknown state: \" + parser.state);\n        }\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser);\n    }\n    return parser;\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode;\n      var floor = Math.floor;\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = arguments.length;\n        if (!length) {\n          return \"\";\n        }\n        var result = \"\";\n        while (++index < length) {\n          var codePoint = Number(arguments[index]);\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10ffff || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError(\"Invalid code point: \" + codePoint);\n          }\n          if (codePoint <= 0xffff) {\n            // BMP code point\n            codeUnits.push(codePoint);\n          } else {\n            // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000;\n            highSurrogate = (codePoint >> 10) + 0xd800;\n            lowSurrogate = (codePoint % 0x400) + 0xdc00;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n        return result;\n      };\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, \"fromCodePoint\", {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true,\n        });\n      } else {\n        String.fromCodePoint = fromCodePoint;\n      }\n    })();\n  }\n  return sax;\n};\n\nconst sax = /** #__PURE__ */ initializeSax();\n\nexport { sax };\n", "import {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"./transform.js\";\nimport { Operation, compare } from \"../utils/json_patch.js\";\nimport { sax } from \"../utils/sax-js/sax.js\";\nimport { ChatGeneration, Generation } from \"../outputs.js\";\n\nexport const XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\n\nexport interface XMLOutputParserFields\n  extends BaseCumulativeTransformOutputParserInput {\n  /**\n   * Optional list of tags that the output should conform to.\n   * Only used in formatting of the prompt.\n   */\n  tags?: string[];\n}\n\nexport type Content = string | undefined | Array<{ [key: string]: Content }>;\n\nexport type XMLResult = {\n  [key: string]: Content;\n};\n\nexport class XMLOutputParser extends BaseCumulativeTransformOutputParser<XMLResult> {\n  tags?: string[];\n\n  constructor(fields?: XMLOutputParserFields) {\n    super(fields);\n\n    this.tags = fields?.tags;\n  }\n\n  static lc_name() {\n    return \"XMLOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): Operation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{ op: \"replace\", path: \"\", value: next }];\n    }\n    return compare(prev, next);\n  }\n\n  async parsePartialResult(\n    generations: ChatGeneration[] | Generation[]\n  ): Promise<XMLResult | undefined> {\n    return parseXMLMarkdown(generations[0].text);\n  }\n\n  async parse(text: string): Promise<XMLResult> {\n    return parseXMLMarkdown(text);\n  }\n\n  getFormatInstructions(): string {\n    const withTags = !!(this.tags && this.tags.length > 0);\n    return withTags\n      ? XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n      : XML_FORMAT_INSTRUCTIONS;\n  }\n}\n\nconst strip = (text: string) =>\n  text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\n\ntype ParsedResult = {\n  name: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  attributes: Record<string, any>;\n  children: Array<ParsedResult>;\n  text?: string;\n  isSelfClosing: boolean;\n};\n\nconst parseParsedResult = (input: ParsedResult): XMLResult => {\n  if (Object.keys(input).length === 0) {\n    return {};\n  }\n  const result: XMLResult = {};\n  if (input.children.length > 0) {\n    result[input.name] = input.children.map(parseParsedResult);\n    return result;\n  } else {\n    result[input.name] = input.text ?? undefined;\n    return result;\n  }\n};\n\nexport function parseXMLMarkdown(s: string): XMLResult {\n  const cleanedString = strip(s);\n  const parser = sax.parser(true);\n  let parsedResult: ParsedResult = {} as ParsedResult;\n  const elementStack: ParsedResult[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onopentag = (node: any) => {\n    const element = {\n      name: node.name,\n      attributes: node.attributes,\n      children: [],\n      text: \"\",\n      isSelfClosing: node.isSelfClosing,\n    };\n\n    if (elementStack.length > 0) {\n      const parentElement = elementStack[elementStack.length - 1];\n      parentElement.children.push(element);\n    } else {\n      parsedResult = element as ParsedResult;\n    }\n\n    if (!node.isSelfClosing) {\n      elementStack.push(element);\n    }\n  };\n\n  parser.onclosetag = () => {\n    if (elementStack.length > 0) {\n      const lastElement = elementStack.pop();\n      if (elementStack.length === 0 && lastElement) {\n        parsedResult = lastElement as ParsedResult;\n      }\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.ontext = (text: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.text += text;\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onattribute = (attr: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.attributes[attr.name] = attr.value;\n    }\n  };\n\n  // Try to find XML string within triple backticks.\n  const match = /```(xml)?(.*)```/s.exec(cleanedString);\n  const xmlString = match ? match[2] : cleanedString;\n  parser.write(xmlString).close();\n\n  // Remove the XML declaration if present\n  if (parsedResult && parsedResult.name === \"?xml\") {\n    parsedResult = parsedResult.children[0] as ParsedResult;\n  }\n\n  return parseParsedResult(parsedResult);\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { parseJsonMarkdown, parsePartialJson } from \"../utils/json.js\";\nimport { BaseLLMOutputParser, BaseOutputParser, OutputParserException } from \"./base.js\";\nimport { BaseCumulativeTransformOutputParser, BaseTransformOutputParser } from \"./transform.js\";\nimport { BytesOutputParser } from \"./bytes.js\";\nimport { CommaSeparatedListOutputParser, CustomListOutputParser, ListOutputParser, MarkdownListOutputParser, NumberedListOutputParser } from \"./list.js\";\nimport { StringOutputParser } from \"./string.js\";\nimport { AsymmetricStructuredOutputParser, JsonMarkdownStructuredOutputParser, StructuredOutputParser } from \"./structured.js\";\nimport { JsonOutputParser } from \"./json.js\";\nimport { XMLOutputParser, XML_FORMAT_INSTRUCTIONS, parseXMLMarkdown } from \"./xml.js\";\n\n//#region src/output_parsers/index.ts\nvar output_parsers_exports = {};\n__export(output_parsers_exports, {\n\tAsymmetricStructuredOutputParser: () => AsymmetricStructuredOutputParser,\n\tBaseCumulativeTransformOutputParser: () => BaseCumulativeTransformOutputParser,\n\tBaseLLMOutputParser: () => BaseLLMOutputParser,\n\tBaseOutputParser: () => BaseOutputParser,\n\tBaseTransformOutputParser: () => BaseTransformOutputParser,\n\tBytesOutputParser: () => BytesOutputParser,\n\tCommaSeparatedListOutputParser: () => CommaSeparatedListOutputParser,\n\tCustomListOutputParser: () => CustomListOutputParser,\n\tJsonMarkdownStructuredOutputParser: () => JsonMarkdownStructuredOutputParser,\n\tJsonOutputParser: () => JsonOutputParser,\n\tListOutputParser: () => ListOutputParser,\n\tMarkdownListOutputParser: () => MarkdownListOutputParser,\n\tNumberedListOutputParser: () => NumberedListOutputParser,\n\tOutputParserException: () => OutputParserException,\n\tStringOutputParser: () => StringOutputParser,\n\tStructuredOutputParser: () => StructuredOutputParser,\n\tXMLOutputParser: () => XMLOutputParser,\n\tXML_FORMAT_INSTRUCTIONS: () => XML_FORMAT_INSTRUCTIONS,\n\tparseJsonMarkdown: () => parseJsonMarkdown,\n\tparsePartialJson: () => parsePartialJson,\n\tparseXMLMarkdown: () => parseXMLMarkdown\n});\n\n//#endregion\nexport { AsymmetricStructuredOutputParser, BaseCumulativeTransformOutputParser, BaseLLMOutputParser, BaseOutputParser, BaseTransformOutputParser, BytesOutputParser, CommaSeparatedListOutputParser, CustomListOutputParser, JsonMarkdownStructuredOutputParser, JsonOutputParser, ListOutputParser, MarkdownListOutputParser, NumberedListOutputParser, OutputParserException, StringOutputParser, StructuredOutputParser, XMLOutputParser, XML_FORMAT_INSTRUCTIONS, output_parsers_exports, parseJsonMarkdown, parsePartialJson, parseXMLMarkdown };\n//# sourceMappingURL=index.js.map", "import { Optional } from \"../../types/type-utils.js\";\nimport { Generation, ChatGeneration } from \"../../outputs.js\";\nimport { BaseLLMOutputParser } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"../transform.js\";\nimport { JsonSchema7ObjectType } from \"../../utils/json_schema.js\";\nimport {\n  compare,\n  type Operation as JSONPatchOperation,\n} from \"../../utils/json_patch.js\";\n\n/**\n * Represents optional parameters for a function in a JSON Schema.\n */\nexport type FunctionParameters = Optional<\n  JsonSchema7ObjectType,\n  \"additionalProperties\"\n>;\n\n/**\n * Class for parsing the output of an LLM. Can be configured to return\n * only the arguments of the function call in the output.\n */\nexport class OutputFunctionsParser extends BaseLLMOutputParser<string> {\n  static lc_name() {\n    return \"OutputFunctionsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_functions\"];\n\n  lc_serializable = true;\n\n  argsOnly = true;\n\n  constructor(config?: { argsOnly?: boolean }) {\n    super();\n    this.argsOnly = config?.argsOnly ?? this.argsOnly;\n  }\n\n  /**\n   * Parses the output and returns a string representation of the function\n   * call or its arguments.\n   * @param generations The output of the LLM to parse.\n   * @returns A string representation of the function call or its arguments.\n   */\n  async parseResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<string> {\n    if (\"message\" in generations[0]) {\n      const gen = generations[0] as ChatGeneration;\n      const functionCall = gen.message.additional_kwargs.function_call;\n      if (!functionCall) {\n        throw new Error(\n          `No function_call in message ${JSON.stringify(generations)}`\n        );\n      }\n      if (!functionCall.arguments) {\n        throw new Error(\n          `No arguments in function_call ${JSON.stringify(generations)}`\n        );\n      }\n      if (this.argsOnly) {\n        return functionCall.arguments;\n      }\n      return JSON.stringify(functionCall);\n    } else {\n      throw new Error(\n        `No message in generations ${JSON.stringify(generations)}`\n      );\n    }\n  }\n}\n\n/**\n * Class for parsing the output of an LLM into a JSON object. Uses an\n * instance of `OutputFunctionsParser` to parse the output.\n */\nexport class JsonOutputFunctionsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Output extends Record<string, any> = Record<string, any>,\n> extends BaseCumulativeTransformOutputParser<Output> {\n  static lc_name() {\n    return \"JsonOutputFunctionsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_functions\"];\n\n  lc_serializable = true;\n\n  outputParser: OutputFunctionsParser;\n\n  argsOnly = true;\n\n  constructor(\n    config?: { argsOnly?: boolean } & BaseCumulativeTransformOutputParserInput\n  ) {\n    super(config);\n    this.argsOnly = config?.argsOnly ?? this.argsOnly;\n    this.outputParser = new OutputFunctionsParser(config);\n  }\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): JSONPatchOperation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    const ops = compare(prev ?? {}, next);\n    return ops;\n  }\n\n  async parsePartialResult(\n    generations: ChatGeneration[]\n  ): Promise<Output | undefined> {\n    const generation = generations[0];\n    if (!generation.message) {\n      return undefined;\n    }\n    const { message } = generation;\n    const functionCall = message.additional_kwargs.function_call;\n    if (!functionCall) {\n      return undefined;\n    }\n    if (this.argsOnly) {\n      return parsePartialJson(functionCall.arguments);\n    }\n\n    return {\n      ...functionCall,\n      arguments: parsePartialJson(functionCall.arguments),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as Record<string, any> as Output;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parseResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<Output> {\n    const result = await this.outputParser.parseResult(generations);\n    if (!result) {\n      throw new Error(\n        `No result from \"OutputFunctionsParser\" ${JSON.stringify(generations)}`\n      );\n    }\n    return this.parse(result);\n  }\n\n  async parse(text: string): Promise<Output> {\n    const parsedResult = JSON.parse(text);\n    if (this.argsOnly) {\n      return parsedResult;\n    }\n    parsedResult.arguments = JSON.parse(parsedResult.arguments);\n    return parsedResult;\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n\n/**\n * Class for parsing the output of an LLM into a JSON object and returning\n * a specific attribute. Uses an instance of `JsonOutputFunctionsParser`\n * to parse the output.\n */\nexport class JsonKeyOutputFunctionsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> extends BaseLLMOutputParser<T> {\n  static lc_name() {\n    return \"JsonKeyOutputFunctionsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_functions\"];\n\n  lc_serializable = true;\n\n  outputParser = new JsonOutputFunctionsParser();\n\n  attrName: string;\n\n  get lc_aliases() {\n    return {\n      attrName: \"key_name\",\n    };\n  }\n\n  constructor(fields: { attrName: string }) {\n    super(fields);\n    this.attrName = fields.attrName;\n  }\n\n  /**\n   * Parses the output and returns a specific attribute of the parsed JSON\n   * object.\n   * @param generations The output of the LLM to parse.\n   * @returns The value of a specific attribute of the parsed JSON object.\n   */\n  async parseResult(generations: Generation[] | ChatGeneration[]): Promise<T> {\n    const result = await this.outputParser.parseResult(generations);\n    return result[this.attrName as keyof typeof result] as T;\n  }\n}\n", "import { __export } from \"../../_virtual/rolldown_runtime.js\";\nimport { JsonKeyOutputFunctionsParser, JsonOutputFunctionsParser, OutputFunctionsParser } from \"./json_output_functions_parsers.js\";\n\n//#region src/output_parsers/openai_functions/index.ts\nvar openai_functions_exports = {};\n__export(openai_functions_exports, {\n\tJsonKeyOutputFunctionsParser: () => JsonKeyOutputFunctionsParser,\n\tJsonOutputFunctionsParser: () => JsonOutputFunctionsParser,\n\tOutputFunctionsParser: () => OutputFunctionsParser\n});\n\n//#endregion\nexport { JsonKeyOutputFunctionsParser, JsonOutputFunctionsParser, OutputFunctionsParser, openai_functions_exports };\n//# sourceMappingURL=index.js.map", "import type * as z3 from \"zod/v3\";\nimport type * as z4 from \"zod/v4/core\";\nimport { ChatGeneration, ChatGenerationChunk } from \"../../outputs.js\";\nimport { OutputParserException } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport { InvalidToolCall, ToolCall } from \"../../messages/tool.js\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"../transform.js\";\nimport { isAIMessage } from \"../../messages/ai.js\";\nimport {\n  type InteropZodType,\n  interopSafeParseAsync,\n} from \"../../utils/types/zod.js\";\n\nexport type ParsedToolCall = {\n  id?: string;\n\n  type: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: Record<string, any>;\n};\n\nexport type JsonOutputToolsParserParams = {\n  /** Whether to return the tool call id. */\n  returnId?: boolean;\n} & BaseCumulativeTransformOutputParserInput;\n\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options: { returnId?: boolean; partial: true }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: false }\n): ToolCall;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined {\n  if (rawToolCall.function === undefined) {\n    return undefined;\n  }\n  let functionArgs;\n  if (options?.partial) {\n    try {\n      functionArgs = parsePartialJson(rawToolCall.function.arguments ?? \"{}\");\n    } catch {\n      return undefined;\n    }\n  } else {\n    try {\n      functionArgs = JSON.parse(rawToolCall.function.arguments);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new OutputParserException(\n        [\n          `Function \"${rawToolCall.function.name}\" arguments:`,\n          ``,\n          rawToolCall.function.arguments,\n          ``,\n          `are not valid JSON.`,\n          `Error: ${e.message}`,\n        ].join(\"\\n\")\n      );\n    }\n  }\n\n  const parsedToolCall: ToolCall = {\n    name: rawToolCall.function.name,\n    args: functionArgs,\n    type: \"tool_call\",\n  };\n\n  if (options?.returnId) {\n    parsedToolCall.id = rawToolCall.id;\n  }\n\n  return parsedToolCall;\n}\n\nexport function convertLangChainToolCallToOpenAI(toolCall: ToolCall) {\n  if (toolCall.id === undefined) {\n    throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n  }\n  return {\n    id: toolCall.id,\n    type: \"function\",\n    function: {\n      name: toolCall.name,\n      arguments: JSON.stringify(toolCall.args),\n    },\n  };\n}\n\nexport function makeInvalidToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  errorMsg?: string\n): InvalidToolCall {\n  return {\n    name: rawToolCall.function?.name,\n    args: rawToolCall.function?.arguments,\n    id: rawToolCall.id,\n    error: errorMsg,\n    type: \"invalid_tool_call\",\n  };\n}\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser<\n  T,\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n\n  returnId = false;\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  constructor(fields?: JsonOutputToolsParserParams) {\n    super(fields);\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n\n  protected _diff() {\n    throw new Error(\"Not supported.\");\n  }\n\n  async parse(): Promise<T> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async parseResult(generations: ChatGeneration[]): Promise<T> {\n    const result = await this.parsePartialResult(generations, false);\n    return result;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parsePartialResult(\n    generations: ChatGenerationChunk[] | ChatGeneration[],\n    partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const message = generations[0].message;\n    let toolCalls;\n    if (isAIMessage(message) && message.tool_calls?.length) {\n      toolCalls = message.tool_calls.map((toolCall) => {\n        const { id, ...rest } = toolCall;\n        if (!this.returnId) {\n          return rest;\n        }\n        return {\n          id,\n          ...rest,\n        };\n      });\n    } else if (message.additional_kwargs.tool_calls !== undefined) {\n      const rawToolCalls = JSON.parse(\n        JSON.stringify(message.additional_kwargs.tool_calls)\n      );\n      toolCalls = rawToolCalls.map((rawToolCall: Record<string, unknown>) => {\n        return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n      });\n    }\n    if (!toolCalls) {\n      return [];\n    }\n    const parsedToolCalls = [];\n    for (const toolCall of toolCalls) {\n      if (toolCall !== undefined) {\n        const backwardsCompatibleToolCall: ParsedToolCall = {\n          type: toolCall.name,\n          args: toolCall.args,\n          id: toolCall.id,\n        };\n        parsedToolCalls.push(backwardsCompatibleToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n\ntype JsonOutputKeyToolsParserParamsBase = {\n  keyName: string;\n  returnSingle?: boolean;\n} & JsonOutputToolsParserParams;\n\ntype JsonOutputKeyToolsParserParamsV3<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: z3.ZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\ntype JsonOutputKeyToolsParserParamsV4<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: z4.$ZodType<T, T> } & JsonOutputKeyToolsParserParamsBase;\n\nexport type JsonOutputKeyToolsParserParamsInterop<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: InteropZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\n// Use Zod 3 for backwards compatibility\nexport type JsonOutputKeyToolsParserParams<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = JsonOutputKeyToolsParserParamsV3<T>;\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> extends JsonOutputToolsParser<T> {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  zodSchema?: InteropZodType<T>;\n\n  constructor(params: JsonOutputKeyToolsParserParamsV3<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsV4<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsInterop<T>);\n\n  constructor(\n    params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>\n  ) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n\n  protected async _validateResult(result: unknown): Promise<T> {\n    if (this.zodSchema === undefined) {\n      return result as T;\n    }\n    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${JSON.stringify(\n          result,\n          null,\n          2\n        )}\". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`,\n        JSON.stringify(result, null, 2)\n      );\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parsePartialResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return returnedValues[0];\n    }\n    return returnedValues;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations, false);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return this._validateResult(returnedValues[0]);\n    }\n    const toolCallResults = await Promise.all(\n      returnedValues.map((value) => this._validateResult(value))\n    );\n    return toolCallResults;\n  }\n}\n", "import { __export } from \"../../_virtual/rolldown_runtime.js\";\nimport { JsonOutputKeyToolsParser, JsonOutputToolsParser, convertLangChainToolCallToOpenAI, makeInvalidToolCall, parseToolCall } from \"./json_output_tools_parsers.js\";\n\n//#region src/output_parsers/openai_tools/index.ts\nvar openai_tools_exports = {};\n__export(openai_tools_exports, {\n\tJsonOutputKeyToolsParser: () => JsonOutputKeyToolsParser,\n\tJsonOutputToolsParser: () => JsonOutputToolsParser,\n\tconvertLangChainToolCallToOpenAI: () => convertLangChainToolCallToOpenAI,\n\tmakeInvalidToolCall: () => makeInvalidToolCall,\n\tparseToolCall: () => parseToolCall\n});\n\n//#endregion\nexport { JsonOutputKeyToolsParser, JsonOutputToolsParser, convertLangChainToolCallToOpenAI, makeInvalidToolCall, openai_tools_exports, parseToolCall };\n//# sourceMappingURL=index.js.map", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport type {\n  InputValues,\n  PartialValues,\n  StringWithAutocomplete,\n} from \"../utils/types/index.js\";\nimport { type BasePromptValueInterface } from \"../prompt_values.js\";\nimport { BaseOutputParser } from \"../output_parsers/index.js\";\nimport type { SerializedFields } from \"../load/map_keys.js\";\nimport { Runnable } from \"../runnables/base.js\";\nimport { BaseCallbackConfig } from \"../callbacks/manager.js\";\n\nexport type TypedPromptInputValues<RunInput> = InputValues<\n  StringWithAutocomplete<Extract<keyof RunInput, string>>\n>;\n\nexport type Example = Record<string, string>;\n\n/**\n * Input common to all prompt templates.\n */\nexport interface BasePromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  InputVariables extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n> {\n  /**\n   * A list of variable names the prompt template expects\n   */\n  inputVariables: Array<Extract<keyof InputVariables, string>>;\n\n  /**\n   * How to parse the output of calling an LLM on this formatted prompt\n   */\n  outputParser?: BaseOutputParser;\n\n  /** Partial variables */\n  partialVariables?: PartialValues<PartialVariableName>;\n}\n\n/**\n * Base class for prompt templates. Exposes a format method that returns a\n * string prompt given a set of input values.\n */\nexport abstract class BasePromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    RunOutput extends BasePromptValueInterface = BasePromptValueInterface,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any,\n  >\n  extends Runnable<RunInput, RunOutput>\n  implements BasePromptTemplateInput\n{\n  declare PromptValueReturnType: RunOutput;\n\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain_core\", \"prompts\", this._getPromptType()];\n\n  get lc_attributes(): SerializedFields | undefined {\n    return {\n      partialVariables: undefined, // python doesn't support this yet\n    };\n  }\n\n  inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  outputParser?: BaseOutputParser;\n\n  partialVariables: PartialValues<PartialVariableName>;\n\n  /**\n   * Metadata to be used for tracing.\n   */\n  metadata?: Record<string, unknown>;\n\n  /** Tags to be used for tracing. */\n  tags?: string[];\n\n  constructor(input: BasePromptTemplateInput) {\n    super(input);\n    const { inputVariables } = input;\n    if (inputVariables.includes(\"stop\")) {\n      throw new Error(\n        \"Cannot have an input variable named 'stop', as it is used internally, please rename.\"\n      );\n    }\n    Object.assign(this, input);\n  }\n\n  abstract partial(\n    values: PartialValues\n  ): Promise<BasePromptTemplate<RunInput, RunOutput, PartialVariableName>>;\n\n  /**\n   * Merges partial variables and user variables.\n   * @param userVariables The user variables to merge with the partial variables.\n   * @returns A Promise that resolves to an object containing the merged variables.\n   */\n  async mergePartialAndUserVariables(\n    userVariables: TypedPromptInputValues<RunInput>\n  ): Promise<\n    InputValues<Extract<keyof RunInput, string> | PartialVariableName>\n  > {\n    const partialVariables = this.partialVariables ?? {};\n    const partialValues: Record<string, string> = {};\n\n    for (const [key, value] of Object.entries(partialVariables)) {\n      if (typeof value === \"string\") {\n        partialValues[key] = value;\n      } else {\n        partialValues[key] = await (value as () => Promise<string>)();\n      }\n    }\n\n    const allKwargs = {\n      ...(partialValues as Record<PartialVariableName, string>),\n      ...userVariables,\n    };\n    return allKwargs;\n  }\n\n  /**\n   * Invokes the prompt template with the given input and options.\n   * @param input The input to invoke the prompt template with.\n   * @param options Optional configuration for the callback.\n   * @returns A Promise that resolves to the output of the prompt template.\n   */\n  async invoke(\n    input: RunInput,\n    options?: BaseCallbackConfig\n  ): Promise<RunOutput> {\n    const metadata = {\n      ...this.metadata,\n      ...options?.metadata,\n    };\n    const tags = [...(this.tags ?? []), ...(options?.tags ?? [])];\n    return this._callWithConfig(\n      (input: RunInput) => this.formatPromptValue(input),\n      input,\n      { ...options, tags, metadata, runType: \"prompt\" }\n    );\n  }\n\n  /**\n   * Format the prompt given the input values.\n   *\n   * @param values - A dictionary of arguments to be passed to the prompt template.\n   * @returns A formatted prompt string.\n   *\n   * @example\n   * ```ts\n   * prompt.format({ foo: \"bar\" });\n   * ```\n   */\n  abstract format(values: TypedPromptInputValues<RunInput>): Promise<string>;\n\n  /**\n   * Format the prompt given the input values and return a formatted prompt value.\n   * @param values\n   * @returns A formatted PromptValue.\n   */\n  abstract formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<RunOutput>;\n\n  /**\n   * Return the string type key uniquely identifying this class of prompt template.\n   */\n  abstract _getPromptType(): string;\n}\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport type { InputValues } from \"../utils/types/index.js\";\nimport {\n  type StringPromptValueInterface,\n  StringPromptValue,\n} from \"../prompt_values.js\";\nimport { BasePromptTemplate, type TypedPromptInputValues } from \"./base.js\";\n\n/**\n * Base class for string prompt templates. It extends the\n * BasePromptTemplate class and overrides the formatPromptValue method to\n * return a StringPromptValue.\n */\nexport abstract class BaseStringPromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n> extends BasePromptTemplate<\n  RunInput,\n  StringPromptValueInterface,\n  PartialVariableName\n> {\n  /**\n   * Formats the prompt given the input values and returns a formatted\n   * prompt value.\n   * @param values The input values to format the prompt.\n   * @returns A Promise that resolves to a formatted prompt value.\n   */\n  async formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<StringPromptValueInterface> {\n    const formattedPrompt = await this.format(values);\n    return new StringPromptValue(formattedPrompt);\n  }\n}\n", "/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\nvar objectToString = Object.prototype.toString;\nvar isArray = Array.isArray || function isArrayPolyfill (object) {\n  return objectToString.call(object) === '[object Array]';\n};\n\nfunction isFunction (object) {\n  return typeof object === 'function';\n}\n\n/**\n * More correct typeof string handling array\n * which normally returns typeof 'object'\n */\nfunction typeStr (obj) {\n  return isArray(obj) ? 'array' : typeof obj;\n}\n\nfunction escapeRegExp (string) {\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n/**\n * Null safe way of checking whether or not an object,\n * including its prototype, has a given property\n */\nfunction hasProperty (obj, propName) {\n  return obj != null && typeof obj === 'object' && (propName in obj);\n}\n\n/**\n * Safe way of detecting whether or not the given thing is a primitive and\n * whether it has the given property\n */\nfunction primitiveHasOwnProperty (primitive, propName) {\n  return (\n    primitive != null\n    && typeof primitive !== 'object'\n    && primitive.hasOwnProperty\n    && primitive.hasOwnProperty(propName)\n  );\n}\n\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n// See https://github.com/janl/mustache.js/issues/189\nvar regExpTest = RegExp.prototype.test;\nfunction testRegExp (re, string) {\n  return regExpTest.call(re, string);\n}\n\nvar nonSpaceRe = /\\S/;\nfunction isWhitespace (string) {\n  return !testRegExp(nonSpaceRe, string);\n}\n\nvar entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;'\n};\n\nfunction escapeHtml (string) {\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n    return entityMap[s];\n  });\n}\n\nvar whiteRe = /\\s*/;\nvar spaceRe = /\\s+/;\nvar equalsRe = /\\s*=/;\nvar curlyRe = /\\s*\\}/;\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n/**\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\n * argument is given here it must be an array with two string values: the\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n * course, the default is to use mustaches (i.e. mustache.tags).\n *\n * A token is an array with at least 4 elements. The first element is the\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n * all text that appears outside a symbol this element is \"text\".\n *\n * The second element of a token is its \"value\". For mustache tags this is\n * whatever else was inside the tag besides the opening symbol. For text tokens\n * this is the text itself.\n *\n * The third and fourth elements of the token are the start and end indices,\n * respectively, of the token in the original template.\n *\n * Tokens that are the root node of a subtree contain two more elements: 1) an\n * array of tokens in the subtree and 2) the index in the original template at\n * which the closing tag for that section begins.\n *\n * Tokens for partials also contain two more elements: 1) a string value of\n * indendation prior to that tag and 2) the index of that tag on that line -\n * eg a value of 2 indicates the partial is the third tag on this line.\n */\nfunction parseTemplate (template, tags) {\n  if (!template)\n    return [];\n  var lineHasNonSpace = false;\n  var sections = [];     // Stack to hold section tokens\n  var tokens = [];       // Buffer to hold the tokens\n  var spaces = [];       // Indices of whitespace tokens on the current line\n  var hasTag = false;    // Is there a {{tag}} on the current line?\n  var nonSpace = false;  // Is there a non-space char on the current line?\n  var indentation = '';  // Tracks indentation for tags that use it\n  var tagIndex = 0;      // Stores a count of number of tags encountered on a line\n\n  // Strips all whitespace tokens array for the current line\n  // if there was a {{#tag}} on it and otherwise only space.\n  function stripSpace () {\n    if (hasTag && !nonSpace) {\n      while (spaces.length)\n        delete tokens[spaces.pop()];\n    } else {\n      spaces = [];\n    }\n\n    hasTag = false;\n    nonSpace = false;\n  }\n\n  var openingTagRe, closingTagRe, closingCurlyRe;\n  function compileTags (tagsToCompile) {\n    if (typeof tagsToCompile === 'string')\n      tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n      throw new Error('Invalid tags: ' + tagsToCompile);\n\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n  }\n\n  compileTags(tags || mustache.tags);\n\n  var scanner = new Scanner(template);\n\n  var start, type, value, chr, token, openSection;\n  while (!scanner.eos()) {\n    start = scanner.pos;\n\n    // Match any text between tags.\n    value = scanner.scanUntil(openingTagRe);\n\n    if (value) {\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n        chr = value.charAt(i);\n\n        if (isWhitespace(chr)) {\n          spaces.push(tokens.length);\n          indentation += chr;\n        } else {\n          nonSpace = true;\n          lineHasNonSpace = true;\n          indentation += ' ';\n        }\n\n        tokens.push([ 'text', chr, start, start + 1 ]);\n        start += 1;\n\n        // Check for whitespace on the current line.\n        if (chr === '\\n') {\n          stripSpace();\n          indentation = '';\n          tagIndex = 0;\n          lineHasNonSpace = false;\n        }\n      }\n    }\n\n    // Match the opening tag.\n    if (!scanner.scan(openingTagRe))\n      break;\n\n    hasTag = true;\n\n    // Get the tag type.\n    type = scanner.scan(tagRe) || 'name';\n    scanner.scan(whiteRe);\n\n    // Get the tag value.\n    if (type === '=') {\n      value = scanner.scanUntil(equalsRe);\n      scanner.scan(equalsRe);\n      scanner.scanUntil(closingTagRe);\n    } else if (type === '{') {\n      value = scanner.scanUntil(closingCurlyRe);\n      scanner.scan(curlyRe);\n      scanner.scanUntil(closingTagRe);\n      type = '&';\n    } else {\n      value = scanner.scanUntil(closingTagRe);\n    }\n\n    // Match the closing tag.\n    if (!scanner.scan(closingTagRe))\n      throw new Error('Unclosed tag at ' + scanner.pos);\n\n    if (type == '>') {\n      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\n    } else {\n      token = [ type, value, start, scanner.pos ];\n    }\n    tagIndex++;\n    tokens.push(token);\n\n    if (type === '#' || type === '^') {\n      sections.push(token);\n    } else if (type === '/') {\n      // Check section nesting.\n      openSection = sections.pop();\n\n      if (!openSection)\n        throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n      if (openSection[1] !== value)\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n    } else if (type === 'name' || type === '{' || type === '&') {\n      nonSpace = true;\n    } else if (type === '=') {\n      // Set the tags for the next time around.\n      compileTags(value);\n    }\n  }\n\n  stripSpace();\n\n  // Make sure there are no open sections when we're done.\n  openSection = sections.pop();\n\n  if (openSection)\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n  return nestTokens(squashTokens(tokens));\n}\n\n/**\n * Combines the values of consecutive text tokens in the given `tokens` array\n * to a single token.\n */\nfunction squashTokens (tokens) {\n  var squashedTokens = [];\n\n  var token, lastToken;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    if (token) {\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n      } else {\n        squashedTokens.push(token);\n        lastToken = token;\n      }\n    }\n  }\n\n  return squashedTokens;\n}\n\n/**\n * Forms the given array of `tokens` into a nested tree structure where\n * tokens that represent a section have two additional items: 1) an array of\n * all tokens that appear in that section and 2) the index in the original\n * template that represents the end of that section.\n */\nfunction nestTokens (tokens) {\n  var nestedTokens = [];\n  var collector = nestedTokens;\n  var sections = [];\n\n  var token, section;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case '#':\n      case '^':\n        collector.push(token);\n        sections.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n        break;\n      default:\n        collector.push(token);\n    }\n  }\n\n  return nestedTokens;\n}\n\n/**\n * A simple string scanner that is used by the template parser to find\n * tokens in template strings.\n */\nfunction Scanner (string) {\n  this.string = string;\n  this.tail = string;\n  this.pos = 0;\n}\n\n/**\n * Returns `true` if the tail is empty (end of string).\n */\nScanner.prototype.eos = function eos () {\n  return this.tail === '';\n};\n\n/**\n * Tries to match the given regular expression at the current position.\n * Returns the matched text if it can match, the empty string otherwise.\n */\nScanner.prototype.scan = function scan (re) {\n  var match = this.tail.match(re);\n\n  if (!match || match.index !== 0)\n    return '';\n\n  var string = match[0];\n\n  this.tail = this.tail.substring(string.length);\n  this.pos += string.length;\n\n  return string;\n};\n\n/**\n * Skips all text until the given regular expression can be matched. Returns\n * the skipped string, which is the entire tail if no match can be made.\n */\nScanner.prototype.scanUntil = function scanUntil (re) {\n  var index = this.tail.search(re), match;\n\n  switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = '';\n      break;\n    case 0:\n      match = '';\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n  }\n\n  this.pos += match.length;\n\n  return match;\n};\n\n/**\n * Represents a rendering context by wrapping a view object and\n * maintaining a reference to the parent context.\n */\nfunction Context (view, parentContext) {\n  this.view = view;\n  this.cache = { '.': this.view };\n  this.parent = parentContext;\n}\n\n/**\n * Creates a new context using the given view with this context\n * as the parent.\n */\nContext.prototype.push = function push (view) {\n  return new Context(view, this);\n};\n\n/**\n * Returns the value of the given name in this context, traversing\n * up the context hierarchy if the value is absent in this context's view.\n */\nContext.prototype.lookup = function lookup (name) {\n  var cache = this.cache;\n\n  var value;\n  if (cache.hasOwnProperty(name)) {\n    value = cache[name];\n  } else {\n    var context = this, intermediateValue, names, index, lookupHit = false;\n\n    while (context) {\n      if (name.indexOf('.') > 0) {\n        intermediateValue = context.view;\n        names = name.split('.');\n        index = 0;\n\n        /**\n         * Using the dot notion path in `name`, we descend through the\n         * nested objects.\n         *\n         * To be certain that the lookup has been successful, we have to\n         * check if the last object in the path actually has the property\n         * we are looking for. We store the result in `lookupHit`.\n         *\n         * This is specially necessary for when the value has been set to\n         * `undefined` and we want to avoid looking up parent contexts.\n         *\n         * In the case where dot notation is used, we consider the lookup\n         * to be successful even if the last \"object\" in the path is\n         * not actually an object but a primitive (e.g., a string, or an\n         * integer), because it is sometimes useful to access a property\n         * of an autoboxed primitive, such as the length of a string.\n         **/\n        while (intermediateValue != null && index < names.length) {\n          if (index === names.length - 1)\n            lookupHit = (\n              hasProperty(intermediateValue, names[index])\n              || primitiveHasOwnProperty(intermediateValue, names[index])\n            );\n\n          intermediateValue = intermediateValue[names[index++]];\n        }\n      } else {\n        intermediateValue = context.view[name];\n\n        /**\n         * Only checking against `hasProperty`, which always returns `false` if\n         * `context.view` is not an object. Deliberately omitting the check\n         * against `primitiveHasOwnProperty` if dot notation is not used.\n         *\n         * Consider this example:\n         * ```\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n         * ```\n         *\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\n         * in the dot notation case, then render call would return:\n         *\n         * \"The length of a football field is 9.\"\n         *\n         * rather than the expected:\n         *\n         * \"The length of a football field is 100 yards.\"\n         **/\n        lookupHit = hasProperty(context.view, name);\n      }\n\n      if (lookupHit) {\n        value = intermediateValue;\n        break;\n      }\n\n      context = context.parent;\n    }\n\n    cache[name] = value;\n  }\n\n  if (isFunction(value))\n    value = value.call(this.view);\n\n  return value;\n};\n\n/**\n * A Writer knows how to take a stream of tokens and render them to a\n * string, given a context. It also maintains a cache of templates to\n * avoid the need to parse the same template twice.\n */\nfunction Writer () {\n  this.templateCache = {\n    _cache: {},\n    set: function set (key, value) {\n      this._cache[key] = value;\n    },\n    get: function get (key) {\n      return this._cache[key];\n    },\n    clear: function clear () {\n      this._cache = {};\n    }\n  };\n}\n\n/**\n * Clears all cached templates in this writer.\n */\nWriter.prototype.clearCache = function clearCache () {\n  if (typeof this.templateCache !== 'undefined') {\n    this.templateCache.clear();\n  }\n};\n\n/**\n * Parses and caches the given `template` according to the given `tags` or\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n * that is generated from the parse.\n */\nWriter.prototype.parse = function parse (template, tags) {\n  var cache = this.templateCache;\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n  var isCacheEnabled = typeof cache !== 'undefined';\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\n\n  if (tokens == undefined) {\n    tokens = parseTemplate(template, tags);\n    isCacheEnabled && cache.set(cacheKey, tokens);\n  }\n  return tokens;\n};\n\n/**\n * High-level method that is used to render the given `template` with\n * the given `view`.\n *\n * The optional `partials` argument may be an object that contains the\n * names and templates of partials that are used in the template. It may\n * also be a function that is used to load partial templates on the fly\n * that takes a single argument: the name of the partial.\n *\n * If the optional `config` argument is given here, then it should be an\n * object with a `tags` attribute or an `escape` attribute or both.\n * If an array is passed, then it will be interpreted the same way as\n * a `tags` attribute on a `config` object.\n *\n * The `tags` attribute of a `config` object must be an array with two\n * string values: the opening and closing tags used in the template (e.g.\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n *\n * The `escape` attribute of a `config` object must be a function which\n * accepts a string as input and outputs a safely escaped string.\n * If an `escape` function is not provided, then an HTML-safe string\n * escaping function is used as the default.\n */\nWriter.prototype.render = function render (template, view, partials, config) {\n  var tags = this.getConfigTags(config);\n  var tokens = this.parse(template, tags);\n  var context = (view instanceof Context) ? view : new Context(view, undefined);\n  return this.renderTokens(tokens, context, partials, template, config);\n};\n\n/**\n * Low-level method that renders the given array of `tokens` using\n * the given `context` and `partials`.\n *\n * Note: The `originalTemplate` is only ever used to extract the portion\n * of the original template that was contained in a higher-order section.\n * If the template doesn't use higher-order sections, this argument may\n * be omitted.\n */\nWriter.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {\n  var buffer = '';\n\n  var token, symbol, value;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    value = undefined;\n    token = tokens[i];\n    symbol = token[0];\n\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\n    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\n    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\n    else if (symbol === '&') value = this.unescapedValue(token, context);\n    else if (symbol === 'name') value = this.escapedValue(token, context, config);\n    else if (symbol === 'text') value = this.rawValue(token);\n\n    if (value !== undefined)\n      buffer += value;\n  }\n\n  return buffer;\n};\n\nWriter.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {\n  var self = this;\n  var buffer = '';\n  var value = context.lookup(token[1]);\n\n  // This function is used to render an arbitrary template\n  // in the current context by higher-order sections.\n  function subRender (template) {\n    return self.render(template, context, partials, config);\n  }\n\n  if (!value) return;\n\n  if (isArray(value)) {\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\n    }\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\n  } else if (isFunction(value)) {\n    if (typeof originalTemplate !== 'string')\n      throw new Error('Cannot use higher-order sections without the original template');\n\n    // Extract the portion of the original template that the section contains.\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n    if (value != null)\n      buffer += value;\n  } else {\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\n  }\n  return buffer;\n};\n\nWriter.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {\n  var value = context.lookup(token[1]);\n\n  // Use JavaScript's definition of falsy. Include empty arrays.\n  // See https://github.com/janl/mustache.js/issues/186\n  if (!value || (isArray(value) && value.length === 0))\n    return this.renderTokens(token[4], context, partials, originalTemplate, config);\n};\n\nWriter.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\n  var partialByNl = partial.split('\\n');\n  for (var i = 0; i < partialByNl.length; i++) {\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n      partialByNl[i] = filteredIndentation + partialByNl[i];\n    }\n  }\n  return partialByNl.join('\\n');\n};\n\nWriter.prototype.renderPartial = function renderPartial (token, context, partials, config) {\n  if (!partials) return;\n  var tags = this.getConfigTags(config);\n\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n  if (value != null) {\n    var lineHasNonSpace = token[6];\n    var tagIndex = token[5];\n    var indentation = token[4];\n    var indentedValue = value;\n    if (tagIndex == 0 && indentation) {\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n    }\n    var tokens = this.parse(indentedValue, tags);\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\n  }\n};\n\nWriter.prototype.unescapedValue = function unescapedValue (token, context) {\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return value;\n};\n\nWriter.prototype.escapedValue = function escapedValue (token, context, config) {\n  var escape = this.getConfigEscape(config) || mustache.escape;\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\n};\n\nWriter.prototype.rawValue = function rawValue (token) {\n  return token[1];\n};\n\nWriter.prototype.getConfigTags = function getConfigTags (config) {\n  if (isArray(config)) {\n    return config;\n  }\n  else if (config && typeof config === 'object') {\n    return config.tags;\n  }\n  else {\n    return undefined;\n  }\n};\n\nWriter.prototype.getConfigEscape = function getConfigEscape (config) {\n  if (config && typeof config === 'object' && !isArray(config)) {\n    return config.escape;\n  }\n  else {\n    return undefined;\n  }\n};\n\nvar mustache = {\n  name: 'mustache.js',\n  version: '4.2.0',\n  tags: [ '{{', '}}' ],\n  clearCache: undefined,\n  escape: undefined,\n  parse: undefined,\n  render: undefined,\n  Scanner: undefined,\n  Context: undefined,\n  Writer: undefined,\n  /**\n   * Allows a user to override the default caching strategy, by providing an\n   * object with set, get and clear methods. This can also be used to disable\n   * the cache by setting it to the literal `undefined`.\n   */\n  set templateCache (cache) {\n    defaultWriter.templateCache = cache;\n  },\n  /**\n   * Gets the default or overridden caching object from the default writer.\n   */\n  get templateCache () {\n    return defaultWriter.templateCache;\n  }\n};\n\n// All high-level mustache.* functions use this writer.\nvar defaultWriter = new Writer();\n\n/**\n * Clears all cached templates in the default writer.\n */\nmustache.clearCache = function clearCache () {\n  return defaultWriter.clearCache();\n};\n\n/**\n * Parses and caches the given template in the default writer and returns the\n * array of tokens it contains. Doing this ahead of time avoids the need to\n * parse templates on the fly as they are rendered.\n */\nmustache.parse = function parse (template, tags) {\n  return defaultWriter.parse(template, tags);\n};\n\n/**\n * Renders the `template` with the given `view`, `partials`, and `config`\n * using the default writer.\n */\nmustache.render = function render (template, view, partials, config) {\n  if (typeof template !== 'string') {\n    throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                        'but \"' + typeStr(template) + '\" was given as the first ' +\n                        'argument for mustache#render(template, view, partials)');\n  }\n\n  return defaultWriter.render(template, view, partials, config);\n};\n\n// Export the escaping function so that the user may override it.\n// See https://github.com/janl/mustache.js/issues/244\nmustache.escape = escapeHtml;\n\n// Export these mainly for testing, but also for advanced usage.\nmustache.Scanner = Scanner;\nmustache.Context = Context;\nmustache.Writer = Writer;\n\nexport default mustache;\n", "import mustache from \"mustache\";\nimport { MessageContent } from \"../messages/index.js\";\nimport type { InputValues } from \"../utils/types/index.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n\nfunction configureMustache() {\n  // Use unescaped HTML\n  // https://github.com/janl/mustache.js?tab=readme-ov-file#variables\n  mustache.escape = (text) => text;\n}\n\n/**\n * Type that specifies the format of a template.\n */\nexport type TemplateFormat = \"f-string\" | \"mustache\";\n\n/**\n * Type that represents a node in a parsed format string. It can be either\n * a literal text or a variable name.\n */\nexport type ParsedTemplateNode =\n  | { type: \"literal\"; text: string }\n  | { type: \"variable\"; name: string };\n\n/**\n * Alias for `ParsedTemplateNode` since it is the same for\n * both f-string and mustache templates.\n */\nexport type ParsedFStringNode = ParsedTemplateNode;\n\nexport const parseFString = (template: string): ParsedTemplateNode[] => {\n  // Core logic replicated from internals of pythons built in Formatter class.\n  // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n  const chars = template.split(\"\");\n  const nodes: ParsedTemplateNode[] = [];\n\n  const nextBracket = (bracket: \"}\" | \"{\" | \"{}\", start: number) => {\n    for (let i = start; i < chars.length; i += 1) {\n      if (bracket.includes(chars[i])) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  let i = 0;\n  while (i < chars.length) {\n    if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n      nodes.push({ type: \"literal\", text: \"{\" });\n      i += 2;\n    } else if (\n      chars[i] === \"}\" &&\n      i + 1 < chars.length &&\n      chars[i + 1] === \"}\"\n    ) {\n      nodes.push({ type: \"literal\", text: \"}\" });\n      i += 2;\n    } else if (chars[i] === \"{\") {\n      const j = nextBracket(\"}\", i);\n      if (j < 0) {\n        throw new Error(\"Unclosed '{' in template.\");\n      }\n\n      nodes.push({\n        type: \"variable\",\n        name: chars.slice(i + 1, j).join(\"\"),\n      });\n      i = j + 1;\n    } else if (chars[i] === \"}\") {\n      throw new Error(\"Single '}' in template.\");\n    } else {\n      const next = nextBracket(\"{}\", i);\n      const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n      nodes.push({ type: \"literal\", text });\n      i = next < 0 ? chars.length : next;\n    }\n  }\n  return nodes;\n};\n\n/**\n * Convert the result of mustache.parse into an array of ParsedTemplateNode,\n * to make it compatible with other LangChain string parsing template formats.\n *\n * @param {mustache.TemplateSpans} template The result of parsing a mustache template with the mustache.js library.\n * @param {string[]} context Array of section variable names for nested context\n * @returns {ParsedTemplateNode[]}\n */\nconst mustacheTemplateToNodes = (\n  template: mustache.TemplateSpans,\n  context: string[] = []\n): ParsedTemplateNode[] => {\n  const nodes: ParsedTemplateNode[] = [];\n\n  for (const temp of template) {\n    if (temp[0] === \"name\") {\n      const name = temp[1].includes(\".\") ? temp[1].split(\".\")[0] : temp[1];\n      nodes.push({ type: \"variable\", name });\n    } else if ([\"#\", \"&\", \"^\", \">\"].includes(temp[0])) {\n      // # represents a section, \"&\" represents an unescaped variable.\n      // These should both be considered variables.\n      nodes.push({ type: \"variable\", name: temp[1] });\n\n      // If this is a section with nested content, recursively process it\n      if (temp[0] === \"#\" && temp.length > 4 && Array.isArray(temp[4])) {\n        const newContext = [...context, temp[1]];\n        const nestedNodes = mustacheTemplateToNodes(temp[4], newContext);\n        nodes.push(...nestedNodes);\n      }\n    } else {\n      nodes.push({ type: \"literal\", text: temp[1] });\n    }\n  }\n\n  return nodes;\n};\n\nexport const parseMustache = (template: string) => {\n  configureMustache();\n  const parsed = mustache.parse(template);\n  return mustacheTemplateToNodes(parsed);\n};\n\nexport const interpolateFString = (template: string, values: InputValues) => {\n  return parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n      if (node.name in values) {\n        const stringValue =\n          typeof values[node.name] === \"string\"\n            ? values[node.name]\n            : JSON.stringify(values[node.name]);\n        return res + stringValue;\n      }\n      throw new Error(`(f-string) Missing value for input ${node.name}`);\n    }\n\n    return res + node.text;\n  }, \"\");\n};\n\nexport const interpolateMustache = (template: string, values: InputValues) => {\n  configureMustache();\n  return mustache.render(template, values);\n};\n\n/**\n * Type that represents a function that takes a template string and a set\n * of input values, and returns a string where all variables in the\n * template have been replaced with their corresponding values.\n */\ntype Interpolator = (template: string, values: InputValues) => string;\n\n/**\n * Type that represents a function that takes a template string and\n * returns an array of `ParsedTemplateNode`.\n */\ntype Parser = (template: string) => ParsedTemplateNode[];\n\nexport const DEFAULT_FORMATTER_MAPPING: Record<TemplateFormat, Interpolator> = {\n  \"f-string\": interpolateFString,\n  mustache: interpolateMustache,\n};\n\nexport const DEFAULT_PARSER_MAPPING: Record<TemplateFormat, Parser> = {\n  \"f-string\": parseFString,\n  mustache: parseMustache,\n};\n\nexport const renderTemplate = (\n  template: string,\n  templateFormat: TemplateFormat,\n  inputValues: InputValues\n) => {\n  try {\n    return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\n  } catch (e) {\n    const error = addLangChainErrorFields(e, \"INVALID_PROMPT_INPUT\");\n    throw error;\n  }\n};\n\nexport const parseTemplate = (\n  template: string,\n  templateFormat: TemplateFormat\n) => DEFAULT_PARSER_MAPPING[templateFormat](template);\n\nexport const checkValidTemplate = (\n  template: MessageContent,\n  templateFormat: TemplateFormat,\n  inputVariables: string[]\n) => {\n  if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n    const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n    throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n  }\n  try {\n    // Build dummy inputs using Object.fromEntries to avoid prototype pollution\n    // from dynamic property assignment with user-provided keys\n    const dummyInputs: InputValues = Object.fromEntries(\n      inputVariables.map((v) => [v, \"foo\"])\n    );\n    if (Array.isArray(template)) {\n      template.forEach((message) => {\n        if (\n          message.type === \"text\" &&\n          \"text\" in message &&\n          typeof message.text === \"string\"\n        ) {\n          renderTemplate(message.text, templateFormat, dummyInputs);\n        } else if (message.type === \"image_url\") {\n          if (typeof message.image_url === \"string\") {\n            renderTemplate(message.image_url, templateFormat, dummyInputs);\n          } else if (\n            typeof message.image_url === \"object\" &&\n            message.image_url !== null &&\n            \"url\" in message.image_url &&\n            typeof message.image_url.url === \"string\"\n          ) {\n            const imageUrl = message.image_url.url;\n            renderTemplate(imageUrl, templateFormat, dummyInputs);\n          }\n        } else {\n          throw new Error(\n            `Invalid message template received. ${JSON.stringify(\n              message,\n              null,\n              2\n            )}`\n          );\n        }\n      });\n    } else {\n      renderTemplate(template, templateFormat, dummyInputs);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e: any) {\n    throw new Error(`Invalid prompt schema: ${e.message}`);\n  }\n};\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport type {\n  BasePromptTemplateInput,\n  TypedPromptInputValues,\n} from \"./base.js\";\nimport {\n  checkValidTemplate,\n  parseTemplate,\n  renderTemplate,\n  type TemplateFormat,\n} from \"./template.js\";\nimport type { SerializedPromptTemplate } from \"./serde.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport { MessageContent, ContentBlock } from \"../messages/index.js\";\n\n/**\n * Inputs to create a {@link PromptTemplate}\n * @augments BasePromptTemplateInput\n */\nexport interface PromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n  Format extends TemplateFormat = TemplateFormat,\n> extends BasePromptTemplateInput<RunInput, PartialVariableName> {\n  /**\n   * The prompt template\n   */\n  template: MessageContent;\n\n  /**\n   * The format of the prompt template. Options are \"f-string\" and \"mustache\"\n   */\n  templateFormat?: Format;\n\n  /**\n   * Whether or not to try validating the template on initialization\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n}\n\ntype NonAlphanumeric =\n  | \" \"\n  | \"\\t\"\n  | \"\\n\"\n  | \"\\r\"\n  | '\"'\n  | \"'\"\n  | \"{\"\n  | \"[\"\n  | \"(\"\n  | \"`\"\n  | \":\"\n  | \";\";\n\n/**\n * Recursive type to extract template parameters from a string.\n * @template T - The input string.\n * @template Result - The resulting array of extracted template parameters.\n */\ntype ExtractTemplateParamsRecursive<\n  T extends string,\n  Result extends string[] = [],\n> = T extends `${string}{${infer Param}}${infer Rest}`\n  ? Param extends `${NonAlphanumeric}${string}`\n    ? ExtractTemplateParamsRecursive<Rest, Result> // for non-template variables that look like template variables e.g. see https://github.com/langchain-ai/langchainjs/blob/main/langchain/src/chains/query_constructor/prompt.ts\n    : ExtractTemplateParamsRecursive<Rest, [...Result, Param]>\n  : Result;\n\nexport type ParamsFromFString<T extends string> = {\n  [Key in\n    | ExtractTemplateParamsRecursive<T>[number]\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | (string & Record<never, never>)]: any;\n};\n\nexport type ExtractedFStringParams<\n  T extends string,\n  RunInput extends InputValues = Symbol,\n> = RunInput extends Symbol ? ParamsFromFString<T> : RunInput;\n\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any,\n  >\n  extends BaseStringPromptTemplate<RunInput, PartialVariableName>\n  implements PromptTemplateInput<RunInput, PartialVariableName>\n{\n  static lc_name() {\n    return \"PromptTemplate\";\n  }\n\n  template: MessageContent;\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n\n  constructor(input: PromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n    // If input is mustache and validateTemplate is not defined, set it to false\n    if (\n      input.templateFormat === \"mustache\" &&\n      input.validateTemplate === undefined\n    ) {\n      this.validateTemplate = false;\n    }\n    Object.assign(this, input);\n\n    if (this.validateTemplate) {\n      if (this.templateFormat === \"mustache\") {\n        throw new Error(\"Mustache templates cannot be validated.\");\n      }\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        this.template,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  _getPromptType(): \"prompt\" {\n    return \"prompt\";\n  }\n\n  /**\n   * Formats the prompt template with the provided values.\n   * @param values The values to be used to format the prompt template.\n   * @returns A promise that resolves to a string which is the formatted prompt.\n   */\n  async format(values: TypedPromptInputValues<RunInput>): Promise<string> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    return renderTemplate(\n      this.template as string,\n      this.templateFormat,\n      allValues\n    );\n  }\n\n  /**\n   * Take examples in list format with prefix and suffix to create a prompt.\n   *\n   * Intended to be used a a way to dynamically create a prompt from examples.\n   *\n   * @param examples - List of examples to use in the prompt.\n   * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n   * @param inputVariables - A list of variable names the final prompt template will expect\n   * @param exampleSeparator - The separator to use in between examples\n   * @param prefix - String that should go before any examples. Generally includes examples.\n   *\n   * @returns The final prompt template generated.\n   */\n  static fromExamples(\n    examples: string[],\n    suffix: string,\n    inputVariables: string[],\n    exampleSeparator = \"\\n\\n\",\n    prefix = \"\"\n  ) {\n    const template = [prefix, ...examples, suffix].join(exampleSeparator);\n    return new PromptTemplate({\n      inputVariables,\n      template,\n    });\n  }\n\n  /**\n   * Load prompt template from a template f-string\n   */\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string,\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"f-string\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string,\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string>,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string,\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"mustache\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<InputValues>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string,\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<ExtractedFStringParams<T, RunInput> | InputValues> {\n    const { templateFormat = \"f-string\", ...rest } = options ?? {};\n    const names = new Set<string>();\n    parseTemplate(template, templateFormat).forEach((node) => {\n      if (node.type === \"variable\") {\n        names.add(node.name);\n      }\n    });\n\n    return new PromptTemplate({\n      // Rely on extracted types\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      inputVariables: [...names] as any[],\n      templateFormat,\n      template,\n      ...rest,\n    });\n  }\n\n  /**\n   * Partially applies values to the prompt template.\n   * @param values The values to be partially applied to the prompt template.\n   * @returns A new instance of PromptTemplate with the partially applied values.\n   */\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    ) as Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | NewPartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new PromptTemplate<\n      InputValues<\n        Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>\n      >\n    >(promptDict);\n  }\n\n  serialize(): SerializedPromptTemplate {\n    if (this.outputParser !== undefined) {\n      throw new Error(\n        \"Cannot serialize a prompt template with an output parser\"\n      );\n    }\n    return {\n      _type: this._getPromptType(),\n      input_variables: this.inputVariables,\n      template: this.template,\n      template_format: this.templateFormat,\n    };\n  }\n\n  static async deserialize(\n    data: SerializedPromptTemplate\n  ): Promise<PromptTemplate> {\n    if (!data.template) {\n      throw new Error(\"Prompt template must have a template\");\n    }\n    const res = new PromptTemplate({\n      inputVariables: data.input_variables,\n      template: data.template,\n      templateFormat: data.template_format,\n    });\n    return res;\n  }\n\n  // TODO(from file)\n}\n", "import { MessageContent, ContentBlock } from \"../messages/index.js\";\nimport { ImagePromptValue, ImageContent } from \"../prompt_values.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport {\n  BasePromptTemplate,\n  BasePromptTemplateInput,\n  TypedPromptInputValues,\n} from \"./base.js\";\nimport {\n  TemplateFormat,\n  checkValidTemplate,\n  renderTemplate,\n} from \"./template.js\";\n\n/**\n * Inputs to create a {@link ImagePromptTemplate}\n * @augments BasePromptTemplateInput\n */\nexport interface ImagePromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n> extends BasePromptTemplateInput<RunInput, PartialVariableName> {\n  /**\n   * The prompt template\n   */\n  template: Record<string, unknown>;\n\n  /**\n   * The format of the prompt template. Options are 'f-string'\n   *\n   * @defaultValue 'f-string'\n   */\n  templateFormat?: TemplateFormat;\n\n  /**\n   * Whether or not to try validating the template on initialization\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n}\n\n/**\n * An image prompt template for a multimodal model.\n */\nexport class ImagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n> extends BasePromptTemplate<RunInput, ImagePromptValue, PartialVariableName> {\n  static lc_name() {\n    return \"ImagePromptTemplate\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"prompts\", \"image\"];\n\n  template: Record<string, unknown>;\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n\n  constructor(input: ImagePromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n    this.template = input.template;\n    this.templateFormat = input.templateFormat ?? this.templateFormat;\n    this.validateTemplate = input.validateTemplate ?? this.validateTemplate;\n    this.additionalContentFields = input.additionalContentFields;\n\n    if (this.validateTemplate) {\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        [\n          { type: \"image_url\", image_url: this.template },\n        ] as unknown as MessageContent,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  _getPromptType(): \"prompt\" {\n    return \"prompt\";\n  }\n\n  /**\n   * Partially applies values to the prompt template.\n   * @param values The values to be partially applied to the prompt template.\n   * @returns A new instance of ImagePromptTemplate with the partially applied values.\n   */\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    ) as Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | NewPartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new ImagePromptTemplate<\n      InputValues<\n        Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>\n      >\n    >(promptDict);\n  }\n\n  /**\n   * Formats the prompt template with the provided values.\n   * @param values The values to be used to format the prompt template.\n   * @returns A promise that resolves to a string which is the formatted prompt.\n   */\n  async format<FormatOutput = ImageContent>(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<FormatOutput> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const formatted: Record<string, any> = {};\n    for (const [key, value] of Object.entries(this.template)) {\n      if (typeof value === \"string\") {\n        formatted[key] = renderTemplate(value, this.templateFormat, values);\n      } else {\n        formatted[key] = value;\n      }\n    }\n    const url = values.url || formatted.url;\n    const detail = values.detail || formatted.detail;\n    if (!url) {\n      throw new Error(\"Must provide either an image URL.\");\n    }\n    if (typeof url !== \"string\") {\n      throw new Error(\"url must be a string.\");\n    }\n    const output: ImageContent = { url };\n    if (detail) {\n      output.detail = detail;\n    }\n    return output as FormatOutput;\n  }\n\n  /**\n   * Formats the prompt given the input values and returns a formatted\n   * prompt value.\n   * @param values The input values to format the prompt.\n   * @returns A Promise that resolves to a formatted prompt value.\n   */\n  async formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<ImagePromptValue> {\n    const formattedPrompt = await this.format(values);\n    return new ImagePromptValue(formattedPrompt);\n  }\n}\n", "import { Runnable } from \"../runnables/base.js\";\nimport type { InputValues } from \"../utils/types/index.js\";\nimport { TypedPromptInputValues } from \"./base.js\";\nimport { parseTemplate, renderTemplate, TemplateFormat } from \"./template.js\";\n\nexport class DictPromptTemplate<\n  RunInput extends InputValues = InputValues,\n  RunOutput extends Record<string, unknown> = Record<string, unknown>,\n> extends Runnable<TypedPromptInputValues<RunInput>, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"dict\"];\n\n  lc_serializable = true;\n\n  template: Record<string, unknown>;\n\n  templateFormat: TemplateFormat;\n\n  inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  static lc_name() {\n    return \"DictPromptTemplate\";\n  }\n\n  constructor(fields: {\n    template: Record<string, unknown>;\n    templateFormat?: TemplateFormat;\n  }) {\n    const templateFormat = fields.templateFormat ?? \"f-string\";\n    const inputVariables = _getInputVariables(\n      fields.template,\n      templateFormat\n    ) as Array<Extract<keyof RunInput, string>>;\n    super({ inputVariables, ...fields });\n    this.template = fields.template;\n    this.templateFormat = templateFormat;\n    this.inputVariables = inputVariables;\n  }\n\n  async format(values: TypedPromptInputValues<RunInput>): Promise<RunOutput> {\n    return _insertInputVariables(\n      this.template,\n      values,\n      this.templateFormat\n    ) as RunOutput;\n  }\n\n  async invoke(\n    values: TypedPromptInputValues<InputValues>\n  ): Promise<RunOutput> {\n    return await this._callWithConfig(this.format.bind(this), values, {\n      runType: \"prompt\",\n    });\n  }\n}\n\nfunction _getInputVariables(\n  template: Record<string, unknown>,\n  templateFormat: TemplateFormat\n): Array<Extract<keyof InputValues, string>> {\n  const inputVariables: Array<Extract<keyof InputValues, string>> = [];\n  for (const v of Object.values(template)) {\n    if (typeof v === \"string\") {\n      parseTemplate(v, templateFormat).forEach((t) => {\n        if (t.type === \"variable\") {\n          inputVariables.push(t.name);\n        }\n      });\n    } else if (Array.isArray(v)) {\n      for (const x of v) {\n        if (typeof x === \"string\") {\n          parseTemplate(x, templateFormat).forEach((t) => {\n            if (t.type === \"variable\") {\n              inputVariables.push(t.name);\n            }\n          });\n        } else if (typeof x === \"object\") {\n          inputVariables.push(..._getInputVariables(x, templateFormat));\n        }\n      }\n    } else if (typeof v === \"object\" && v !== null) {\n      inputVariables.push(\n        ..._getInputVariables(v as Record<string, unknown>, templateFormat)\n      );\n    }\n  }\n  return Array.from(new Set(inputVariables));\n}\n\nfunction _insertInputVariables(\n  template: Record<string, unknown>,\n  inputs: TypedPromptInputValues<InputValues>,\n  templateFormat: TemplateFormat\n): Record<string, unknown> {\n  const formatted: Record<string, unknown> = {};\n  for (const [k, v] of Object.entries(template)) {\n    if (typeof v === \"string\") {\n      formatted[k] = renderTemplate(v, templateFormat, inputs);\n    } else if (Array.isArray(v)) {\n      const formattedV: Array<unknown> = [];\n      for (const x of v) {\n        if (typeof x === \"string\") {\n          formattedV.push(renderTemplate(x, templateFormat, inputs));\n        } else if (typeof x === \"object\") {\n          formattedV.push(_insertInputVariables(x, inputs, templateFormat));\n        }\n      }\n      formatted[k] = formattedV;\n    } else if (typeof v === \"object\" && v !== null) {\n      formatted[k] = _insertInputVariables(\n        v as Record<string, unknown>,\n        inputs,\n        templateFormat\n      );\n    } else {\n      formatted[k] = v;\n    }\n  }\n  return formatted;\n}\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  AIMessage,\n  HumanMessage,\n  SystemMessage,\n  BaseMessage,\n  ChatMessage,\n  type BaseMessageLike,\n  coerceMessageLikeToMessage,\n  isBaseMessage,\n  MessageContent,\n  ContentBlock,\n} from \"../messages/index.js\";\nimport {\n  type ChatPromptValueInterface,\n  ChatPromptValue,\n} from \"../prompt_values.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport { Runnable } from \"../runnables/base.js\";\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport {\n  BasePromptTemplate,\n  type BasePromptTemplateInput,\n  type TypedPromptInputValues,\n} from \"./base.js\";\nimport {\n  PromptTemplate,\n  type ParamsFromFString,\n  PromptTemplateInput,\n  ExtractedFStringParams,\n} from \"./prompt.js\";\nimport { ImagePromptTemplate } from \"./image.js\";\nimport {\n  ParsedTemplateNode,\n  TemplateFormat,\n  parseFString,\n  parseMustache,\n} from \"./template.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\nimport { DictPromptTemplate } from \"./dict.js\";\n\n/**\n * Abstract class that serves as a base for creating message prompt\n * templates. It defines how to format messages for different roles in a\n * conversation.\n */\nexport abstract class BaseMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  RunOutput extends BaseMessage[] = BaseMessage[],\n> extends Runnable<RunInput, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"chat\"];\n\n  lc_serializable = true;\n\n  abstract inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  /**\n   * Method that takes an object of TypedPromptInputValues and returns a\n   * promise that resolves to an array of BaseMessage instances.\n   * @param values Object of TypedPromptInputValues\n   * @returns Formatted array of BaseMessages\n   */\n  abstract formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<RunOutput>;\n\n  /**\n   * Calls the formatMessages method with the provided input and options.\n   * @param input Input for the formatMessages method\n   * @param options Optional BaseCallbackConfig\n   * @returns Formatted output messages\n   */\n  async invoke(\n    input: RunInput,\n    options?: BaseCallbackConfig\n  ): Promise<RunOutput> {\n    return this._callWithConfig(\n      (input: RunInput) => this.formatMessages(input),\n      input,\n      { ...options, runType: \"prompt\" }\n    );\n  }\n}\n\n/**\n * Interface for the fields of a MessagePlaceholder.\n */\nexport interface MessagesPlaceholderFields<T extends string> {\n  variableName: T;\n  optional?: boolean;\n}\n\n/**\n * Class that represents a placeholder for messages in a chat prompt. It\n * extends the BaseMessagePromptTemplate.\n */\nexport class MessagesPlaceholder<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n  >\n  extends BaseMessagePromptTemplate<RunInput>\n  implements MessagesPlaceholderFields<Extract<keyof RunInput, string>>\n{\n  static lc_name() {\n    return \"MessagesPlaceholder\";\n  }\n\n  variableName: Extract<keyof RunInput, string>;\n\n  optional: boolean;\n\n  constructor(variableName: Extract<keyof RunInput, string>);\n\n  constructor(\n    fields: MessagesPlaceholderFields<Extract<keyof RunInput, string>>\n  );\n\n  constructor(\n    fields:\n      | Extract<keyof RunInput, string>\n      | MessagesPlaceholderFields<Extract<keyof RunInput, string>>\n  ) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      fields = { variableName: fields };\n    }\n    super(fields);\n    this.variableName = fields.variableName;\n    this.optional = fields.optional ?? false;\n  }\n\n  get inputVariables() {\n    return [this.variableName];\n  }\n\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    const input = values[this.variableName];\n    if (this.optional && !input) {\n      return [];\n    } else if (!input) {\n      const error = new Error(\n        `Field \"${this.variableName}\" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`\n      );\n      error.name = \"InputFormatError\";\n      throw error;\n    }\n\n    let formattedMessages;\n    try {\n      if (Array.isArray(input)) {\n        formattedMessages = input.map(coerceMessageLikeToMessage);\n      } else {\n        formattedMessages = [coerceMessageLikeToMessage(input)];\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      const readableInput =\n        typeof input === \"string\" ? input : JSON.stringify(input, null, 2);\n      const error = new Error(\n        [\n          `Field \"${this.variableName}\" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,\n          `Received value: ${readableInput}`,\n          `Additional message: ${e.message}`,\n        ].join(\"\\n\\n\")\n      );\n      error.name = \"InputFormatError\";\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (error as any).lc_error_code = e.lc_error_code;\n      throw error;\n    }\n\n    return formattedMessages;\n  }\n}\n\n/**\n * Interface for the fields of a MessageStringPromptTemplate.\n */\nexport interface MessageStringPromptTemplateFields<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends InputValues = any,\n> {\n  prompt: BaseStringPromptTemplate<T, string>;\n}\n\n/**\n * Abstract class that serves as a base for creating message string prompt\n * templates. It extends the BaseMessagePromptTemplate.\n */\nexport abstract class BaseMessageStringPromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n> extends BaseMessagePromptTemplate<RunInput> {\n  prompt: BaseStringPromptTemplate<\n    InputValues<Extract<keyof RunInput, string>>,\n    string\n  >;\n\n  constructor(\n    prompt: BaseStringPromptTemplate<\n      InputValues<Extract<keyof RunInput, string>>\n    >\n  );\n\n  constructor(\n    fields: MessageStringPromptTemplateFields<\n      InputValues<Extract<keyof RunInput, string>>\n    >\n  );\n\n  constructor(\n    fields:\n      | MessageStringPromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<\n          InputValues<Extract<keyof RunInput, string>>,\n          string\n        >\n  ) {\n    if (!(\"prompt\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { prompt: fields };\n    }\n    super(fields);\n    this.prompt = fields.prompt;\n  }\n\n  get inputVariables() {\n    return this.prompt.inputVariables;\n  }\n\n  abstract format(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage>;\n\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    return [await this.format(values)];\n  }\n}\n\n/**\n * Abstract class that serves as a base for creating chat prompt\n * templates. It extends the BasePromptTemplate.\n */\nexport abstract class BaseChatPromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n> extends BasePromptTemplate<\n  RunInput,\n  ChatPromptValueInterface,\n  PartialVariableName\n> {\n  constructor(input: BasePromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n  }\n\n  abstract formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]>;\n\n  async format(values: TypedPromptInputValues<RunInput>): Promise<string> {\n    return (await this.formatPromptValue(values)).toString();\n  }\n\n  async formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<ChatPromptValueInterface> {\n    const resultMessages = await this.formatMessages(values);\n    return new ChatPromptValue(resultMessages);\n  }\n}\n\n/**\n * Interface for the fields of a ChatMessagePromptTemplate.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface ChatMessagePromptTemplateFields<T extends InputValues = any>\n  extends MessageStringPromptTemplateFields<T> {\n  role: string;\n}\n\n/**\n * Class that represents a chat message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n */\nexport class ChatMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n> extends BaseMessageStringPromptTemplate<RunInput> {\n  static lc_name() {\n    return \"ChatMessagePromptTemplate\";\n  }\n\n  role: string;\n\n  constructor(\n    prompt: BaseStringPromptTemplate<\n      InputValues<Extract<keyof RunInput, string>>\n    >,\n    role: string\n  );\n\n  constructor(\n    fields: ChatMessagePromptTemplateFields<\n      InputValues<Extract<keyof RunInput, string>>\n    >\n  );\n\n  constructor(\n    fields:\n      | ChatMessagePromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<InputValues<Extract<keyof RunInput, string>>>,\n    role?: string\n  ) {\n    if (!(\"prompt\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { prompt: fields, role: role! };\n    }\n    super(fields);\n    this.role = fields.role;\n  }\n\n  async format(values: RunInput): Promise<BaseMessage> {\n    return new ChatMessage(await this.prompt.format(values), this.role);\n  }\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string,\n  >(template: T, role: string, options?: { templateFormat?: TemplateFormat }) {\n    return new this(\n      PromptTemplate.fromTemplate<RunInput, T>(template, {\n        templateFormat: options?.templateFormat,\n      }),\n      role\n    );\n  }\n}\n\ninterface _TextTemplateParam {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  text?: string | Record<string, any>;\n}\n\nfunction isTextTemplateParam(param: unknown): param is _TextTemplateParam {\n  if (param === null || typeof param !== \"object\" || Array.isArray(param)) {\n    return false;\n  }\n  return (\n    Object.keys(param).length === 1 &&\n    \"text\" in param &&\n    typeof param.text === \"string\"\n  );\n}\n\ninterface _ImageTemplateParam {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  image_url?: string | Record<string, any>;\n}\n\nfunction isImageTemplateParam(param: unknown): param is _ImageTemplateParam {\n  if (param === null || typeof param !== \"object\" || Array.isArray(param)) {\n    return false;\n  }\n  return (\n    \"image_url\" in param &&\n    (typeof param.image_url === \"string\" ||\n      (typeof param.image_url === \"object\" &&\n        param.image_url !== null &&\n        \"url\" in param.image_url &&\n        typeof param.image_url.url === \"string\"))\n  );\n}\n\ntype MessageClass =\n  | typeof HumanMessage\n  | typeof AIMessage\n  | typeof SystemMessage;\n\ntype ChatMessageClass = typeof ChatMessage;\n\ninterface _StringImageMessagePromptTemplateOptions<\n  Format extends TemplateFormat = TemplateFormat,\n> extends Record<string, unknown> {\n  templateFormat?: Format;\n}\n\nclass _StringImageMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  RunOutput extends BaseMessage[] = BaseMessage[],\n> extends BaseMessagePromptTemplate<RunInput, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"chat\"];\n\n  lc_serializable = true;\n\n  inputVariables: Array<Extract<keyof RunInput, string>> = [];\n\n  additionalOptions: _StringImageMessagePromptTemplateOptions = {};\n\n  prompt:\n    | BaseStringPromptTemplate<\n        InputValues<Extract<keyof RunInput, string>>,\n        string\n      >\n    | Array<\n        | BaseStringPromptTemplate<\n            InputValues<Extract<keyof RunInput, string>>,\n            string\n          >\n        | ImagePromptTemplate<\n            InputValues<Extract<keyof RunInput, string>>,\n            string\n          >\n        | MessageStringPromptTemplateFields<\n            InputValues<Extract<keyof RunInput, string>>\n          >\n        | DictPromptTemplate<InputValues<Extract<keyof RunInput, string>>>\n      >;\n\n  protected messageClass?: MessageClass;\n\n  static _messageClass(): MessageClass {\n    throw new Error(\n      \"Can not invoke _messageClass from inside _StringImageMessagePromptTemplate\"\n    );\n  }\n\n  // ChatMessage contains role field, others don't.\n  // Because of this, we have a separate class property for ChatMessage.\n  protected chatMessageClass?: ChatMessageClass;\n\n  constructor(\n    /** @TODO When we come up with a better way to type prompt templates, fix this */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    fields: any,\n    additionalOptions?: _StringImageMessagePromptTemplateOptions\n  ) {\n    if (!(\"prompt\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { prompt: fields };\n    }\n    super(fields);\n    this.prompt = fields.prompt;\n    if (Array.isArray(this.prompt)) {\n      let inputVariables: Extract<keyof RunInput, string>[] = [];\n      this.prompt.forEach((prompt) => {\n        if (\"inputVariables\" in prompt) {\n          inputVariables = inputVariables.concat(prompt.inputVariables);\n        }\n      });\n      this.inputVariables = inputVariables;\n    } else {\n      this.inputVariables = this.prompt.inputVariables;\n    }\n    this.additionalOptions = additionalOptions ?? this.additionalOptions;\n  }\n\n  createMessage(content: MessageContent) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const constructor = this.constructor as any;\n    if (constructor._messageClass()) {\n      const MsgClass = constructor._messageClass();\n      return new MsgClass({ content });\n    } else if (constructor.chatMessageClass) {\n      const MsgClass = constructor.chatMessageClass();\n      // Assuming ChatMessage constructor also takes a content argument\n      return new MsgClass({\n        content,\n        role: this.getRoleFromMessageClass(MsgClass.lc_name()),\n      });\n    } else {\n      throw new Error(\"No message class defined\");\n    }\n  }\n\n  getRoleFromMessageClass(name: string) {\n    switch (name) {\n      case \"HumanMessage\":\n        return \"human\";\n      case \"AIMessage\":\n        return \"ai\";\n      case \"SystemMessage\":\n        return \"system\";\n      case \"ChatMessage\":\n        return \"chat\";\n      default:\n        throw new Error(\"Invalid message class name\");\n    }\n  }\n\n  static fromTemplate(\n    template:\n      | string\n      | Array<\n          | string\n          | _TextTemplateParam\n          | _ImageTemplateParam\n          | Record<string, unknown>\n        >,\n    additionalOptions?: _StringImageMessagePromptTemplateOptions\n  ) {\n    if (typeof template === \"string\") {\n      return new this(PromptTemplate.fromTemplate(template, additionalOptions));\n    }\n    const prompt: Array<\n      | PromptTemplate<InputValues>\n      | ImagePromptTemplate<InputValues>\n      | DictPromptTemplate\n    > = [];\n    for (const item of template) {\n      // handle string cases\n      if (typeof item === \"string\") {\n        prompt.push(PromptTemplate.fromTemplate(item, additionalOptions));\n      } else if (item === null) {\n        // pass\n      } else if (isTextTemplateParam(item)) {\n        let text = \"\";\n        if (typeof item.text === \"string\") {\n          text = item.text ?? \"\";\n        }\n\n        const options = {\n          ...additionalOptions,\n          additionalContentFields: item as ContentBlock,\n        };\n        prompt.push(PromptTemplate.fromTemplate(text, options));\n      } else if (isImageTemplateParam(item)) {\n        let imgTemplate = item.image_url ?? \"\";\n        let imgTemplateObject: ImagePromptTemplate<InputValues>;\n        let inputVariables: string[] = [];\n        if (typeof imgTemplate === \"string\") {\n          let parsedTemplate: ParsedTemplateNode[];\n          if (additionalOptions?.templateFormat === \"mustache\") {\n            parsedTemplate = parseMustache(imgTemplate);\n          } else {\n            parsedTemplate = parseFString(imgTemplate);\n          }\n\n          const variables = parsedTemplate.flatMap((item) =>\n            item.type === \"variable\" ? [item.name] : []\n          );\n\n          if ((variables?.length ?? 0) > 0) {\n            if (variables.length > 1) {\n              throw new Error(\n                `Only one format variable allowed per image template.\\nGot: ${variables}\\nFrom: ${imgTemplate}`\n              );\n            }\n            inputVariables = [variables[0]];\n          } else {\n            inputVariables = [];\n          }\n\n          imgTemplate = { url: imgTemplate };\n          imgTemplateObject = new ImagePromptTemplate<InputValues>({\n            template: imgTemplate,\n            inputVariables,\n            templateFormat: additionalOptions?.templateFormat,\n            additionalContentFields: item as ContentBlock,\n          });\n        } else if (typeof imgTemplate === \"object\") {\n          if (\"url\" in imgTemplate) {\n            let parsedTemplate: ParsedTemplateNode[];\n            if (additionalOptions?.templateFormat === \"mustache\") {\n              parsedTemplate = parseMustache(imgTemplate.url);\n            } else {\n              parsedTemplate = parseFString(imgTemplate.url);\n            }\n\n            inputVariables = parsedTemplate.flatMap((item) =>\n              item.type === \"variable\" ? [item.name] : []\n            );\n          } else {\n            inputVariables = [];\n          }\n          imgTemplateObject = new ImagePromptTemplate<InputValues>({\n            template: imgTemplate,\n            inputVariables,\n            templateFormat: additionalOptions?.templateFormat,\n            additionalContentFields: item as ContentBlock,\n          });\n        } else {\n          throw new Error(\"Invalid image template\");\n        }\n        prompt.push(imgTemplateObject);\n      } else if (typeof item === \"object\") {\n        prompt.push(\n          new DictPromptTemplate({\n            template: item,\n            templateFormat: additionalOptions?.templateFormat,\n          })\n        );\n      }\n    }\n    return new this({ prompt, additionalOptions });\n  }\n\n  async format(input: TypedPromptInputValues<RunInput>): Promise<BaseMessage> {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (this.prompt instanceof BaseStringPromptTemplate) {\n      const text = await this.prompt.format(input);\n\n      return this.createMessage(text);\n    } else {\n      const content: MessageContent = [];\n      for (const prompt of this.prompt) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let inputs: Record<string, any> = {};\n        if (!(\"inputVariables\" in prompt)) {\n          throw new Error(\n            `Prompt ${prompt} does not have inputVariables defined.`\n          );\n        }\n        for (const item of prompt.inputVariables) {\n          if (!inputs) {\n            inputs = { [item]: input[item] };\n          }\n          inputs = { ...inputs, [item]: input[item] };\n        }\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (prompt instanceof BaseStringPromptTemplate) {\n          const formatted = await prompt.format(\n            inputs as TypedPromptInputValues<RunInput>\n          );\n          let additionalContentFields: ContentBlock | undefined;\n          if (\"additionalContentFields\" in prompt) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            additionalContentFields = prompt.additionalContentFields as any;\n          }\n          if (formatted !== \"\") {\n            content.push({\n              ...additionalContentFields,\n              type: \"text\",\n              text: formatted,\n            });\n          }\n          /** @TODO replace this */\n          // eslint-disable-next-line no-instanceof/no-instanceof\n        } else if (prompt instanceof ImagePromptTemplate) {\n          const formatted = await prompt.format(\n            inputs as TypedPromptInputValues<RunInput>\n          );\n          let additionalContentFields: ContentBlock | undefined;\n          if (\"additionalContentFields\" in prompt) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            additionalContentFields = prompt.additionalContentFields as any;\n          }\n          content.push({\n            ...additionalContentFields,\n            type: \"image_url\",\n            image_url: formatted,\n          });\n          // eslint-disable-next-line no-instanceof/no-instanceof\n        } else if (prompt instanceof DictPromptTemplate) {\n          const formatted = await prompt.format(\n            inputs as TypedPromptInputValues<RunInput>\n          );\n          let additionalContentFields: ContentBlock | undefined;\n          if (\"additionalContentFields\" in prompt) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            additionalContentFields = prompt.additionalContentFields as any;\n          }\n          content.push({\n            ...additionalContentFields,\n            ...formatted,\n          } as ContentBlock);\n        }\n      }\n      return this.createMessage(content);\n    }\n  }\n\n  async formatMessages(values: RunInput): Promise<RunOutput> {\n    return [await this.format(values)] as BaseMessage[] as RunOutput;\n  }\n}\n\n/**\n * Class that represents a human message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n * @example\n * ```typescript\n * const message = HumanMessagePromptTemplate.fromTemplate(\"{text}\");\n * const formatted = await message.format({ text: \"Hello world!\" });\n *\n * const chatPrompt = ChatPromptTemplate.fromMessages([message]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nexport class HumanMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n> extends _StringImageMessagePromptTemplate<RunInput> {\n  static _messageClass(): typeof HumanMessage {\n    return HumanMessage;\n  }\n\n  static lc_name() {\n    return \"HumanMessagePromptTemplate\";\n  }\n}\n\n/**\n * Class that represents an AI message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n */\nexport class AIMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n> extends _StringImageMessagePromptTemplate<RunInput> {\n  static _messageClass(): typeof AIMessage {\n    return AIMessage;\n  }\n\n  static lc_name() {\n    return \"AIMessagePromptTemplate\";\n  }\n}\n\n/**\n * Class that represents a system message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n * @example\n * ```typescript\n * const message = SystemMessagePromptTemplate.fromTemplate(\"{text}\");\n * const formatted = await message.format({ text: \"Hello world!\" });\n *\n * const chatPrompt = ChatPromptTemplate.fromMessages([message]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nexport class SystemMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n> extends _StringImageMessagePromptTemplate<RunInput> {\n  static _messageClass(): typeof SystemMessage {\n    return SystemMessage;\n  }\n\n  static lc_name() {\n    return \"SystemMessagePromptTemplate\";\n  }\n}\n\n/**\n * Interface for the input of a ChatPromptTemplate.\n */\nexport interface ChatPromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n> extends BasePromptTemplateInput<RunInput, PartialVariableName> {\n  /**\n   * The prompt messages\n   */\n  promptMessages: Array<BaseMessagePromptTemplate | BaseMessage>;\n\n  /**\n   * Whether to try validating the template on initialization\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n\n  /**\n   * The formatting method to use on the prompt.\n   * @default \"f-string\"\n   */\n  templateFormat?: TemplateFormat;\n}\n\nexport type BaseMessagePromptTemplateLike =\n  | BaseMessagePromptTemplate\n  | BaseMessageLike;\n\nfunction _isBaseMessagePromptTemplate(\n  baseMessagePromptTemplateLike: BaseMessagePromptTemplateLike\n): baseMessagePromptTemplateLike is BaseMessagePromptTemplate {\n  return (\n    typeof (baseMessagePromptTemplateLike as BaseMessagePromptTemplate)\n      .formatMessages === \"function\"\n  );\n}\n\nfunction _coerceMessagePromptTemplateLike<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  Extra extends Omit<\n    ChatPromptTemplateInput<RunInput>,\n    \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n  > = Omit<\n    ChatPromptTemplateInput<RunInput>,\n    \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n  >,\n>(\n  messagePromptTemplateLike: BaseMessagePromptTemplateLike,\n  extra?: Extra\n): BaseMessagePromptTemplate | BaseMessage {\n  if (\n    _isBaseMessagePromptTemplate(messagePromptTemplateLike) ||\n    isBaseMessage(messagePromptTemplateLike)\n  ) {\n    return messagePromptTemplateLike;\n  }\n  if (\n    Array.isArray(messagePromptTemplateLike) &&\n    messagePromptTemplateLike[0] === \"placeholder\"\n  ) {\n    const messageContent = messagePromptTemplateLike[1];\n    if (\n      extra?.templateFormat === \"mustache\" &&\n      typeof messageContent === \"string\" &&\n      messageContent.slice(0, 2) === \"{{\" &&\n      messageContent.slice(-2) === \"}}\"\n    ) {\n      const variableName = messageContent.slice(2, -2);\n      return new MessagesPlaceholder({ variableName, optional: true });\n    } else if (\n      typeof messageContent === \"string\" &&\n      messageContent[0] === \"{\" &&\n      messageContent[messageContent.length - 1] === \"}\"\n    ) {\n      const variableName = messageContent.slice(1, -1);\n      return new MessagesPlaceholder({ variableName, optional: true });\n    }\n    throw new Error(\n      `Invalid placeholder template for format ${\n        extra?.templateFormat ?? `\"f-string\"`\n      }: \"${\n        messagePromptTemplateLike[1]\n      }\". Expected a variable name surrounded by ${\n        extra?.templateFormat === \"mustache\" ? \"double\" : \"single\"\n      } curly braces.`\n    );\n  }\n  const message = coerceMessageLikeToMessage(messagePromptTemplateLike);\n  let templateData:\n    | string\n    | (\n        | string\n        | _TextTemplateParam\n        | _ImageTemplateParam\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        | Record<string, any>\n      )[];\n\n  if (typeof message.content === \"string\") {\n    templateData = message.content;\n  } else {\n    // Assuming message.content is an array of complex objects, transform it.\n    templateData = message.content.map((item) => {\n      if (\"text\" in item) {\n        return { ...item, text: item.text };\n      } else if (\"image_url\" in item) {\n        return { ...item, image_url: item.image_url };\n      } else {\n        return item;\n      }\n    });\n  }\n\n  if (message._getType() === \"human\") {\n    return HumanMessagePromptTemplate.fromTemplate(templateData, extra);\n  } else if (message._getType() === \"ai\") {\n    return AIMessagePromptTemplate.fromTemplate(templateData, extra);\n  } else if (message._getType() === \"system\") {\n    return SystemMessagePromptTemplate.fromTemplate(templateData, extra);\n  } else if (ChatMessage.isInstance(message)) {\n    return ChatMessagePromptTemplate.fromTemplate(\n      message.content as string,\n      message.role,\n      extra\n    );\n  } else {\n    throw new Error(\n      `Could not coerce message prompt template from input. Received message type: \"${message._getType()}\".`\n    );\n  }\n}\n\nfunction isMessagesPlaceholder(\n  x: BaseMessagePromptTemplate | BaseMessage\n): x is MessagesPlaceholder {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (x.constructor as any).lc_name() === \"MessagesPlaceholder\";\n}\n\n/**\n * Class that represents a chat prompt. It extends the\n * BaseChatPromptTemplate and uses an array of BaseMessagePromptTemplate\n * instances to format a series of messages for a conversation.\n * @example\n * ```typescript\n * const message = SystemMessagePromptTemplate.fromTemplate(\"{text}\");\n * const chatPrompt = ChatPromptTemplate.fromMessages([\n *   [\"ai\", \"You are a helpful assistant.\"],\n *   message,\n * ]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nexport class ChatPromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any,\n  >\n  extends BaseChatPromptTemplate<RunInput, PartialVariableName>\n  implements ChatPromptTemplateInput<RunInput, PartialVariableName>\n{\n  static lc_name() {\n    return \"ChatPromptTemplate\";\n  }\n\n  get lc_aliases(): Record<string, string> {\n    return {\n      promptMessages: \"messages\",\n    };\n  }\n\n  promptMessages: Array<BaseMessagePromptTemplate | BaseMessage>;\n\n  validateTemplate = true;\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  constructor(input: ChatPromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n    // If input is mustache and validateTemplate is not defined, set it to false\n    if (\n      input.templateFormat === \"mustache\" &&\n      input.validateTemplate === undefined\n    ) {\n      this.validateTemplate = false;\n    }\n    Object.assign(this, input);\n\n    if (this.validateTemplate) {\n      const inputVariablesMessages = new Set<string>();\n      for (const promptMessage of this.promptMessages) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (promptMessage instanceof BaseMessage) continue;\n        for (const inputVariable of promptMessage.inputVariables) {\n          inputVariablesMessages.add(inputVariable);\n        }\n      }\n\n      const totalInputVariables = this.inputVariables as string[];\n      const inputVariablesInstance = new Set(\n        this.partialVariables\n          ? totalInputVariables.concat(Object.keys(this.partialVariables))\n          : totalInputVariables\n      );\n      const difference = new Set(\n        [...inputVariablesInstance].filter(\n          (x) => !inputVariablesMessages.has(x)\n        )\n      );\n      if (difference.size > 0) {\n        throw new Error(\n          `Input variables \\`${[\n            ...difference,\n          ]}\\` are not used in any of the prompt messages.`\n        );\n      }\n      const otherDifference = new Set(\n        [...inputVariablesMessages].filter(\n          (x) => !inputVariablesInstance.has(x)\n        )\n      );\n      if (otherDifference.size > 0) {\n        throw new Error(\n          `Input variables \\`${[\n            ...otherDifference,\n          ]}\\` are used in prompt messages but not in the prompt template.`\n        );\n      }\n    }\n  }\n\n  _getPromptType(): \"chat\" {\n    return \"chat\";\n  }\n\n  private async _parseImagePrompts(\n    message: BaseMessage,\n    inputValues: InputValues<\n      PartialVariableName | Extract<keyof RunInput, string>\n    >\n  ): Promise<BaseMessage> {\n    if (typeof message.content === \"string\") {\n      return message;\n    }\n    const formattedMessageContent = await Promise.all(\n      message.content.map(async (item) => {\n        if (item.type !== \"image_url\") {\n          return item;\n        }\n\n        let imageUrl = \"\";\n        if (typeof item.image_url === \"string\") {\n          imageUrl = item.image_url;\n        } else if (\n          typeof item.image_url === \"object\" &&\n          item.image_url !== null &&\n          \"url\" in item.image_url &&\n          typeof item.image_url.url === \"string\"\n        ) {\n          imageUrl = item.image_url.url;\n        }\n\n        const promptTemplatePlaceholder = PromptTemplate.fromTemplate(\n          imageUrl,\n          {\n            templateFormat: this.templateFormat,\n          }\n        );\n        const formattedUrl =\n          await promptTemplatePlaceholder.format(inputValues);\n\n        if (\n          typeof item.image_url === \"object\" &&\n          item.image_url !== null &&\n          \"url\" in item.image_url\n        ) {\n          // eslint-disable-next-line no-param-reassign\n          item.image_url.url = formattedUrl;\n        } else {\n          item.image_url = formattedUrl;\n        }\n        return item;\n      })\n    );\n    message.content = formattedMessageContent;\n    return message;\n  }\n\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    let resultMessages: BaseMessage[] = [];\n\n    for (const promptMessage of this.promptMessages) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (promptMessage instanceof BaseMessage) {\n        resultMessages.push(\n          await this._parseImagePrompts(promptMessage, allValues)\n        );\n      } else {\n        let inputValues: InputValues;\n\n        if (this.templateFormat === \"mustache\") {\n          inputValues = { ...allValues };\n        } else {\n          inputValues = promptMessage.inputVariables.reduce(\n            (acc, inputVariable) => {\n              if (\n                !(inputVariable in allValues) &&\n                !(\n                  isMessagesPlaceholder(promptMessage) && promptMessage.optional\n                )\n              ) {\n                const error = addLangChainErrorFields(\n                  new Error(\n                    `Missing value for input variable \\`${inputVariable.toString()}\\``\n                  ),\n                  \"INVALID_PROMPT_INPUT\"\n                );\n                throw error;\n              }\n              acc[inputVariable] = allValues[inputVariable];\n              return acc;\n            },\n            {} as InputValues\n          );\n        }\n        const message = await promptMessage.formatMessages(inputValues);\n        resultMessages = resultMessages.concat(message);\n      }\n    }\n    return resultMessages;\n  }\n\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    // This is implemented in a way it doesn't require making\n    // BaseMessagePromptTemplate aware of .partial()\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    ) as Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | NewPartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new ChatPromptTemplate<\n      InputValues<\n        Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>\n      >\n    >(promptDict);\n  }\n\n  /**\n   * Load prompt template from a template f-string\n   */\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string,\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"f-string\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string,\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string>,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string,\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"mustache\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<InputValues>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string,\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<ExtractedFStringParams<T, RunInput> | InputValues> {\n    const prompt = PromptTemplate.fromTemplate(template, options);\n    const humanTemplate = new HumanMessagePromptTemplate({ prompt });\n    return this.fromMessages<\n      RunInput extends Symbol ? ParamsFromFString<T> : RunInput\n    >([humanTemplate]);\n  }\n\n  /**\n   * Create a chat model-specific prompt from individual chat messages\n   * or message-like tuples.\n   * @param promptMessages Messages to be passed to the chat model\n   * @returns A new ChatPromptTemplate\n   */\n  static fromMessages<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    Extra extends\n      ChatPromptTemplateInput<RunInput> = ChatPromptTemplateInput<RunInput>,\n  >(\n    promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[],\n    extra?: Omit<\n      Extra,\n      \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n    >\n  ): ChatPromptTemplate<RunInput> {\n    const flattenedMessages = promptMessages.reduce(\n      (acc: Array<BaseMessagePromptTemplate | BaseMessage>, promptMessage) =>\n        acc.concat(\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          promptMessage instanceof ChatPromptTemplate\n            ? promptMessage.promptMessages\n            : [\n                _coerceMessagePromptTemplateLike<\n                  RunInput,\n                  Omit<\n                    Extra,\n                    \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n                  >\n                >(promptMessage, extra),\n              ]\n        ),\n      []\n    );\n    const flattenedPartialVariables = promptMessages.reduce(\n      (acc, promptMessage) =>\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        promptMessage instanceof ChatPromptTemplate\n          ? Object.assign(acc, promptMessage.partialVariables)\n          : acc,\n      Object.create(null) as PartialValues\n    );\n    const inputVariables = new Set<string>();\n    for (const promptMessage of flattenedMessages) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (promptMessage instanceof BaseMessage) continue;\n      for (const inputVariable of promptMessage.inputVariables) {\n        if (inputVariable in flattenedPartialVariables) {\n          continue;\n        }\n        inputVariables.add(inputVariable);\n      }\n    }\n    return new this<RunInput>({\n      ...extra,\n      inputVariables: [...inputVariables] as Extract<keyof RunInput, string>[],\n      promptMessages: flattenedMessages,\n      partialVariables: flattenedPartialVariables,\n      templateFormat: extra?.templateFormat,\n    });\n  }\n}\n", "import { BaseStringPromptTemplate } from \"./string.js\";\nimport type {\n  BasePromptTemplateInput,\n  TypedPromptInputValues,\n  Example,\n} from \"./base.js\";\nimport type { BaseExampleSelector } from \"../example_selectors/base.js\";\nimport {\n  type TemplateFormat,\n  checkValidTemplate,\n  renderTemplate,\n} from \"./template.js\";\nimport { PromptTemplate } from \"./prompt.js\";\nimport type { SerializedFewShotTemplate } from \"./serde.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport type { BaseMessage } from \"../messages/index.js\";\nimport {\n  BaseChatPromptTemplate,\n  type BaseMessagePromptTemplate,\n} from \"./chat.js\";\n\nexport interface FewShotPromptTemplateInput\n  extends BasePromptTemplateInput<InputValues> {\n  /**\n   * Examples to format into the prompt. Exactly one of this or\n   * {@link exampleSelector} must be\n   * provided.\n   */\n  examples?: Example[];\n\n  /**\n   * An {@link BaseExampleSelector} Examples to format into the prompt. Exactly one of this or\n   * {@link examples} must be\n   * provided.\n   */\n  exampleSelector?: BaseExampleSelector;\n\n  /**\n   * An {@link PromptTemplate} used to format a single example.\n   */\n  examplePrompt: PromptTemplate;\n\n  /**\n   * String separator used to join the prefix, the examples, and suffix.\n   */\n  exampleSeparator?: string;\n\n  /**\n   * A prompt template string to put before the examples.\n   *\n   * @defaultValue `\"\"`\n   */\n  prefix?: string;\n\n  /**\n   * A prompt template string to put after the examples.\n   */\n  suffix?: string;\n\n  /**\n   * The format of the prompt template. Options are: 'f-string'\n   */\n  templateFormat?: TemplateFormat;\n\n  /**\n   * Whether or not to try validating the template on initialization.\n   */\n  validateTemplate?: boolean;\n}\n\n/**\n * Prompt template that contains few-shot examples.\n * @augments BasePromptTemplate\n * @augments FewShotPromptTemplateInput\n * @example\n * ```typescript\n * const examplePrompt = PromptTemplate.fromTemplate(\n *   \"Input: {input}\\nOutput: {output}\",\n * );\n *\n * const exampleSelector = await SemanticSimilarityExampleSelector.fromExamples(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   new OpenAIEmbeddings(),\n *   HNSWLib,\n *   { k: 1 },\n * );\n *\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt,\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n *\n * // Format the dynamic prompt with the input 'rainy'\n * console.log(await dynamicPrompt.format({ adjective: \"rainy\" }));\n *\n * ```\n */\nexport class FewShotPromptTemplate\n  extends BaseStringPromptTemplate\n  implements FewShotPromptTemplateInput\n{\n  lc_serializable = false;\n\n  examples?: InputValues[];\n\n  exampleSelector?: BaseExampleSelector | undefined;\n\n  examplePrompt: PromptTemplate;\n\n  suffix = \"\";\n\n  exampleSeparator = \"\\n\\n\";\n\n  prefix = \"\";\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  constructor(input: FewShotPromptTemplateInput) {\n    super(input);\n    Object.assign(this, input);\n\n    if (this.examples !== undefined && this.exampleSelector !== undefined) {\n      throw new Error(\n        \"Only one of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.examples === undefined && this.exampleSelector === undefined) {\n      throw new Error(\n        \"One of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.validateTemplate) {\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        this.prefix + this.suffix,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  _getPromptType(): \"few_shot\" {\n    return \"few_shot\";\n  }\n\n  static lc_name() {\n    return \"FewShotPromptTemplate\";\n  }\n\n  private async getExamples(\n    inputVariables: InputValues\n  ): Promise<InputValues[]> {\n    if (this.examples !== undefined) {\n      return this.examples;\n    }\n    if (this.exampleSelector !== undefined) {\n      return this.exampleSelector.selectExamples(inputVariables);\n    }\n\n    throw new Error(\n      \"One of 'examples' and 'example_selector' should be provided\"\n    );\n  }\n\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    );\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    };\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new FewShotPromptTemplate(promptDict);\n  }\n\n  /**\n   * Formats the prompt with the given values.\n   * @param values The values to format the prompt with.\n   * @returns A promise that resolves to a string representing the formatted prompt.\n   */\n  async format(values: InputValues): Promise<string> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    const examples = await this.getExamples(allValues);\n\n    const exampleStrings = await Promise.all(\n      examples.map((example) => this.examplePrompt.format(example))\n    );\n    const template = [this.prefix, ...exampleStrings, this.suffix].join(\n      this.exampleSeparator\n    );\n    return renderTemplate(template, this.templateFormat, allValues);\n  }\n\n  serialize(): SerializedFewShotTemplate {\n    if (this.exampleSelector || !this.examples) {\n      throw new Error(\n        \"Serializing an example selector is not currently supported\"\n      );\n    }\n    if (this.outputParser !== undefined) {\n      throw new Error(\n        \"Serializing an output parser is not currently supported\"\n      );\n    }\n    return {\n      _type: this._getPromptType(),\n      input_variables: this.inputVariables,\n      example_prompt: this.examplePrompt.serialize(),\n      example_separator: this.exampleSeparator,\n      suffix: this.suffix,\n      prefix: this.prefix,\n      template_format: this.templateFormat,\n      examples: this.examples,\n    };\n  }\n\n  static async deserialize(\n    data: SerializedFewShotTemplate\n  ): Promise<FewShotPromptTemplate> {\n    const { example_prompt } = data;\n    if (!example_prompt) {\n      throw new Error(\"Missing example prompt\");\n    }\n    const examplePrompt = await PromptTemplate.deserialize(example_prompt);\n\n    let examples: Example[];\n\n    if (Array.isArray(data.examples)) {\n      examples = data.examples;\n    } else {\n      throw new Error(\n        \"Invalid examples format. Only list or string are supported.\"\n      );\n    }\n\n    return new FewShotPromptTemplate({\n      inputVariables: data.input_variables,\n      examplePrompt,\n      examples,\n      exampleSeparator: data.example_separator,\n      prefix: data.prefix,\n      suffix: data.suffix,\n      templateFormat: data.template_format,\n    });\n  }\n}\n\nexport interface FewShotChatMessagePromptTemplateInput\n  extends BasePromptTemplateInput<InputValues> {\n  /**\n   * Examples to format into the prompt. Exactly one of this or\n   * {@link exampleSelector} must be\n   * provided.\n   */\n  examples?: Example[];\n\n  /**\n   * An {@link BaseMessagePromptTemplate} | {@link BaseChatPromptTemplate} used to format a single example.\n   */\n  examplePrompt: BaseMessagePromptTemplate | BaseChatPromptTemplate;\n\n  /**\n   * String separator used to join the prefix, the examples, and suffix.\n   *\n   * @defaultValue `\"\\n\\n\"`\n   */\n  exampleSeparator?: string;\n\n  /**\n   * An {@link BaseExampleSelector} Examples to format into the prompt. Exactly one of this or\n   * {@link examples} must be\n   * provided.\n   */\n  exampleSelector?: BaseExampleSelector | undefined;\n\n  /**\n   * A prompt template string to put before the examples.\n   *\n   * @defaultValue `\"\"`\n   */\n  prefix?: string;\n\n  /**\n   * A prompt template string to put after the examples.\n   *\n   * @defaultValue `\"\"`\n   */\n  suffix?: string;\n\n  /**\n   * The format of the prompt template. Options are: 'f-string'\n   *\n   * @defaultValue `f-string`\n   */\n  templateFormat?: TemplateFormat;\n\n  /**\n   * Whether or not to try validating the template on initialization.\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n}\n\n/**\n * Chat prompt template that contains few-shot examples.\n * @augments BasePromptTemplateInput\n * @augments FewShotChatMessagePromptTemplateInput\n */\nexport class FewShotChatMessagePromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any,\n  >\n  extends BaseChatPromptTemplate\n  implements FewShotChatMessagePromptTemplateInput\n{\n  lc_serializable = true;\n\n  examples?: InputValues[];\n\n  exampleSelector?: BaseExampleSelector | undefined;\n\n  examplePrompt: BaseMessagePromptTemplate | BaseChatPromptTemplate;\n\n  suffix = \"\";\n\n  exampleSeparator = \"\\n\\n\";\n\n  prefix = \"\";\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  _getPromptType(): \"few_shot_chat\" {\n    return \"few_shot_chat\";\n  }\n\n  static lc_name() {\n    return \"FewShotChatMessagePromptTemplate\";\n  }\n\n  constructor(fields: FewShotChatMessagePromptTemplateInput) {\n    super(fields);\n\n    this.examples = fields.examples;\n    this.examplePrompt = fields.examplePrompt;\n    this.exampleSeparator = fields.exampleSeparator ?? \"\\n\\n\";\n    this.exampleSelector = fields.exampleSelector;\n    this.prefix = fields.prefix ?? \"\";\n    this.suffix = fields.suffix ?? \"\";\n    this.templateFormat = fields.templateFormat ?? \"f-string\";\n    this.validateTemplate = fields.validateTemplate ?? true;\n\n    if (this.examples !== undefined && this.exampleSelector !== undefined) {\n      throw new Error(\n        \"Only one of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.examples === undefined && this.exampleSelector === undefined) {\n      throw new Error(\n        \"One of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.validateTemplate) {\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        this.prefix + this.suffix,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  private async getExamples(\n    inputVariables: InputValues\n  ): Promise<InputValues[]> {\n    if (this.examples !== undefined) {\n      return this.examples;\n    }\n    if (this.exampleSelector !== undefined) {\n      return this.exampleSelector.selectExamples(inputVariables);\n    }\n\n    throw new Error(\n      \"One of 'examples' and 'example_selector' should be provided\"\n    );\n  }\n\n  /**\n   * Formats the list of values and returns a list of formatted messages.\n   * @param values The values to format the prompt with.\n   * @returns A promise that resolves to a string representing the formatted prompt.\n   */\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    let examples = await this.getExamples(allValues);\n\n    examples = examples.map((example) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const result: Record<string, any> = {};\n      this.examplePrompt.inputVariables.forEach((inputVariable) => {\n        result[inputVariable] = example[inputVariable];\n      });\n      return result;\n    });\n\n    const messages: BaseMessage[] = [];\n    for (const example of examples) {\n      const exampleMessages = await this.examplePrompt.formatMessages(example);\n      messages.push(...exampleMessages);\n    }\n    return messages;\n  }\n\n  /**\n   * Formats the prompt with the given values.\n   * @param values The values to format the prompt with.\n   * @returns A promise that resolves to a string representing the formatted prompt.\n   */\n  async format(values: TypedPromptInputValues<RunInput>): Promise<string> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    const examples = await this.getExamples(allValues);\n    const exampleMessages = await Promise.all(\n      examples.map((example) => this.examplePrompt.formatMessages(example))\n    );\n    const exampleStrings = exampleMessages\n      .flat()\n      .map((message) => message.content);\n    const template = [this.prefix, ...exampleStrings, this.suffix].join(\n      this.exampleSeparator\n    );\n    return renderTemplate(template, this.templateFormat, allValues);\n  }\n\n  /**\n   * Partially formats the prompt with the given values.\n   * @param values The values to partially format the prompt with.\n   * @returns A promise that resolves to an instance of `FewShotChatMessagePromptTemplate` with the given values partially formatted.\n   */\n  async partial(\n    values: PartialValues<PartialVariableName>\n  ): Promise<FewShotChatMessagePromptTemplate<RunInput, PartialVariableName>> {\n    const newInputVariables = this.inputVariables.filter(\n      (variable) => !(variable in values)\n    ) as Exclude<Extract<keyof RunInput, string>, PartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | PartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new FewShotChatMessagePromptTemplate<\n      InputValues<Exclude<Extract<keyof RunInput, string>, PartialVariableName>>\n    >(promptDict);\n  }\n}\n", "import type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport type { SerializedBasePromptTemplate } from \"./serde.js\";\nimport { BasePromptTemplate, type BasePromptTemplateInput } from \"./base.js\";\nimport { ChatPromptTemplate } from \"./chat.js\";\n\n/**\n * Type that includes the name of the prompt and the prompt itself.\n */\nexport type PipelinePromptParams<\n  PromptTemplateType extends BasePromptTemplate,\n> = {\n  name: string;\n  prompt: PromptTemplateType;\n};\n\n/**\n * Type that extends the BasePromptTemplateInput type, excluding the\n * inputVariables property. It includes an array of pipelinePrompts and a\n * finalPrompt.\n */\nexport type PipelinePromptTemplateInput<\n  PromptTemplateType extends BasePromptTemplate,\n> = Omit<BasePromptTemplateInput, \"inputVariables\"> & {\n  pipelinePrompts: PipelinePromptParams<PromptTemplateType>[];\n  finalPrompt: PromptTemplateType;\n};\n\n/**\n * Class that handles a sequence of prompts, each of which may require\n * different input variables. Includes methods for formatting these\n * prompts, extracting required input values, and handling partial\n * prompts.\n * @example\n * ```typescript\n * const composedPrompt = new PipelinePromptTemplate({\n *   pipelinePrompts: [\n *     {\n *       name: \"introduction\",\n *       prompt: PromptTemplate.fromTemplate(`You are impersonating {person}.`),\n *     },\n *     {\n *       name: \"example\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Here's an example of an interaction:\n * Q: {example_q}\n * A: {example_a}`,\n *       ),\n *     },\n *     {\n *       name: \"start\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Now, do this for real!\n * Q: {input}\n * A:`,\n *       ),\n *     },\n *   ],\n *   finalPrompt: PromptTemplate.fromTemplate(\n *     `{introduction}\n * {example}\n * {start}`,\n *   ),\n * });\n *\n * const formattedPrompt = await composedPrompt.format({\n *   person: \"Elon Musk\",\n *   example_q: `What's your favorite car?`,\n *   example_a: \"Tesla\",\n *   input: `What's your favorite social media site?`,\n * });\n * ```\n */\nexport class PipelinePromptTemplate<\n  PromptTemplateType extends BasePromptTemplate,\n> extends BasePromptTemplate {\n  static lc_name() {\n    return \"PipelinePromptTemplate\";\n  }\n\n  pipelinePrompts: PipelinePromptParams<PromptTemplateType>[];\n\n  finalPrompt: PromptTemplateType;\n\n  constructor(input: PipelinePromptTemplateInput<PromptTemplateType>) {\n    super({ ...input, inputVariables: [] });\n    this.pipelinePrompts = input.pipelinePrompts;\n    this.finalPrompt = input.finalPrompt;\n    this.inputVariables = this.computeInputValues();\n  }\n\n  /**\n   * Computes the input values required by the pipeline prompts.\n   * @returns Array of input values required by the pipeline prompts.\n   */\n  protected computeInputValues() {\n    const intermediateValues = this.pipelinePrompts.map(\n      (pipelinePrompt) => pipelinePrompt.name\n    );\n    const inputValues = this.pipelinePrompts\n      .map((pipelinePrompt) =>\n        pipelinePrompt.prompt.inputVariables.filter(\n          (inputValue) => !intermediateValues.includes(inputValue)\n        )\n      )\n      .flat();\n    return [...new Set(inputValues)];\n  }\n\n  protected static extractRequiredInputValues(\n    allValues: InputValues,\n    requiredValueNames: string[]\n  ) {\n    return requiredValueNames.reduce((requiredValues, valueName) => {\n      requiredValues[valueName] = allValues[valueName];\n      return requiredValues;\n    }, {} as InputValues);\n  }\n\n  /**\n   * Formats the pipeline prompts based on the provided input values.\n   * @param values Input values to format the pipeline prompts.\n   * @returns Promise that resolves with the formatted input values.\n   */\n  protected async formatPipelinePrompts(\n    values: InputValues\n  ): Promise<InputValues> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this\n      .pipelinePrompts) {\n      const pipelinePromptInputValues =\n        PipelinePromptTemplate.extractRequiredInputValues(\n          allValues,\n          pipelinePrompt.inputVariables\n        );\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (pipelinePrompt instanceof ChatPromptTemplate) {\n        allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(\n          pipelinePromptInputValues\n        );\n      } else {\n        allValues[pipelinePromptName] = await pipelinePrompt.format(\n          pipelinePromptInputValues\n        );\n      }\n    }\n    return PipelinePromptTemplate.extractRequiredInputValues(\n      allValues,\n      this.finalPrompt.inputVariables\n    );\n  }\n\n  /**\n   * Formats the final prompt value based on the provided input values.\n   * @param values Input values to format the final prompt value.\n   * @returns Promise that resolves with the formatted final prompt value.\n   */\n  async formatPromptValue(\n    values: InputValues\n  ): Promise<PromptTemplateType[\"PromptValueReturnType\"]> {\n    return this.finalPrompt.formatPromptValue(\n      await this.formatPipelinePrompts(values)\n    );\n  }\n\n  async format(values: InputValues): Promise<string> {\n    return this.finalPrompt.format(await this.formatPipelinePrompts(values));\n  }\n\n  /**\n   * Handles partial prompts, which are prompts that have been partially\n   * filled with input values.\n   * @param values Partial input values.\n   * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.\n   */\n  async partial(\n    values: PartialValues\n  ): Promise<PipelinePromptTemplate<PromptTemplateType>> {\n    const promptDict = { ...this };\n    promptDict.inputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    );\n    promptDict.partialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    };\n    return new PipelinePromptTemplate<PromptTemplateType>(promptDict);\n  }\n\n  serialize(): SerializedBasePromptTemplate {\n    throw new Error(\"Not implemented.\");\n  }\n\n  _getPromptType(): string {\n    return \"pipeline\";\n  }\n}\n", "import { ChatPromptValueInterface } from \"../prompt_values.js\";\nimport { RunnableLike, Runnable, RunnableBinding } from \"../runnables/base.js\";\nimport { RunnableConfig } from \"../runnables/config.js\";\nimport { InputValues } from \"../utils/types/index.js\";\nimport {\n  BaseMessagePromptTemplateLike,\n  ChatPromptTemplate,\n  ChatPromptTemplateInput,\n} from \"./chat.js\";\n\nfunction isWithStructuredOutput(x: unknown): x is {\n  withStructuredOutput: (...arg: unknown[]) => Runnable;\n} {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    \"withStructuredOutput\" in x &&\n    typeof x.withStructuredOutput === \"function\"\n  );\n}\n\nfunction isRunnableBinding(x: unknown): x is RunnableBinding<unknown, unknown> {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    \"lc_id\" in x &&\n    Array.isArray(x.lc_id) &&\n    x.lc_id.join(\"/\") === \"langchain_core/runnables/RunnableBinding\"\n  );\n}\n\n/**\n * Interface for the input of a ChatPromptTemplate.\n */\nexport interface StructuredPromptInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n> extends ChatPromptTemplateInput<RunInput, PartialVariableName> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: Record<string, any>;\n  method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\";\n}\n\nexport class StructuredPrompt<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any,\n  >\n  extends ChatPromptTemplate<RunInput, PartialVariableName>\n  implements StructuredPromptInput<RunInput, PartialVariableName>\n{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: Record<string, any>;\n\n  method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\";\n\n  lc_namespace = [\"langchain_core\", \"prompts\", \"structured\"];\n\n  get lc_aliases(): Record<string, string> {\n    return {\n      ...super.lc_aliases,\n      schema: \"schema_\",\n    };\n  }\n\n  constructor(input: StructuredPromptInput<RunInput, PartialVariableName>) {\n    super(input);\n    this.schema = input.schema;\n    this.method = input.method;\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike<ChatPromptValueInterface, NewRunOutput>\n  ): Runnable<RunInput, Exclude<NewRunOutput, Error>, RunnableConfig> {\n    if (isWithStructuredOutput(coerceable)) {\n      return super.pipe(coerceable.withStructuredOutput(this.schema));\n    }\n\n    if (\n      isRunnableBinding(coerceable) &&\n      isWithStructuredOutput(coerceable.bound)\n    ) {\n      return super.pipe(\n        new RunnableBinding({\n          bound: coerceable.bound.withStructuredOutput(\n            this.schema,\n            ...(this.method ? [{ method: this.method }] : [])\n          ),\n          kwargs: coerceable.kwargs ?? {},\n          config: coerceable.config,\n          configFactories: coerceable.configFactories,\n        })\n      );\n    }\n\n    throw new Error(\n      `Structured prompts need to be piped to a language model that supports the \"withStructuredOutput()\" method.`\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromMessagesAndSchema<RunInput extends InputValues = any>(\n    promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[],\n    schema: StructuredPromptInput[\"schema\"],\n    method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\"\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): ChatPromptTemplate<RunInput, any> {\n    return StructuredPrompt.fromMessages<\n      RunInput,\n      StructuredPromptInput<RunInput>\n    >(promptMessages, { schema, method });\n  }\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { BasePromptTemplate } from \"./base.js\";\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { DEFAULT_FORMATTER_MAPPING, DEFAULT_PARSER_MAPPING, checkValidTemplate, interpolateFString, interpolateMustache, parseFString, parseMustache, parseTemplate, renderTemplate } from \"./template.js\";\nimport { PromptTemplate } from \"./prompt.js\";\nimport { ImagePromptTemplate } from \"./image.js\";\nimport { DictPromptTemplate } from \"./dict.js\";\nimport { AIMessagePromptTemplate, BaseChatPromptTemplate, BaseMessagePromptTemplate, BaseMessageStringPromptTemplate, ChatMessagePromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate, MessagesPlaceholder, SystemMessagePromptTemplate } from \"./chat.js\";\nimport { FewShotChatMessagePromptTemplate, FewShotPromptTemplate } from \"./few_shot.js\";\nimport { PipelinePromptTemplate } from \"./pipeline.js\";\nimport { StructuredPrompt } from \"./structured.js\";\n\n//#region src/prompts/index.ts\nvar prompts_exports = {};\n__export(prompts_exports, {\n\tAIMessagePromptTemplate: () => AIMessagePromptTemplate,\n\tBaseChatPromptTemplate: () => BaseChatPromptTemplate,\n\tBaseMessagePromptTemplate: () => BaseMessagePromptTemplate,\n\tBaseMessageStringPromptTemplate: () => BaseMessageStringPromptTemplate,\n\tBasePromptTemplate: () => BasePromptTemplate,\n\tBaseStringPromptTemplate: () => BaseStringPromptTemplate,\n\tChatMessagePromptTemplate: () => ChatMessagePromptTemplate,\n\tChatPromptTemplate: () => ChatPromptTemplate,\n\tDEFAULT_FORMATTER_MAPPING: () => DEFAULT_FORMATTER_MAPPING,\n\tDEFAULT_PARSER_MAPPING: () => DEFAULT_PARSER_MAPPING,\n\tDictPromptTemplate: () => DictPromptTemplate,\n\tFewShotChatMessagePromptTemplate: () => FewShotChatMessagePromptTemplate,\n\tFewShotPromptTemplate: () => FewShotPromptTemplate,\n\tHumanMessagePromptTemplate: () => HumanMessagePromptTemplate,\n\tImagePromptTemplate: () => ImagePromptTemplate,\n\tMessagesPlaceholder: () => MessagesPlaceholder,\n\tPipelinePromptTemplate: () => PipelinePromptTemplate,\n\tPromptTemplate: () => PromptTemplate,\n\tStructuredPrompt: () => StructuredPrompt,\n\tSystemMessagePromptTemplate: () => SystemMessagePromptTemplate,\n\tcheckValidTemplate: () => checkValidTemplate,\n\tinterpolateFString: () => interpolateFString,\n\tinterpolateMustache: () => interpolateMustache,\n\tparseFString: () => parseFString,\n\tparseMustache: () => parseMustache,\n\tparseTemplate: () => parseTemplate,\n\trenderTemplate: () => renderTemplate\n});\n\n//#endregion\nexport { AIMessagePromptTemplate, BaseChatPromptTemplate, BaseMessagePromptTemplate, BaseMessageStringPromptTemplate, BasePromptTemplate, BaseStringPromptTemplate, ChatMessagePromptTemplate, ChatPromptTemplate, DEFAULT_FORMATTER_MAPPING, DEFAULT_PARSER_MAPPING, DictPromptTemplate, FewShotChatMessagePromptTemplate, FewShotPromptTemplate, HumanMessagePromptTemplate, ImagePromptTemplate, MessagesPlaceholder, PipelinePromptTemplate, PromptTemplate, StructuredPrompt, SystemMessagePromptTemplate, checkValidTemplate, interpolateFString, interpolateMustache, parseFString, parseMustache, parseTemplate, prompts_exports, renderTemplate };\n//# sourceMappingURL=index.js.map", "import { Callbacks } from \"../../callbacks/manager.js\";\nimport { DocumentInterface } from \"../../documents/document.js\";\n\n/**\n * Base Document Compression class. All compressors should extend this class.\n */\nexport abstract class BaseDocumentCompressor {\n  /**\n   * Abstract method that must be implemented by any class that extends\n   * `BaseDocumentCompressor`. This method takes an array of `Document`\n   * objects and a query string as parameters and returns a Promise that\n   * resolves with an array of compressed `Document` objects.\n   * @param documents An array of `Document` objects to be compressed.\n   * @param query A query string.\n   * @returns A Promise that resolves with an array of compressed `Document` objects.\n   */\n  abstract compressDocuments(\n    documents: DocumentInterface[],\n    query: string,\n    callbacks?: Callbacks\n  ): Promise<DocumentInterface[]>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isBaseDocumentCompressor(x: any): x is BaseDocumentCompressor {\n    return x?.compressDocuments !== undefined;\n  }\n}\n", "import { VectorStore } from \"../vectorstores.js\";\n\n/**\n * Represents logical AND operator.\n */\nexport type AND = \"and\";\n/**\n * Represents logical OR operator.\n */\nexport type OR = \"or\";\n/**\n * Represents logical NOT operator.\n */\nexport type NOT = \"not\";\n\n/**\n * Represents a logical operator which can be AND, OR, or NOT.\n */\nexport type Operator = AND | OR | NOT;\n\n/**\n * Represents equality comparison operator.\n */\nexport type EQ = \"eq\";\n/**\n * Represents inequality comparison operator.\n */\nexport type NE = \"ne\";\n/**\n * Represents less than comparison operator.\n */\nexport type LT = \"lt\";\n/**\n * Represents greater than comparison operator.\n */\nexport type GT = \"gt\";\n/**\n * Represents less than or equal to comparison operator.\n */\nexport type LTE = \"lte\";\n/**\n * Represents greater than or equal to comparison operator.\n */\nexport type GTE = \"gte\";\n\n/**\n * Represents a comparison operator which can be EQ, NE, LT, GT, LTE, or\n * GTE.\n */\nexport type Comparator = EQ | NE | LT | GT | LTE | GTE;\n\nexport const Operators: { [key: string]: Operator } = {\n  and: \"and\",\n  or: \"or\",\n  not: \"not\",\n};\n\nexport const Comparators: { [key: string]: Comparator } = {\n  eq: \"eq\",\n  ne: \"ne\",\n  lt: \"lt\",\n  gt: \"gt\",\n  lte: \"lte\",\n  gte: \"gte\",\n};\n\n/**\n * Represents the result of visiting an operation or comparison\n * expression.\n */\nexport type VisitorResult = VisitorOperationResult | VisitorComparisonResult;\n\n/**\n * Represents the result of visiting an operation expression.\n */\nexport type VisitorOperationResult = {\n  [operator: string]: VisitorResult[];\n};\n\n/**\n * Represents the result of visiting a comparison expression.\n */\nexport type VisitorComparisonResult = {\n  [attr: string]: {\n    [comparator: string]: string | number | boolean;\n  };\n};\n\n/**\n * Represents the result of visiting a structured query expression.\n */\nexport type VisitorStructuredQueryResult = {\n  filter?: VisitorComparisonResult | VisitorOperationResult;\n};\n\n/**\n * Abstract class for visiting expressions. Subclasses must implement\n * visitOperation, visitComparison, and visitStructuredQuery methods.\n */\nexport abstract class Visitor<T extends VectorStore = VectorStore> {\n  declare VisitOperationOutput: object;\n\n  declare VisitComparisonOutput: object;\n\n  declare VisitStructuredQueryOutput: { filter?: T[\"FilterType\"] };\n\n  abstract allowedOperators: Operator[];\n\n  abstract allowedComparators: Comparator[];\n\n  abstract visitOperation(operation: Operation): this[\"VisitOperationOutput\"];\n\n  abstract visitComparison(\n    comparison: Comparison\n  ): this[\"VisitComparisonOutput\"];\n\n  abstract visitStructuredQuery(\n    structuredQuery: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"];\n}\n\n/**\n * Abstract class representing an expression. Subclasses must implement\n * the exprName property and the accept method.\n */\nexport abstract class Expression {\n  abstract exprName: \"Operation\" | \"Comparison\" | \"StructuredQuery\";\n\n  accept(visitor: Visitor) {\n    if (this.exprName === \"Operation\") {\n      return visitor.visitOperation(this as unknown as Operation);\n    } else if (this.exprName === \"Comparison\") {\n      return visitor.visitComparison(this as unknown as Comparison);\n    } else if (this.exprName === \"StructuredQuery\") {\n      return visitor.visitStructuredQuery(this as unknown as StructuredQuery);\n    } else {\n      throw new Error(\"Unknown Expression type\");\n    }\n  }\n}\n\n/**\n * Abstract class representing a filter directive. It extends the\n * Expression class.\n */\nexport abstract class FilterDirective extends Expression {}\n\n/**\n * Class representing a comparison filter directive. It extends the\n * FilterDirective class.\n */\nexport class Comparison<ValueTypes = string | number> extends FilterDirective {\n  exprName = \"Comparison\" as const;\n\n  constructor(\n    public comparator: Comparator,\n    public attribute: string,\n    public value: ValueTypes\n  ) {\n    super();\n  }\n}\n\n/**\n * Class representing an operation filter directive. It extends the\n * FilterDirective class.\n */\nexport class Operation extends FilterDirective {\n  exprName = \"Operation\" as const;\n\n  constructor(\n    public operator: Operator,\n    public args?: FilterDirective[]\n  ) {\n    super();\n  }\n}\n\n/**\n * Class representing a structured query expression. It extends the\n * Expression class.\n */\nexport class StructuredQuery extends Expression {\n  exprName = \"StructuredQuery\" as const;\n\n  constructor(\n    public query: string,\n    public filter?: FilterDirective\n  ) {\n    super();\n  }\n}\n", "/**\n * Checks if the provided argument is an object and not an array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isObject(obj: any): obj is object {\n  return obj && typeof obj === \"object\" && !Array.isArray(obj);\n}\n\n/**\n * Checks if a provided filter is empty. The filter can be a function, an\n * object, a string, or undefined.\n */\nexport function isFilterEmpty(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  filter: ((q: any) => any) | object | string | undefined\n): filter is undefined {\n  if (!filter) return true;\n  // for Milvus\n  if (typeof filter === \"string\" && filter.length > 0) {\n    return false;\n  }\n  if (typeof filter === \"function\") {\n    return false;\n  }\n  return isObject(filter) && Object.keys(filter).length === 0;\n}\n\n/**\n * Checks if the provided value is an integer.\n */\nexport function isInt(value: unknown): boolean {\n  if (typeof value === \"number\") {\n    return value % 1 === 0;\n  } else if (typeof value === \"string\") {\n    const numberValue = parseInt(value, 10);\n    return (\n      !Number.isNaN(numberValue) &&\n      numberValue % 1 === 0 &&\n      numberValue.toString() === value\n    );\n  }\n\n  return false;\n}\n\n/**\n * Checks if the provided value is a floating-point number.\n */\nexport function isFloat(value: unknown): boolean {\n  if (typeof value === \"number\") {\n    return value % 1 !== 0;\n  } else if (typeof value === \"string\") {\n    const numberValue = parseFloat(value);\n    return (\n      !Number.isNaN(numberValue) &&\n      numberValue % 1 !== 0 &&\n      numberValue.toString() === value\n    );\n  }\n\n  return false;\n}\n\n/**\n * Checks if the provided value is a string that cannot be parsed into a\n * number.\n */\nexport function isString(value: unknown): boolean {\n  return (\n    typeof value === \"string\" &&\n    (Number.isNaN(parseFloat(value)) || parseFloat(value).toString() !== value)\n  );\n}\n\n/**\n * Checks if the provided value is a boolean.\n */\nexport function isBoolean(value: unknown): boolean {\n  return typeof value === \"boolean\";\n}\n\n/**\n * Casts a value that might be string or number to actual string or number.\n * Since LLM might return back an integer/float as a string, we need to cast\n * it back to a number, as many vector databases can't handle number as string\n * values as a comparator.\n */\nexport function castValue(input: unknown): string | number | boolean {\n  let value;\n  if (isString(input)) {\n    value = input as string;\n  } else if (isInt(input)) {\n    value = parseInt(input as string, 10);\n  } else if (isFloat(input)) {\n    value = parseFloat(input as string);\n  } else if (isBoolean(input)) {\n    value = Boolean(input);\n  } else {\n    throw new Error(\"Unsupported value type\");\n  }\n\n  return value;\n}\n", "import { VectorStore } from \"../vectorstores.js\";\nimport {\n  Comparator,\n  Comparators,\n  Comparison,\n  Operation,\n  Operator,\n  Operators,\n  StructuredQuery,\n  Visitor,\n  VisitorComparisonResult,\n  VisitorOperationResult,\n  VisitorResult,\n  VisitorStructuredQueryResult,\n} from \"./ir.js\";\nimport { isFilterEmpty, castValue } from \"./utils.js\";\n\n/**\n * Options object for the BasicTranslator class. Specifies the allowed\n * operators and comparators.\n */\nexport type TranslatorOpts = {\n  allowedOperators: Operator[];\n  allowedComparators: Comparator[];\n};\n\n/**\n * Abstract class that provides a blueprint for creating specific\n * translator classes. Defines two abstract methods: formatFunction and\n * mergeFilters.\n */\nexport abstract class BaseTranslator<\n  T extends VectorStore = VectorStore,\n> extends Visitor<T> {\n  /**\n   * Formats a given function (either an operator or a comparator) into a\n   * string.\n   * @param func The function to format.\n   * @returns Formatted string representation of the function.\n   */\n  abstract formatFunction(func: Operator | Comparator): string;\n\n  /**\n   * Merges two filters into one, using a specified merge type.\n   * @param defaultFilter The default filter.\n   * @param generatedFilter The generated filter.\n   * @param mergeType The type of merge to perform. Can be 'and', 'or', or 'replace'.\n   * @param forceDefaultFilter If true, the default filter will be used even if the generated filter is not empty.\n   * @returns The merged filter, or undefined if both filters are empty.\n   */\n  abstract mergeFilters(\n    defaultFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    generatedFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    mergeType?: \"and\" | \"or\" | \"replace\",\n    forceDefaultFilter?: boolean\n  ): this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined;\n}\n\n/**\n * Class that extends the BaseTranslator class and provides concrete\n * implementations for the abstract methods. Also declares three types:\n * VisitOperationOutput, VisitComparisonOutput, and\n * VisitStructuredQueryOutput, which are used as the return types for the\n * visitOperation, visitComparison, and visitStructuredQuery methods\n * respectively.\n */\nexport class BasicTranslator<\n  T extends VectorStore = VectorStore,\n> extends BaseTranslator<T> {\n  declare VisitOperationOutput: VisitorOperationResult;\n\n  declare VisitComparisonOutput: VisitorComparisonResult;\n\n  declare VisitStructuredQueryOutput: VisitorStructuredQueryResult;\n\n  allowedOperators: Operator[];\n\n  allowedComparators: Comparator[];\n\n  constructor(opts?: TranslatorOpts) {\n    super();\n    this.allowedOperators = opts?.allowedOperators ?? [\n      Operators.and,\n      Operators.or,\n    ];\n    this.allowedComparators = opts?.allowedComparators ?? [\n      Comparators.eq,\n      Comparators.ne,\n      Comparators.gt,\n      Comparators.gte,\n      Comparators.lt,\n      Comparators.lte,\n    ];\n  }\n\n  formatFunction(func: Operator | Comparator): string {\n    if (func in Comparators) {\n      if (\n        this.allowedComparators.length > 0 &&\n        this.allowedComparators.indexOf(func as Comparator) === -1\n      ) {\n        throw new Error(\n          `Comparator ${func} not allowed. Allowed comparators: ${this.allowedComparators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else if (func in Operators) {\n      if (\n        this.allowedOperators.length > 0 &&\n        this.allowedOperators.indexOf(func as Operator) === -1\n      ) {\n        throw new Error(\n          `Operator ${func} not allowed. Allowed operators: ${this.allowedOperators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else {\n      throw new Error(\"Unknown comparator or operator\");\n    }\n    return `$${func}`;\n  }\n\n  /**\n   * Visits an operation and returns a result.\n   * @param operation The operation to visit.\n   * @returns The result of visiting the operation.\n   */\n  visitOperation(operation: Operation): this[\"VisitOperationOutput\"] {\n    const args = operation.args?.map((arg) =>\n      arg.accept(this)\n    ) as VisitorResult[];\n    return {\n      [this.formatFunction(operation.operator)]: args,\n    };\n  }\n\n  /**\n   * Visits a comparison and returns a result.\n   * @param comparison The comparison to visit.\n   * @returns The result of visiting the comparison.\n   */\n  visitComparison(comparison: Comparison): this[\"VisitComparisonOutput\"] {\n    return {\n      [comparison.attribute]: {\n        [this.formatFunction(comparison.comparator)]: castValue(\n          comparison.value\n        ),\n      },\n    };\n  }\n\n  /**\n   * Visits a structured query and returns a result.\n   * @param query The structured query to visit.\n   * @returns The result of visiting the structured query.\n   */\n  visitStructuredQuery(\n    query: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"] {\n    let nextArg = {};\n    if (query.filter) {\n      nextArg = {\n        filter: query.filter.accept(this),\n      };\n    }\n    return nextArg;\n  }\n\n  mergeFilters(\n    defaultFilter: VisitorStructuredQueryResult[\"filter\"] | undefined,\n    generatedFilter: VisitorStructuredQueryResult[\"filter\"] | undefined,\n    mergeType = \"and\",\n    forceDefaultFilter = false\n  ): VisitorStructuredQueryResult[\"filter\"] | undefined {\n    if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) {\n      return undefined;\n    }\n    if (isFilterEmpty(defaultFilter) || mergeType === \"replace\") {\n      if (isFilterEmpty(generatedFilter)) {\n        return undefined;\n      }\n      return generatedFilter;\n    }\n    if (isFilterEmpty(generatedFilter)) {\n      if (forceDefaultFilter) {\n        return defaultFilter;\n      }\n      if (mergeType === \"and\") {\n        return undefined;\n      }\n      return defaultFilter;\n    }\n    if (mergeType === \"and\") {\n      return {\n        $and: [defaultFilter, generatedFilter],\n      };\n    } else if (mergeType === \"or\") {\n      return {\n        $or: [defaultFilter, generatedFilter],\n      };\n    } else {\n      throw new Error(\"Unknown merge type\");\n    }\n  }\n}\n", "import { Document } from \"../documents/document.js\";\nimport {\n  Comparator,\n  Comparators,\n  Comparison,\n  Operation,\n  Operator,\n  Operators,\n  StructuredQuery,\n} from \"./ir.js\";\nimport { BaseTranslator } from \"./base.js\";\nimport { castValue, isFilterEmpty } from \"./utils.js\";\n\n/**\n * A type alias for an object that maps comparison operators to string or\n * number values. This is used in the comparison functions to determine\n * the result of a comparison operation.\n */\ntype ValueType = {\n  eq: string | number | boolean;\n  ne: string | number | boolean;\n  lt: string | number;\n  lte: string | number;\n  gt: string | number;\n  gte: string | number;\n};\n\n/**\n * A type alias for a function that takes a `Document` as an argument and\n * returns a boolean. This function is used as a filter for documents.\n */\nexport type FunctionFilter = (document: Document) => boolean;\n\n/**\n * A class that extends `BaseTranslator` to translate structured queries\n * into functional filters.\n * @example\n * ```typescript\n * const functionalTranslator = new FunctionalTranslator();\n * const relevantDocuments = await functionalTranslator.getRelevantDocuments(\n *   \"Which movies are rated higher than 8.5?\",\n * );\n * ```\n */\nexport class FunctionalTranslator extends BaseTranslator {\n  declare VisitOperationOutput: FunctionFilter;\n\n  declare VisitComparisonOutput: FunctionFilter;\n\n  declare VisitStructuredQueryOutput:\n    | { filter: FunctionFilter }\n    | { [k: string]: never };\n\n  allowedOperators: Operator[] = [Operators.and, Operators.or];\n\n  allowedComparators: Comparator[] = [\n    Comparators.eq,\n    Comparators.ne,\n    Comparators.gt,\n    Comparators.gte,\n    Comparators.lt,\n    Comparators.lte,\n  ];\n\n  formatFunction(): string {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Returns the allowed comparators for a given data type.\n   * @param input The input value to get the allowed comparators for.\n   * @returns An array of allowed comparators for the input data type.\n   */\n  getAllowedComparatorsForType(inputType: string): Comparator[] {\n    switch (inputType) {\n      case \"string\": {\n        return [\n          Comparators.eq,\n          Comparators.ne,\n          Comparators.gt,\n          Comparators.gte,\n          Comparators.lt,\n          Comparators.lte,\n        ];\n      }\n      case \"number\": {\n        return [\n          Comparators.eq,\n          Comparators.ne,\n          Comparators.gt,\n          Comparators.gte,\n          Comparators.lt,\n          Comparators.lte,\n        ];\n      }\n      case \"boolean\": {\n        return [Comparators.eq, Comparators.ne];\n      }\n      default: {\n        throw new Error(`Unsupported data type: ${inputType}`);\n      }\n    }\n  }\n\n  /**\n   * Returns a function that performs a comparison based on the provided\n   * comparator.\n   * @param comparator The comparator to base the comparison function on.\n   * @returns A function that takes two arguments and returns a boolean based on the comparison.\n   */\n  getComparatorFunction<C extends Comparator>(\n    comparator: Comparator\n  ): (a: string | number, b: ValueType[C]) => boolean {\n    switch (comparator) {\n      case Comparators.eq: {\n        return (a: string | number, b: ValueType[C]) => a === b;\n      }\n      case Comparators.ne: {\n        return (a: string | number, b: ValueType[C]) => a !== b;\n      }\n      case Comparators.gt: {\n        return (a: string | number, b: ValueType[C]) => a > b;\n      }\n      case Comparators.gte: {\n        return (a: string | number, b: ValueType[C]) => a >= b;\n      }\n      case Comparators.lt: {\n        return (a: string | number, b: ValueType[C]) => a < b;\n      }\n      case Comparators.lte: {\n        return (a: string | number, b: ValueType[C]) => a <= b;\n      }\n      default: {\n        throw new Error(\"Unknown comparator\");\n      }\n    }\n  }\n\n  /**\n   * Returns a function that performs an operation based on the provided\n   * operator.\n   * @param operator The operator to base the operation function on.\n   * @returns A function that takes two boolean arguments and returns a boolean based on the operation.\n   */\n  getOperatorFunction(operator: Operator): (a: boolean, b: boolean) => boolean {\n    switch (operator) {\n      case Operators.and: {\n        return (a, b) => a && b;\n      }\n      case Operators.or: {\n        return (a, b) => a || b;\n      }\n      default: {\n        throw new Error(\"Unknown operator\");\n      }\n    }\n  }\n\n  /**\n   * Visits the operation part of a structured query and translates it into\n   * a functional filter.\n   * @param operation The operation part of a structured query.\n   * @returns A function that takes a `Document` as an argument and returns a boolean based on the operation.\n   */\n  visitOperation(operation: Operation): this[\"VisitOperationOutput\"] {\n    const { operator, args } = operation;\n    if (this.allowedOperators.includes(operator)) {\n      const operatorFunction = this.getOperatorFunction(operator);\n      return (document: Document) => {\n        if (!args) {\n          return true;\n        }\n\n        return args.reduce((acc, arg) => {\n          const result = arg.accept(this);\n          if (typeof result === \"function\") {\n            return operatorFunction(acc, result(document));\n          } else {\n            throw new Error(\"Filter is not a function\");\n          }\n        }, true);\n      };\n    } else {\n      throw new Error(\"Operator not allowed\");\n    }\n  }\n\n  /**\n   * Visits the comparison part of a structured query and translates it into\n   * a functional filter.\n   * @param comparison The comparison part of a structured query.\n   * @returns A function that takes a `Document` as an argument and returns a boolean based on the comparison.\n   */\n  visitComparison(\n    comparison: Comparison<string | number | boolean>\n  ): this[\"VisitComparisonOutput\"] {\n    const { comparator, attribute, value } = comparison;\n    const undefinedTrue = [Comparators.ne];\n    if (this.allowedComparators.includes(comparator)) {\n      if (\n        !this.getAllowedComparatorsForType(typeof value).includes(comparator)\n      ) {\n        throw new Error(\n          `'${comparator}' comparator not allowed to be used with ${typeof value}`\n        );\n      }\n      const comparatorFunction = this.getComparatorFunction(comparator);\n      return (document: Document) => {\n        const documentValue = document.metadata[attribute];\n        if (documentValue === undefined) {\n          if (undefinedTrue.includes(comparator)) {\n            return true;\n          }\n          return false;\n        }\n        return comparatorFunction(documentValue, castValue(value));\n      };\n    } else {\n      throw new Error(\"Comparator not allowed\");\n    }\n  }\n\n  /**\n   * Visits a structured query and translates it into a functional filter.\n   * @param query The structured query to translate.\n   * @returns An object containing a `filter` property, which is a function that takes a `Document` as an argument and returns a boolean based on the structured query.\n   */\n  visitStructuredQuery(\n    query: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"] {\n    if (!query.filter) {\n      return {};\n    }\n    const filterFunction = query.filter?.accept(this);\n    if (typeof filterFunction !== \"function\") {\n      throw new Error(\"Structured query filter is not a function\");\n    }\n    return { filter: filterFunction as FunctionFilter };\n  }\n\n  /**\n   * Merges two filters into one, based on the specified merge type.\n   * @param defaultFilter The default filter function.\n   * @param generatedFilter The generated filter function.\n   * @param mergeType The type of merge to perform. Can be 'and', 'or', or 'replace'. Default is 'and'.\n   * @returns A function that takes a `Document` as an argument and returns a boolean based on the merged filters, or `undefined` if both filters are empty.\n   */\n  mergeFilters(\n    defaultFilter: FunctionFilter,\n    generatedFilter: FunctionFilter,\n    mergeType = \"and\"\n  ): FunctionFilter | undefined {\n    if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) {\n      return undefined;\n    }\n    if (isFilterEmpty(defaultFilter) || mergeType === \"replace\") {\n      if (isFilterEmpty(generatedFilter)) {\n        return undefined;\n      }\n      return generatedFilter;\n    }\n    if (isFilterEmpty(generatedFilter)) {\n      if (mergeType === \"and\") {\n        return undefined;\n      }\n      return defaultFilter;\n    }\n\n    if (mergeType === \"and\") {\n      return (document: Document) =>\n        defaultFilter(document) && generatedFilter(document);\n    } else if (mergeType === \"or\") {\n      return (document: Document) =>\n        defaultFilter(document) || generatedFilter(document);\n    } else {\n      throw new Error(\"Unknown merge type\");\n    }\n  }\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { Comparators, Comparison, Expression, FilterDirective, Operation, Operators, StructuredQuery, Visitor } from \"./ir.js\";\nimport { castValue, isBoolean, isFilterEmpty, isFloat, isInt, isObject, isString } from \"./utils.js\";\nimport { BaseTranslator, BasicTranslator } from \"./base.js\";\nimport { FunctionalTranslator } from \"./functional.js\";\n\n//#region src/structured_query/index.ts\nvar structured_query_exports = {};\n__export(structured_query_exports, {\n\tBaseTranslator: () => BaseTranslator,\n\tBasicTranslator: () => BasicTranslator,\n\tComparators: () => Comparators,\n\tComparison: () => Comparison,\n\tExpression: () => Expression,\n\tFilterDirective: () => FilterDirective,\n\tFunctionalTranslator: () => FunctionalTranslator,\n\tOperation: () => Operation,\n\tOperators: () => Operators,\n\tStructuredQuery: () => StructuredQuery,\n\tVisitor: () => Visitor,\n\tcastValue: () => castValue,\n\tisBoolean: () => isBoolean,\n\tisFilterEmpty: () => isFilterEmpty,\n\tisFloat: () => isFloat,\n\tisInt: () => isInt,\n\tisObject: () => isObject,\n\tisString: () => isString\n});\n\n//#endregion\nexport { BaseTranslator, BasicTranslator, Comparators, Comparison, Expression, FilterDirective, FunctionalTranslator, Operation, Operators, StructuredQuery, Visitor, castValue, isBoolean, isFilterEmpty, isFloat, isInt, isObject, isString, structured_query_exports };\n//# sourceMappingURL=index.js.map", "import type { z as z3 } from \"zod/v3\";\nimport { CallbackManagerForToolRun } from \"../callbacks/manager.js\";\nimport type {\n  BaseLangChainParams,\n  ToolDefinition,\n} from \"../language_models/base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport {\n  Runnable,\n  RunnableToolLike,\n  type RunnableInterface,\n} from \"../runnables/base.js\";\nimport {\n  type DirectToolOutput,\n  type ToolCall,\n  type ToolMessage,\n} from \"../messages/tool.js\";\nimport type { MessageContent } from \"../messages/base.js\";\nimport {\n  type InferInteropZodInput,\n  type InferInteropZodOutput,\n  type InteropZodType,\n  isInteropZodSchema,\n  type InteropZodObject,\n} from \"../utils/types/zod.js\";\n\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport type { BaseStore } from \"../stores.js\";\n\nexport type ResponseFormat = \"content\" | \"content_and_artifact\" | string;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolOutputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ContentAndArtifact = [MessageContent, any];\n\n/**\n * Conditional type that determines the return type of the {@link StructuredTool.invoke} method.\n * - If the input is a ToolCall, it returns a ToolMessage\n * - If the config is a runnable config and contains a toolCall property, it returns a ToolMessage\n * - Otherwise, it returns the original output type\n */\nexport type ToolReturnType<TInput, TConfig, TOutput> =\n  TOutput extends DirectToolOutput\n    ? TOutput\n    : TConfig extends { toolCall: { id: string } }\n      ? ToolMessage\n      : TConfig extends { toolCall: { id: undefined } }\n        ? TOutput\n        : TConfig extends { toolCall: { id?: string } }\n          ? TOutput | ToolMessage\n          : TInput extends ToolCall\n            ? ToolMessage\n            : TOutput;\n\n/**\n * Base type that establishes the types of input schemas that can be used for LangChain tool\n * definitions.\n */\nexport type ToolInputSchemaBase = z3.ZodTypeAny | JSONSchema;\n\n/**\n * Parameters for the Tool classes.\n */\nexport interface ToolParams extends BaseLangChainParams {\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n  /**\n   * Whether to show full details in the thrown parsing errors.\n   *\n   * @default false\n   */\n  verboseParsingErrors?: boolean;\n  /**\n   * Metadata for the tool.\n   */\n  metadata?: Record<string, unknown>;\n  /**\n   * Optional provider-specific extra fields for the tool.\n   *\n   * This is used to pass provider-specific configuration that doesn't fit into\n   * standard tool fields.\n   */\n  extras?: Record<string, unknown>;\n}\n\nexport type ToolRunnableConfig<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ConfigurableFieldType extends Record<string, any> = Record<string, any>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextSchema = any,\n> = RunnableConfig<ConfigurableFieldType> & {\n  toolCall?: ToolCall;\n  context?: ContextSchema;\n};\n\n/**\n * Schema for defining tools.\n *\n * @version 0.2.19\n */\nexport interface StructuredToolParams\n  extends Pick<StructuredToolInterface, \"name\" | \"schema\" | \"extras\"> {\n  /**\n   * An optional description of the tool to pass to the model.\n   */\n  description?: string;\n}\n\n/**\n * Utility type that resolves the output type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaOutputType<T> = T extends InteropZodType\n  ? InferInteropZodOutput<T>\n  : T extends JSONSchema\n    ? unknown\n    : never;\n\n/**\n * Utility type that resolves the input type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaInputType<T> = T extends InteropZodType\n  ? InferInteropZodInput<T>\n  : T extends JSONSchema\n    ? unknown\n    : never;\n\n/**\n * Defines the type that will be passed into a tool handler function as a result of a tool call.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport type StructuredToolCallInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n> =\n  | (ToolInputSchemaOutputType<SchemaT> extends string ? string : never)\n  | SchemaInputT\n  | ToolCall;\n\n/**\n * An input schema type for tools that accept a single string input.\n *\n * This schema defines a tool that takes an optional string parameter named \"input\".\n * It uses Zod's effects to transform the input and strip any extra properties.\n *\n * This is primarily used for creating simple string-based tools where the LLM\n * only needs to provide a single text value as input to the tool.\n */\nexport type StringInputToolSchema = z3.ZodType<\n  string | undefined,\n  z3.ZodTypeDef,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  any\n>;\n\n/**\n * Defines the type for input to a tool's call method.\n *\n * This type is a convenience alias for StructuredToolCallInput with the input type\n * derived from the schema. It represents the possible inputs that can be passed to a tool,\n * which can be either:\n * - A string (if the tool accepts string input)\n * - A structured input matching the tool's schema\n * - A ToolCall object (typically from an LLM)\n *\n * @param SchemaT - The schema type for the tool input, defaults to StringInputToolSchema\n */\nexport type ToolCallInput<SchemaT = StringInputToolSchema> =\n  StructuredToolCallInput<SchemaT, ToolInputSchemaInputType<SchemaT>>;\n\n/**\n * Interface that defines the shape of a LangChain structured tool.\n *\n * A structured tool is a tool that uses a schema to define the structure of the arguments that the\n * LLM generates as part of its {@link ToolCall}.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface StructuredToolInterface<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n> extends RunnableInterface<\n    StructuredToolCallInput<SchemaT, SchemaInputT>,\n    ToolOutputT | ToolMessage\n  > {\n  lc_namespace: string[];\n\n  /**\n   * A Zod schema representing the parameters of the tool.\n   */\n  schema: SchemaT;\n\n  /**\n   * Invokes the tool with the provided argument and configuration.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration for the tool call.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  invoke<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    arg: TArg,\n    configArg?: TConfig\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * The name of the tool.\n   */\n  name: string;\n\n  /**\n   * A description of the tool.\n   */\n  description: string;\n\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect: boolean;\n\n  /**\n   * Optional provider-specific extra fields for the tool.\n   *\n   * This is used to pass provider-specific configuration that doesn't fit into\n   * standard tool fields.\n   */\n  extras?: Record<string, unknown>;\n}\n\n/**\n * A special interface for tools that accept a string input, usually defined with the {@link Tool} class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface ToolInterface<\n  SchemaT = StringInputToolSchema,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n> extends StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT> {\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    // TODO: shouldn't this be narrowed based on SchemaT?\n    arg: TArg,\n    callbacks?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>>;\n}\n\n/**\n * Base interface for the input parameters of the {@link DynamicTool} and\n * {@link DynamicStructuredTool} classes.\n */\nexport interface BaseDynamicToolInput extends ToolParams {\n  name: string;\n  description: string;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n\n/**\n * Interface for the input parameters of the DynamicTool class.\n */\nexport interface DynamicToolInput<ToolOutputT = ToolOutputType>\n  extends BaseDynamicToolInput {\n  func: (\n    input: string,\n    runManager?: CallbackManagerForToolRun,\n    config?: ToolRunnableConfig\n  ) => Promise<ToolOutputT>;\n}\n\n/**\n * Interface for the input parameters of the DynamicStructuredTool class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaOutputT - The TypeScript type representing the result of applying the schema to the tool arguments. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface DynamicStructuredToolInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n> extends BaseDynamicToolInput {\n  /**\n   * Tool handler function - the function that will be called when the tool is invoked.\n   *\n   * @param input - The input to the tool.\n   * @param runManager - The run manager for the tool.\n   * @param config - The configuration for the tool.\n   * @returns The result of the tool.\n   */\n  func: (\n    input: SchemaOutputT,\n    runManager?: CallbackManagerForToolRun,\n    config?: RunnableConfig\n  ) => Promise<ToolOutputT>;\n  schema: SchemaT;\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nexport function isStructuredTool(\n  tool?: StructuredToolInterface | ToolDefinition | JSONSchema\n): tool is StructuredToolInterface {\n  return (\n    tool !== undefined &&\n    Array.isArray((tool as StructuredToolInterface).lc_namespace)\n  );\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nexport function isRunnableToolLike(tool?: unknown): tool is RunnableToolLike {\n  return (\n    tool !== undefined &&\n    Runnable.isRunnable(tool) &&\n    \"lc_name\" in tool.constructor &&\n    typeof tool.constructor.lc_name === \"function\" &&\n    tool.constructor.lc_name() === \"RunnableToolLike\"\n  );\n}\n\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nexport function isStructuredToolParams(\n  tool?: unknown\n): tool is StructuredToolParams {\n  return (\n    !!tool &&\n    typeof tool === \"object\" &&\n    \"name\" in tool &&\n    \"schema\" in tool &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (isInteropZodSchema(tool.schema as Record<string, any>) ||\n      (tool.schema != null &&\n        typeof tool.schema === \"object\" &&\n        \"type\" in tool.schema &&\n        typeof tool.schema.type === \"string\" &&\n        [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"].includes(\n          tool.schema.type\n        )))\n  );\n}\n\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nexport function isLangChainTool(tool?: unknown): tool is StructuredToolParams {\n  return (\n    isStructuredToolParams(tool) ||\n    isRunnableToolLike(tool) ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isStructuredTool(tool as any)\n  );\n}\n\n/**\n * Runtime context automatically injected into tools.\n *\n * When a tool function has a parameter named `tool_runtime` with type hint\n * `ToolRuntime`, the tool execution system will automatically inject an instance\n * containing:\n *\n * - `state`: The current graph state\n * - `toolCallId`: The ID of the current tool call\n * - `config`: `RunnableConfig` for the current execution\n * - `context`: Runtime context\n * - `store`: `BaseStore` instance for persistent storage\n * - `writer`: Stream writer for streaming output\n *\n * No `Annotated` wrapper is needed - just use `runtime: ToolRuntime`\n * as a parameter.\n *\n * @example\n * ```typescript\n * import { tool, type ToolRuntime } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const stateSchema = z.object({\n *   messages: z.array(z.any()),\n *   userId: z.string().optional(),\n * });\n *\n * const greet = tool(\n *   async ({ name }, runtime: ToolRuntime<typeof stateSchema>) => {\n *     // Access state\n *     const messages = runtime.state.messages;\n *\n *     // Access tool_call_id\n *     console.log(`Tool call ID: ${runtime.toolCallId}`);\n *\n *     // Access config\n *     console.log(`Run ID: ${runtime.config.runId}`);\n *\n *     // Access runtime context\n *     const userId = runtime.context?.userId;\n *\n *     // Access store\n *     await runtime.store?.mset([[\"key\", \"value\"]]);\n *\n *     // Stream output\n *     runtime.writer?.(\"Processing...\");\n *\n *     return `Hello! User ID: ${runtime.state.userId || \"unknown\"} ${name}`;\n *   },\n *   {\n *     name: \"greet\",\n *     description: \"Use this to greet the user once you found their info.\",\n *     schema: z.object({ name: z.string() }),\n *     stateSchema,\n *   }\n * );\n *\n * const agent = createAgent({\n *   model,\n *   tools: [greet],\n *   stateSchema,\n *   contextSchema,\n * });\n * ```\n *\n * @template StateT - The type of the state schema (inferred from stateSchema)\n * @template ContextT - The type of the context schema (inferred from contextSchema)\n */\nexport type ToolRuntime<\n  TState = unknown,\n  TContext = unknown,\n> = RunnableConfig & {\n  /**\n   * The current graph state.\n   */\n  state: TState extends InteropZodObject\n    ? InferInteropZodOutput<TState>\n    : TState extends Record<string, unknown>\n      ? TState\n      : unknown;\n  /**\n   * The ID of the current tool call.\n   */\n  toolCallId: string;\n  /**\n   * The current tool call.\n   */\n  toolCall?: ToolCall;\n  /**\n   * RunnableConfig for the current execution.\n   */\n  config: ToolRunnableConfig;\n  /**\n   * Runtime context (from langgraph `Runtime`).\n   */\n  context: TContext extends InteropZodObject\n    ? InferInteropZodOutput<TContext>\n    : TContext extends Record<string, unknown>\n      ? TContext\n      : unknown;\n  /**\n   * BaseStore instance for persistent storage (from langgraph `Runtime`).\n   */\n  store: BaseStore<string, unknown> | null;\n  /**\n   * Stream writer for streaming output (from langgraph `Runtime`).\n   */\n  writer: ((chunk: unknown) => void) | null;\n};\n", "export * as core from \"../core/index.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./errors.js\";\nexport * from \"./parse.js\";\nexport * from \"./compat.js\";\n// zod-specified\nimport { config } from \"../core/index.js\";\nimport en from \"../locales/en.js\";\nconfig(en());\nexport { globalRegistry, registry, config, $output, $input, $brand, clone, regexes, treeifyError, prettifyError, formatError, flattenError, TimePrecision, util, NEVER, } from \"../core/index.js\";\nexport { toJSONSchema } from \"../core/json-schema-processors.js\";\nexport { fromJSONSchema } from \"./from-json-schema.js\";\nexport * as locales from \"../locales/index.js\";\n// iso\n// must be exported from top-level\n// https://github.com/colinhacks/zod/issues/4491\nexport { ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration } from \"./iso.js\";\nexport * as iso from \"./iso.js\";\nexport * as coerce from \"./coerce.js\";\n", "import * as core from \"../core/index.js\";\nimport { util } from \"../core/index.js\";\nimport * as processors from \"../core/json-schema-processors.js\";\nimport { createStandardJSONSchemaMethod, createToJSONSchemaMethod } from \"../core/to-json-schema.js\";\nimport * as checks from \"./checks.js\";\nimport * as iso from \"./iso.js\";\nimport * as parse from \"./parse.js\";\nexport const ZodType = /*@__PURE__*/ core.$constructor(\"ZodType\", (inst, def) => {\n    core.$ZodType.init(inst, def);\n    Object.assign(inst[\"~standard\"], {\n        jsonSchema: {\n            input: createStandardJSONSchemaMethod(inst, \"input\"),\n            output: createStandardJSONSchemaMethod(inst, \"output\"),\n        },\n    });\n    inst.toJSONSchema = createToJSONSchemaMethod(inst, {});\n    inst.def = def;\n    inst.type = def.type;\n    Object.defineProperty(inst, \"_def\", { value: def });\n    // base methods\n    inst.check = (...checks) => {\n        return inst.clone(util.mergeDefs(def, {\n            checks: [\n                ...(def.checks ?? []),\n                ...checks.map((ch) => typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch),\n            ],\n        }), {\n            parent: true,\n        });\n    };\n    inst.with = inst.check;\n    inst.clone = (def, params) => core.clone(inst, def, params);\n    inst.brand = () => inst;\n    inst.register = ((reg, meta) => {\n        reg.add(inst, meta);\n        return inst;\n    });\n    // parsing\n    inst.parse = (data, params) => parse.parse(inst, data, params, { callee: inst.parse });\n    inst.safeParse = (data, params) => parse.safeParse(inst, data, params);\n    inst.parseAsync = async (data, params) => parse.parseAsync(inst, data, params, { callee: inst.parseAsync });\n    inst.safeParseAsync = async (data, params) => parse.safeParseAsync(inst, data, params);\n    inst.spa = inst.safeParseAsync;\n    // encoding/decoding\n    inst.encode = (data, params) => parse.encode(inst, data, params);\n    inst.decode = (data, params) => parse.decode(inst, data, params);\n    inst.encodeAsync = async (data, params) => parse.encodeAsync(inst, data, params);\n    inst.decodeAsync = async (data, params) => parse.decodeAsync(inst, data, params);\n    inst.safeEncode = (data, params) => parse.safeEncode(inst, data, params);\n    inst.safeDecode = (data, params) => parse.safeDecode(inst, data, params);\n    inst.safeEncodeAsync = async (data, params) => parse.safeEncodeAsync(inst, data, params);\n    inst.safeDecodeAsync = async (data, params) => parse.safeDecodeAsync(inst, data, params);\n    // refinements\n    inst.refine = (check, params) => inst.check(refine(check, params));\n    inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n    inst.overwrite = (fn) => inst.check(checks.overwrite(fn));\n    // wrappers\n    inst.optional = () => optional(inst);\n    inst.exactOptional = () => exactOptional(inst);\n    inst.nullable = () => nullable(inst);\n    inst.nullish = () => optional(nullable(inst));\n    inst.nonoptional = (params) => nonoptional(inst, params);\n    inst.array = () => array(inst);\n    inst.or = (arg) => union([inst, arg]);\n    inst.and = (arg) => intersection(inst, arg);\n    inst.transform = (tx) => pipe(inst, transform(tx));\n    inst.default = (def) => _default(inst, def);\n    inst.prefault = (def) => prefault(inst, def);\n    // inst.coalesce = (def, params) => coalesce(inst, def, params);\n    inst.catch = (params) => _catch(inst, params);\n    inst.pipe = (target) => pipe(inst, target);\n    inst.readonly = () => readonly(inst);\n    // meta\n    inst.describe = (description) => {\n        const cl = inst.clone();\n        core.globalRegistry.add(cl, { description });\n        return cl;\n    };\n    Object.defineProperty(inst, \"description\", {\n        get() {\n            return core.globalRegistry.get(inst)?.description;\n        },\n        configurable: true,\n    });\n    inst.meta = (...args) => {\n        if (args.length === 0) {\n            return core.globalRegistry.get(inst);\n        }\n        const cl = inst.clone();\n        core.globalRegistry.add(cl, args[0]);\n        return cl;\n    };\n    // helpers\n    inst.isOptional = () => inst.safeParse(undefined).success;\n    inst.isNullable = () => inst.safeParse(null).success;\n    inst.apply = (fn) => fn(inst);\n    return inst;\n});\n/** @internal */\nexport const _ZodString = /*@__PURE__*/ core.$constructor(\"_ZodString\", (inst, def) => {\n    core.$ZodString.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.stringProcessor(inst, ctx, json, params);\n    const bag = inst._zod.bag;\n    inst.format = bag.format ?? null;\n    inst.minLength = bag.minimum ?? null;\n    inst.maxLength = bag.maximum ?? null;\n    // validations\n    inst.regex = (...args) => inst.check(checks.regex(...args));\n    inst.includes = (...args) => inst.check(checks.includes(...args));\n    inst.startsWith = (...args) => inst.check(checks.startsWith(...args));\n    inst.endsWith = (...args) => inst.check(checks.endsWith(...args));\n    inst.min = (...args) => inst.check(checks.minLength(...args));\n    inst.max = (...args) => inst.check(checks.maxLength(...args));\n    inst.length = (...args) => inst.check(checks.length(...args));\n    inst.nonempty = (...args) => inst.check(checks.minLength(1, ...args));\n    inst.lowercase = (params) => inst.check(checks.lowercase(params));\n    inst.uppercase = (params) => inst.check(checks.uppercase(params));\n    // transforms\n    inst.trim = () => inst.check(checks.trim());\n    inst.normalize = (...args) => inst.check(checks.normalize(...args));\n    inst.toLowerCase = () => inst.check(checks.toLowerCase());\n    inst.toUpperCase = () => inst.check(checks.toUpperCase());\n    inst.slugify = () => inst.check(checks.slugify());\n});\nexport const ZodString = /*@__PURE__*/ core.$constructor(\"ZodString\", (inst, def) => {\n    core.$ZodString.init(inst, def);\n    _ZodString.init(inst, def);\n    inst.email = (params) => inst.check(core._email(ZodEmail, params));\n    inst.url = (params) => inst.check(core._url(ZodURL, params));\n    inst.jwt = (params) => inst.check(core._jwt(ZodJWT, params));\n    inst.emoji = (params) => inst.check(core._emoji(ZodEmoji, params));\n    inst.guid = (params) => inst.check(core._guid(ZodGUID, params));\n    inst.uuid = (params) => inst.check(core._uuid(ZodUUID, params));\n    inst.uuidv4 = (params) => inst.check(core._uuidv4(ZodUUID, params));\n    inst.uuidv6 = (params) => inst.check(core._uuidv6(ZodUUID, params));\n    inst.uuidv7 = (params) => inst.check(core._uuidv7(ZodUUID, params));\n    inst.nanoid = (params) => inst.check(core._nanoid(ZodNanoID, params));\n    inst.guid = (params) => inst.check(core._guid(ZodGUID, params));\n    inst.cuid = (params) => inst.check(core._cuid(ZodCUID, params));\n    inst.cuid2 = (params) => inst.check(core._cuid2(ZodCUID2, params));\n    inst.ulid = (params) => inst.check(core._ulid(ZodULID, params));\n    inst.base64 = (params) => inst.check(core._base64(ZodBase64, params));\n    inst.base64url = (params) => inst.check(core._base64url(ZodBase64URL, params));\n    inst.xid = (params) => inst.check(core._xid(ZodXID, params));\n    inst.ksuid = (params) => inst.check(core._ksuid(ZodKSUID, params));\n    inst.ipv4 = (params) => inst.check(core._ipv4(ZodIPv4, params));\n    inst.ipv6 = (params) => inst.check(core._ipv6(ZodIPv6, params));\n    inst.cidrv4 = (params) => inst.check(core._cidrv4(ZodCIDRv4, params));\n    inst.cidrv6 = (params) => inst.check(core._cidrv6(ZodCIDRv6, params));\n    inst.e164 = (params) => inst.check(core._e164(ZodE164, params));\n    // iso\n    inst.datetime = (params) => inst.check(iso.datetime(params));\n    inst.date = (params) => inst.check(iso.date(params));\n    inst.time = (params) => inst.check(iso.time(params));\n    inst.duration = (params) => inst.check(iso.duration(params));\n});\nexport function string(params) {\n    return core._string(ZodString, params);\n}\nexport const ZodStringFormat = /*@__PURE__*/ core.$constructor(\"ZodStringFormat\", (inst, def) => {\n    core.$ZodStringFormat.init(inst, def);\n    _ZodString.init(inst, def);\n});\nexport const ZodEmail = /*@__PURE__*/ core.$constructor(\"ZodEmail\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodEmail.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function email(params) {\n    return core._email(ZodEmail, params);\n}\nexport const ZodGUID = /*@__PURE__*/ core.$constructor(\"ZodGUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodGUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function guid(params) {\n    return core._guid(ZodGUID, params);\n}\nexport const ZodUUID = /*@__PURE__*/ core.$constructor(\"ZodUUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodUUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function uuid(params) {\n    return core._uuid(ZodUUID, params);\n}\nexport function uuidv4(params) {\n    return core._uuidv4(ZodUUID, params);\n}\n// ZodUUIDv6\nexport function uuidv6(params) {\n    return core._uuidv6(ZodUUID, params);\n}\n// ZodUUIDv7\nexport function uuidv7(params) {\n    return core._uuidv7(ZodUUID, params);\n}\nexport const ZodURL = /*@__PURE__*/ core.$constructor(\"ZodURL\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodURL.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function url(params) {\n    return core._url(ZodURL, params);\n}\nexport function httpUrl(params) {\n    return core._url(ZodURL, {\n        protocol: /^https?$/,\n        hostname: core.regexes.domain,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodEmoji = /*@__PURE__*/ core.$constructor(\"ZodEmoji\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodEmoji.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function emoji(params) {\n    return core._emoji(ZodEmoji, params);\n}\nexport const ZodNanoID = /*@__PURE__*/ core.$constructor(\"ZodNanoID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodNanoID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function nanoid(params) {\n    return core._nanoid(ZodNanoID, params);\n}\nexport const ZodCUID = /*@__PURE__*/ core.$constructor(\"ZodCUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cuid(params) {\n    return core._cuid(ZodCUID, params);\n}\nexport const ZodCUID2 = /*@__PURE__*/ core.$constructor(\"ZodCUID2\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCUID2.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cuid2(params) {\n    return core._cuid2(ZodCUID2, params);\n}\nexport const ZodULID = /*@__PURE__*/ core.$constructor(\"ZodULID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodULID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ulid(params) {\n    return core._ulid(ZodULID, params);\n}\nexport const ZodXID = /*@__PURE__*/ core.$constructor(\"ZodXID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodXID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function xid(params) {\n    return core._xid(ZodXID, params);\n}\nexport const ZodKSUID = /*@__PURE__*/ core.$constructor(\"ZodKSUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodKSUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ksuid(params) {\n    return core._ksuid(ZodKSUID, params);\n}\nexport const ZodIPv4 = /*@__PURE__*/ core.$constructor(\"ZodIPv4\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodIPv4.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ipv4(params) {\n    return core._ipv4(ZodIPv4, params);\n}\nexport const ZodMAC = /*@__PURE__*/ core.$constructor(\"ZodMAC\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodMAC.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function mac(params) {\n    return core._mac(ZodMAC, params);\n}\nexport const ZodIPv6 = /*@__PURE__*/ core.$constructor(\"ZodIPv6\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodIPv6.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ipv6(params) {\n    return core._ipv6(ZodIPv6, params);\n}\nexport const ZodCIDRv4 = /*@__PURE__*/ core.$constructor(\"ZodCIDRv4\", (inst, def) => {\n    core.$ZodCIDRv4.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cidrv4(params) {\n    return core._cidrv4(ZodCIDRv4, params);\n}\nexport const ZodCIDRv6 = /*@__PURE__*/ core.$constructor(\"ZodCIDRv6\", (inst, def) => {\n    core.$ZodCIDRv6.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cidrv6(params) {\n    return core._cidrv6(ZodCIDRv6, params);\n}\nexport const ZodBase64 = /*@__PURE__*/ core.$constructor(\"ZodBase64\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodBase64.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function base64(params) {\n    return core._base64(ZodBase64, params);\n}\nexport const ZodBase64URL = /*@__PURE__*/ core.$constructor(\"ZodBase64URL\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodBase64URL.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function base64url(params) {\n    return core._base64url(ZodBase64URL, params);\n}\nexport const ZodE164 = /*@__PURE__*/ core.$constructor(\"ZodE164\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodE164.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function e164(params) {\n    return core._e164(ZodE164, params);\n}\nexport const ZodJWT = /*@__PURE__*/ core.$constructor(\"ZodJWT\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodJWT.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function jwt(params) {\n    return core._jwt(ZodJWT, params);\n}\nexport const ZodCustomStringFormat = /*@__PURE__*/ core.$constructor(\"ZodCustomStringFormat\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCustomStringFormat.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function stringFormat(format, fnOrRegex, _params = {}) {\n    return core._stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);\n}\nexport function hostname(_params) {\n    return core._stringFormat(ZodCustomStringFormat, \"hostname\", core.regexes.hostname, _params);\n}\nexport function hex(_params) {\n    return core._stringFormat(ZodCustomStringFormat, \"hex\", core.regexes.hex, _params);\n}\nexport function hash(alg, params) {\n    const enc = params?.enc ?? \"hex\";\n    const format = `${alg}_${enc}`;\n    const regex = core.regexes[format];\n    if (!regex)\n        throw new Error(`Unrecognized hash format: ${format}`);\n    return core._stringFormat(ZodCustomStringFormat, format, regex, params);\n}\nexport const ZodNumber = /*@__PURE__*/ core.$constructor(\"ZodNumber\", (inst, def) => {\n    core.$ZodNumber.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.numberProcessor(inst, ctx, json, params);\n    inst.gt = (value, params) => inst.check(checks.gt(value, params));\n    inst.gte = (value, params) => inst.check(checks.gte(value, params));\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.lt = (value, params) => inst.check(checks.lt(value, params));\n    inst.lte = (value, params) => inst.check(checks.lte(value, params));\n    inst.max = (value, params) => inst.check(checks.lte(value, params));\n    inst.int = (params) => inst.check(int(params));\n    inst.safe = (params) => inst.check(int(params));\n    inst.positive = (params) => inst.check(checks.gt(0, params));\n    inst.nonnegative = (params) => inst.check(checks.gte(0, params));\n    inst.negative = (params) => inst.check(checks.lt(0, params));\n    inst.nonpositive = (params) => inst.check(checks.lte(0, params));\n    inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));\n    inst.step = (value, params) => inst.check(checks.multipleOf(value, params));\n    // inst.finite = (params) => inst.check(core.finite(params));\n    inst.finite = () => inst;\n    const bag = inst._zod.bag;\n    inst.minValue =\n        Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;\n    inst.maxValue =\n        Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;\n    inst.isInt = (bag.format ?? \"\").includes(\"int\") || Number.isSafeInteger(bag.multipleOf ?? 0.5);\n    inst.isFinite = true;\n    inst.format = bag.format ?? null;\n});\nexport function number(params) {\n    return core._number(ZodNumber, params);\n}\nexport const ZodNumberFormat = /*@__PURE__*/ core.$constructor(\"ZodNumberFormat\", (inst, def) => {\n    core.$ZodNumberFormat.init(inst, def);\n    ZodNumber.init(inst, def);\n});\nexport function int(params) {\n    return core._int(ZodNumberFormat, params);\n}\nexport function float32(params) {\n    return core._float32(ZodNumberFormat, params);\n}\nexport function float64(params) {\n    return core._float64(ZodNumberFormat, params);\n}\nexport function int32(params) {\n    return core._int32(ZodNumberFormat, params);\n}\nexport function uint32(params) {\n    return core._uint32(ZodNumberFormat, params);\n}\nexport const ZodBoolean = /*@__PURE__*/ core.$constructor(\"ZodBoolean\", (inst, def) => {\n    core.$ZodBoolean.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.booleanProcessor(inst, ctx, json, params);\n});\nexport function boolean(params) {\n    return core._boolean(ZodBoolean, params);\n}\nexport const ZodBigInt = /*@__PURE__*/ core.$constructor(\"ZodBigInt\", (inst, def) => {\n    core.$ZodBigInt.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.bigintProcessor(inst, ctx, json, params);\n    inst.gte = (value, params) => inst.check(checks.gte(value, params));\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.gt = (value, params) => inst.check(checks.gt(value, params));\n    inst.gte = (value, params) => inst.check(checks.gte(value, params));\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.lt = (value, params) => inst.check(checks.lt(value, params));\n    inst.lte = (value, params) => inst.check(checks.lte(value, params));\n    inst.max = (value, params) => inst.check(checks.lte(value, params));\n    inst.positive = (params) => inst.check(checks.gt(BigInt(0), params));\n    inst.negative = (params) => inst.check(checks.lt(BigInt(0), params));\n    inst.nonpositive = (params) => inst.check(checks.lte(BigInt(0), params));\n    inst.nonnegative = (params) => inst.check(checks.gte(BigInt(0), params));\n    inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));\n    const bag = inst._zod.bag;\n    inst.minValue = bag.minimum ?? null;\n    inst.maxValue = bag.maximum ?? null;\n    inst.format = bag.format ?? null;\n});\nexport function bigint(params) {\n    return core._bigint(ZodBigInt, params);\n}\nexport const ZodBigIntFormat = /*@__PURE__*/ core.$constructor(\"ZodBigIntFormat\", (inst, def) => {\n    core.$ZodBigIntFormat.init(inst, def);\n    ZodBigInt.init(inst, def);\n});\n// int64\nexport function int64(params) {\n    return core._int64(ZodBigIntFormat, params);\n}\n// uint64\nexport function uint64(params) {\n    return core._uint64(ZodBigIntFormat, params);\n}\nexport const ZodSymbol = /*@__PURE__*/ core.$constructor(\"ZodSymbol\", (inst, def) => {\n    core.$ZodSymbol.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.symbolProcessor(inst, ctx, json, params);\n});\nexport function symbol(params) {\n    return core._symbol(ZodSymbol, params);\n}\nexport const ZodUndefined = /*@__PURE__*/ core.$constructor(\"ZodUndefined\", (inst, def) => {\n    core.$ZodUndefined.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.undefinedProcessor(inst, ctx, json, params);\n});\nfunction _undefined(params) {\n    return core._undefined(ZodUndefined, params);\n}\nexport { _undefined as undefined };\nexport const ZodNull = /*@__PURE__*/ core.$constructor(\"ZodNull\", (inst, def) => {\n    core.$ZodNull.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.nullProcessor(inst, ctx, json, params);\n});\nfunction _null(params) {\n    return core._null(ZodNull, params);\n}\nexport { _null as null };\nexport const ZodAny = /*@__PURE__*/ core.$constructor(\"ZodAny\", (inst, def) => {\n    core.$ZodAny.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.anyProcessor(inst, ctx, json, params);\n});\nexport function any() {\n    return core._any(ZodAny);\n}\nexport const ZodUnknown = /*@__PURE__*/ core.$constructor(\"ZodUnknown\", (inst, def) => {\n    core.$ZodUnknown.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.unknownProcessor(inst, ctx, json, params);\n});\nexport function unknown() {\n    return core._unknown(ZodUnknown);\n}\nexport const ZodNever = /*@__PURE__*/ core.$constructor(\"ZodNever\", (inst, def) => {\n    core.$ZodNever.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.neverProcessor(inst, ctx, json, params);\n});\nexport function never(params) {\n    return core._never(ZodNever, params);\n}\nexport const ZodVoid = /*@__PURE__*/ core.$constructor(\"ZodVoid\", (inst, def) => {\n    core.$ZodVoid.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.voidProcessor(inst, ctx, json, params);\n});\nfunction _void(params) {\n    return core._void(ZodVoid, params);\n}\nexport { _void as void };\nexport const ZodDate = /*@__PURE__*/ core.$constructor(\"ZodDate\", (inst, def) => {\n    core.$ZodDate.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.dateProcessor(inst, ctx, json, params);\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.max = (value, params) => inst.check(checks.lte(value, params));\n    const c = inst._zod.bag;\n    inst.minDate = c.minimum ? new Date(c.minimum) : null;\n    inst.maxDate = c.maximum ? new Date(c.maximum) : null;\n});\nexport function date(params) {\n    return core._date(ZodDate, params);\n}\nexport const ZodArray = /*@__PURE__*/ core.$constructor(\"ZodArray\", (inst, def) => {\n    core.$ZodArray.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.arrayProcessor(inst, ctx, json, params);\n    inst.element = def.element;\n    inst.min = (minLength, params) => inst.check(checks.minLength(minLength, params));\n    inst.nonempty = (params) => inst.check(checks.minLength(1, params));\n    inst.max = (maxLength, params) => inst.check(checks.maxLength(maxLength, params));\n    inst.length = (len, params) => inst.check(checks.length(len, params));\n    inst.unwrap = () => inst.element;\n});\nexport function array(element, params) {\n    return core._array(ZodArray, element, params);\n}\n// .keyof\nexport function keyof(schema) {\n    const shape = schema._zod.def.shape;\n    return _enum(Object.keys(shape));\n}\nexport const ZodObject = /*@__PURE__*/ core.$constructor(\"ZodObject\", (inst, def) => {\n    core.$ZodObjectJIT.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.objectProcessor(inst, ctx, json, params);\n    util.defineLazy(inst, \"shape\", () => {\n        return def.shape;\n    });\n    inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));\n    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall });\n    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });\n    inst.extend = (incoming) => {\n        return util.extend(inst, incoming);\n    };\n    inst.safeExtend = (incoming) => {\n        return util.safeExtend(inst, incoming);\n    };\n    inst.merge = (other) => util.merge(inst, other);\n    inst.pick = (mask) => util.pick(inst, mask);\n    inst.omit = (mask) => util.omit(inst, mask);\n    inst.partial = (...args) => util.partial(ZodOptional, inst, args[0]);\n    inst.required = (...args) => util.required(ZodNonOptional, inst, args[0]);\n});\nexport function object(shape, params) {\n    const def = {\n        type: \"object\",\n        shape: shape ?? {},\n        ...util.normalizeParams(params),\n    };\n    return new ZodObject(def);\n}\n// strictObject\nexport function strictObject(shape, params) {\n    return new ZodObject({\n        type: \"object\",\n        shape,\n        catchall: never(),\n        ...util.normalizeParams(params),\n    });\n}\n// looseObject\nexport function looseObject(shape, params) {\n    return new ZodObject({\n        type: \"object\",\n        shape,\n        catchall: unknown(),\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodUnion = /*@__PURE__*/ core.$constructor(\"ZodUnion\", (inst, def) => {\n    core.$ZodUnion.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.unionProcessor(inst, ctx, json, params);\n    inst.options = def.options;\n});\nexport function union(options, params) {\n    return new ZodUnion({\n        type: \"union\",\n        options: options,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodXor = /*@__PURE__*/ core.$constructor(\"ZodXor\", (inst, def) => {\n    ZodUnion.init(inst, def);\n    core.$ZodXor.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.unionProcessor(inst, ctx, json, params);\n    inst.options = def.options;\n});\n/** Creates an exclusive union (XOR) where exactly one option must match.\n * Unlike regular unions that succeed when any option matches, xor fails if\n * zero or more than one option matches the input. */\nexport function xor(options, params) {\n    return new ZodXor({\n        type: \"union\",\n        options: options,\n        inclusive: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodDiscriminatedUnion = /*@__PURE__*/ core.$constructor(\"ZodDiscriminatedUnion\", (inst, def) => {\n    ZodUnion.init(inst, def);\n    core.$ZodDiscriminatedUnion.init(inst, def);\n});\nexport function discriminatedUnion(discriminator, options, params) {\n    // const [options, params] = args;\n    return new ZodDiscriminatedUnion({\n        type: \"union\",\n        options,\n        discriminator,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodIntersection = /*@__PURE__*/ core.$constructor(\"ZodIntersection\", (inst, def) => {\n    core.$ZodIntersection.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.intersectionProcessor(inst, ctx, json, params);\n});\nexport function intersection(left, right) {\n    return new ZodIntersection({\n        type: \"intersection\",\n        left: left,\n        right: right,\n    });\n}\nexport const ZodTuple = /*@__PURE__*/ core.$constructor(\"ZodTuple\", (inst, def) => {\n    core.$ZodTuple.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.tupleProcessor(inst, ctx, json, params);\n    inst.rest = (rest) => inst.clone({\n        ...inst._zod.def,\n        rest: rest,\n    });\n});\nexport function tuple(items, _paramsOrRest, _params) {\n    const hasRest = _paramsOrRest instanceof core.$ZodType;\n    const params = hasRest ? _params : _paramsOrRest;\n    const rest = hasRest ? _paramsOrRest : null;\n    return new ZodTuple({\n        type: \"tuple\",\n        items: items,\n        rest,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodRecord = /*@__PURE__*/ core.$constructor(\"ZodRecord\", (inst, def) => {\n    core.$ZodRecord.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.recordProcessor(inst, ctx, json, params);\n    inst.keyType = def.keyType;\n    inst.valueType = def.valueType;\n});\nexport function record(keyType, valueType, params) {\n    return new ZodRecord({\n        type: \"record\",\n        keyType,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\n// type alksjf = core.output<core.$ZodRecordKey>;\nexport function partialRecord(keyType, valueType, params) {\n    const k = core.clone(keyType);\n    k._zod.values = undefined;\n    return new ZodRecord({\n        type: \"record\",\n        keyType: k,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport function looseRecord(keyType, valueType, params) {\n    return new ZodRecord({\n        type: \"record\",\n        keyType,\n        valueType: valueType,\n        mode: \"loose\",\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMap = /*@__PURE__*/ core.$constructor(\"ZodMap\", (inst, def) => {\n    core.$ZodMap.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.mapProcessor(inst, ctx, json, params);\n    inst.keyType = def.keyType;\n    inst.valueType = def.valueType;\n    inst.min = (...args) => inst.check(core._minSize(...args));\n    inst.nonempty = (params) => inst.check(core._minSize(1, params));\n    inst.max = (...args) => inst.check(core._maxSize(...args));\n    inst.size = (...args) => inst.check(core._size(...args));\n});\nexport function map(keyType, valueType, params) {\n    return new ZodMap({\n        type: \"map\",\n        keyType: keyType,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodSet = /*@__PURE__*/ core.$constructor(\"ZodSet\", (inst, def) => {\n    core.$ZodSet.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.setProcessor(inst, ctx, json, params);\n    inst.min = (...args) => inst.check(core._minSize(...args));\n    inst.nonempty = (params) => inst.check(core._minSize(1, params));\n    inst.max = (...args) => inst.check(core._maxSize(...args));\n    inst.size = (...args) => inst.check(core._size(...args));\n});\nexport function set(valueType, params) {\n    return new ZodSet({\n        type: \"set\",\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodEnum = /*@__PURE__*/ core.$constructor(\"ZodEnum\", (inst, def) => {\n    core.$ZodEnum.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.enumProcessor(inst, ctx, json, params);\n    inst.enum = def.entries;\n    inst.options = Object.values(def.entries);\n    const keys = new Set(Object.keys(def.entries));\n    inst.extract = (values, params) => {\n        const newEntries = {};\n        for (const value of values) {\n            if (keys.has(value)) {\n                newEntries[value] = def.entries[value];\n            }\n            else\n                throw new Error(`Key ${value} not found in enum`);\n        }\n        return new ZodEnum({\n            ...def,\n            checks: [],\n            ...util.normalizeParams(params),\n            entries: newEntries,\n        });\n    };\n    inst.exclude = (values, params) => {\n        const newEntries = { ...def.entries };\n        for (const value of values) {\n            if (keys.has(value)) {\n                delete newEntries[value];\n            }\n            else\n                throw new Error(`Key ${value} not found in enum`);\n        }\n        return new ZodEnum({\n            ...def,\n            checks: [],\n            ...util.normalizeParams(params),\n            entries: newEntries,\n        });\n    };\n});\nfunction _enum(values, params) {\n    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n    return new ZodEnum({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\nexport { _enum as enum };\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function nativeEnum(entries, params) {\n    return new ZodEnum({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodLiteral = /*@__PURE__*/ core.$constructor(\"ZodLiteral\", (inst, def) => {\n    core.$ZodLiteral.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.literalProcessor(inst, ctx, json, params);\n    inst.values = new Set(def.values);\n    Object.defineProperty(inst, \"value\", {\n        get() {\n            if (def.values.length > 1) {\n                throw new Error(\"This schema contains multiple valid literal values. Use `.values` instead.\");\n            }\n            return def.values[0];\n        },\n    });\n});\nexport function literal(value, params) {\n    return new ZodLiteral({\n        type: \"literal\",\n        values: Array.isArray(value) ? value : [value],\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodFile = /*@__PURE__*/ core.$constructor(\"ZodFile\", (inst, def) => {\n    core.$ZodFile.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.fileProcessor(inst, ctx, json, params);\n    inst.min = (size, params) => inst.check(core._minSize(size, params));\n    inst.max = (size, params) => inst.check(core._maxSize(size, params));\n    inst.mime = (types, params) => inst.check(core._mime(Array.isArray(types) ? types : [types], params));\n});\nexport function file(params) {\n    return core._file(ZodFile, params);\n}\nexport const ZodTransform = /*@__PURE__*/ core.$constructor(\"ZodTransform\", (inst, def) => {\n    core.$ZodTransform.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.transformProcessor(inst, ctx, json, params);\n    inst._zod.parse = (payload, _ctx) => {\n        if (_ctx.direction === \"backward\") {\n            throw new core.$ZodEncodeError(inst.constructor.name);\n        }\n        payload.addIssue = (issue) => {\n            if (typeof issue === \"string\") {\n                payload.issues.push(util.issue(issue, payload.value, def));\n            }\n            else {\n                // for Zod 3 backwards compatibility\n                const _issue = issue;\n                if (_issue.fatal)\n                    _issue.continue = false;\n                _issue.code ?? (_issue.code = \"custom\");\n                _issue.input ?? (_issue.input = payload.value);\n                _issue.inst ?? (_issue.inst = inst);\n                // _issue.continue ??= true;\n                payload.issues.push(util.issue(_issue));\n            }\n        };\n        const output = def.transform(payload.value, payload);\n        if (output instanceof Promise) {\n            return output.then((output) => {\n                payload.value = output;\n                return payload;\n            });\n        }\n        payload.value = output;\n        return payload;\n    };\n});\nexport function transform(fn) {\n    return new ZodTransform({\n        type: \"transform\",\n        transform: fn,\n    });\n}\nexport const ZodOptional = /*@__PURE__*/ core.$constructor(\"ZodOptional\", (inst, def) => {\n    core.$ZodOptional.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.optionalProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function optional(innerType) {\n    return new ZodOptional({\n        type: \"optional\",\n        innerType: innerType,\n    });\n}\nexport const ZodExactOptional = /*@__PURE__*/ core.$constructor(\"ZodExactOptional\", (inst, def) => {\n    core.$ZodExactOptional.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.optionalProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function exactOptional(innerType) {\n    return new ZodExactOptional({\n        type: \"optional\",\n        innerType: innerType,\n    });\n}\nexport const ZodNullable = /*@__PURE__*/ core.$constructor(\"ZodNullable\", (inst, def) => {\n    core.$ZodNullable.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.nullableProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function nullable(innerType) {\n    return new ZodNullable({\n        type: \"nullable\",\n        innerType: innerType,\n    });\n}\n// nullish\nexport function nullish(innerType) {\n    return optional(nullable(innerType));\n}\nexport const ZodDefault = /*@__PURE__*/ core.$constructor(\"ZodDefault\", (inst, def) => {\n    core.$ZodDefault.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.defaultProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n    inst.removeDefault = inst.unwrap;\n});\nexport function _default(innerType, defaultValue) {\n    return new ZodDefault({\n        type: \"default\",\n        innerType: innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\nexport const ZodPrefault = /*@__PURE__*/ core.$constructor(\"ZodPrefault\", (inst, def) => {\n    core.$ZodPrefault.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.prefaultProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function prefault(innerType, defaultValue) {\n    return new ZodPrefault({\n        type: \"prefault\",\n        innerType: innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\nexport const ZodNonOptional = /*@__PURE__*/ core.$constructor(\"ZodNonOptional\", (inst, def) => {\n    core.$ZodNonOptional.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.nonoptionalProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function nonoptional(innerType, params) {\n    return new ZodNonOptional({\n        type: \"nonoptional\",\n        innerType: innerType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodSuccess = /*@__PURE__*/ core.$constructor(\"ZodSuccess\", (inst, def) => {\n    core.$ZodSuccess.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.successProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function success(innerType) {\n    return new ZodSuccess({\n        type: \"success\",\n        innerType: innerType,\n    });\n}\nexport const ZodCatch = /*@__PURE__*/ core.$constructor(\"ZodCatch\", (inst, def) => {\n    core.$ZodCatch.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.catchProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n    inst.removeCatch = inst.unwrap;\n});\nfunction _catch(innerType, catchValue) {\n    return new ZodCatch({\n        type: \"catch\",\n        innerType: innerType,\n        catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue),\n    });\n}\nexport { _catch as catch };\nexport const ZodNaN = /*@__PURE__*/ core.$constructor(\"ZodNaN\", (inst, def) => {\n    core.$ZodNaN.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.nanProcessor(inst, ctx, json, params);\n});\nexport function nan(params) {\n    return core._nan(ZodNaN, params);\n}\nexport const ZodPipe = /*@__PURE__*/ core.$constructor(\"ZodPipe\", (inst, def) => {\n    core.$ZodPipe.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.pipeProcessor(inst, ctx, json, params);\n    inst.in = def.in;\n    inst.out = def.out;\n});\nexport function pipe(in_, out) {\n    return new ZodPipe({\n        type: \"pipe\",\n        in: in_,\n        out: out,\n        // ...util.normalizeParams(params),\n    });\n}\nexport const ZodCodec = /*@__PURE__*/ core.$constructor(\"ZodCodec\", (inst, def) => {\n    ZodPipe.init(inst, def);\n    core.$ZodCodec.init(inst, def);\n});\nexport function codec(in_, out, params) {\n    return new ZodCodec({\n        type: \"pipe\",\n        in: in_,\n        out: out,\n        transform: params.decode,\n        reverseTransform: params.encode,\n    });\n}\nexport const ZodReadonly = /*@__PURE__*/ core.$constructor(\"ZodReadonly\", (inst, def) => {\n    core.$ZodReadonly.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.readonlyProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function readonly(innerType) {\n    return new ZodReadonly({\n        type: \"readonly\",\n        innerType: innerType,\n    });\n}\nexport const ZodTemplateLiteral = /*@__PURE__*/ core.$constructor(\"ZodTemplateLiteral\", (inst, def) => {\n    core.$ZodTemplateLiteral.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.templateLiteralProcessor(inst, ctx, json, params);\n});\nexport function templateLiteral(parts, params) {\n    return new ZodTemplateLiteral({\n        type: \"template_literal\",\n        parts,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodLazy = /*@__PURE__*/ core.$constructor(\"ZodLazy\", (inst, def) => {\n    core.$ZodLazy.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.lazyProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.getter();\n});\nexport function lazy(getter) {\n    return new ZodLazy({\n        type: \"lazy\",\n        getter: getter,\n    });\n}\nexport const ZodPromise = /*@__PURE__*/ core.$constructor(\"ZodPromise\", (inst, def) => {\n    core.$ZodPromise.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.promiseProcessor(inst, ctx, json, params);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function promise(innerType) {\n    return new ZodPromise({\n        type: \"promise\",\n        innerType: innerType,\n    });\n}\nexport const ZodFunction = /*@__PURE__*/ core.$constructor(\"ZodFunction\", (inst, def) => {\n    core.$ZodFunction.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.functionProcessor(inst, ctx, json, params);\n});\nexport function _function(params) {\n    return new ZodFunction({\n        type: \"function\",\n        input: Array.isArray(params?.input) ? tuple(params?.input) : (params?.input ?? array(unknown())),\n        output: params?.output ?? unknown(),\n    });\n}\nexport { _function as function };\nexport const ZodCustom = /*@__PURE__*/ core.$constructor(\"ZodCustom\", (inst, def) => {\n    core.$ZodCustom.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.processJSONSchema = (ctx, json, params) => processors.customProcessor(inst, ctx, json, params);\n});\n// custom checks\nexport function check(fn) {\n    const ch = new core.$ZodCheck({\n        check: \"custom\",\n        // ...util.normalizeParams(params),\n    });\n    ch._zod.check = fn;\n    return ch;\n}\nexport function custom(fn, _params) {\n    return core._custom(ZodCustom, fn ?? (() => true), _params);\n}\nexport function refine(fn, _params = {}) {\n    return core._refine(ZodCustom, fn, _params);\n}\n// superRefine\nexport function superRefine(fn) {\n    return core._superRefine(fn);\n}\n// Re-export describe and meta from core\nexport const describe = core.describe;\nexport const meta = core.meta;\nfunction _instanceof(cls, params = {}) {\n    const inst = new ZodCustom({\n        type: \"custom\",\n        check: \"custom\",\n        fn: (data) => data instanceof cls,\n        abort: true,\n        ...util.normalizeParams(params),\n    });\n    inst._zod.bag.Class = cls;\n    // Override check to emit invalid_type instead of custom\n    inst._zod.check = (payload) => {\n        if (!(payload.value instanceof cls)) {\n            payload.issues.push({\n                code: \"invalid_type\",\n                expected: cls.name,\n                input: payload.value,\n                inst,\n                path: [...(inst._zod.def.path ?? [])],\n            });\n        }\n    };\n    return inst;\n}\nexport { _instanceof as instanceof };\n// stringbool\nexport const stringbool = (...args) => core._stringbool({\n    Codec: ZodCodec,\n    Boolean: ZodBoolean,\n    String: ZodString,\n}, ...args);\nexport function json(params) {\n    const jsonSchema = lazy(() => {\n        return union([string(params), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);\n    });\n    return jsonSchema;\n}\n// preprocess\n// /** @deprecated Use `z.pipe()` and `z.transform()` instead. */\nexport function preprocess(fn, schema) {\n    return pipe(transform(fn), schema);\n}\n", "export { _lt as lt, _lte as lte, _gt as gt, _gte as gte, _positive as positive, _negative as negative, _nonpositive as nonpositive, _nonnegative as nonnegative, _multipleOf as multipleOf, _maxSize as maxSize, _minSize as minSize, _size as size, _maxLength as maxLength, _minLength as minLength, _length as length, _regex as regex, _lowercase as lowercase, _uppercase as uppercase, _includes as includes, _startsWith as startsWith, _endsWith as endsWith, _property as property, _mime as mime, _overwrite as overwrite, _normalize as normalize, _trim as trim, _toLowerCase as toLowerCase, _toUpperCase as toUpperCase, _slugify as slugify, } from \"../core/index.js\";\n", "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport const ZodISODateTime = /*@__PURE__*/ core.$constructor(\"ZodISODateTime\", (inst, def) => {\n    core.$ZodISODateTime.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function datetime(params) {\n    return core._isoDateTime(ZodISODateTime, params);\n}\nexport const ZodISODate = /*@__PURE__*/ core.$constructor(\"ZodISODate\", (inst, def) => {\n    core.$ZodISODate.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function date(params) {\n    return core._isoDate(ZodISODate, params);\n}\nexport const ZodISOTime = /*@__PURE__*/ core.$constructor(\"ZodISOTime\", (inst, def) => {\n    core.$ZodISOTime.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function time(params) {\n    return core._isoTime(ZodISOTime, params);\n}\nexport const ZodISODuration = /*@__PURE__*/ core.$constructor(\"ZodISODuration\", (inst, def) => {\n    core.$ZodISODuration.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function duration(params) {\n    return core._isoDuration(ZodISODuration, params);\n}\n", "import * as core from \"../core/index.js\";\nimport { $ZodError } from \"../core/index.js\";\nimport * as util from \"../core/util.js\";\nconst initializer = (inst, issues) => {\n    $ZodError.init(inst, issues);\n    inst.name = \"ZodError\";\n    Object.defineProperties(inst, {\n        format: {\n            value: (mapper) => core.formatError(inst, mapper),\n            // enumerable: false,\n        },\n        flatten: {\n            value: (mapper) => core.flattenError(inst, mapper),\n            // enumerable: false,\n        },\n        addIssue: {\n            value: (issue) => {\n                inst.issues.push(issue);\n                inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);\n            },\n            // enumerable: false,\n        },\n        addIssues: {\n            value: (issues) => {\n                inst.issues.push(...issues);\n                inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);\n            },\n            // enumerable: false,\n        },\n        isEmpty: {\n            get() {\n                return inst.issues.length === 0;\n            },\n            // enumerable: false,\n        },\n    });\n    // Object.defineProperty(inst, \"isEmpty\", {\n    //   get() {\n    //     return inst.issues.length === 0;\n    //   },\n    // });\n};\nexport const ZodError = core.$constructor(\"ZodError\", initializer);\nexport const ZodRealError = core.$constructor(\"ZodError\", initializer, {\n    Parent: Error,\n});\n// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */\n// export type ErrorMapCtx = core.$ZodErrorMapCtx;\n", "import * as core from \"../core/index.js\";\nimport { ZodRealError } from \"./errors.js\";\nexport const parse = /* @__PURE__ */ core._parse(ZodRealError);\nexport const parseAsync = /* @__PURE__ */ core._parseAsync(ZodRealError);\nexport const safeParse = /* @__PURE__ */ core._safeParse(ZodRealError);\nexport const safeParseAsync = /* @__PURE__ */ core._safeParseAsync(ZodRealError);\n// Codec functions\nexport const encode = /* @__PURE__ */ core._encode(ZodRealError);\nexport const decode = /* @__PURE__ */ core._decode(ZodRealError);\nexport const encodeAsync = /* @__PURE__ */ core._encodeAsync(ZodRealError);\nexport const decodeAsync = /* @__PURE__ */ core._decodeAsync(ZodRealError);\nexport const safeEncode = /* @__PURE__ */ core._safeEncode(ZodRealError);\nexport const safeDecode = /* @__PURE__ */ core._safeDecode(ZodRealError);\nexport const safeEncodeAsync = /* @__PURE__ */ core._safeEncodeAsync(ZodRealError);\nexport const safeDecodeAsync = /* @__PURE__ */ core._safeDecodeAsync(ZodRealError);\n", "// Zod 3 compat layer\nimport * as core from \"../core/index.js\";\n/** @deprecated Use the raw string literal codes instead, e.g. \"invalid_type\". */\nexport const ZodIssueCode = {\n    invalid_type: \"invalid_type\",\n    too_big: \"too_big\",\n    too_small: \"too_small\",\n    invalid_format: \"invalid_format\",\n    not_multiple_of: \"not_multiple_of\",\n    unrecognized_keys: \"unrecognized_keys\",\n    invalid_union: \"invalid_union\",\n    invalid_key: \"invalid_key\",\n    invalid_element: \"invalid_element\",\n    invalid_value: \"invalid_value\",\n    custom: \"custom\",\n};\nexport { $brand, config } from \"../core/index.js\";\n/** @deprecated Use `z.config(params)` instead. */\nexport function setErrorMap(map) {\n    core.config({\n        customError: map,\n    });\n}\n/** @deprecated Use `z.config()` instead. */\nexport function getErrorMap() {\n    return core.config().customError;\n}\n/** @deprecated Do not use. Stub definition, only included for zod-to-json-schema compatibility. */\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n", "import { globalRegistry } from \"../core/registries.js\";\nimport * as _checks from \"./checks.js\";\nimport * as _iso from \"./iso.js\";\nimport * as _schemas from \"./schemas.js\";\n// Local z object to avoid circular dependency with ../index.js\nconst z = {\n    ..._schemas,\n    ..._checks,\n    iso: _iso,\n};\n// Keys that are recognized and handled by the conversion logic\nconst RECOGNIZED_KEYS = new Set([\n    // Schema identification\n    \"$schema\",\n    \"$ref\",\n    \"$defs\",\n    \"definitions\",\n    // Core schema keywords\n    \"$id\",\n    \"id\",\n    \"$comment\",\n    \"$anchor\",\n    \"$vocabulary\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n    // Type\n    \"type\",\n    \"enum\",\n    \"const\",\n    // Composition\n    \"anyOf\",\n    \"oneOf\",\n    \"allOf\",\n    \"not\",\n    // Object\n    \"properties\",\n    \"required\",\n    \"additionalProperties\",\n    \"patternProperties\",\n    \"propertyNames\",\n    \"minProperties\",\n    \"maxProperties\",\n    // Array\n    \"items\",\n    \"prefixItems\",\n    \"additionalItems\",\n    \"minItems\",\n    \"maxItems\",\n    \"uniqueItems\",\n    \"contains\",\n    \"minContains\",\n    \"maxContains\",\n    // String\n    \"minLength\",\n    \"maxLength\",\n    \"pattern\",\n    \"format\",\n    // Number\n    \"minimum\",\n    \"maximum\",\n    \"exclusiveMinimum\",\n    \"exclusiveMaximum\",\n    \"multipleOf\",\n    // Already handled metadata\n    \"description\",\n    \"default\",\n    // Content\n    \"contentEncoding\",\n    \"contentMediaType\",\n    \"contentSchema\",\n    // Unsupported (error-throwing)\n    \"unevaluatedItems\",\n    \"unevaluatedProperties\",\n    \"if\",\n    \"then\",\n    \"else\",\n    \"dependentSchemas\",\n    \"dependentRequired\",\n    // OpenAPI\n    \"nullable\",\n    \"readOnly\",\n]);\nfunction detectVersion(schema, defaultTarget) {\n    const $schema = schema.$schema;\n    if ($schema === \"https://json-schema.org/draft/2020-12/schema\") {\n        return \"draft-2020-12\";\n    }\n    if ($schema === \"http://json-schema.org/draft-07/schema#\") {\n        return \"draft-7\";\n    }\n    if ($schema === \"http://json-schema.org/draft-04/schema#\") {\n        return \"draft-4\";\n    }\n    // Use defaultTarget if provided, otherwise default to draft-2020-12\n    return defaultTarget ?? \"draft-2020-12\";\n}\nfunction resolveRef(ref, ctx) {\n    if (!ref.startsWith(\"#\")) {\n        throw new Error(\"External $ref is not supported, only local refs (#/...) are allowed\");\n    }\n    const path = ref.slice(1).split(\"/\").filter(Boolean);\n    // Handle root reference \"#\"\n    if (path.length === 0) {\n        return ctx.rootSchema;\n    }\n    const defsKey = ctx.version === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n    if (path[0] === defsKey) {\n        const key = path[1];\n        if (!key || !ctx.defs[key]) {\n            throw new Error(`Reference not found: ${ref}`);\n        }\n        return ctx.defs[key];\n    }\n    throw new Error(`Reference not found: ${ref}`);\n}\nfunction convertBaseSchema(schema, ctx) {\n    // Handle unsupported features\n    if (schema.not !== undefined) {\n        // Special case: { not: {} } represents never\n        if (typeof schema.not === \"object\" && Object.keys(schema.not).length === 0) {\n            return z.never();\n        }\n        throw new Error(\"not is not supported in Zod (except { not: {} } for never)\");\n    }\n    if (schema.unevaluatedItems !== undefined) {\n        throw new Error(\"unevaluatedItems is not supported\");\n    }\n    if (schema.unevaluatedProperties !== undefined) {\n        throw new Error(\"unevaluatedProperties is not supported\");\n    }\n    if (schema.if !== undefined || schema.then !== undefined || schema.else !== undefined) {\n        throw new Error(\"Conditional schemas (if/then/else) are not supported\");\n    }\n    if (schema.dependentSchemas !== undefined || schema.dependentRequired !== undefined) {\n        throw new Error(\"dependentSchemas and dependentRequired are not supported\");\n    }\n    // Handle $ref\n    if (schema.$ref) {\n        const refPath = schema.$ref;\n        if (ctx.refs.has(refPath)) {\n            return ctx.refs.get(refPath);\n        }\n        if (ctx.processing.has(refPath)) {\n            // Circular reference - use lazy\n            return z.lazy(() => {\n                if (!ctx.refs.has(refPath)) {\n                    throw new Error(`Circular reference not resolved: ${refPath}`);\n                }\n                return ctx.refs.get(refPath);\n            });\n        }\n        ctx.processing.add(refPath);\n        const resolved = resolveRef(refPath, ctx);\n        const zodSchema = convertSchema(resolved, ctx);\n        ctx.refs.set(refPath, zodSchema);\n        ctx.processing.delete(refPath);\n        return zodSchema;\n    }\n    // Handle enum\n    if (schema.enum !== undefined) {\n        const enumValues = schema.enum;\n        // Special case: OpenAPI 3.0 null representation { type: \"string\", nullable: true, enum: [null] }\n        if (ctx.version === \"openapi-3.0\" &&\n            schema.nullable === true &&\n            enumValues.length === 1 &&\n            enumValues[0] === null) {\n            return z.null();\n        }\n        if (enumValues.length === 0) {\n            return z.never();\n        }\n        if (enumValues.length === 1) {\n            return z.literal(enumValues[0]);\n        }\n        // Check if all values are strings\n        if (enumValues.every((v) => typeof v === \"string\")) {\n            return z.enum(enumValues);\n        }\n        // Mixed types - use union of literals\n        const literalSchemas = enumValues.map((v) => z.literal(v));\n        if (literalSchemas.length < 2) {\n            return literalSchemas[0];\n        }\n        return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);\n    }\n    // Handle const\n    if (schema.const !== undefined) {\n        return z.literal(schema.const);\n    }\n    // Handle type\n    const type = schema.type;\n    if (Array.isArray(type)) {\n        // Expand type array into anyOf union\n        const typeSchemas = type.map((t) => {\n            const typeSchema = { ...schema, type: t };\n            return convertBaseSchema(typeSchema, ctx);\n        });\n        if (typeSchemas.length === 0) {\n            return z.never();\n        }\n        if (typeSchemas.length === 1) {\n            return typeSchemas[0];\n        }\n        return z.union(typeSchemas);\n    }\n    if (!type) {\n        // No type specified - empty schema (any)\n        return z.any();\n    }\n    let zodSchema;\n    switch (type) {\n        case \"string\": {\n            let stringSchema = z.string();\n            // Apply format using .check() with Zod format functions\n            if (schema.format) {\n                const format = schema.format;\n                // Map common formats to Zod check functions\n                if (format === \"email\") {\n                    stringSchema = stringSchema.check(z.email());\n                }\n                else if (format === \"uri\" || format === \"uri-reference\") {\n                    stringSchema = stringSchema.check(z.url());\n                }\n                else if (format === \"uuid\" || format === \"guid\") {\n                    stringSchema = stringSchema.check(z.uuid());\n                }\n                else if (format === \"date-time\") {\n                    stringSchema = stringSchema.check(z.iso.datetime());\n                }\n                else if (format === \"date\") {\n                    stringSchema = stringSchema.check(z.iso.date());\n                }\n                else if (format === \"time\") {\n                    stringSchema = stringSchema.check(z.iso.time());\n                }\n                else if (format === \"duration\") {\n                    stringSchema = stringSchema.check(z.iso.duration());\n                }\n                else if (format === \"ipv4\") {\n                    stringSchema = stringSchema.check(z.ipv4());\n                }\n                else if (format === \"ipv6\") {\n                    stringSchema = stringSchema.check(z.ipv6());\n                }\n                else if (format === \"mac\") {\n                    stringSchema = stringSchema.check(z.mac());\n                }\n                else if (format === \"cidr\") {\n                    stringSchema = stringSchema.check(z.cidrv4());\n                }\n                else if (format === \"cidr-v6\") {\n                    stringSchema = stringSchema.check(z.cidrv6());\n                }\n                else if (format === \"base64\") {\n                    stringSchema = stringSchema.check(z.base64());\n                }\n                else if (format === \"base64url\") {\n                    stringSchema = stringSchema.check(z.base64url());\n                }\n                else if (format === \"e164\") {\n                    stringSchema = stringSchema.check(z.e164());\n                }\n                else if (format === \"jwt\") {\n                    stringSchema = stringSchema.check(z.jwt());\n                }\n                else if (format === \"emoji\") {\n                    stringSchema = stringSchema.check(z.emoji());\n                }\n                else if (format === \"nanoid\") {\n                    stringSchema = stringSchema.check(z.nanoid());\n                }\n                else if (format === \"cuid\") {\n                    stringSchema = stringSchema.check(z.cuid());\n                }\n                else if (format === \"cuid2\") {\n                    stringSchema = stringSchema.check(z.cuid2());\n                }\n                else if (format === \"ulid\") {\n                    stringSchema = stringSchema.check(z.ulid());\n                }\n                else if (format === \"xid\") {\n                    stringSchema = stringSchema.check(z.xid());\n                }\n                else if (format === \"ksuid\") {\n                    stringSchema = stringSchema.check(z.ksuid());\n                }\n                // Note: json-string format is not currently supported by Zod\n                // Custom formats are ignored - keep as plain string\n            }\n            // Apply constraints\n            if (typeof schema.minLength === \"number\") {\n                stringSchema = stringSchema.min(schema.minLength);\n            }\n            if (typeof schema.maxLength === \"number\") {\n                stringSchema = stringSchema.max(schema.maxLength);\n            }\n            if (schema.pattern) {\n                // JSON Schema patterns are not implicitly anchored (match anywhere in string)\n                stringSchema = stringSchema.regex(new RegExp(schema.pattern));\n            }\n            zodSchema = stringSchema;\n            break;\n        }\n        case \"number\":\n        case \"integer\": {\n            let numberSchema = type === \"integer\" ? z.number().int() : z.number();\n            // Apply constraints\n            if (typeof schema.minimum === \"number\") {\n                numberSchema = numberSchema.min(schema.minimum);\n            }\n            if (typeof schema.maximum === \"number\") {\n                numberSchema = numberSchema.max(schema.maximum);\n            }\n            if (typeof schema.exclusiveMinimum === \"number\") {\n                numberSchema = numberSchema.gt(schema.exclusiveMinimum);\n            }\n            else if (schema.exclusiveMinimum === true && typeof schema.minimum === \"number\") {\n                numberSchema = numberSchema.gt(schema.minimum);\n            }\n            if (typeof schema.exclusiveMaximum === \"number\") {\n                numberSchema = numberSchema.lt(schema.exclusiveMaximum);\n            }\n            else if (schema.exclusiveMaximum === true && typeof schema.maximum === \"number\") {\n                numberSchema = numberSchema.lt(schema.maximum);\n            }\n            if (typeof schema.multipleOf === \"number\") {\n                numberSchema = numberSchema.multipleOf(schema.multipleOf);\n            }\n            zodSchema = numberSchema;\n            break;\n        }\n        case \"boolean\": {\n            zodSchema = z.boolean();\n            break;\n        }\n        case \"null\": {\n            zodSchema = z.null();\n            break;\n        }\n        case \"object\": {\n            const shape = {};\n            const properties = schema.properties || {};\n            const requiredSet = new Set(schema.required || []);\n            // Convert properties - mark optional ones\n            for (const [key, propSchema] of Object.entries(properties)) {\n                const propZodSchema = convertSchema(propSchema, ctx);\n                // If not in required array, make it optional\n                shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();\n            }\n            // Handle propertyNames\n            if (schema.propertyNames) {\n                const keySchema = convertSchema(schema.propertyNames, ctx);\n                const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === \"object\"\n                    ? convertSchema(schema.additionalProperties, ctx)\n                    : z.any();\n                // Case A: No properties (pure record)\n                if (Object.keys(shape).length === 0) {\n                    zodSchema = z.record(keySchema, valueSchema);\n                    break;\n                }\n                // Case B: With properties (intersection of object and looseRecord)\n                const objectSchema = z.object(shape).passthrough();\n                const recordSchema = z.looseRecord(keySchema, valueSchema);\n                zodSchema = z.intersection(objectSchema, recordSchema);\n                break;\n            }\n            // Handle patternProperties\n            if (schema.patternProperties) {\n                // patternProperties: keys matching pattern must satisfy corresponding schema\n                // Use loose records so non-matching keys pass through\n                const patternProps = schema.patternProperties;\n                const patternKeys = Object.keys(patternProps);\n                const looseRecords = [];\n                for (const pattern of patternKeys) {\n                    const patternValue = convertSchema(patternProps[pattern], ctx);\n                    const keySchema = z.string().regex(new RegExp(pattern));\n                    looseRecords.push(z.looseRecord(keySchema, patternValue));\n                }\n                // Build intersection: object schema + all pattern property records\n                const schemasToIntersect = [];\n                if (Object.keys(shape).length > 0) {\n                    // Use passthrough so patternProperties can validate additional keys\n                    schemasToIntersect.push(z.object(shape).passthrough());\n                }\n                schemasToIntersect.push(...looseRecords);\n                if (schemasToIntersect.length === 0) {\n                    zodSchema = z.object({}).passthrough();\n                }\n                else if (schemasToIntersect.length === 1) {\n                    zodSchema = schemasToIntersect[0];\n                }\n                else {\n                    // Chain intersections: (A & B) & C & D ...\n                    let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);\n                    for (let i = 2; i < schemasToIntersect.length; i++) {\n                        result = z.intersection(result, schemasToIntersect[i]);\n                    }\n                    zodSchema = result;\n                }\n                break;\n            }\n            // Handle additionalProperties\n            // In JSON Schema, additionalProperties defaults to true (allow any extra properties)\n            // In Zod, objects strip unknown keys by default, so we need to handle this explicitly\n            const objectSchema = z.object(shape);\n            if (schema.additionalProperties === false) {\n                // Strict mode - no extra properties allowed\n                zodSchema = objectSchema.strict();\n            }\n            else if (typeof schema.additionalProperties === \"object\") {\n                // Extra properties must match the specified schema\n                zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));\n            }\n            else {\n                // additionalProperties is true or undefined - allow any extra properties (passthrough)\n                zodSchema = objectSchema.passthrough();\n            }\n            break;\n        }\n        case \"array\": {\n            // TODO: uniqueItems is not supported\n            // TODO: contains/minContains/maxContains are not supported\n            // Check if this is a tuple (prefixItems or items as array)\n            const prefixItems = schema.prefixItems;\n            const items = schema.items;\n            if (prefixItems && Array.isArray(prefixItems)) {\n                // Tuple with prefixItems (draft-2020-12)\n                const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));\n                const rest = items && typeof items === \"object\" && !Array.isArray(items)\n                    ? convertSchema(items, ctx)\n                    : undefined;\n                if (rest) {\n                    zodSchema = z.tuple(tupleItems).rest(rest);\n                }\n                else {\n                    zodSchema = z.tuple(tupleItems);\n                }\n                // Apply minItems/maxItems constraints to tuples\n                if (typeof schema.minItems === \"number\") {\n                    zodSchema = zodSchema.check(z.minLength(schema.minItems));\n                }\n                if (typeof schema.maxItems === \"number\") {\n                    zodSchema = zodSchema.check(z.maxLength(schema.maxItems));\n                }\n            }\n            else if (Array.isArray(items)) {\n                // Tuple with items array (draft-7)\n                const tupleItems = items.map((item) => convertSchema(item, ctx));\n                const rest = schema.additionalItems && typeof schema.additionalItems === \"object\"\n                    ? convertSchema(schema.additionalItems, ctx)\n                    : undefined; // additionalItems: false means no rest, handled by default tuple behavior\n                if (rest) {\n                    zodSchema = z.tuple(tupleItems).rest(rest);\n                }\n                else {\n                    zodSchema = z.tuple(tupleItems);\n                }\n                // Apply minItems/maxItems constraints to tuples\n                if (typeof schema.minItems === \"number\") {\n                    zodSchema = zodSchema.check(z.minLength(schema.minItems));\n                }\n                if (typeof schema.maxItems === \"number\") {\n                    zodSchema = zodSchema.check(z.maxLength(schema.maxItems));\n                }\n            }\n            else if (items !== undefined) {\n                // Regular array\n                const element = convertSchema(items, ctx);\n                let arraySchema = z.array(element);\n                // Apply constraints\n                if (typeof schema.minItems === \"number\") {\n                    arraySchema = arraySchema.min(schema.minItems);\n                }\n                if (typeof schema.maxItems === \"number\") {\n                    arraySchema = arraySchema.max(schema.maxItems);\n                }\n                zodSchema = arraySchema;\n            }\n            else {\n                // No items specified - array of any\n                zodSchema = z.array(z.any());\n            }\n            break;\n        }\n        default:\n            throw new Error(`Unsupported type: ${type}`);\n    }\n    // Apply metadata\n    if (schema.description) {\n        zodSchema = zodSchema.describe(schema.description);\n    }\n    if (schema.default !== undefined) {\n        zodSchema = zodSchema.default(schema.default);\n    }\n    return zodSchema;\n}\nfunction convertSchema(schema, ctx) {\n    if (typeof schema === \"boolean\") {\n        return schema ? z.any() : z.never();\n    }\n    // Convert base schema first (ignoring composition keywords)\n    let baseSchema = convertBaseSchema(schema, ctx);\n    const hasExplicitType = schema.type || schema.enum !== undefined || schema.const !== undefined;\n    // Process composition keywords LAST (they can appear together)\n    // Handle anyOf - wrap base schema with union\n    if (schema.anyOf && Array.isArray(schema.anyOf)) {\n        const options = schema.anyOf.map((s) => convertSchema(s, ctx));\n        const anyOfUnion = z.union(options);\n        baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;\n    }\n    // Handle oneOf - exclusive union (exactly one must match)\n    if (schema.oneOf && Array.isArray(schema.oneOf)) {\n        const options = schema.oneOf.map((s) => convertSchema(s, ctx));\n        const oneOfUnion = z.xor(options);\n        baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;\n    }\n    // Handle allOf - wrap base schema with intersection\n    if (schema.allOf && Array.isArray(schema.allOf)) {\n        if (schema.allOf.length === 0) {\n            baseSchema = hasExplicitType ? baseSchema : z.any();\n        }\n        else {\n            let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);\n            const startIdx = hasExplicitType ? 0 : 1;\n            for (let i = startIdx; i < schema.allOf.length; i++) {\n                result = z.intersection(result, convertSchema(schema.allOf[i], ctx));\n            }\n            baseSchema = result;\n        }\n    }\n    // Handle nullable (OpenAPI 3.0)\n    if (schema.nullable === true && ctx.version === \"openapi-3.0\") {\n        baseSchema = z.nullable(baseSchema);\n    }\n    // Handle readOnly\n    if (schema.readOnly === true) {\n        baseSchema = z.readonly(baseSchema);\n    }\n    // Collect metadata: core schema keywords and unrecognized keys\n    const extraMeta = {};\n    // Core schema keywords that should be captured as metadata\n    const coreMetadataKeys = [\"$id\", \"id\", \"$comment\", \"$anchor\", \"$vocabulary\", \"$dynamicRef\", \"$dynamicAnchor\"];\n    for (const key of coreMetadataKeys) {\n        if (key in schema) {\n            extraMeta[key] = schema[key];\n        }\n    }\n    // Content keywords - store as metadata\n    const contentMetadataKeys = [\"contentEncoding\", \"contentMediaType\", \"contentSchema\"];\n    for (const key of contentMetadataKeys) {\n        if (key in schema) {\n            extraMeta[key] = schema[key];\n        }\n    }\n    // Unrecognized keys (custom metadata)\n    for (const key of Object.keys(schema)) {\n        if (!RECOGNIZED_KEYS.has(key)) {\n            extraMeta[key] = schema[key];\n        }\n    }\n    if (Object.keys(extraMeta).length > 0) {\n        ctx.registry.add(baseSchema, extraMeta);\n    }\n    return baseSchema;\n}\n/**\n * Converts a JSON Schema to a Zod schema. This function should be considered semi-experimental. It's behavior is liable to change. */\nexport function fromJSONSchema(schema, params) {\n    // Handle boolean schemas\n    if (typeof schema === \"boolean\") {\n        return schema ? z.any() : z.never();\n    }\n    const version = detectVersion(schema, params?.defaultTarget);\n    const defs = (schema.$defs || schema.definitions || {});\n    const ctx = {\n        version,\n        defs,\n        refs: new Map(),\n        processing: new Set(),\n        rootSchema: schema,\n        registry: params?.registry ?? globalRegistry,\n    };\n    return convertSchema(schema, ctx);\n}\n", "import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport function string(params) {\n    return core._coercedString(schemas.ZodString, params);\n}\nexport function number(params) {\n    return core._coercedNumber(schemas.ZodNumber, params);\n}\nexport function boolean(params) {\n    return core._coercedBoolean(schemas.ZodBoolean, params);\n}\nexport function bigint(params) {\n    return core._coercedBigint(schemas.ZodBigInt, params);\n}\nexport function date(params) {\n    return core._coercedDate(schemas.ZodDate, params);\n}\n", "import { z } from \"zod/v3\";\nimport { z as z4, ZodError } from \"zod/v4\";\nimport {\n  validate,\n  type Schema as ValidationSchema,\n} from \"@cfworker/json-schema\";\nimport {\n  CallbackManager,\n  CallbackManagerForToolRun,\n  parseCallbackConfigArg,\n} from \"../callbacks/manager.js\";\nimport { BaseLangChain } from \"../language_models/base.js\";\nimport {\n  mergeConfigs,\n  ensureConfig,\n  patchConfig,\n  pickRunnableConfigKeys,\n  type RunnableConfig,\n} from \"../runnables/config.js\";\nimport type { RunnableFunc } from \"../runnables/base.js\";\nimport { isDirectToolOutput, ToolCall, ToolMessage } from \"../messages/tool.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport type { RunnableToolLike } from \"../runnables/base.js\";\nimport {\n  _configHasToolCallId,\n  _isToolCall,\n  ToolInputParsingException,\n} from \"./utils.js\";\nimport {\n  type InferInteropZodInput,\n  type InferInteropZodOutput,\n  type InteropZodObject,\n  type InteropZodType,\n  interopParseAsync,\n  isSimpleStringZodSchema,\n  isInteropZodError,\n  isInteropZodSchema,\n  type ZodStringV3,\n  type ZodStringV4,\n  type ZodObjectV3,\n  type ZodObjectV4,\n} from \"../utils/types/zod.js\";\nimport { getAbortSignalError } from \"../utils/signal.js\";\nimport type {\n  StructuredToolCallInput,\n  ToolInputSchemaBase,\n  ToolReturnType,\n  ResponseFormat,\n  ToolInputSchemaInputType,\n  ToolInputSchemaOutputType,\n  ToolParams,\n  ToolRunnableConfig,\n  StructuredToolInterface,\n  DynamicToolInput,\n  DynamicStructuredToolInput,\n  StringInputToolSchema,\n  ToolInterface,\n  ToolOutputType,\n  ToolRuntime,\n} from \"./types.js\";\nimport { type JSONSchema, validatesOnlyStrings } from \"../utils/json_schema.js\";\n\nexport type {\n  BaseDynamicToolInput,\n  ContentAndArtifact,\n  DynamicToolInput,\n  DynamicStructuredToolInput,\n  ResponseFormat,\n  StructuredToolCallInput,\n  StructuredToolInterface,\n  StructuredToolParams,\n  ToolInterface,\n  ToolParams,\n  ToolReturnType,\n  ToolRunnableConfig,\n  ToolInputSchemaBase as ToolSchemaBase,\n} from \"./types.js\";\n\nexport {\n  isLangChainTool,\n  isRunnableToolLike,\n  isStructuredTool,\n  isStructuredToolParams,\n  type ToolRuntime,\n} from \"./types.js\";\n\nexport { ToolInputParsingException };\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nexport abstract class StructuredTool<\n    SchemaT = ToolInputSchemaBase,\n    SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n    SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n    ToolOutputT = ToolOutputType,\n  >\n  extends BaseLangChain<\n    StructuredToolCallInput<SchemaT, SchemaInputT>,\n    ToolOutputT | ToolMessage\n  >\n  implements StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT>\n{\n  abstract name: string;\n\n  abstract description: string;\n\n  abstract schema: SchemaT;\n\n  /**\n   * Optional provider-specific extra fields for the tool.\n   *\n   * This is used to pass provider-specific configuration that doesn't fit into\n   * standard tool fields.\n   */\n  extras?: Record<string, unknown>;\n\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect = false;\n\n  verboseParsingErrors = false;\n\n  get lc_namespace() {\n    return [\"langchain\", \"tools\"];\n  }\n\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat = \"content\";\n\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n\n  constructor(fields?: ToolParams) {\n    super(fields ?? {});\n\n    this.verboseParsingErrors =\n      fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n    this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n    this.defaultConfig = fields?.defaultConfig ?? this.defaultConfig;\n    this.metadata = fields?.metadata ?? this.metadata;\n    this.extras = fields?.extras ?? this.extras;\n  }\n\n  protected abstract _call(\n    arg: SchemaOutputT,\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: ToolRunnableConfig\n  ): Promise<ToolOutputT>;\n\n  /**\n   * Invokes the tool with the provided input and configuration.\n   * @param input The input for the tool.\n   * @param config Optional configuration for the tool.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  async invoke<\n    TInput extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    input: TInput,\n    config?: TConfig\n  ): Promise<ToolReturnType<TInput, TConfig, ToolOutputT>> {\n    let toolInput: Exclude<\n      StructuredToolCallInput<SchemaT, SchemaInputT>,\n      ToolCall\n    >;\n\n    let enrichedConfig: ToolRunnableConfig = ensureConfig(\n      mergeConfigs(this.defaultConfig, config)\n    );\n    if (_isToolCall(input)) {\n      toolInput = input.args as Exclude<\n        StructuredToolCallInput<SchemaT, SchemaInputT>,\n        ToolCall\n      >;\n      enrichedConfig = {\n        ...enrichedConfig,\n        toolCall: input,\n      };\n    } else {\n      toolInput = input as Exclude<\n        StructuredToolCallInput<SchemaT, SchemaInputT>,\n        ToolCall\n      >;\n    }\n\n    return this.call(toolInput, enrichedConfig) as Promise<\n      ToolReturnType<TInput, TConfig, ToolOutputT>\n    >;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  async call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>> {\n    // Determine the actual input that needs parsing/validation.\n    // If arg is a ToolCall, use its args; otherwise, use arg directly.\n    const inputForValidation = _isToolCall(arg) ? arg.args : arg;\n\n    let parsed: SchemaOutputT; // This will hold the successfully parsed input of the expected output type.\n    if (isInteropZodSchema(this.schema)) {\n      try {\n        // Validate the inputForValidation - TS needs help here as it can't exclude ToolCall based on the check\n        parsed = await interopParseAsync(\n          this.schema as InteropZodType,\n          inputForValidation as Exclude<TArg, ToolCall>\n        );\n      } catch (e) {\n        let message = `Received tool input did not match expected schema`;\n        if (this.verboseParsingErrors) {\n          message = `${message}\\nDetails: ${(e as Error).message}`;\n        }\n        if (isInteropZodError(e)) {\n          message = `${message}\\n\\n${z4.prettifyError(e as ZodError)}`;\n        }\n        // Pass the original raw input arg to the exception\n        throw new ToolInputParsingException(message, JSON.stringify(arg));\n      }\n    } else {\n      const result = validate(\n        inputForValidation,\n        this.schema as ValidationSchema\n      );\n      if (!result.valid) {\n        let message = `Received tool input did not match expected schema`;\n        if (this.verboseParsingErrors) {\n          message = `${message}\\nDetails: ${result.errors\n            .map((e) => `${e.keywordLocation}: ${e.error}`)\n            .join(\"\\n\")}`;\n        }\n        // Pass the original raw input arg to the exception\n        throw new ToolInputParsingException(message, JSON.stringify(arg));\n      }\n      // Assign the validated input to parsed\n      // We cast here because validate() doesn't narrow the type sufficiently for TS, but we know it's valid.\n      parsed = inputForValidation as SchemaOutputT;\n    }\n\n    const config = parseCallbackConfigArg(configArg);\n    const callbackManager_ = CallbackManager.configure(\n      config.callbacks,\n      this.callbacks,\n      config.tags || tags,\n      this.tags,\n      config.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const runManager = await callbackManager_?.handleToolStart(\n      this.toJSON(),\n      // Log the original raw input arg\n      typeof arg === \"string\" ? arg : JSON.stringify(arg),\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config.runName\n    );\n    delete config.runId;\n    let result;\n    try {\n      // Pass the correctly typed parsed input to _call\n      result = await this._call(parsed, runManager, config);\n    } catch (e) {\n      await runManager?.handleToolError(e);\n      throw e;\n    }\n    let content;\n    let artifact;\n    if (this.responseFormat === \"content_and_artifact\") {\n      if (Array.isArray(result) && result.length === 2) {\n        [content, artifact] = result;\n      } else {\n        throw new Error(\n          `Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(\n            result\n          )}`\n        );\n      }\n    } else {\n      content = result;\n    }\n\n    let toolCallId: string | undefined;\n    // Extract toolCallId ONLY if the original arg was a ToolCall\n    if (_isToolCall(arg)) {\n      toolCallId = arg.id;\n    }\n    // Or if it was provided in the config's toolCall property\n    if (!toolCallId && _configHasToolCallId(config)) {\n      toolCallId = config.toolCall.id;\n    }\n\n    const formattedOutput = _formatToolOutput<ToolOutputT>({\n      content,\n      artifact,\n      toolCallId,\n      name: this.name,\n      metadata: this.metadata,\n    });\n    await runManager?.handleToolEnd(formattedOutput);\n    return formattedOutput as ToolReturnType<TArg, TConfig, ToolOutputT>;\n  }\n}\n\n/**\n * Base class for Tools that accept input as a string.\n */\nexport abstract class Tool<ToolOutputT = ToolOutputType>\n  extends StructuredTool<\n    StringInputToolSchema,\n    ToolInputSchemaOutputType<StringInputToolSchema>,\n    ToolInputSchemaInputType<StringInputToolSchema>,\n    ToolOutputT\n  >\n  implements\n    ToolInterface<\n      StringInputToolSchema,\n      ToolInputSchemaInputType<StringInputToolSchema>,\n      ToolOutputT\n    >\n{\n  schema = z\n    .object({ input: z.string().optional() })\n    .transform((obj) => obj.input);\n\n  constructor(fields?: ToolParams) {\n    super(fields);\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  // Match the base class signature including the generics and conditional return type\n  call<\n    TArg extends string | undefined | z.input<this[\"schema\"]> | ToolCall,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    arg: TArg,\n    callbacks?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    // Prepare the input for the base class call method.\n    // If arg is string or undefined, wrap it; otherwise, pass ToolCall or { input: ... } directly.\n    const structuredArg =\n      typeof arg === \"string\" || arg == null ? { input: arg } : arg;\n\n    // Ensure TConfig is passed to super.call\n    return super.call(structuredArg, callbacks);\n  }\n}\n\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nexport class DynamicTool<\n  ToolOutputT = ToolOutputType,\n> extends Tool<ToolOutputT> {\n  static lc_name() {\n    return \"DynamicTool\";\n  }\n\n  name: string;\n\n  description: string;\n\n  func: DynamicToolInput<ToolOutputT>[\"func\"];\n\n  constructor(fields: DynamicToolInput<ToolOutputT>) {\n    super(fields);\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  async call<\n    TArg extends string | undefined | z.input<this[\"schema\"]> | ToolCall,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    arg: TArg,\n    configArg?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n    // Call the Tool class's call method, passing generics through\n    // Cast config to TConfig to satisfy the super.call signature\n    return super.call<TArg, TConfig>(arg, config as TConfig);\n  }\n\n  /** @ignore */\n  async _call(\n    input: string, // DynamicTool's _call specifically expects a string after schema transformation\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: ToolRunnableConfig\n  ): Promise<ToolOutputT> {\n    return this.func(input, runManager, parentConfig);\n  }\n}\n\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n *\n * @template SchemaT The input schema type for the tool (Zod schema or JSON schema). Defaults to `ToolInputSchemaBase`.\n * @template SchemaOutputT The output type derived from the schema after parsing/validation. Defaults to `ToolInputSchemaOutputType<SchemaT>`.\n * @template SchemaInputT The input type derived from the schema before parsing. Defaults to `ToolInputSchemaInputType<SchemaT>`.\n * @template ToolOutputT The return type of the tool's function. Defaults to `ToolOutputType`.\n * @template NameT The literal type of the tool name (for discriminated union support). Defaults to `string`.\n */\nexport class DynamicStructuredTool<\n  SchemaT = ToolInputSchemaBase,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  NameT extends string = string,\n> extends StructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT> {\n  static lc_name() {\n    return \"DynamicStructuredTool\";\n  }\n\n  declare name: NameT;\n\n  description: string;\n\n  func: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>[\"func\"];\n\n  schema: SchemaT;\n\n  constructor(\n    fields: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT> & {\n      name: NameT;\n    }\n  ) {\n    super(fields);\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    this.schema = fields.schema;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  // Match the base class signature\n  async call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n\n    // Call the base class method, passing generics through\n    // Cast config to TConfig to satisfy the super.call signature\n    return super.call<TArg, TConfig>(arg, config as TConfig, tags);\n  }\n\n  protected _call(\n    arg: Parameters<\n      DynamicStructuredToolInput<SchemaT, SchemaOutputT>[\"func\"]\n    >[0],\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: RunnableConfig\n  ): Promise<ToolOutputT> {\n    return this.func(arg, runManager, parentConfig);\n  }\n}\n\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nexport abstract class BaseToolkit {\n  abstract tools: StructuredToolInterface[];\n\n  getTools(): StructuredToolInterface[] {\n    return this.tools;\n  }\n}\n\n/**\n * Parameters for the tool function.\n * Schema can be provided as Zod or JSON schema.\n * Both schema types will be validated.\n * @template {ToolInputSchemaBase} RunInput The input schema for the tool.\n * @template {string} NameT The literal name type for discriminated union support.\n */\ninterface ToolWrapperParams<\n  RunInput = ToolInputSchemaBase | undefined,\n  NameT extends string = string,\n> extends ToolParams {\n  /**\n   * The name of the tool. If using with an LLM, this\n   * will be passed as the tool name.\n   */\n  name: NameT;\n  /**\n   * The description of the tool.\n   * @default `${fields.name} tool`\n   */\n  description?: string;\n  /**\n   * The input schema for the tool. If using an LLM, this\n   * will be passed as the tool schema to generate arguments\n   * for.\n   */\n  schema?: RunInput;\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n\n/**\n * Creates a new StructuredTool instance with the provided function, name, description, and schema.\n *\n * Schema can be provided as Zod or JSON schema, and both will be validated.\n *\n * @function\n * @template {ToolInputSchemaBase} SchemaT The input schema for the tool.\n * @template {ToolReturnType} ToolOutputT The output type of the tool.\n *\n * @param {RunnableFunc<z.output<SchemaT>, ToolOutputT>} func - The function to invoke when the tool is called.\n * @param {ToolWrapperParams<SchemaT>} fields - An object containing the following properties:\n * @param {string} fields.name The name of the tool.\n * @param {string | undefined} fields.description The description of the tool. Defaults to either the description on the Zod schema, or `${fields.name} tool`.\n * @param {z.AnyZodObject | z.ZodString | undefined} fields.schema The Zod schema defining the input for the tool. If undefined, it will default to a Zod string schema.\n *\n * @returns {DynamicStructuredTool<SchemaT>} A new StructuredTool instance.\n */\nexport function tool<SchemaT extends ZodStringV3, ToolOutputT = ToolOutputType>(\n  func: RunnableFunc<\n    InferInteropZodOutput<SchemaT>,\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<SchemaT extends ZodStringV4, ToolOutputT = ToolOutputType>(\n  func: RunnableFunc<\n    InferInteropZodOutput<SchemaT>,\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV3,\n  NameT extends string,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT, NameT>\n): DynamicStructuredTool<\n  SchemaT,\n  SchemaOutputT,\n  SchemaInputT,\n  ToolOutputT,\n  NameT\n>;\n\nexport function tool<\n  SchemaT extends ZodObjectV4,\n  NameT extends string,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT, NameT>\n): DynamicStructuredTool<\n  SchemaT,\n  SchemaOutputT,\n  SchemaInputT,\n  ToolOutputT,\n  NameT\n>;\n\nexport function tool<\n  SchemaT extends JSONSchema,\n  NameT extends string,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n>(\n  func: RunnableFunc<\n    Parameters<DynamicStructuredToolInput<SchemaT>[\"func\"]>[0],\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT, NameT>\n): DynamicStructuredTool<\n  SchemaT,\n  SchemaOutputT,\n  SchemaInputT,\n  ToolOutputT,\n  NameT\n>;\n\nexport function tool<\n  SchemaT extends\n    | InteropZodObject\n    | InteropZodType<string>\n    | JSONSchema = InteropZodObject,\n  NameT extends string = string,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT, NameT>\n):\n  | DynamicStructuredTool<\n      SchemaT,\n      SchemaOutputT,\n      SchemaInputT,\n      ToolOutputT,\n      NameT\n    >\n  | DynamicTool<ToolOutputT>;\n\n// Overloads with ToolRuntime as CallOptions\nexport function tool<\n  SchemaT extends ZodStringV3,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown,\n>(\n  func: (\n    input: InferInteropZodOutput<SchemaT>,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodStringV4,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown,\n>(\n  func: (\n    input: InferInteropZodOutput<SchemaT>,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV3,\n  NameT extends string,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown,\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT, NameT>\n): DynamicStructuredTool<\n  SchemaT,\n  SchemaOutputT,\n  SchemaInputT,\n  ToolOutputT,\n  NameT\n>;\n\nexport function tool<\n  SchemaT extends ZodObjectV4,\n  NameT extends string,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown,\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT, NameT>\n): DynamicStructuredTool<\n  SchemaT,\n  SchemaOutputT,\n  SchemaInputT,\n  ToolOutputT,\n  NameT\n>;\n\nexport function tool<\n  SchemaT extends JSONSchema,\n  NameT extends string,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown,\n>(\n  func: (\n    input: Parameters<DynamicStructuredToolInput<SchemaT>[\"func\"]>[0],\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT, NameT>\n): DynamicStructuredTool<\n  SchemaT,\n  SchemaOutputT,\n  SchemaInputT,\n  ToolOutputT,\n  NameT\n>;\n\nexport function tool<\n  SchemaT extends\n    | InteropZodObject\n    | InteropZodType<string>\n    | JSONSchema = InteropZodObject,\n  NameT extends string = string,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown,\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT, NameT>\n):\n  | DynamicStructuredTool<\n      SchemaT,\n      SchemaOutputT,\n      SchemaInputT,\n      ToolOutputT,\n      NameT\n    >\n  | DynamicTool<ToolOutputT> {\n  const isSimpleStringSchema = isSimpleStringZodSchema(fields.schema);\n  const isStringJSONSchema = validatesOnlyStrings(fields.schema);\n\n  // If the schema is not provided, or it's a simple string schema, create a DynamicTool\n  if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) {\n    return new DynamicTool<ToolOutputT>({\n      ...fields,\n      description:\n        fields.description ??\n        (fields.schema as { description?: string } | undefined)?.description ??\n        `${fields.name} tool`,\n      func: async (input, runManager, config) => {\n        return new Promise<ToolOutputT>((resolve, reject) => {\n          const childConfig = patchConfig(config, {\n            callbacks: runManager?.getChild(),\n          });\n          // eslint-disable-next-line no-void\n          void AsyncLocalStorageProviderSingleton.runWithConfig(\n            pickRunnableConfigKeys(childConfig),\n            async () => {\n              try {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                resolve(func(input as any, childConfig as any));\n              } catch (e) {\n                reject(e);\n              }\n            }\n          );\n        });\n      },\n    });\n  }\n\n  const schema = fields.schema as InteropZodObject | JSONSchema;\n\n  const description =\n    fields.description ??\n    (fields.schema as { description?: string }).description ??\n    `${fields.name} tool`;\n\n  return new DynamicStructuredTool<\n    typeof schema,\n    SchemaOutputT,\n    SchemaInputT,\n    ToolOutputT,\n    NameT\n  >({\n    ...fields,\n    description,\n    schema,\n    func: async (input, runManager, config) => {\n      return new Promise<ToolOutputT>((resolve, reject) => {\n        let listener: (() => void) | undefined;\n        const cleanup = () => {\n          if (config?.signal && listener) {\n            config.signal.removeEventListener(\"abort\", listener);\n          }\n        };\n\n        if (config?.signal) {\n          listener = () => {\n            cleanup();\n            reject(getAbortSignalError(config.signal));\n          };\n          config.signal.addEventListener(\"abort\", listener);\n        }\n\n        const childConfig = patchConfig(config, {\n          callbacks: runManager?.getChild(),\n        });\n        // eslint-disable-next-line no-void\n        void AsyncLocalStorageProviderSingleton.runWithConfig(\n          pickRunnableConfigKeys(childConfig),\n          async () => {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              const result = await func(input as any, childConfig as any);\n\n              /**\n               * If the signal is aborted, we don't want to resolve the promise\n               * as the promise is already rejected.\n               */\n              if (config?.signal?.aborted) {\n                cleanup();\n                return;\n              }\n\n              cleanup();\n              resolve(result);\n            } catch (e) {\n              cleanup();\n              reject(e);\n            }\n          }\n        );\n      });\n    },\n  }) as DynamicStructuredTool<\n    SchemaT,\n    SchemaOutputT,\n    SchemaInputT,\n    ToolOutputT,\n    NameT\n  >;\n}\n\nfunction _formatToolOutput<TOutput extends ToolOutputType>(params: {\n  content: TOutput;\n  name: string;\n  artifact?: unknown;\n  toolCallId?: string;\n  metadata?: Record<string, unknown>;\n}): ToolMessage | TOutput {\n  const { content, artifact, toolCallId, metadata } = params;\n  if (toolCallId && !isDirectToolOutput(content)) {\n    if (\n      typeof content === \"string\" ||\n      (Array.isArray(content) &&\n        content.every((item) => typeof item === \"object\"))\n    ) {\n      return new ToolMessage({\n        status: \"success\",\n        content,\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name,\n        metadata,\n      });\n    } else {\n      return new ToolMessage({\n        status: \"success\",\n        content: _stringify(content),\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name,\n        metadata,\n      });\n    }\n  } else {\n    return content;\n  }\n}\n\nfunction _stringify(content: unknown): string {\n  try {\n    return JSON.stringify(content) ?? \"\";\n  } catch (_noOp) {\n    return `${content}`;\n  }\n}\n\nexport type ServerTool = Record<string, unknown>;\nexport type ClientTool =\n  | StructuredToolInterface\n  | DynamicTool\n  | RunnableToolLike;\n", "import { BaseRun, Run } from \"langsmith/schemas\";\nimport { BaseTracer } from \"./base.js\";\n\n/**\n * A callback handler that collects traced runs and makes it easy to fetch the traced run object from calls through any langchain object.\n * For instance, it makes it easy to fetch the run ID and then do things with that, such as log feedback.\n */\nexport class RunCollectorCallbackHandler extends BaseTracer {\n  /** The name of the callback handler. */\n  name = \"run_collector\";\n\n  /** The ID of the example. */\n  exampleId?: string;\n\n  /** An array of traced runs. */\n  tracedRuns: Run[];\n\n  /**\n   * Creates a new instance of the RunCollectorCallbackHandler class.\n   * @param exampleId The ID of the example.\n   */\n  constructor({ exampleId }: { exampleId?: string } = {}) {\n    super({ _awaitHandler: true });\n    this.exampleId = exampleId;\n    this.tracedRuns = [];\n  }\n\n  /**\n   * Persists the given run object.\n   * @param run The run object to persist.\n   */\n  protected async persistRun(run: BaseRun): Promise<void> {\n    const run_ = { ...run } as Run;\n    run_.reference_example_id = this.exampleId;\n    this.tracedRuns.push(run_);\n  }\n}\n", "//#region src/types/stream.ts\nvar stream_exports = {};\n\n//#endregion\nexport { stream_exports };\n//# sourceMappingURL=stream.js.map", "export const chunkArray = <T>(arr: T[], chunkSize: number) =>\n  arr.reduce((chunks, elem, index) => {\n    const chunkIndex = Math.floor(index / chunkSize);\n    const chunk = chunks[chunkIndex] || [];\n    chunks[chunkIndex] = chunk.concat([elem]);\n    return chunks;\n  }, [] as T[][]);\n", "/**\n * A tagged template function for creating formatted strings.\n *\n * This utility provides a clean, template literal-based API for string formatting\n * that can be used for prompts, descriptions, and other text formatting needs.\n *\n * It automatically handles whitespace normalization and indentation, making it\n * ideal for multi-line strings in code.\n *\n * When using this utility, it will:\n * - Strip common leading indentation from all lines\n * - Trim leading/trailing whitespace\n * - Align multi-line interpolated values to match indentation\n * - Support escape sequences: `\\\\n` (newline), `\\\\`` (backtick), `\\\\$` (dollar), `\\\\{` (brace)\n *\n * @example\n * ```typescript\n * import { context } from \"@langchain/core/utils/context\";\n *\n * const role = \"agent\";\n * const prompt = context`\n *   You are an ${role}.\n *   Your task is to help users.\n * `;\n * // Returns: \"You are an agent.\\nYour task is to help users.\"\n * ```\n *\n * @example\n * ```typescript\n * // Multi-line interpolated values are aligned\n * const items = \"- Item 1\\n- Item 2\\n- Item 3\";\n * const message = context`\n *   Shopping list:\n *     ${items}\n *   End of list.\n * `;\n * // The items will be indented to match \"    \" (4 spaces)\n * ```\n */\nexport function context(\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): string {\n  const raw = strings.raw;\n  let result = \"\";\n\n  for (let i = 0; i < raw.length; i++) {\n    // Handle escaped characters in template literals\n    const next = raw[i]\n      .replace(/\\\\\\n[ \\t]*/g, \"\") // escaped newlines (line continuation)\n      .replace(/\\\\`/g, \"`\") // escaped backticks\n      .replace(/\\\\\\$/g, \"$\") // escaped dollar signs\n      .replace(/\\\\\\{/g, \"{\"); // escaped braces\n\n    result += next;\n\n    if (i < values.length) {\n      const value = alignValue(values[i], result);\n      result += typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n\n  // Strip common indentation\n  result = stripIndent(result);\n\n  // Trim leading/trailing whitespace\n  result = result.trim();\n\n  // Handle escaped \\n at the end (preserve intentional newlines)\n  result = result.replace(/\\\\n/g, \"\\n\");\n\n  return result;\n}\n\n/**\n * Adjusts the indentation of a multi-line interpolated value to match the current line.\n *\n * @param value - The interpolated value\n * @param precedingText - The text that comes before this value\n * @returns The value with adjusted indentation\n */\nfunction alignValue(value: unknown, precedingText: string): unknown {\n  if (typeof value !== \"string\" || !value.includes(\"\\n\")) {\n    return value;\n  }\n\n  const currentLine = precedingText.slice(precedingText.lastIndexOf(\"\\n\") + 1);\n  const indentMatch = currentLine.match(/^(\\s+)/);\n\n  if (indentMatch) {\n    const indent = indentMatch[1];\n    return value.replace(/\\n/g, `\\n${indent}`);\n  }\n\n  return value;\n}\n\n/**\n * Strips common leading indentation from all lines.\n *\n * @param text - The text to process\n * @returns The text with common indentation removed\n */\nfunction stripIndent(text: string): string {\n  const lines = text.split(\"\\n\");\n\n  // Find minimum indentation (only from lines that have content)\n  let minIndent: number | null = null;\n  for (const line of lines) {\n    const match = line.match(/^(\\s+)\\S+/);\n    if (match) {\n      const indent = match[1].length;\n      if (minIndent === null) {\n        minIndent = indent;\n      } else {\n        minIndent = Math.min(minIndent, indent);\n      }\n    }\n  }\n\n  if (minIndent === null) {\n    return text;\n  }\n\n  // Remove the common indentation from all lines\n  return lines\n    .map((line) =>\n      line[0] === \" \" || line[0] === \"\\t\" ? line.slice(minIndent) : line\n    )\n    .join(\"\\n\");\n}\n", "/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nimport { IterableReadableStream } from \"./stream.js\";\n\nexport const EventStreamContentType = \"text/event-stream\";\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string;\n  /** A string identifying the type of event described. */\n  event: string;\n  /** The event data */\n  data: string;\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  stream: ReadableStream<Uint8Array> | AsyncIterable<any>,\n  onChunk: (arr: Uint8Array, flush?: boolean) => void\n) {\n  // TODO: Use Async iteration for both cases?\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  if (stream instanceof ReadableStream) {\n    const reader = stream.getReader();\n    // CHANGED: Introduced a \"flush\" mechanism to process potential pending messages when the stream ends.\n    //          This change is essential to ensure that we capture every last piece of information from streams,\n    //          such as those from Azure OpenAI, which may not terminate with a blank line. Without this\n    //          mechanism, we risk ignoring a possibly significant last message.\n    //          See https://github.com/langchain-ai/langchainjs/issues/1299 for details.\n    while (true) {\n      const result = await reader.read();\n      if (result.done) {\n        onChunk(new Uint8Array(), true);\n        break;\n      }\n      onChunk(result.value);\n    }\n  } else {\n    try {\n      // Handle Node.js Readable streams with async iteration\n      for await (const chunk of stream) {\n        onChunk(new Uint8Array(chunk));\n      }\n      onChunk(new Uint8Array(), true);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new Error(\n        [\n          \"Parsing event source stream failed.\",\n          \"Ensure your implementation of fetch returns a web or Node readable stream.\",\n          `Error: ${e.message}`,\n        ].join(\"\\n\")\n      );\n    }\n  }\n}\n\nconst enum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n  onLine: (line: Uint8Array, fieldLength: number, flush?: boolean) => void\n) {\n  let buffer: Uint8Array | undefined;\n  let position: number; // current read position\n  let fieldLength: number; // length of the `field` portion of the line\n  let discardTrailingNewline = false;\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array, flush?: boolean) {\n    if (flush) {\n      onLine(arr, 0, true);\n      return;\n    }\n\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr);\n    }\n\n    const bufLength = buffer.length;\n    let lineStart = 0; // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position; // skip to next char\n        }\n\n        discardTrailingNewline = false;\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1; // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart;\n            }\n            break;\n          // @ts-expect-error \\r case below should fallthrough to \\n:\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true;\n          // eslint-disable-next-line no-fallthrough\n          case ControlChars.NewLine:\n            lineEnd = position;\n            break;\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break;\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position; // we're now on the next line\n      fieldLength = -1;\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined; // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n  onMessage?: (msg: EventSourceMessage) => void,\n  onId?: (id: string) => void,\n  onRetry?: (retry: number) => void\n) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(\n    line: Uint8Array,\n    fieldLength: number,\n    flush?: boolean\n  ) {\n    if (flush) {\n      if (!isEmpty(message)) {\n        onMessage?.(message);\n        message = newMessage();\n      }\n      return;\n    }\n\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset =\n        fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case \"data\":\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId?.((message.id = value));\n          break;\n        case \"retry\": {\n          const retry = parseInt(value, 10);\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry?.((message.retry = retry));\n          }\n          break;\n        }\n      }\n    }\n  };\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: undefined,\n  };\n}\n\nexport function convertEventStreamToIterableReadableDataStream(\n  stream: ReadableStream,\n  onMetadataEvent?: (e: unknown) => unknown\n) {\n  const dataStream = new ReadableStream({\n    async start(controller) {\n      const enqueueLine = getMessages((msg) => {\n        if (msg.event === \"error\") {\n          throw new Error(msg.data ?? \"Unspecified event streaming error.\");\n        } else if (msg.event === \"metadata\") {\n          onMetadataEvent?.(msg);\n        } else {\n          if (msg.data) controller.enqueue(msg.data);\n        }\n      });\n      const onLine = (\n        line: Uint8Array,\n        fieldLength: number,\n        flush?: boolean\n      ) => {\n        enqueueLine(line, fieldLength, flush);\n        if (flush) controller.close();\n      };\n      await getBytes(stream, getLines(onLine));\n    },\n  });\n  return IterableReadableStream.fromReadableStream(dataStream);\n}\n\nfunction isEmpty(message: EventSourceMessage): boolean {\n  return (\n    message.data === \"\" &&\n    message.event === \"\" &&\n    message.id === \"\" &&\n    message.retry === undefined\n  );\n}\n", "//#region src/utils/format.ts\nvar format_exports = {};\n\n//#endregion\nexport { format_exports };\n//# sourceMappingURL=format.js.map", "import {\n  StructuredToolInterface,\n  StructuredToolParams,\n  isLangChainTool,\n} from \"../tools/types.js\";\nimport { FunctionDefinition, ToolDefinition } from \"../language_models/base.js\";\nimport { RunnableToolLike } from \"../runnables/base.js\";\nimport { toJsonSchema } from \"./json_schema.js\";\n\n// These utility functions were moved to a more appropriate location,\n// but we still export them here for backwards compatibility.\nexport {\n  isStructuredTool,\n  isStructuredToolParams,\n  isRunnableToolLike,\n  isLangChainTool,\n} from \"../tools/types.js\";\n\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a format\n * that is compatible with OpenAI function calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | RunnableToolLike} tool The tool to convert to an OpenAI function.\n * @returns {FunctionDefinition} The inputted tool in OpenAI function format.\n */\nexport function convertToOpenAIFunction(\n  tool: StructuredToolInterface | RunnableToolLike | StructuredToolParams,\n  fields?:\n    | {\n        /**\n         * If `true`, model output is guaranteed to exactly match the JSON Schema\n         * provided in the function definition.\n         */\n        strict?: boolean;\n      }\n    | number\n): FunctionDefinition {\n  // @TODO 0.3.0 Remove the `number` typing\n  const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n\n  return {\n    name: tool.name,\n    description: tool.description,\n    parameters: toJsonSchema(tool.schema),\n    // Do not include the `strict` field if it is `undefined`.\n    ...(fieldsCopy?.strict !== undefined ? { strict: fieldsCopy.strict } : {}),\n  };\n}\n\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a\n * format that is compatible with OpenAI tool calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | Record<string, any> | RunnableToolLike} tool The tool to convert to an OpenAI tool.\n * @returns {ToolDefinition} The inputted tool in OpenAI tool format.\n */\nexport function convertToOpenAITool(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tool: StructuredToolInterface | Record<string, any> | RunnableToolLike,\n  fields?:\n    | {\n        /**\n         * If `true`, model output is guaranteed to exactly match the JSON Schema\n         * provided in the function definition.\n         */\n        strict?: boolean;\n      }\n    | number\n): ToolDefinition {\n  // @TODO 0.3.0 Remove the `number` typing\n  const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n\n  let toolDef: ToolDefinition | undefined;\n  if (isLangChainTool(tool)) {\n    toolDef = {\n      type: \"function\",\n      function: convertToOpenAIFunction(tool),\n    };\n  } else {\n    toolDef = tool as ToolDefinition;\n  }\n\n  if (fieldsCopy?.strict !== undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (toolDef.function as any).strict = fieldsCopy.strict;\n  }\n\n  return toolDef;\n}\n", "/**\n * Returns the average of cosine distances between vectors a and b\n * @param a - first vector\n * @param b - second vector\n *\n */\nexport function cosine(a: number[], b: number[]): number {\n  let p = 0;\n  let p2 = 0;\n  let q2 = 0;\n  for (let i = 0; i < a.length; i++) {\n    p += a[i] * b[i];\n    p2 += a[i] * a[i];\n    q2 += b[i] * b[i];\n  }\n  return p / (Math.sqrt(p2) * Math.sqrt(q2));\n}\n", "/**\n *Returns the Inner Product similarity between vectors a and b\n * @link [Inner Product Similarity algorithm](https://www.naun.org/main/NAUN/ijmmas/mmmas-49.pdf)\n * @param a - first vector\n * @param b - second vector\n *\n */\nexport function innerProduct(a: number[], b: number[]): number {\n  let ans = 0;\n  for (let i = 0; i < a.length; i++) {\n    ans += a[i] * b[i];\n  }\n  return ans;\n}\n", "export function squaredEuclidean(p: number[], q: number[]) {\n  let d = 0;\n  for (let i = 0; i < p.length; i++) {\n    d += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n  return d;\n}\n\nexport function euclidean(p: number[], q: number[]) {\n  return Math.sqrt(squaredEuclidean(p, q));\n}\n", "import { cosine } from \"./ml-distance/similarities.js\";\nimport { innerProduct as innerProductDistance } from \"./ml-distance/distances.js\";\nimport { euclidean } from \"./ml-distance-euclidean/euclidean.js\";\n\ntype VectorFunction = (xVector: number[], yVector: number[]) => number;\n\n/**\n * Apply a row-wise function between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n * @param {VectorFunction} func - The function to apply.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the result of applying the function between the corresponding rows of X and Y.\n */\n\nexport function matrixFunc(\n  X: number[][],\n  Y: number[][],\n  func: VectorFunction\n): number[][] {\n  if (\n    X.length === 0 ||\n    X[0].length === 0 ||\n    Y.length === 0 ||\n    Y[0].length === 0\n  ) {\n    return [[]];\n  }\n\n  if (X[0].length !== Y[0].length) {\n    throw new Error(\n      `Number of columns in X and Y must be the same. X has shape ${[\n        X.length,\n        X[0].length,\n      ]} and Y has shape ${[Y.length, Y[0].length]}.`\n    );\n  }\n\n  return X.map((xVector) =>\n    Y.map((yVector) => func(xVector, yVector)).map((similarity) =>\n      Number.isNaN(similarity) ? 0 : similarity\n    )\n  );\n}\n\nexport function normalize(M: number[][], similarity = false): number[][] {\n  const max = matrixMaxVal(M);\n  return M.map((row) =>\n    row.map((val) => (similarity ? 1 - val / max : val / max))\n  );\n}\n\n/**\n * This function calculates the row-wise cosine similarity between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the cosine similarity values between the corresponding rows of X and Y.\n */\nexport function cosineSimilarity(X: number[][], Y: number[][]): number[][] {\n  return matrixFunc(X, Y, cosine);\n}\n\nexport function innerProduct(X: number[][], Y: number[][]): number[][] {\n  return matrixFunc(X, Y, innerProductDistance);\n}\n\nexport function euclideanDistance(X: number[][], Y: number[][]): number[][] {\n  return matrixFunc(X, Y, euclidean);\n}\n\n/**\n * This function implements the Maximal Marginal Relevance algorithm\n * to select a set of embeddings that maximizes the diversity and relevance to a query embedding.\n *\n * @param {number[]|number[][]} queryEmbedding - The query embedding.\n * @param {number[][]} embeddingList - The list of embeddings to select from.\n * @param {number} [lambda=0.5] - The trade-off parameter between relevance and diversity.\n * @param {number} [k=4] - The maximum number of embeddings to select.\n *\n * @returns {number[]} The indexes of the selected embeddings in the embeddingList.\n */\nexport function maximalMarginalRelevance(\n  queryEmbedding: number[] | number[][],\n  embeddingList: number[][],\n  lambda = 0.5,\n  k = 4\n): number[] {\n  if (Math.min(k, embeddingList.length) <= 0) {\n    return [];\n  }\n\n  const queryEmbeddingExpanded = (\n    Array.isArray(queryEmbedding[0]) ? queryEmbedding : [queryEmbedding]\n  ) as number[][];\n\n  const similarityToQuery = cosineSimilarity(\n    queryEmbeddingExpanded,\n    embeddingList\n  )[0];\n  const mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;\n\n  const selectedEmbeddings = [embeddingList[mostSimilarEmbeddingIndex]];\n  const selectedEmbeddingsIndexes = [mostSimilarEmbeddingIndex];\n\n  while (selectedEmbeddingsIndexes.length < Math.min(k, embeddingList.length)) {\n    let bestScore = -Infinity;\n    let bestIndex = -1;\n\n    const similarityToSelected = cosineSimilarity(\n      embeddingList,\n      selectedEmbeddings\n    );\n\n    similarityToQuery.forEach((queryScore, queryScoreIndex) => {\n      if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) {\n        return;\n      }\n      const maxSimilarityToSelected = Math.max(\n        ...similarityToSelected[queryScoreIndex]\n      );\n      const score =\n        lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;\n\n      if (score > bestScore) {\n        bestScore = score;\n        bestIndex = queryScoreIndex;\n      }\n    });\n    selectedEmbeddings.push(embeddingList[bestIndex]);\n    selectedEmbeddingsIndexes.push(bestIndex);\n  }\n\n  return selectedEmbeddingsIndexes;\n}\n\ntype MaxInfo = {\n  maxIndex: number;\n  maxValue: number;\n};\n\n/**\n * Finds the index of the maximum value in the given array.\n * @param {number[]} array - The input array.\n *\n * @returns {number} The index of the maximum value in the array. If the array is empty, returns -1.\n */\nfunction argMax(array: number[]): MaxInfo {\n  if (array.length === 0) {\n    return {\n      maxIndex: -1,\n      maxValue: NaN,\n    };\n  }\n\n  let maxValue = array[0];\n  let maxIndex = 0;\n\n  for (let i = 1; i < array.length; i += 1) {\n    if (array[i] > maxValue) {\n      maxIndex = i;\n      maxValue = array[i];\n    }\n  }\n  return { maxIndex, maxValue };\n}\n\nfunction matrixMaxVal(arrays: number[][]): number {\n  return arrays.reduce(\n    (acc, array) => Math.max(acc, argMax(array).maxValue),\n    0\n  );\n}\n", "import { CallbackManagerForLLMRun } from \"../../callbacks/manager.js\";\nimport {\n  BaseChatModel,\n  BaseChatModelCallOptions,\n  BaseChatModelParams,\n} from \"../../language_models/chat_models.js\";\nimport { BaseLLMParams } from \"../../language_models/llms.js\";\nimport {\n  BaseMessage,\n  AIMessage,\n  AIMessageChunk,\n} from \"../../messages/index.js\";\nimport { type ChatResult, ChatGenerationChunk } from \"../../outputs.js\";\nimport { Runnable, RunnableLambda } from \"../../runnables/base.js\";\nimport { StructuredTool } from \"../../tools/index.js\";\nimport {\n  StructuredOutputMethodParams,\n  BaseLanguageModelInput,\n  StructuredOutputMethodOptions,\n} from \"../../language_models/base.js\";\n\nimport { toJsonSchema } from \"../json_schema.js\";\nimport { InteropZodType } from \"../types/zod.js\";\n\n/** Minimal shape actually needed by `bindTools` */\nexport interface ToolSpec {\n  name: string;\n  description?: string;\n  schema: InteropZodType | Record<string, unknown>; // Either a Zod schema *or* a plain JSON-Schema object\n}\n\n/**\n * Interface specific to the Fake Streaming Chat model.\n */\nexport interface FakeStreamingChatModelCallOptions\n  extends BaseChatModelCallOptions {}\n/**\n * Interface for the Constructor-field specific to the Fake Streaming Chat model (all optional because we fill in defaults).\n */\nexport interface FakeStreamingChatModelFields extends BaseChatModelParams {\n  /** Milliseconds to pause between fallback char-by-char chunks */\n  sleep?: number;\n\n  /** Full AI messages to fall back to when no `chunks` supplied */\n  responses?: BaseMessage[];\n\n  /** Exact chunks to emit (can include tool-call deltas) */\n  chunks?: AIMessageChunk[];\n\n  /** How tool specs are formatted in `bindTools` */\n  toolStyle?: \"openai\" | \"anthropic\" | \"bedrock\" | \"google\";\n\n  /** Throw this error instead of streaming (useful in tests) */\n  thrownErrorString?: string;\n}\n\nexport class FakeChatModel extends BaseChatModel {\n  _combineLLMOutput() {\n    return [];\n  }\n\n  _llmType(): string {\n    return \"fake\";\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    options?: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    if (options?.stop?.length) {\n      return {\n        generations: [\n          {\n            message: new AIMessage(options.stop[0]),\n            text: options.stop[0],\n          },\n        ],\n      };\n    }\n    const text = messages\n      .map((m) => {\n        if (typeof m.content === \"string\") {\n          return m.content;\n        }\n        return JSON.stringify(m.content, null, 2);\n      })\n      .join(\"\\n\");\n    await runManager?.handleLLMNewToken(text);\n    return {\n      generations: [\n        {\n          message: new AIMessage(text),\n          text,\n        },\n      ],\n      llmOutput: {},\n    };\n  }\n}\n\nexport class FakeStreamingChatModel extends BaseChatModel<FakeStreamingChatModelCallOptions> {\n  sleep = 50;\n\n  responses: BaseMessage[] = [];\n\n  chunks: AIMessageChunk[] = [];\n\n  toolStyle: \"openai\" | \"anthropic\" | \"bedrock\" | \"google\" = \"openai\";\n\n  thrownErrorString?: string;\n\n  private tools: (StructuredTool | ToolSpec)[] = [];\n\n  constructor({\n    sleep = 50,\n    responses = [],\n    chunks = [],\n    toolStyle = \"openai\",\n    thrownErrorString,\n    ...rest\n  }: FakeStreamingChatModelFields & BaseLLMParams) {\n    super(rest);\n    this.sleep = sleep;\n    this.responses = responses;\n    this.chunks = chunks;\n    this.toolStyle = toolStyle;\n    this.thrownErrorString = thrownErrorString;\n  }\n\n  _llmType() {\n    return \"fake\";\n  }\n\n  bindTools(tools: (StructuredTool | ToolSpec)[]) {\n    const merged = [...this.tools, ...tools];\n\n    const toolDicts = merged.map((t) => {\n      switch (this.toolStyle) {\n        case \"openai\":\n          return {\n            type: \"function\",\n            function: {\n              name: t.name,\n              description: t.description,\n              parameters: toJsonSchema(t.schema),\n            },\n          };\n        case \"anthropic\":\n          return {\n            name: t.name,\n            description: t.description,\n            input_schema: toJsonSchema(t.schema),\n          };\n        case \"bedrock\":\n          return {\n            toolSpec: {\n              name: t.name,\n              description: t.description,\n              inputSchema: toJsonSchema(t.schema),\n            },\n          };\n        case \"google\":\n          return {\n            name: t.name,\n            description: t.description,\n            parameters: toJsonSchema(t.schema),\n          };\n        default:\n          throw new Error(`Unsupported tool style: ${this.toolStyle}`);\n      }\n    });\n\n    const wrapped =\n      this.toolStyle === \"google\"\n        ? [{ functionDeclarations: toolDicts }]\n        : toolDicts;\n\n    /* creating a *new* instance  mirrors LangChain .bind semantics for type-safety and avoiding noise */\n    const next = new FakeStreamingChatModel({\n      sleep: this.sleep,\n      responses: this.responses,\n      chunks: this.chunks,\n      toolStyle: this.toolStyle,\n      thrownErrorString: this.thrownErrorString,\n    });\n    next.tools = merged;\n\n    return next.withConfig({ tools: wrapped } as BaseChatModelCallOptions);\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n\n    const content = this.responses?.[0]?.content ?? messages[0].content ?? \"\";\n\n    const generation: ChatResult = {\n      generations: [\n        {\n          text: \"\",\n          message: new AIMessage({\n            content,\n            tool_calls: this.chunks?.[0]?.tool_calls,\n          }),\n        },\n      ],\n    };\n\n    return generation;\n  }\n\n  async *_streamResponseChunks(\n    _messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n    if (this.chunks?.length) {\n      for (const msgChunk of this.chunks) {\n        const cg = new ChatGenerationChunk({\n          message: new AIMessageChunk({\n            content: msgChunk.content,\n            tool_calls: msgChunk.tool_calls,\n            additional_kwargs: msgChunk.additional_kwargs ?? {},\n          }),\n          text: msgChunk.content?.toString() ?? \"\",\n        });\n\n        if (options.signal?.aborted) break;\n        yield cg;\n        await runManager?.handleLLMNewToken(\n          msgChunk.content as string,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          { chunk: cg }\n        );\n      }\n      return;\n    }\n\n    const fallback =\n      this.responses?.[0] ??\n      new AIMessage(\n        typeof _messages[0].content === \"string\" ? _messages[0].content : \"\"\n      );\n    const text = typeof fallback.content === \"string\" ? fallback.content : \"\";\n\n    for (const ch of text) {\n      await new Promise((r) => setTimeout(r, this.sleep));\n      const cg = new ChatGenerationChunk({\n        message: new AIMessageChunk({ content: ch }),\n        text: ch,\n      });\n      if (options.signal?.aborted) break;\n      yield cg;\n      await runManager?.handleLLMNewToken(\n        ch,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        { chunk: cg }\n      );\n    }\n  }\n}\n\n/**\n * Interface for the input parameters specific to the Fake List Chat model.\n */\nexport interface FakeChatInput extends BaseChatModelParams {\n  /** Responses to return */\n  responses: string[];\n\n  /** Time to sleep in milliseconds between responses */\n  sleep?: number;\n\n  emitCustomEvent?: boolean;\n\n  /**\n   * Generation info to include on the last chunk during streaming.\n   * This gets merged into response_metadata by the base chat model.\n   * Useful for testing response_metadata propagation (e.g., finish_reason).\n   */\n  generationInfo?: Record<string, unknown>;\n}\n\nexport interface FakeListChatModelCallOptions extends BaseChatModelCallOptions {\n  thrownErrorString?: string;\n}\n\n/**\n * A fake Chat Model that returns a predefined list of responses. It can be used\n * for testing purposes.\n * @example\n * ```typescript\n * const chat = new FakeListChatModel({\n *   responses: [\"I'll callback later.\", \"You 'console' them!\"]\n * });\n *\n * const firstMessage = new HumanMessage(\"You want to hear a JavaScript joke?\");\n * const secondMessage = new HumanMessage(\"How do you cheer up a JavaScript developer?\");\n *\n * // Call the chat model with a message and log the response\n * const firstResponse = await chat.call([firstMessage]);\n * console.log({ firstResponse });\n *\n * const secondResponse = await chat.call([secondMessage]);\n * console.log({ secondResponse });\n * ```\n */\nexport class FakeListChatModel extends BaseChatModel<FakeListChatModelCallOptions> {\n  static lc_name() {\n    return \"FakeListChatModel\";\n  }\n\n  lc_serializable = true;\n\n  responses: string[];\n\n  i = 0;\n\n  sleep?: number;\n\n  emitCustomEvent = false;\n\n  generationInfo?: Record<string, unknown>;\n\n  private tools: (StructuredTool | ToolSpec)[] = [];\n\n  toolStyle: \"openai\" | \"anthropic\" | \"bedrock\" | \"google\" = \"openai\";\n\n  constructor(params: FakeChatInput) {\n    super(params);\n    const { responses, sleep, emitCustomEvent, generationInfo } = params;\n    this.responses = responses;\n    this.sleep = sleep;\n    this.emitCustomEvent = emitCustomEvent ?? this.emitCustomEvent;\n    this.generationInfo = generationInfo;\n  }\n\n  _combineLLMOutput() {\n    return [];\n  }\n\n  _llmType(): string {\n    return \"fake-list\";\n  }\n\n  async _generate(\n    _messages: BaseMessage[],\n    options?: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    await this._sleepIfRequested();\n    if (options?.thrownErrorString) {\n      throw new Error(options.thrownErrorString);\n    }\n    if (this.emitCustomEvent) {\n      await runManager?.handleCustomEvent(\"some_test_event\", {\n        someval: true,\n      });\n    }\n\n    if (options?.stop?.length) {\n      return {\n        generations: [this._formatGeneration(options.stop[0])],\n      };\n    } else {\n      const response = this._currentResponse();\n      this._incrementResponse();\n\n      return {\n        generations: [this._formatGeneration(response)],\n        llmOutput: {},\n      };\n    }\n  }\n\n  _formatGeneration(text: string) {\n    return {\n      message: new AIMessage(text),\n      text,\n    };\n  }\n\n  async *_streamResponseChunks(\n    _messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const response = this._currentResponse();\n    this._incrementResponse();\n    if (this.emitCustomEvent) {\n      await runManager?.handleCustomEvent(\"some_test_event\", {\n        someval: true,\n      });\n    }\n\n    const responseChars = [...response];\n    for (let i = 0; i < responseChars.length; i++) {\n      const text = responseChars[i];\n      const isLastChunk = i === responseChars.length - 1;\n      await this._sleepIfRequested();\n      if (options?.thrownErrorString) {\n        throw new Error(options.thrownErrorString);\n      }\n      // Include generationInfo on the last chunk (like real providers do)\n      // This gets merged into response_metadata by the base chat model\n      const chunk = this._createResponseChunk(\n        text,\n        isLastChunk ? this.generationInfo : undefined\n      );\n      if (options.signal?.aborted) break;\n      yield chunk;\n      // eslint-disable-next-line no-void\n      void runManager?.handleLLMNewToken(text);\n    }\n  }\n\n  async _sleepIfRequested() {\n    if (this.sleep !== undefined) {\n      await this._sleep();\n    }\n  }\n\n  async _sleep() {\n    return new Promise<void>((resolve) => {\n      setTimeout(() => resolve(), this.sleep);\n    });\n  }\n\n  _createResponseChunk(\n    text: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    generationInfo?: Record<string, any>\n  ): ChatGenerationChunk {\n    return new ChatGenerationChunk({\n      message: new AIMessageChunk({ content: text }),\n      text,\n      generationInfo,\n    });\n  }\n\n  _currentResponse() {\n    return this.responses[this.i];\n  }\n\n  _incrementResponse() {\n    if (this.i < this.responses.length - 1) {\n      this.i += 1;\n    } else {\n      this.i = 0;\n    }\n  }\n\n  bindTools(tools: (StructuredTool | ToolSpec)[]) {\n    const merged = [...this.tools, ...tools];\n\n    const toolDicts = merged.map((t) => {\n      switch (this.toolStyle) {\n        case \"openai\":\n          return {\n            type: \"function\",\n            function: {\n              name: t.name,\n              description: t.description,\n              parameters: toJsonSchema(t.schema),\n            },\n          };\n        case \"anthropic\":\n          return {\n            name: t.name,\n            description: t.description,\n            input_schema: toJsonSchema(t.schema),\n          };\n        case \"bedrock\":\n          return {\n            toolSpec: {\n              name: t.name,\n              description: t.description,\n              inputSchema: toJsonSchema(t.schema),\n            },\n          };\n        case \"google\":\n          return {\n            name: t.name,\n            description: t.description,\n            parameters: toJsonSchema(t.schema),\n          };\n        default:\n          throw new Error(`Unsupported tool style: ${this.toolStyle}`);\n      }\n    });\n\n    const wrapped =\n      this.toolStyle === \"google\"\n        ? [{ functionDeclarations: toolDicts }]\n        : toolDicts;\n\n    const next = new FakeListChatModel({\n      responses: this.responses,\n      sleep: this.sleep,\n      emitCustomEvent: this.emitCustomEvent,\n      generationInfo: this.generationInfo,\n    });\n    next.tools = merged;\n    next.toolStyle = this.toolStyle;\n    next.i = this.i;\n\n    return next.withConfig({ tools: wrapped } as BaseChatModelCallOptions);\n  }\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    _params:\n      | StructuredOutputMethodParams<RunOutput, false>\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    _params:\n      | StructuredOutputMethodParams<RunOutput, true>\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    _params:\n      | StructuredOutputMethodParams<RunOutput, boolean>\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    _config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        { raw: BaseMessage; parsed: RunOutput }\n      > {\n    return RunnableLambda.from(async (input) => {\n      const message = await this.invoke(input);\n      if (message.tool_calls?.[0]?.args) {\n        return message.tool_calls[0].args as RunOutput;\n      }\n      if (typeof message.content === \"string\") {\n        return JSON.parse(message.content);\n      }\n      throw new Error(\"No structured output found\");\n    }) as Runnable;\n  }\n}\n", "import { Embeddings, EmbeddingsParams } from \"../../embeddings.js\";\n\n/**\n * An interface that defines additional parameters specific to the\n * SyntheticEmbeddings class.\n */\ninterface SyntheticEmbeddingsParams extends EmbeddingsParams {\n  vectorSize: number;\n}\n\n/**\n * A class that provides synthetic embeddings by overriding the\n * embedDocuments and embedQuery methods to generate embeddings based on\n * the input documents. The embeddings are generated by converting each\n * document into chunks, calculating a numerical value for each chunk, and\n * returning an array of these values as the embedding.\n */\nexport class SyntheticEmbeddings\n  extends Embeddings\n  implements SyntheticEmbeddingsParams\n{\n  vectorSize: number;\n\n  constructor(params?: SyntheticEmbeddingsParams) {\n    super(params ?? {});\n    this.vectorSize = params?.vectorSize ?? 4;\n  }\n\n  /**\n   * Generates synthetic embeddings for a list of documents.\n   * @param documents List of documents to generate embeddings for.\n   * @returns A promise that resolves with a list of synthetic embeddings for each document.\n   */\n  async embedDocuments(documents: string[]): Promise<number[][]> {\n    return Promise.all(documents.map((doc) => this.embedQuery(doc)));\n  }\n\n  /**\n   * Generates a synthetic embedding for a document. The document is\n   * converted into chunks, a numerical value is calculated for each chunk,\n   * and an array of these values is returned as the embedding.\n   * @param document The document to generate an embedding for.\n   * @returns A promise that resolves with a synthetic embedding for the document.\n   */\n  async embedQuery(document: string): Promise<number[]> {\n    let doc = document;\n\n    // Only use the letters (and space) from the document, and make them lower case\n    doc = doc.toLowerCase().replaceAll(/[^a-z ]/g, \"\");\n\n    // Pad the document to make sure it has a divisible number of chunks\n    const padMod = doc.length % this.vectorSize;\n    const padGapSize = padMod === 0 ? 0 : this.vectorSize - padMod;\n    const padSize = doc.length + padGapSize;\n    doc = doc.padEnd(padSize, \" \");\n\n    // Break it into chunks\n    const chunkSize = doc.length / this.vectorSize;\n    const docChunk = [];\n    for (let co = 0; co < doc.length; co += chunkSize) {\n      docChunk.push(doc.slice(co, co + chunkSize));\n    }\n\n    // Turn each chunk into a number\n    const ret: number[] = docChunk.map((s) => {\n      let sum = 0;\n      // Get a total value by adding the value of each character in the string\n      for (let co = 0; co < s.length; co += 1) {\n        sum += s === \" \" ? 0 : s.charCodeAt(co);\n      }\n      // Reduce this to a number between 0 and 25 inclusive\n      // Then get the fractional number by dividing it by 26\n      const ret = (sum % 26) / 26;\n      return ret;\n    });\n\n    return ret;\n  }\n}\n\n/**\n * A class that provides fake embeddings by overriding the embedDocuments\n * and embedQuery methods to return fixed values.\n */\nexport class FakeEmbeddings extends Embeddings {\n  constructor(params?: EmbeddingsParams) {\n    super(params ?? {});\n  }\n\n  /**\n   * Generates fixed embeddings for a list of documents.\n   * @param documents List of documents to generate embeddings for.\n   * @returns A promise that resolves with a list of fixed embeddings for each document.\n   */\n  embedDocuments(documents: string[]): Promise<number[][]> {\n    return Promise.resolve(documents.map(() => [0.1, 0.2, 0.3, 0.4]));\n  }\n\n  /**\n   * Generates a fixed embedding for a query.\n   * @param _ The query to generate an embedding for.\n   * @returns A promise that resolves with a fixed embedding for the query.\n   */\n  embedQuery(_: string): Promise<number[]> {\n    return Promise.resolve([0.1, 0.2, 0.3, 0.4]);\n  }\n}\n", "import { CallbackManagerForLLMRun } from \"../../callbacks/manager.js\";\nimport { BaseLLMParams, LLM } from \"../../language_models/llms.js\";\nimport { GenerationChunk } from \"../../outputs.js\";\n\nexport class FakeLLM extends LLM {\n  response?: string;\n\n  thrownErrorString?: string;\n\n  constructor(\n    fields: { response?: string; thrownErrorString?: string } & BaseLLMParams\n  ) {\n    super(fields);\n    this.response = fields.response;\n    this.thrownErrorString = fields.thrownErrorString;\n  }\n\n  _llmType() {\n    return \"fake\";\n  }\n\n  async _call(\n    prompt: string,\n    _options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string> {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n    const response = this.response ?? prompt;\n    await runManager?.handleLLMNewToken(response);\n    return response;\n  }\n}\n\nexport class FakeStreamingLLM extends LLM {\n  sleep?: number = 50;\n\n  responses?: string[];\n\n  thrownErrorString?: string;\n\n  constructor(\n    fields: {\n      sleep?: number;\n      responses?: string[];\n      thrownErrorString?: string;\n    } & BaseLLMParams\n  ) {\n    super(fields);\n    this.sleep = fields.sleep ?? this.sleep;\n    this.responses = fields.responses;\n    this.thrownErrorString = fields.thrownErrorString;\n  }\n\n  _llmType() {\n    return \"fake\";\n  }\n\n  async _call(prompt: string): Promise<string> {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n    const response = this.responses?.[0];\n    this.responses = this.responses?.slice(1);\n    return response ?? prompt;\n  }\n\n  async *_streamResponseChunks(\n    input: string,\n    _options?: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ) {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n    const response = this.responses?.[0];\n    this.responses = this.responses?.slice(1);\n    for (const c of response ?? input) {\n      await new Promise((resolve) => setTimeout(resolve, this.sleep));\n      yield { text: c, generationInfo: {} } as GenerationChunk;\n      await runManager?.handleLLMNewToken(c);\n    }\n  }\n}\n", "import {\n  BaseChatMessageHistory,\n  BaseListChatMessageHistory,\n} from \"../../chat_history.js\";\nimport { BaseMessage, AIMessage, HumanMessage } from \"../../messages/index.js\";\nimport { BaseTracer, Run } from \"../../tracers/base.js\";\n\nexport class FakeChatMessageHistory extends BaseChatMessageHistory {\n  lc_namespace = [\"langchain_core\", \"message\", \"fake\"];\n\n  messages: Array<BaseMessage> = [];\n\n  constructor() {\n    super();\n  }\n\n  async getMessages(): Promise<BaseMessage[]> {\n    return this.messages;\n  }\n\n  async addMessage(message: BaseMessage): Promise<void> {\n    this.messages.push(message);\n  }\n\n  async addUserMessage(message: string): Promise<void> {\n    this.messages.push(new HumanMessage(message));\n  }\n\n  async addAIMessage(message: string): Promise<void> {\n    this.messages.push(new AIMessage(message));\n  }\n\n  async clear(): Promise<void> {\n    this.messages = [];\n  }\n}\n\nexport class FakeListChatMessageHistory extends BaseListChatMessageHistory {\n  lc_namespace = [\"langchain_core\", \"message\", \"fake\"];\n\n  messages: Array<BaseMessage> = [];\n\n  constructor() {\n    super();\n  }\n\n  async addMessage(message: BaseMessage): Promise<void> {\n    this.messages.push(message);\n  }\n\n  async getMessages(): Promise<BaseMessage[]> {\n    return this.messages;\n  }\n}\n\nexport class FakeTracer extends BaseTracer {\n  name = \"fake_tracer\";\n\n  runs: Run[] = [];\n\n  constructor() {\n    super();\n  }\n\n  protected persistRun(run: Run): Promise<void> {\n    this.runs.push(run);\n    return Promise.resolve();\n  }\n}\n", "import { BaseOutputParser } from \"../../output_parsers/base.js\";\n\n/**\n * Parser for comma-separated values. It splits the input text by commas\n * and trims the resulting values.\n */\nexport class FakeSplitIntoListParser extends BaseOutputParser<string[]> {\n  lc_namespace = [\"tests\", \"fake\"];\n\n  getFormatInstructions() {\n    return \"\";\n  }\n\n  async parse(text: string): Promise<string[]> {\n    return text.split(\",\").map((value) => value.trim());\n  }\n}\n", "import { Document } from \"../../documents/document.js\";\nimport { BaseRetriever } from \"../../retrievers/index.js\";\n\nexport class FakeRetriever extends BaseRetriever {\n  lc_namespace = [\"test\", \"fake\"];\n\n  output = [\n    new Document({ pageContent: \"foo\" }),\n    new Document({ pageContent: \"bar\" }),\n  ];\n\n  constructor(fields?: { output: Document[] }) {\n    super();\n    this.output = fields?.output ?? this.output;\n  }\n\n  async _getRelevantDocuments(\n    _query: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<Document<Record<string, any>>[]> {\n    return this.output;\n  }\n}\n", "import { BaseCallbackConfig } from \"../../callbacks/manager.js\";\nimport { Runnable } from \"../../runnables/base.js\";\n\nexport class FakeRunnable extends Runnable<string, Record<string, unknown>> {\n  lc_namespace = [\"tests\", \"fake\"];\n\n  returnOptions?: boolean;\n\n  constructor(fields: { returnOptions?: boolean }) {\n    super(fields);\n    this.returnOptions = fields.returnOptions;\n  }\n\n  async invoke(\n    input: string,\n    options?: Partial<BaseCallbackConfig>\n  ): Promise<Record<string, unknown>> {\n    if (this.returnOptions) {\n      return options ?? {};\n    }\n    return { input };\n  }\n}\n", "import { CallbackManagerForToolRun } from \"../../callbacks/manager.js\";\nimport { StructuredTool, ToolParams } from \"../../tools/index.js\";\nimport { ToolInputSchemaOutputType } from \"../../tools/types.js\";\nimport { InteropZodObject } from \"../types/zod.js\";\n\nexport interface FakeToolParams<T extends InteropZodObject = InteropZodObject>\n  extends ToolParams {\n  name: string;\n  description: string;\n  schema: T;\n}\n\nexport class FakeTool<\n  T extends InteropZodObject = InteropZodObject,\n> extends StructuredTool<T> {\n  name: string;\n\n  description: string;\n\n  schema: T;\n\n  constructor(fields: FakeToolParams<T>) {\n    super(fields);\n    this.name = fields.name;\n    this.description = fields.description;\n    this.schema = fields.schema;\n  }\n\n  protected async _call(\n    arg: ToolInputSchemaOutputType<T>,\n    _runManager?: CallbackManagerForToolRun\n  ): Promise<string> {\n    return JSON.stringify(arg);\n  }\n}\n", "import { BaseTracer, Run } from \"../../tracers/base.js\";\n\nexport class SingleRunExtractor extends BaseTracer {\n  runPromiseResolver: (run: Run) => void;\n\n  runPromise: Promise<Run>;\n\n  /** The name of the callback handler. */\n  name = \"single_run_extractor\";\n\n  constructor() {\n    super();\n    this.runPromise = new Promise<Run>((extract) => {\n      this.runPromiseResolver = extract;\n    });\n  }\n\n  async persistRun(run: Run) {\n    this.runPromiseResolver(run);\n  }\n\n  async extract(): Promise<Run> {\n    return this.runPromise;\n  }\n}\n", "import { Document } from \"../../documents/document.js\";\nimport { EmbeddingsInterface } from \"../../embeddings.js\";\nimport { VectorStore } from \"../../vectorstores.js\";\nimport { cosine } from \"../ml-distance/similarities.js\";\n\n/**\n * Interface representing a vector in memory. It includes the content\n * (text), the corresponding embedding (vector), and any associated\n * metadata.\n */\ninterface MemoryVector {\n  content: string;\n  embedding: number[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n}\n\n/**\n * Interface for the arguments that can be passed to the\n * `FakeVectorStore` constructor. It includes an optional `similarity`\n * function.\n */\nexport interface FakeVectorStoreArgs {\n  similarity?: typeof cosine;\n}\n\n/**\n * Class that extends `VectorStore` to store vectors in memory. Provides\n * methods for adding documents, performing similarity searches, and\n * creating instances from texts, documents, or an existing index.\n */\nexport class FakeVectorStore extends VectorStore {\n  declare FilterType: (doc: Document) => boolean;\n\n  memoryVectors: MemoryVector[] = [];\n\n  similarity: typeof cosine;\n\n  _vectorstoreType(): string {\n    return \"memory\";\n  }\n\n  constructor(\n    embeddings: EmbeddingsInterface,\n    { similarity, ...rest }: FakeVectorStoreArgs = {}\n  ) {\n    super(embeddings, rest);\n\n    this.similarity = similarity ?? cosine;\n  }\n\n  /**\n   * Method to add documents to the memory vector store. It extracts the\n   * text from each document, generates embeddings for them, and adds the\n   * resulting vectors to the store.\n   * @param documents Array of `Document` instances to be added to the store.\n   * @returns Promise that resolves when all documents have been added.\n   */\n  async addDocuments(documents: Document[]): Promise<void> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents\n    );\n  }\n\n  /**\n   * Method to add vectors to the memory vector store. It creates\n   * `MemoryVector` instances for each vector and document pair and adds\n   * them to the store.\n   * @param vectors Array of vectors to be added to the store.\n   * @param documents Array of `Document` instances corresponding to the vectors.\n   * @returns Promise that resolves when all vectors have been added.\n   */\n  async addVectors(vectors: number[][], documents: Document[]): Promise<void> {\n    const memoryVectors = vectors.map((embedding, idx) => ({\n      content: documents[idx].pageContent,\n      embedding,\n      metadata: documents[idx].metadata,\n    }));\n\n    this.memoryVectors = this.memoryVectors.concat(memoryVectors);\n  }\n\n  /**\n   * Method to perform a similarity search in the memory vector store. It\n   * calculates the similarity between the query vector and each vector in\n   * the store, sorts the results by similarity, and returns the top `k`\n   * results along with their scores.\n   * @param query Query vector to compare against the vectors in the store.\n   * @param k Number of top results to return.\n   * @param filter Optional filter function to apply to the vectors before performing the search.\n   * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[Document, number][]> {\n    const filterFunction = (memoryVector: MemoryVector) => {\n      if (!filter) {\n        return true;\n      }\n\n      const doc = new Document({\n        metadata: memoryVector.metadata,\n        pageContent: memoryVector.content,\n      });\n      return filter(doc);\n    };\n    const filteredMemoryVectors = this.memoryVectors.filter(filterFunction);\n    const searches = filteredMemoryVectors\n      .map((vector, index) => ({\n        similarity: this.similarity(query, vector.embedding),\n        index,\n      }))\n      .sort((a, b) => (a.similarity > b.similarity ? -1 : 0))\n      .slice(0, k);\n\n    const result: [Document, number][] = searches.map((search) => [\n      new Document({\n        metadata: filteredMemoryVectors[search.index].metadata,\n        pageContent: filteredMemoryVectors[search.index].content,\n      }),\n      search.similarity,\n    ]);\n\n    return result;\n  }\n\n  /**\n   * Static method to create a `FakeVectorStore` instance from an array of\n   * texts. It creates a `Document` for each text and metadata pair, and\n   * adds them to the store.\n   * @param texts Array of texts to be added to the store.\n   * @param metadatas Array or single object of metadata corresponding to the texts.\n   * @param embeddings `Embeddings` instance used to generate embeddings for the texts.\n   * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.\n   * @returns Promise that resolves with a new `FakeVectorStore` instance.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig?: FakeVectorStoreArgs\n  ): Promise<FakeVectorStore> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return FakeVectorStore.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Static method to create a `FakeVectorStore` instance from an array of\n   * `Document` instances. It adds the documents to the store.\n   * @param docs Array of `Document` instances to be added to the store.\n   * @param embeddings `Embeddings` instance used to generate embeddings for the documents.\n   * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.\n   * @returns Promise that resolves with a new `FakeVectorStore` instance.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig?: FakeVectorStoreArgs\n  ): Promise<FakeVectorStore> {\n    const instance = new this(embeddings, dbConfig);\n    await instance.addDocuments(docs);\n    return instance;\n  }\n\n  /**\n   * Static method to create a `FakeVectorStore` instance from an existing\n   * index. It creates a new `FakeVectorStore` instance without adding any\n   * documents or vectors.\n   * @param embeddings `Embeddings` instance used to generate embeddings for the documents.\n   * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.\n   * @returns Promise that resolves with a new `FakeVectorStore` instance.\n   */\n  static async fromExistingIndex(\n    embeddings: EmbeddingsInterface,\n    dbConfig?: FakeVectorStoreArgs\n  ): Promise<FakeVectorStore> {\n    const instance = new this(embeddings, dbConfig);\n    return instance;\n  }\n}\n", "import { __export } from \"../../_virtual/rolldown_runtime.js\";\nimport { FakeChatModel, FakeListChatModel, FakeStreamingChatModel } from \"./chat_models.js\";\nimport { FakeEmbeddings, SyntheticEmbeddings } from \"./embeddings.js\";\nimport { FakeLLM, FakeStreamingLLM } from \"./llms.js\";\nimport { FakeChatMessageHistory, FakeListChatMessageHistory, FakeTracer } from \"./message_history.js\";\nimport { FakeSplitIntoListParser } from \"./output_parsers.js\";\nimport { FakeRetriever } from \"./retrievers.js\";\nimport { FakeRunnable } from \"./runnables.js\";\nimport { FakeTool } from \"./tools.js\";\nimport { SingleRunExtractor } from \"./tracers.js\";\nimport { FakeVectorStore } from \"./vectorstores.js\";\n\n//#region src/utils/testing/index.ts\nvar testing_exports = {};\n__export(testing_exports, {\n\tFakeChatMessageHistory: () => FakeChatMessageHistory,\n\tFakeChatModel: () => FakeChatModel,\n\tFakeEmbeddings: () => FakeEmbeddings,\n\tFakeLLM: () => FakeLLM,\n\tFakeListChatMessageHistory: () => FakeListChatMessageHistory,\n\tFakeListChatModel: () => FakeListChatModel,\n\tFakeRetriever: () => FakeRetriever,\n\tFakeRunnable: () => FakeRunnable,\n\tFakeSplitIntoListParser: () => FakeSplitIntoListParser,\n\tFakeStreamingChatModel: () => FakeStreamingChatModel,\n\tFakeStreamingLLM: () => FakeStreamingLLM,\n\tFakeTool: () => FakeTool,\n\tFakeTracer: () => FakeTracer,\n\tFakeVectorStore: () => FakeVectorStore,\n\tSingleRunExtractor: () => SingleRunExtractor,\n\tSyntheticEmbeddings: () => SyntheticEmbeddings\n});\n\n//#endregion\nexport { FakeChatMessageHistory, FakeChatModel, FakeEmbeddings, FakeLLM, FakeListChatMessageHistory, FakeListChatModel, FakeRetriever, FakeRunnable, FakeSplitIntoListParser, FakeStreamingChatModel, FakeStreamingLLM, FakeTool, FakeTracer, FakeVectorStore, SingleRunExtractor, SyntheticEmbeddings, testing_exports };\n//# sourceMappingURL=index.js.map", "import { __export } from \"../../_virtual/rolldown_runtime.js\";\nimport { extendInteropZodObject, getInteropZodDefaultGetter, getInteropZodObjectShape, getSchemaDescription, interopParse, interopParseAsync, interopSafeParse, interopSafeParseAsync, interopZodObjectMakeFieldsOptional, interopZodObjectPartial, interopZodObjectPassthrough, interopZodObjectStrict, interopZodTransformInputSchema, isInteropZodError, isInteropZodLiteral, isInteropZodObject, isInteropZodSchema, isShapelessZodSchema, isSimpleStringZodSchema, isZodArrayV4, isZodLiteralV3, isZodLiteralV4, isZodNullableV4, isZodObjectV3, isZodObjectV4, isZodOptionalV4, isZodSchema, isZodSchemaV3, isZodSchemaV4 } from \"./zod.js\";\n\n//#region src/utils/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n\textendInteropZodObject: () => extendInteropZodObject,\n\tgetInteropZodDefaultGetter: () => getInteropZodDefaultGetter,\n\tgetInteropZodObjectShape: () => getInteropZodObjectShape,\n\tgetSchemaDescription: () => getSchemaDescription,\n\tinteropParse: () => interopParse,\n\tinteropParseAsync: () => interopParseAsync,\n\tinteropSafeParse: () => interopSafeParse,\n\tinteropSafeParseAsync: () => interopSafeParseAsync,\n\tinteropZodObjectMakeFieldsOptional: () => interopZodObjectMakeFieldsOptional,\n\tinteropZodObjectPartial: () => interopZodObjectPartial,\n\tinteropZodObjectPassthrough: () => interopZodObjectPassthrough,\n\tinteropZodObjectStrict: () => interopZodObjectStrict,\n\tinteropZodTransformInputSchema: () => interopZodTransformInputSchema,\n\tisInteropZodError: () => isInteropZodError,\n\tisInteropZodLiteral: () => isInteropZodLiteral,\n\tisInteropZodObject: () => isInteropZodObject,\n\tisInteropZodSchema: () => isInteropZodSchema,\n\tisShapelessZodSchema: () => isShapelessZodSchema,\n\tisSimpleStringZodSchema: () => isSimpleStringZodSchema,\n\tisZodArrayV4: () => isZodArrayV4,\n\tisZodLiteralV3: () => isZodLiteralV3,\n\tisZodLiteralV4: () => isZodLiteralV4,\n\tisZodNullableV4: () => isZodNullableV4,\n\tisZodObjectV3: () => isZodObjectV3,\n\tisZodObjectV4: () => isZodObjectV4,\n\tisZodOptionalV4: () => isZodOptionalV4,\n\tisZodSchema: () => isZodSchema,\n\tisZodSchemaV3: () => isZodSchemaV3,\n\tisZodSchemaV4: () => isZodSchemaV4\n});\n\n//#endregion\nexport { extendInteropZodObject, getInteropZodDefaultGetter, getInteropZodObjectShape, getSchemaDescription, interopParse, interopParseAsync, interopSafeParse, interopSafeParseAsync, interopZodObjectMakeFieldsOptional, interopZodObjectPartial, interopZodObjectPassthrough, interopZodObjectStrict, interopZodTransformInputSchema, isInteropZodError, isInteropZodLiteral, isInteropZodObject, isInteropZodSchema, isShapelessZodSchema, isSimpleStringZodSchema, isZodArrayV4, isZodLiteralV3, isZodLiteralV4, isZodNullableV4, isZodObjectV3, isZodObjectV4, isZodOptionalV4, isZodSchema, isZodSchemaV3, isZodSchemaV4, types_exports };\n//# sourceMappingURL=index.js.map", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { agents_exports } from \"../agents.js\";\nimport { serializable_exports } from \"./serializable.js\";\nimport { tool_exports } from \"../messages/tool.js\";\nimport { env_exports } from \"../utils/env.js\";\nimport { base_exports } from \"../callbacks/base.js\";\nimport { base_exports as base_exports$1 } from \"../tracers/base.js\";\nimport { console_exports } from \"../tracers/console.js\";\nimport { tracer_langchain_exports } from \"../tracers/tracer_langchain.js\";\nimport { promises_exports } from \"../callbacks/promises.js\";\nimport { manager_exports } from \"../callbacks/manager.js\";\nimport { singletons_exports } from \"../singletons/index.js\";\nimport { stream_exports } from \"../utils/stream.js\";\nimport { log_stream_exports } from \"../tracers/log_stream.js\";\nimport { outputs_exports } from \"../outputs.js\";\nimport { async_caller_exports } from \"../utils/async_caller.js\";\nimport { json_schema_exports } from \"../utils/json_schema.js\";\nimport { graph_exports } from \"../runnables/graph.js\";\nimport { messages_exports } from \"../messages/index.js\";\nimport { chat_history_exports } from \"../chat_history.js\";\nimport { embeddings_exports } from \"../embeddings.js\";\nimport { src_exports } from \"../index.js\";\nimport { memory_exports } from \"../memory.js\";\nimport { prompt_values_exports } from \"../prompt_values.js\";\nimport { stores_exports } from \"../stores.js\";\nimport { retrievers_exports } from \"../retrievers/index.js\";\nimport { vectorstores_exports } from \"../vectorstores.js\";\nimport { hash_exports } from \"../utils/hash.js\";\nimport { caches_exports } from \"../caches/index.js\";\nimport { base_exports as base_exports$2 } from \"../document_loaders/base.js\";\nimport { langsmith_exports } from \"../document_loaders/langsmith.js\";\nimport { documents_exports } from \"../documents/index.js\";\nimport { example_selectors_exports } from \"../example_selectors/index.js\";\nimport { indexing_exports } from \"../indexing/index.js\";\nimport { tiktoken_exports } from \"../utils/tiktoken.js\";\nimport { base_exports as base_exports$3 } from \"../language_models/base.js\";\nimport { chat_models_exports } from \"../language_models/chat_models.js\";\nimport { llms_exports } from \"../language_models/llms.js\";\nimport { profile_exports } from \"../language_models/profile.js\";\nimport { runnables_exports } from \"../runnables/index.js\";\nimport { json_patch_exports } from \"../utils/json_patch.js\";\nimport { output_parsers_exports } from \"../output_parsers/index.js\";\nimport { openai_functions_exports } from \"../output_parsers/openai_functions/index.js\";\nimport { openai_tools_exports } from \"../output_parsers/openai_tools/index.js\";\nimport { prompts_exports } from \"../prompts/index.js\";\nimport { document_compressors_exports } from \"../retrievers/document_compressors/index.js\";\nimport { structured_query_exports } from \"../structured_query/index.js\";\nimport { tools_exports } from \"../tools/index.js\";\nimport { run_collector_exports } from \"../tracers/run_collector.js\";\nimport { stream_exports as stream_exports$1 } from \"../types/stream.js\";\nimport { chunk_array_exports } from \"../utils/chunk_array.js\";\nimport { context_exports } from \"../utils/context.js\";\nimport { event_source_parse_exports } from \"../utils/event_source_parse.js\";\nimport { format_exports } from \"../utils/format.js\";\nimport { function_calling_exports } from \"../utils/function_calling.js\";\nimport { math_exports } from \"../utils/math.js\";\nimport { testing_exports } from \"../utils/testing/index.js\";\nimport { types_exports } from \"../utils/types/index.js\";\n\n//#region src/load/import_map.ts\nvar import_map_exports = {};\n__export(import_map_exports, {\n\tagents: () => agents_exports,\n\tcaches: () => caches_exports,\n\tcallbacks__base: () => base_exports,\n\tcallbacks__manager: () => manager_exports,\n\tcallbacks__promises: () => promises_exports,\n\tchat_history: () => chat_history_exports,\n\tdocument_loaders__base: () => base_exports$2,\n\tdocument_loaders__langsmith: () => langsmith_exports,\n\tdocuments: () => documents_exports,\n\tembeddings: () => embeddings_exports,\n\texample_selectors: () => example_selectors_exports,\n\tindex: () => src_exports,\n\tindexing: () => indexing_exports,\n\tlanguage_models__base: () => base_exports$3,\n\tlanguage_models__chat_models: () => chat_models_exports,\n\tlanguage_models__llms: () => llms_exports,\n\tlanguage_models__profile: () => profile_exports,\n\tload__serializable: () => serializable_exports,\n\tmemory: () => memory_exports,\n\tmessages: () => messages_exports,\n\tmessages__tool: () => tool_exports,\n\toutput_parsers: () => output_parsers_exports,\n\toutput_parsers__openai_functions: () => openai_functions_exports,\n\toutput_parsers__openai_tools: () => openai_tools_exports,\n\toutputs: () => outputs_exports,\n\tprompt_values: () => prompt_values_exports,\n\tprompts: () => prompts_exports,\n\tretrievers: () => retrievers_exports,\n\tretrievers__document_compressors: () => document_compressors_exports,\n\trunnables: () => runnables_exports,\n\trunnables__graph: () => graph_exports,\n\tsingletons: () => singletons_exports,\n\tstores: () => stores_exports,\n\tstructured_query: () => structured_query_exports,\n\ttools: () => tools_exports,\n\ttracers__base: () => base_exports$1,\n\ttracers__console: () => console_exports,\n\ttracers__log_stream: () => log_stream_exports,\n\ttracers__run_collector: () => run_collector_exports,\n\ttracers__tracer_langchain: () => tracer_langchain_exports,\n\ttypes__stream: () => stream_exports$1,\n\tutils__async_caller: () => async_caller_exports,\n\tutils__chunk_array: () => chunk_array_exports,\n\tutils__context: () => context_exports,\n\tutils__env: () => env_exports,\n\tutils__event_source_parse: () => event_source_parse_exports,\n\tutils__format: () => format_exports,\n\tutils__function_calling: () => function_calling_exports,\n\tutils__hash: () => hash_exports,\n\tutils__json_patch: () => json_patch_exports,\n\tutils__json_schema: () => json_schema_exports,\n\tutils__math: () => math_exports,\n\tutils__stream: () => stream_exports,\n\tutils__testing: () => testing_exports,\n\tutils__tiktoken: () => tiktoken_exports,\n\tutils__types: () => types_exports,\n\tvectorstores: () => vectorstores_exports\n});\n\n//#endregion\nexport { import_map_exports };\n//# sourceMappingURL=import_map.js.map", "/**\n * Load LangChain objects from JSON strings or objects.\n *\n * ## How it works\n *\n * Each `Serializable` LangChain object has a unique identifier (its \"class path\"),\n * which is a list of strings representing the module path and class name. For example:\n *\n * - `AIMessage` -> `[\"langchain_core\", \"messages\", \"ai\", \"AIMessage\"]`\n * - `ChatPromptTemplate` -> `[\"langchain_core\", \"prompts\", \"chat\", \"ChatPromptTemplate\"]`\n *\n * When deserializing, the class path is validated against supported namespaces.\n *\n * ## Security model\n *\n * The `secretsFromEnv` parameter controls whether secrets can be loaded from environment\n * variables:\n *\n * - `false` (default): Secrets must be provided in `secretsMap`. If a secret is not\n *   found, `null` is returned instead of loading from environment variables.\n * - `true`: If a secret is not found in `secretsMap`, it will be loaded from\n *   environment variables. Use this only in trusted environments.\n *\n * ### Injection protection (escape-based)\n *\n * During serialization, plain objects that contain an `'lc'` key are escaped by wrapping\n * them: `{\"__lc_escaped__\": {...}}`. During deserialization, escaped objects are unwrapped\n * and returned as plain objects, NOT instantiated as LC objects.\n *\n * This is an allowlist approach: only objects explicitly produced by\n * `Serializable.toJSON()` (which are NOT escaped) are treated as LC objects;\n * everything else is user data.\n *\n * @module\n */\n\nimport {\n  Serializable,\n  SerializedConstructor,\n  SerializedNotImplemented,\n  SerializedSecret,\n  get_lc_unique_name,\n} from \"./serializable.js\";\nimport { optionalImportEntrypoints as defaultOptionalImportEntrypoints } from \"./import_constants.js\";\nimport * as coreImportMap from \"./import_map.js\";\nimport type { OptionalImportMap, SecretMap } from \"./import_type.js\";\nimport { type SerializedFields, keyFromJson, mapKeys } from \"./map_keys.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { isEscapedObject, unescapeValue } from \"./validation.js\";\n\n/**\n * Options for loading serialized LangChain objects.\n *\n * @remarks\n * **Security considerations:**\n *\n * Deserialization can instantiate arbitrary classes from the allowed namespaces.\n * When loading untrusted data, be aware that:\n *\n * 1. **`secretsFromEnv`**: Defaults to `false`. Setting to `true` allows the\n *    deserializer to read environment variables, which could leak secrets if\n *    the serialized data contains malicious secret references.\n *\n * 2. **`importMap` / `optionalImportsMap`**: These allow extending which classes\n *    can be instantiated. Never populate these from user input. Only include\n *    modules you explicitly trust.\n *\n * 3. **Class instantiation**: Allowed classes will have their constructors called\n *    with the deserialized kwargs. If a class performs side effects in its\n *    constructor (network calls, file I/O, etc.), those will execute.\n */\nexport interface LoadOptions {\n  /**\n   * A map of secrets to load. Keys are secret identifiers, values are the secret values.\n   *\n   * If a secret is not found in this map and `secretsFromEnv` is `false`, an error is\n   * thrown. If `secretsFromEnv` is `true`, the secret will be loaded from environment\n   * variables (if not found there either, an error is thrown).\n   */\n  secretsMap?: SecretMap;\n\n  /**\n   * Whether to load secrets from environment variables when not found in `secretsMap`.\n   *\n   * @default false\n   *\n   * @remarks\n   * **Security warning:** Setting this to `true` allows the deserializer to read\n   * environment variables, which could be a security risk if the serialized data\n   * is not trusted. Only set this to `true` when deserializing data from trusted\n   * sources (e.g., your own database, not user input).\n   */\n  secretsFromEnv?: boolean;\n\n  /**\n   * A map of optional imports. Keys are namespace paths (e.g., \"langchain_community/llms\"),\n   * values are the imported modules.\n   *\n   * @remarks\n   * **Security warning:** This extends which classes can be instantiated during\n   * deserialization. Never populate this map with values derived from user input.\n   * Only include modules that you explicitly trust and have reviewed.\n   *\n   * Classes in these modules can be instantiated with attacker-controlled kwargs\n   * if the serialized data is untrusted.\n   */\n  optionalImportsMap?: OptionalImportMap;\n\n  /**\n   * Additional optional import entrypoints to allow beyond the defaults.\n   *\n   * @remarks\n   * **Security warning:** This extends which namespace paths are considered valid\n   * for deserialization. Never populate this array with values derived from user\n   * input. Each entrypoint you add expands the attack surface for deserialization.\n   */\n  optionalImportEntrypoints?: string[];\n\n  /**\n   * Additional import map for the \"langchain\" namespace.\n   *\n   * @remarks\n   * **Security warning:** This extends which classes can be instantiated during\n   * deserialization. Never populate this map with values derived from user input.\n   * Only include modules that you explicitly trust and have reviewed.\n   *\n   * Any class exposed through this map can be instantiated with attacker-controlled\n   * kwargs if the serialized data is untrusted.\n   */\n  importMap?: Record<string, unknown>;\n\n  /**\n   * Maximum recursion depth allowed during deserialization.\n   *\n   * @default 50\n   *\n   * @remarks\n   * This limit protects against denial-of-service attacks using deeply nested\n   * JSON structures that could cause stack overflow. If your legitimate data\n   * requires deeper nesting, you can increase this limit.\n   */\n  maxDepth?: number;\n}\n\n/**\n * Default maximum recursion depth for deserialization.\n * This provides protection against DoS attacks via deeply nested structures.\n */\nconst DEFAULT_MAX_DEPTH = 50;\n\nfunction combineAliasesAndInvert(constructor: typeof Serializable) {\n  const aliases: { [key: string]: string } = {};\n  for (\n    let current = constructor;\n    current && current.prototype;\n    current = Object.getPrototypeOf(current)\n  ) {\n    Object.assign(aliases, Reflect.get(current.prototype, \"lc_aliases\"));\n  }\n  return Object.entries(aliases).reduce(\n    (acc, [key, value]) => {\n      acc[value] = key;\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n}\n\ninterface ReviverContext {\n  optionalImportsMap: OptionalImportMap;\n  optionalImportEntrypoints: string[];\n  secretsMap: SecretMap;\n  secretsFromEnv: boolean;\n  importMap: Record<string, unknown>;\n  path: string[];\n  depth: number;\n  maxDepth: number;\n}\n\n/**\n * Recursively revive a value, handling escape markers and LC objects.\n *\n * This function handles:\n * 1. Escaped dicts - unwrapped and returned as plain objects\n * 2. LC secret objects - resolved from secretsMap or env\n * 3. LC constructor objects - instantiated\n * 4. Regular objects/arrays - recursed into\n */\nasync function reviver(this: ReviverContext, value: unknown): Promise<unknown> {\n  const {\n    optionalImportsMap,\n    optionalImportEntrypoints,\n    importMap,\n    secretsMap,\n    secretsFromEnv,\n    path,\n    depth,\n    maxDepth,\n  } = this;\n  const pathStr = path.join(\".\");\n\n  // Check recursion depth to prevent DoS via deeply nested structures\n  if (depth > maxDepth) {\n    throw new Error(\n      `Maximum recursion depth (${maxDepth}) exceeded during deserialization. ` +\n        `This may indicate a malicious payload or you may need to increase maxDepth.`\n    );\n  }\n\n  // If not an object, return as-is\n  if (typeof value !== \"object\" || value == null) {\n    return value;\n  }\n\n  // Handle arrays - recurse into elements\n  if (Array.isArray(value)) {\n    return Promise.all(\n      value.map((v, i) =>\n        reviver.call({ ...this, path: [...path, `${i}`], depth: depth + 1 }, v)\n      )\n    );\n  }\n\n  // It's an object - check for escape marker FIRST\n  const record = value as Record<string, unknown>;\n  if (isEscapedObject(record)) {\n    // This is an escaped user object - unwrap and return as-is (no LC processing)\n    return unescapeValue(record);\n  }\n\n  // Check for LC secret object\n  if (\n    \"lc\" in record &&\n    \"type\" in record &&\n    \"id\" in record &&\n    record.lc === 1 &&\n    record.type === \"secret\"\n  ) {\n    const serialized = record as unknown as SerializedSecret;\n    const [key] = serialized.id;\n    if (key in secretsMap) {\n      return secretsMap[key as keyof SecretMap];\n    } else if (secretsFromEnv) {\n      const secretValueInEnv = getEnvironmentVariable(key);\n      if (secretValueInEnv) {\n        return secretValueInEnv;\n      }\n    }\n    throw new Error(`Missing secret \"${key}\" at ${pathStr}`);\n  }\n\n  // Check for LC not_implemented object\n  if (\n    \"lc\" in record &&\n    \"type\" in record &&\n    \"id\" in record &&\n    record.lc === 1 &&\n    record.type === \"not_implemented\"\n  ) {\n    const serialized = record as unknown as SerializedNotImplemented;\n    const str = JSON.stringify(serialized);\n    throw new Error(\n      `Trying to load an object that doesn't implement serialization: ${pathStr} -> ${str}`\n    );\n  }\n\n  // Check for LC constructor object\n  if (\n    \"lc\" in record &&\n    \"type\" in record &&\n    \"id\" in record &&\n    \"kwargs\" in record &&\n    record.lc === 1 &&\n    record.type === \"constructor\"\n  ) {\n    const serialized = record as unknown as SerializedConstructor;\n    const str = JSON.stringify(serialized);\n    const [name, ...namespaceReverse] = serialized.id.slice().reverse();\n    const namespace = namespaceReverse.reverse();\n    const importMaps = { langchain_core: coreImportMap, langchain: importMap };\n\n    let module:\n      | (typeof importMaps)[\"langchain_core\"][keyof (typeof importMaps)[\"langchain_core\"]]\n      | (typeof importMaps)[\"langchain\"][keyof (typeof importMaps)[\"langchain\"]]\n      | OptionalImportMap[keyof OptionalImportMap]\n      | null = null;\n\n    const optionalImportNamespaceAliases = [namespace.join(\"/\")];\n    if (namespace[0] === \"langchain_community\") {\n      optionalImportNamespaceAliases.push(\n        [\"langchain\", ...namespace.slice(1)].join(\"/\")\n      );\n    }\n    const matchingNamespaceAlias = optionalImportNamespaceAliases.find(\n      (alias) => alias in optionalImportsMap\n    );\n    if (\n      defaultOptionalImportEntrypoints\n        .concat(optionalImportEntrypoints)\n        .includes(namespace.join(\"/\")) ||\n      matchingNamespaceAlias\n    ) {\n      if (matchingNamespaceAlias !== undefined) {\n        module =\n          await optionalImportsMap[\n            matchingNamespaceAlias as keyof typeof optionalImportsMap\n          ];\n      } else {\n        throw new Error(\n          `Missing key \"${namespace.join(\n            \"/\"\n          )}\" for ${pathStr} in load(optionalImportsMap={})`\n        );\n      }\n    } else {\n      let finalImportMap:\n        | (typeof importMaps)[\"langchain\"]\n        | (typeof importMaps)[\"langchain_core\"];\n      // Currently, we only support langchain and langchain_core imports.\n      if (namespace[0] === \"langchain\" || namespace[0] === \"langchain_core\") {\n        finalImportMap = importMaps[namespace[0]];\n        namespace.shift();\n      } else {\n        throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n      }\n\n      // The root namespace \"langchain\" is not a valid import.\n      if (namespace.length === 0) {\n        throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n      }\n\n      // Find the longest matching namespace.\n      let importMapKey: string;\n      do {\n        importMapKey = namespace.join(\"__\");\n        if (importMapKey in finalImportMap) {\n          break;\n        } else {\n          namespace.pop();\n        }\n      } while (namespace.length > 0);\n\n      // If no matching namespace is found, throw an error.\n      if (importMapKey in finalImportMap) {\n        module = finalImportMap[importMapKey as keyof typeof finalImportMap];\n      }\n    }\n\n    if (typeof module !== \"object\" || module === null) {\n      throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n    }\n\n    // Extract the builder from the import map.\n    const builder =\n      // look for a named export with the same name as the class\n      module[name as keyof typeof module] ??\n      // look for an export with a lc_name property matching the class name\n      // this is necessary for classes that are minified\n      Object.values(module).find(\n        (v) =>\n          typeof v === \"function\" &&\n          get_lc_unique_name(v as typeof Serializable) === name\n      );\n    if (typeof builder !== \"function\") {\n      throw new Error(`Invalid identifer: ${pathStr} -> ${str}`);\n    }\n\n    // Recurse on the arguments, which may be serialized objects themselves\n    const kwargs = await reviver.call(\n      { ...this, path: [...path, \"kwargs\"], depth: depth + 1 },\n      serialized.kwargs\n    );\n\n    // Construct the object\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const instance = new (builder as any)(\n      mapKeys(\n        kwargs as SerializedFields,\n        keyFromJson,\n        combineAliasesAndInvert(builder)\n      )\n    );\n\n    // Minification in severless/edge runtimes will mange the\n    // name of classes presented in traces. As the names in import map\n    // are present as-is even with minification, use these names instead\n    Object.defineProperty(instance.constructor, \"name\", { value: name });\n\n    return instance;\n  }\n\n  // Regular object - recurse into values\n  const result: Record<string, unknown> = {};\n  for (const [key, val] of Object.entries(record)) {\n    result[key] = await reviver.call(\n      { ...this, path: [...path, key], depth: depth + 1 },\n      val\n    );\n  }\n  return result;\n}\n\n/**\n * Load a LangChain object from a JSON string.\n *\n * @param text - The JSON string to parse and load.\n * @param options - Options for loading.\n * @returns The loaded LangChain object.\n *\n * @example\n * ```typescript\n * import { load } from \"@langchain/core/load\";\n * import { AIMessage } from \"@langchain/core/messages\";\n *\n * // Basic usage - secrets must be provided explicitly\n * const msg = await load<AIMessage>(jsonString);\n *\n * // With secrets from a map\n * const msg = await load<AIMessage>(jsonString, {\n *   secretsMap: { OPENAI_API_KEY: \"sk-...\" }\n * });\n *\n * // Allow loading secrets from environment (use with caution)\n * const msg = await load<AIMessage>(jsonString, {\n *   secretsFromEnv: true\n * });\n * ```\n */\nexport async function load<T>(text: string, options?: LoadOptions): Promise<T> {\n  const json = JSON.parse(text);\n\n  const context: ReviverContext = {\n    optionalImportsMap: options?.optionalImportsMap ?? {},\n    optionalImportEntrypoints: options?.optionalImportEntrypoints ?? [],\n    secretsMap: options?.secretsMap ?? {},\n    secretsFromEnv: options?.secretsFromEnv ?? false,\n    importMap: options?.importMap ?? {},\n    path: [\"$\"],\n    depth: 0,\n    maxDepth: options?.maxDepth ?? DEFAULT_MAX_DEPTH,\n  };\n\n  return reviver.call(context, json) as Promise<T>;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-instanceof/no-instanceof */\nimport { load } from \"@langchain/core/load\";\nimport { SerializerProtocol } from \"./base.js\";\nimport { stringify } from \"./utils/fast-safe-stringify/index.js\";\n\nfunction isLangChainSerializedObject(value: Record<string, unknown>) {\n  return (\n    value !== null &&\n    value.lc === 1 &&\n    value.type === \"constructor\" &&\n    Array.isArray(value.id)\n  );\n}\n\n/**\n * The replacer in stringify does not allow delegation to built-in LangChain\n * serialization methods, and instead immediately calls `.toJSON()` and\n * continues to stringify subfields.\n *\n * We therefore must start from the most nested elements in the input and\n * deserialize upwards rather than top-down.\n */\nasync function _reviver(value: any): Promise<any> {\n  if (value && typeof value === \"object\") {\n    if (Array.isArray(value)) {\n      const revivedArray = await Promise.all(\n        value.map((item) => _reviver(item))\n      );\n      return revivedArray;\n    } else {\n      const revivedObj: any = {};\n      for (const [k, v] of Object.entries(value)) {\n        revivedObj[k] = await _reviver(v);\n      }\n\n      if (revivedObj.lc === 2 && revivedObj.type === \"undefined\") {\n        return undefined;\n      } else if (\n        revivedObj.lc === 2 &&\n        revivedObj.type === \"constructor\" &&\n        Array.isArray(revivedObj.id)\n      ) {\n        try {\n          const constructorName = revivedObj.id[revivedObj.id.length - 1];\n          let constructor: any;\n\n          switch (constructorName) {\n            case \"Set\":\n              constructor = Set;\n              break;\n            case \"Map\":\n              constructor = Map;\n              break;\n            case \"RegExp\":\n              constructor = RegExp;\n              break;\n            case \"Error\":\n              constructor = Error;\n              break;\n            default:\n              return revivedObj;\n          }\n          if (revivedObj.method) {\n            return (constructor as any)[revivedObj.method](\n              ...(revivedObj.args || [])\n            );\n          } else {\n            return new (constructor as any)(...(revivedObj.args || []));\n          }\n        } catch (error) {\n          return revivedObj;\n        }\n      } else if (isLangChainSerializedObject(revivedObj)) {\n        return load(JSON.stringify(revivedObj));\n      }\n\n      return revivedObj;\n    }\n  }\n  return value;\n}\n\nfunction _encodeConstructorArgs(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  constructor: Function,\n  method?: string,\n  args?: any[],\n  kwargs?: Record<string, any>\n): object {\n  return {\n    lc: 2,\n    type: \"constructor\",\n    id: [constructor.name],\n    method: method ?? null,\n    args: args ?? [],\n    kwargs: kwargs ?? {},\n  };\n}\n\nfunction _default(obj: any): any {\n  if (obj === undefined) {\n    return {\n      lc: 2,\n      type: \"undefined\",\n    };\n  } else if (obj instanceof Set || obj instanceof Map) {\n    return _encodeConstructorArgs(obj.constructor, undefined, [\n      Array.from(obj),\n    ]);\n  } else if (obj instanceof RegExp) {\n    return _encodeConstructorArgs(RegExp, undefined, [obj.source, obj.flags]);\n  } else if (obj instanceof Error) {\n    return _encodeConstructorArgs(obj.constructor, undefined, [obj.message]);\n    // TODO: Remove special case\n  } else if (obj?.lg_name === \"Send\") {\n    return {\n      node: obj.node,\n      args: obj.args,\n    };\n  } else {\n    return obj;\n  }\n}\n\nexport class JsonPlusSerializer implements SerializerProtocol {\n  protected _dumps(obj: any): Uint8Array {\n    const encoder = new TextEncoder();\n    return encoder.encode(\n      stringify(obj, (_: string, value: any) => {\n        return _default(value);\n      })\n    );\n  }\n\n  async dumpsTyped(obj: any): Promise<[string, Uint8Array]> {\n    if (obj instanceof Uint8Array) {\n      return [\"bytes\", obj];\n    } else {\n      return [\"json\", this._dumps(obj)];\n    }\n  }\n\n  protected async _loads(data: string): Promise<any> {\n    const parsed = JSON.parse(data);\n    return _reviver(parsed);\n  }\n\n  async loadsTyped(type: string, data: Uint8Array | string): Promise<any> {\n    if (type === \"bytes\") {\n      return typeof data === \"string\" ? new TextEncoder().encode(data) : data;\n    } else if (type === \"json\") {\n      return this._loads(\n        typeof data === \"string\" ? data : new TextDecoder().decode(data)\n      );\n    } else {\n      throw new Error(`Unknown serialization type: ${type}`);\n    }\n  }\n}\n", "import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport { SerializerProtocol } from \"./serde/base.js\";\nimport { uuid6 } from \"./id.js\";\nimport type {\n  PendingWrite,\n  CheckpointPendingWrite,\n  CheckpointMetadata,\n} from \"./types.js\";\nimport { ERROR, INTERRUPT, RESUME, SCHEDULED } from \"./serde/types.js\";\nimport { JsonPlusSerializer } from \"./serde/jsonplus.js\";\n\n/** @inline */\ntype ChannelVersion = number | string;\n\nexport type ChannelVersions = Record<string, ChannelVersion>;\n\nexport interface Checkpoint<\n  N extends string = string,\n  C extends string = string\n> {\n  /**\n   * The version of the checkpoint format. Currently 4\n   */\n  v: number;\n  /**\n   * Checkpoint ID {uuid6}\n   */\n  id: string;\n  /**\n   * Timestamp {new Date().toISOString()}\n   */\n  ts: string;\n  /**\n   * @default {}\n   */\n  channel_values: Record<C, unknown>;\n  /**\n   * @default {}\n   */\n  channel_versions: Record<C, ChannelVersion>;\n  /**\n   * @default {}\n   */\n  versions_seen: Record<N, Record<C, ChannelVersion>>;\n}\n\nexport interface ReadonlyCheckpoint extends Readonly<Checkpoint> {\n  readonly channel_values: Readonly<Record<string, unknown>>;\n  readonly channel_versions: Readonly<Record<string, ChannelVersion>>;\n  readonly versions_seen: Readonly<\n    Record<string, Readonly<Record<string, ChannelVersion>>>\n  >;\n}\n\nexport function deepCopy<T>(obj: T): T {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n\n  const newObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      (newObj as Record<PropertyKey, unknown>)[key] = deepCopy(\n        (obj as Record<string, unknown>)[key]\n      );\n    }\n  }\n\n  return newObj as T;\n}\n\n/** @hidden */\nexport function emptyCheckpoint(): Checkpoint {\n  return {\n    v: 4,\n    id: uuid6(-2),\n    ts: new Date().toISOString(),\n    channel_values: {},\n    channel_versions: {},\n    versions_seen: {},\n  };\n}\n\n/** @hidden */\nexport function copyCheckpoint(checkpoint: ReadonlyCheckpoint): Checkpoint {\n  return {\n    v: checkpoint.v,\n    id: checkpoint.id,\n    ts: checkpoint.ts,\n    channel_values: { ...checkpoint.channel_values },\n    channel_versions: { ...checkpoint.channel_versions },\n    versions_seen: deepCopy(checkpoint.versions_seen),\n  };\n}\n\nexport interface CheckpointTuple {\n  config: RunnableConfig;\n  checkpoint: Checkpoint;\n  metadata?: CheckpointMetadata;\n  parentConfig?: RunnableConfig;\n  pendingWrites?: CheckpointPendingWrite[];\n}\n\nexport type CheckpointListOptions = {\n  limit?: number;\n  before?: RunnableConfig;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  filter?: Record<string, any>;\n};\n\nexport abstract class BaseCheckpointSaver<V extends string | number = number> {\n  serde: SerializerProtocol = new JsonPlusSerializer();\n\n  constructor(serde?: SerializerProtocol) {\n    this.serde = serde || this.serde;\n  }\n\n  async get(config: RunnableConfig): Promise<Checkpoint | undefined> {\n    const value = await this.getTuple(config);\n    return value ? value.checkpoint : undefined;\n  }\n\n  abstract getTuple(\n    config: RunnableConfig\n  ): Promise<CheckpointTuple | undefined>;\n\n  abstract list(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncGenerator<CheckpointTuple>;\n\n  abstract put(\n    config: RunnableConfig,\n    checkpoint: Checkpoint,\n    metadata: CheckpointMetadata,\n    newVersions: ChannelVersions\n  ): Promise<RunnableConfig>;\n\n  /**\n   * Store intermediate writes linked to a checkpoint.\n   */\n  abstract putWrites(\n    config: RunnableConfig,\n    writes: PendingWrite[],\n    taskId: string\n  ): Promise<void>;\n\n  /**\n   * Delete all checkpoints and writes associated with a specific thread ID.\n   * @param threadId The thread ID whose checkpoints should be deleted.\n   */\n  abstract deleteThread(threadId: string): Promise<void>;\n\n  /**\n   * Generate the next version ID for a channel.\n   *\n   * Default is to use integer versions, incrementing by 1. If you override, you can use str/int/float versions,\n   * as long as they are monotonically increasing.\n   */\n  getNextVersion(current: V | undefined): V {\n    if (typeof current === \"string\") {\n      throw new Error(\"Please override this method to use string versions.\");\n    }\n    return (\n      current !== undefined && typeof current === \"number\" ? current + 1 : 1\n    ) as V;\n  }\n}\n\nexport function compareChannelVersions(\n  a: ChannelVersion,\n  b: ChannelVersion\n): number {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return Math.sign(a - b);\n  }\n\n  return String(a).localeCompare(String(b));\n}\n\nexport function maxChannelVersion(\n  ...versions: ChannelVersion[]\n): ChannelVersion {\n  return versions.reduce((max, version, idx) => {\n    if (idx === 0) return version;\n    return compareChannelVersions(max, version) >= 0 ? max : version;\n  });\n}\n\n/**\n * Mapping from error type to error index.\n * Regular writes just map to their index in the list of writes being saved.\n * Special writes (e.g. errors) map to negative indices, to avoid those writes from\n * conflicting with regular writes.\n * Each Checkpointer implementation should use this mapping in put_writes.\n */\nexport const WRITES_IDX_MAP: Record<string, number> = {\n  [ERROR]: -1,\n  [SCHEDULED]: -2,\n  [INTERRUPT]: -3,\n  [RESUME]: -4,\n};\n\nexport function getCheckpointId(config: RunnableConfig): string {\n  return (\n    config.configurable?.checkpoint_id || config.configurable?.thread_ts || \"\"\n  );\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Embeddings } from \"@langchain/core/embeddings\";\n\n/**\n * Error thrown when an invalid namespace is provided.\n */\nexport class InvalidNamespaceError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InvalidNamespaceError\";\n  }\n}\n\n/**\n * Validates the provided namespace.\n * @param namespace The namespace to validate.\n * @throws {InvalidNamespaceError} If the namespace is invalid.\n */\nfunction validateNamespace(namespace: string[]): void {\n  if (namespace.length === 0) {\n    throw new InvalidNamespaceError(\"Namespace cannot be empty.\");\n  }\n  for (const label of namespace) {\n    if (typeof label !== \"string\") {\n      throw new InvalidNamespaceError(\n        `Invalid namespace label '${label}' found in ${namespace}. Namespace labels ` +\n          `must be strings, but got ${typeof label}.`\n      );\n    }\n    if (label.includes(\".\")) {\n      throw new InvalidNamespaceError(\n        `Invalid namespace label '${label}' found in ${namespace}. Namespace labels cannot contain periods ('.').`\n      );\n    }\n    if (label === \"\") {\n      throw new InvalidNamespaceError(\n        `Namespace labels cannot be empty strings. Got ${label} in ${namespace}`\n      );\n    }\n  }\n  if (namespace[0] === \"langgraph\") {\n    throw new InvalidNamespaceError(\n      `Root label for namespace cannot be \"langgraph\". Got: ${namespace}`\n    );\n  }\n}\n\n/**\n * Represents a stored item with metadata.\n */\nexport interface Item {\n  /**\n   * The stored data as an object. Keys are filterable.\n   */\n  value: Record<string, any>;\n  /**\n   * Unique identifier within the namespace.\n   */\n  key: string;\n  /**\n   * Hierarchical path defining the collection in which this document resides.\n   * Represented as an array of strings, allowing for nested categorization.\n   * For example: [\"documents\", \"user123\"]\n   */\n  namespace: string[];\n  /**\n   * Timestamp of item creation.\n   */\n  createdAt: Date;\n  /**\n   * Timestamp of last update.\n   */\n  updatedAt: Date;\n}\n\n/**\n * Represents a search result item with relevance score.\n * Extends the base Item interface with an optional similarity score.\n */\nexport interface SearchItem extends Item {\n  /**\n   * Relevance/similarity score if from a ranked operation.\n   * Higher scores indicate better matches.\n   *\n   * This is typically a cosine similarity score between -1 and 1,\n   * where 1 indicates identical vectors and -1 indicates opposite vectors.\n   */\n  score?: number;\n}\n\n/**\n * Operation to retrieve an item by namespace and ID.\n */\nexport interface GetOperation {\n  /**\n   * Hierarchical path for the item.\n   *\n   * @example\n   * // Get a user profile\n   * namespace: [\"users\", \"profiles\"]\n   */\n  namespace: string[];\n\n  /**\n   * Unique identifier within the namespace.\n   * Together with namespace forms the complete path to the item.\n   *\n   * @example\n   * key: \"user123\"  // For a user profile\n   * key: \"doc456\"   // For a document\n   */\n  key: string;\n}\n\n/**\n * Operation to search for items within a namespace prefix.\n */\nexport interface SearchOperation {\n  /**\n   * Hierarchical path prefix to search within.\n   * Only items under this prefix will be searched.\n   *\n   * @example\n   * // Search all user documents\n   * namespacePrefix: [\"users\", \"documents\"]\n   *\n   * // Search everything\n   * namespacePrefix: []\n   */\n  namespacePrefix: string[];\n\n  /**\n   * Key-value pairs to filter results based on exact matches or comparison operators.\n   *\n   * Supports both exact matches and operator-based comparisons:\n   * - $eq: Equal to (same as direct value comparison)\n   * - $ne: Not equal to\n   * - $gt: Greater than\n   * - $gte: Greater than or equal to\n   * - $lt: Less than\n   * - $lte: Less than or equal to\n   *\n   * @example\n   * // Exact match\n   * filter: { status: \"active\" }\n   *\n   * // With operators\n   * filter: { score: { $gt: 4.99 } }\n   *\n   * // Multiple conditions\n   * filter: {\n   *   score: { $gte: 3.0 },\n   *   color: \"red\"\n   * }\n   */\n  filter?: Record<string, any>;\n\n  /**\n   * Maximum number of items to return.\n   * @default 10\n   */\n  limit?: number;\n\n  /**\n   * Number of items to skip before returning results.\n   * Useful for pagination.\n   * @default 0\n   */\n  offset?: number;\n\n  /**\n   * Natural language search query for semantic search.\n   * When provided, results will be ranked by relevance to this query\n   * using vector similarity search.\n   *\n   * @example\n   * // Find technical documentation about APIs\n   * query: \"technical documentation about REST APIs\"\n   *\n   * // Find recent ML papers\n   * query: \"machine learning papers from 2023\"\n   */\n  query?: string;\n}\n\n/**\n * Operation to store, update, or delete an item.\n */\nexport interface PutOperation {\n  /**\n   * Hierarchical path for the item.\n   * Acts as a folder-like structure to organize items.\n   * Each element represents one level in the hierarchy.\n   *\n   * @example\n   * // Root level documents\n   * namespace: [\"documents\"]\n   *\n   * // User-specific documents\n   * namespace: [\"documents\", \"user123\"]\n   *\n   * // Nested cache structure\n   * namespace: [\"cache\", \"docs\", \"v1\"]\n   */\n  namespace: string[];\n\n  /**\n   * Unique identifier for the document within its namespace.\n   * Together with namespace forms the complete path to the item.\n   *\n   * Example: If namespace is [\"documents\", \"user123\"] and key is \"report1\",\n   * the full path would effectively be \"documents/user123/report1\"\n   */\n  key: string;\n\n  /**\n   * Data to be stored, or null to delete the item.\n   * Must be a JSON-serializable object with string keys.\n   * Setting to null signals that the item should be deleted.\n   *\n   * @example\n   * {\n   *   field1: \"string value\",\n   *   field2: 123,\n   *   nested: { can: \"contain\", any: \"serializable data\" }\n   * }\n   */\n  value: Record<string, any> | null;\n\n  /**\n   * Controls how the item's fields are indexed for search operations.\n   *\n   * - undefined: Uses store's default indexing configuration\n   * - false: Disables indexing for this item\n   * - string[]: List of field paths to index\n   *\n   * Path syntax supports:\n   * - Nested fields: \"metadata.title\"\n   * - Array access: \"chapters[*].content\" (each indexed separately)\n   * - Specific indices: \"authors[0].name\"\n   *\n   * @example\n   * // Index specific fields\n   * index: [\"metadata.title\", \"chapters[*].content\"]\n   *\n   * // Disable indexing\n   * index: false\n   */\n  index?: false | string[];\n}\n\n/**\n * Operation to list and filter namespaces in the store.\n */\nexport interface ListNamespacesOperation {\n  matchConditions?: MatchCondition[];\n  maxDepth?: number;\n  limit: number;\n  offset: number;\n}\n\nexport type NameSpacePath = (string | \"*\")[];\n\nexport type NamespaceMatchType = \"prefix\" | \"suffix\";\n\nexport interface MatchCondition {\n  matchType: NamespaceMatchType;\n  path: NameSpacePath;\n}\n\nexport type Operation =\n  | GetOperation\n  | SearchOperation\n  | PutOperation\n  | ListNamespacesOperation;\n\nexport type OperationResults<Tuple extends readonly Operation[]> = {\n  [K in keyof Tuple]: Tuple[K] extends PutOperation\n    ? void\n    : Tuple[K] extends SearchOperation\n    ? SearchItem[]\n    : Tuple[K] extends GetOperation\n    ? Item | null\n    : Tuple[K] extends ListNamespacesOperation\n    ? string[][]\n    : never;\n};\n\n/**\n * Configuration for indexing documents for semantic search in the store.\n *\n * This configures how documents are embedded and indexed for vector similarity search.\n */\nexport interface IndexConfig {\n  /**\n   * Number of dimensions in the embedding vectors.\n   *\n   * Common embedding model dimensions:\n   * - OpenAI text-embedding-3-large: 256, 1024, or 3072\n   * - OpenAI text-embedding-3-small: 512 or 1536\n   * - OpenAI text-embedding-ada-002: 1536\n   * - Cohere embed-english-v3.0: 1024\n   * - Cohere embed-english-light-v3.0: 384\n   * - Cohere embed-multilingual-v3.0: 1024\n   * - Cohere embed-multilingual-light-v3.0: 384\n   */\n  dims: number;\n\n  /**\n   * The embeddings model to use for generating vectors.\n   * This should be a LangChain Embeddings implementation.\n   */\n  embeddings: Embeddings;\n\n  /**\n   * Fields to extract text from for embedding generation.\n   *\n   * Path syntax supports:\n   * - Simple field access: \"field\"\n   * - Nested fields: \"metadata.title\"\n   * - Array indexing:\n   *   - All elements: \"chapters[*].content\"\n   *   - Specific index: \"authors[0].name\"\n   *   - Last element: \"array[-1]\"\n   *\n   * @default [\"$\"] Embeds the entire document as one vector\n   */\n  fields?: string[];\n}\n\n/**\n * Utility function to get text at a specific JSON path\n */\nexport function getTextAtPath(obj: any, path: string): string[] {\n  const parts = path.split(\".\");\n  let current: any = obj;\n\n  for (const part of parts) {\n    if (part.includes(\"[\")) {\n      const [arrayName, indexStr] = part.split(\"[\");\n      const index = indexStr.replace(\"]\", \"\");\n\n      if (!current[arrayName]) return [];\n\n      if (index === \"*\") {\n        const results: string[] = [];\n        for (const item of current[arrayName]) {\n          if (typeof item === \"string\") results.push(item);\n        }\n        return results;\n      }\n\n      const idx = parseInt(index, 10);\n      if (Number.isNaN(idx)) return [];\n      current = current[arrayName][idx];\n    } else {\n      current = current[part];\n    }\n\n    if (current === undefined) return [];\n  }\n\n  return typeof current === \"string\" ? [current] : [];\n}\n\n/**\n * Tokenizes a JSON path into parts\n */\nexport function tokenizePath(path: string): string[] {\n  return path.split(\".\");\n}\n\n/**\n * Abstract base class for persistent key-value stores.\n *\n * Stores enable persistence and memory that can be shared across threads,\n * scoped to user IDs, assistant IDs, or other arbitrary namespaces.\n *\n * Features:\n * - Hierarchical namespaces for organization\n * - Key-value storage with metadata\n * - Vector similarity search (if configured)\n * - Filtering and pagination\n */\nexport abstract class BaseStore {\n  /**\n   * Execute multiple operations in a single batch.\n   * This is more efficient than executing operations individually.\n   *\n   * @param operations Array of operations to execute\n   * @returns Promise resolving to results matching the operations\n   */\n  abstract batch<Op extends Operation[]>(\n    operations: Op\n  ): Promise<OperationResults<Op>>;\n\n  /**\n   * Retrieve a single item by its namespace and key.\n   *\n   * @param namespace Hierarchical path for the item\n   * @param key Unique identifier within the namespace\n   * @returns Promise resolving to the item or null if not found\n   */\n  async get(namespace: string[], key: string): Promise<Item | null> {\n    return (await this.batch<[GetOperation]>([{ namespace, key }]))[0];\n  }\n\n  /**\n   * Search for items within a namespace prefix.\n   * Supports both metadata filtering and vector similarity search.\n   *\n   * @param namespacePrefix Hierarchical path prefix to search within\n   * @param options Search options for filtering and pagination\n   * @returns Promise resolving to list of matching items with relevance scores\n   *\n   * @example\n   * // Search with filters\n   * await store.search([\"documents\"], {\n   *   filter: { type: \"report\", status: \"active\" },\n   *   limit: 5,\n   *   offset: 10\n   * });\n   *\n   * // Vector similarity search\n   * await store.search([\"users\", \"content\"], {\n   *   query: \"technical documentation about APIs\",\n   *   limit: 20\n   * });\n   */\n  async search(\n    namespacePrefix: string[],\n    options: {\n      filter?: Record<string, any>;\n      limit?: number;\n      offset?: number;\n      query?: string;\n    } = {}\n  ): Promise<SearchItem[]> {\n    const { filter, limit = 10, offset = 0, query } = options;\n    return (\n      await this.batch<[SearchOperation]>([\n        {\n          namespacePrefix,\n          filter,\n          limit,\n          offset,\n          query,\n        },\n      ])\n    )[0];\n  }\n\n  /**\n   * Store or update an item.\n   *\n   * @param namespace Hierarchical path for the item\n   * @param key Unique identifier within the namespace\n   * @param value Object containing the item's data\n   * @param index Optional indexing configuration\n   *\n   * @example\n   * // Simple storage\n   * await store.put([\"docs\"], \"report\", { title: \"Annual Report\" });\n   *\n   * // With specific field indexing\n   * await store.put(\n   *   [\"docs\"],\n   *   \"report\",\n   *   {\n   *     title: \"Q4 Report\",\n   *     chapters: [{ content: \"...\" }, { content: \"...\" }]\n   *   },\n   *   [\"title\", \"chapters[*].content\"]\n   * );\n   */\n  async put(\n    namespace: string[],\n    key: string,\n    value: Record<string, any>,\n    index?: false | string[]\n  ): Promise<void> {\n    validateNamespace(namespace);\n    await this.batch<[PutOperation]>([{ namespace, key, value, index }]);\n  }\n\n  /**\n   * Delete an item from the store.\n   *\n   * @param namespace Hierarchical path for the item\n   * @param key Unique identifier within the namespace\n   */\n  async delete(namespace: string[], key: string): Promise<void> {\n    await this.batch<[PutOperation]>([{ namespace, key, value: null }]);\n  }\n\n  /**\n   * List and filter namespaces in the store.\n   * Used to explore data organization and navigate the namespace hierarchy.\n   *\n   * @param options Options for listing namespaces\n   * @returns Promise resolving to list of namespace paths\n   *\n   * @example\n   * // List all namespaces under \"documents\"\n   * await store.listNamespaces({\n   *   prefix: [\"documents\"],\n   *   maxDepth: 2\n   * });\n   *\n   * // List namespaces ending with \"v1\"\n   * await store.listNamespaces({\n   *   suffix: [\"v1\"],\n   *   limit: 50\n   * });\n   */\n  async listNamespaces(\n    options: {\n      prefix?: string[];\n      suffix?: string[];\n      maxDepth?: number;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<string[][]> {\n    const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;\n\n    const matchConditions: MatchCondition[] = [];\n    if (prefix) {\n      matchConditions.push({ matchType: \"prefix\", path: prefix });\n    }\n    if (suffix) {\n      matchConditions.push({ matchType: \"suffix\", path: suffix });\n    }\n\n    return (\n      await this.batch<[ListNamespacesOperation]>([\n        {\n          matchConditions: matchConditions.length ? matchConditions : undefined,\n          maxDepth,\n          limit,\n          offset,\n        },\n      ])\n    )[0];\n  }\n\n  /**\n   * Start the store. Override if initialization is needed.\n   */\n  start(): void | Promise<void> {}\n\n  /**\n   * Stop the store. Override if cleanup is needed.\n   */\n  stop(): void | Promise<void> {}\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n  BaseStore,\n  type Item,\n  type SearchOperation,\n  type PutOperation,\n  type GetOperation,\n  type Operation,\n  OperationResults,\n} from \"./base.js\";\n\n/**\n * Extracts and returns the underlying store from an `AsyncBatchedStore`,\n * or returns the input if it is not an `AsyncBatchedStore`.\n */\nconst extractStore = (input: BaseStore | AsyncBatchedStore): BaseStore => {\n  if (\"lg_name\" in input && input.lg_name === \"AsyncBatchedStore\") {\n    // @ts-expect-error is a protected property\n    return input.store;\n  }\n  return input;\n};\n\nexport class AsyncBatchedStore extends BaseStore {\n  lg_name = \"AsyncBatchedStore\";\n\n  protected store: BaseStore;\n\n  private queue: Map<\n    number,\n    {\n      operation: Operation;\n      resolve: (value: any) => void;\n      reject: (reason?: any) => void;\n    }\n  > = new Map();\n\n  private nextKey: number = 0;\n\n  private running = false;\n\n  private processingTask: Promise<void> | null = null;\n\n  constructor(store: BaseStore) {\n    super();\n    this.store = extractStore(store);\n  }\n\n  get isRunning(): boolean {\n    return this.running;\n  }\n\n  /**\n   * @ignore\n   * Batch is not implemented here as we're only extending `BaseStore`\n   * to allow it to be passed where `BaseStore` is expected, and implement\n   * the convenience methods (get, search, put, delete).\n   */\n  async batch<Op extends Operation[]>(\n    _operations: Op\n  ): Promise<OperationResults<Op>> {\n    throw new Error(\n      \"The `batch` method is not implemented on `AsyncBatchedStore`.\" +\n        \"\\n Instead, it calls the `batch` method on the wrapped store.\" +\n        \"\\n If you are seeing this error, something is wrong.\"\n    );\n  }\n\n  async get(namespace: string[], key: string): Promise<Item | null> {\n    return this.enqueueOperation({ namespace, key } as GetOperation);\n  }\n\n  async search(\n    namespacePrefix: string[],\n    options?: {\n      filter?: Record<string, any>;\n      limit?: number;\n      offset?: number;\n      query?: string;\n    }\n  ): Promise<Item[]> {\n    const { filter, limit = 10, offset = 0, query } = options || {};\n    return this.enqueueOperation({\n      namespacePrefix,\n      filter,\n      limit,\n      offset,\n      query,\n    } as SearchOperation);\n  }\n\n  async put(\n    namespace: string[],\n    key: string,\n    value: Record<string, any>\n  ): Promise<void> {\n    return this.enqueueOperation({ namespace, key, value } as PutOperation);\n  }\n\n  async delete(namespace: string[], key: string): Promise<void> {\n    return this.enqueueOperation({\n      namespace,\n      key,\n      value: null,\n    } as PutOperation);\n  }\n\n  start(): void {\n    if (!this.running) {\n      this.running = true;\n      this.processingTask = this.processBatchQueue();\n    }\n  }\n\n  async stop(): Promise<void> {\n    this.running = false;\n    if (this.processingTask) {\n      await this.processingTask;\n    }\n  }\n\n  private enqueueOperation<T>(operation: Operation): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const key = this.nextKey;\n      this.nextKey += 1;\n      this.queue.set(key, { operation, resolve, reject });\n    });\n  }\n\n  private async processBatchQueue(): Promise<void> {\n    while (this.running) {\n      await new Promise((resolve) => {\n        setTimeout(resolve, 0);\n      });\n      if (this.queue.size === 0) continue;\n\n      const batch = new Map(this.queue);\n      this.queue.clear();\n\n      try {\n        const operations = Array.from(batch.values()).map(\n          ({ operation }) => operation\n        );\n        const results = await this.store.batch(operations);\n\n        batch.forEach(({ resolve }, key) => {\n          const index = Array.from(batch.keys()).indexOf(key);\n          resolve(results[index]);\n        });\n      } catch (e) {\n        batch.forEach(({ reject }) => {\n          reject(e);\n        });\n      }\n    }\n  }\n\n  // AsyncBatchedStore is internal and gets passed as args into traced tasks\n  // some BaseStores contain circular references so just serialize without it\n  // as this causes warnings when tracing with LangSmith.\n  toJSON() {\n    return {\n      queue: this.queue,\n      nextKey: this.nextKey,\n      running: this.running,\n      store: \"[LangGraphStore]\",\n    };\n  }\n}\n", "import { SerializerProtocol } from \"../serde/base.js\";\nimport { JsonPlusSerializer } from \"../serde/jsonplus.js\";\n\nexport type CacheNamespace = string[];\nexport type CacheFullKey = [namespace: CacheNamespace, key: string];\n\nexport abstract class BaseCache<V = unknown> {\n  serde: SerializerProtocol = new JsonPlusSerializer();\n\n  /**\n   * Initialize the cache with a serializer.\n   *\n   * @param serde - The serializer to use.\n   */\n  constructor(serde?: SerializerProtocol) {\n    this.serde = serde || this.serde;\n  }\n\n  /**\n   * Get the cached values for the given keys.\n   *\n   * @param keys - The keys to get.\n   */\n  abstract get(\n    keys: CacheFullKey[]\n  ): Promise<{ key: CacheFullKey; value: V }[]>;\n\n  /**\n   * Set the cached values for the given keys and TTLs.\n   *\n   * @param pairs - The pairs to set.\n   */\n  abstract set(\n    pairs: { key: CacheFullKey; value: V; ttl?: number }[]\n  ): Promise<void>;\n\n  /**\n   * Delete the cached values for the given namespaces.\n   * If no namespaces are provided, clear all cached values.\n   *\n   * @param namespaces - The namespaces to clear.\n   */\n  abstract clear(namespaces: CacheNamespace[]): Promise<void>;\n}\n", "import {\n  ReadonlyCheckpoint,\n  uuid6,\n  Checkpoint,\n} from \"@langchain/langgraph-checkpoint\";\nimport { EmptyChannelError } from \"../errors.js\";\n\nexport function isBaseChannel(obj: unknown): obj is BaseChannel {\n  return obj != null && (obj as BaseChannel).lg_is_channel === true;\n}\n\n/** @internal */\nexport abstract class BaseChannel<\n  ValueType = unknown,\n  UpdateType = unknown,\n  CheckpointType = unknown\n> {\n  ValueType: ValueType;\n\n  UpdateType: UpdateType;\n\n  /**\n   * The name of the channel.\n   */\n  abstract lc_graph_name: string;\n\n  /** @ignore */\n  lg_is_channel = true;\n\n  /**\n   * Return a new identical channel, optionally initialized from a checkpoint.\n   * Can be thought of as a \"restoration\" from a checkpoint which is a \"snapshot\" of the channel's state.\n   *\n   * @param {CheckpointType | undefined} checkpoint\n   * @param {CheckpointType | undefined} initialValue\n   * @returns {this}\n   */\n  abstract fromCheckpoint(checkpoint?: CheckpointType): this;\n\n  /**\n   * Update the channel's value with the given sequence of updates.\n   * The order of the updates in the sequence is arbitrary.\n   * This method is called by Pregel for all channels at the end of each step.\n   * If there are no updates, it is called with an empty sequence.\n   *\n   * Raises InvalidUpdateError if the sequence of updates is invalid.\n   * Returns True if the channel was updated, False otherwise.\n   *\n   * @throws {InvalidUpdateError} if the sequence of updates is invalid.\n   * @param {Array<UpdateType>} values\n   * @returns {void}\n   */\n  abstract update(values: UpdateType[]): boolean;\n\n  /**\n   * Return the current value of the channel.\n   *\n   * @throws {EmptyChannelError} if the channel is empty (never updated yet).\n   * @returns {ValueType}\n   */\n  abstract get(): ValueType;\n\n  /**\n   * Return a string representation of the channel's current state.\n   *\n   * @throws {EmptyChannelError} if the channel is empty (never updated yet), or doesn't support checkpoints.\n   * @returns {CheckpointType | undefined}\n   */\n  abstract checkpoint(): CheckpointType | undefined;\n\n  /**\n   * Mark the current value of the channel as consumed. By default, no-op.\n   * A channel can use this method to modify its state, preventing the value\n   * from being consumed again.\n   *\n   * Returns True if the channel was updated, False otherwise.\n   */\n  consume(): boolean {\n    return false;\n  }\n\n  /**\n   * Notify the channel that the Pregel run is finishing. By default, no-op.\n   * A channel can use this method to modify its state, preventing finish.\n   *\n   * Returns True if the channel was updated, False otherwise.\n   */\n  finish(): boolean {\n    return false;\n  }\n\n  /**\n   * Return True if the channel is available (not empty), False otherwise.\n   * Subclasses should override this method to provide a more efficient\n   * implementation than calling get() and catching EmptyChannelError.\n   */\n  isAvailable(): boolean {\n    try {\n      this.get();\n      return true;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      if (error.name === EmptyChannelError.unminifiable_name) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Compare this channel with another channel for equality.\n   * Used to determine if two channels with the same key are semantically equivalent.\n   * Subclasses should override this method to provide a meaningful comparison.\n   *\n   * @param {BaseChannel} other - The other channel to compare with.\n   * @returns {boolean} True if the channels are equal, false otherwise.\n   */\n  equals(other: BaseChannel): boolean {\n    return this === other;\n  }\n}\n\nconst IS_ONLY_BASE_CHANNEL = Symbol.for(\"LG_IS_ONLY_BASE_CHANNEL\");\nexport function getOnlyChannels(\n  channels: Record<string, BaseChannel>\n): Record<string, BaseChannel> {\n  // @ts-expect-error - we know it's a record of base channels\n  if (channels[IS_ONLY_BASE_CHANNEL] === true) return channels;\n\n  const newChannels = {} as Record<string, BaseChannel>;\n  for (const k in channels) {\n    if (!Object.prototype.hasOwnProperty.call(channels, k)) continue;\n    const value = channels[k];\n    if (isBaseChannel(value)) newChannels[k] = value;\n  }\n\n  Object.assign(newChannels, { [IS_ONLY_BASE_CHANNEL]: true });\n  return newChannels;\n}\n\nexport function emptyChannels<Cc extends Record<string, BaseChannel>>(\n  channels: Cc,\n  checkpoint: ReadonlyCheckpoint\n): Cc {\n  const filteredChannels = getOnlyChannels(channels) as Cc;\n\n  const newChannels = {} as Cc;\n  for (const k in filteredChannels) {\n    if (!Object.prototype.hasOwnProperty.call(filteredChannels, k)) continue;\n    const channelValue = checkpoint.channel_values[k];\n    newChannels[k] = filteredChannels[k].fromCheckpoint(channelValue);\n  }\n  Object.assign(newChannels, { [IS_ONLY_BASE_CHANNEL]: true });\n  return newChannels;\n}\n\nexport function createCheckpoint<ValueType>(\n  checkpoint: ReadonlyCheckpoint,\n  channels: Record<string, BaseChannel<ValueType>> | undefined,\n  step: number,\n  options?: { id?: string }\n): Checkpoint {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let values: Record<string, any>;\n  if (channels === undefined) {\n    values = checkpoint.channel_values;\n  } else {\n    values = {};\n    for (const k in channels) {\n      if (!Object.prototype.hasOwnProperty.call(channels, k)) continue;\n      try {\n        values[k] = channels[k].checkpoint();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (error: any) {\n        if (error.name === EmptyChannelError.unminifiable_name) {\n          // no-op\n        } else {\n          throw error; // Rethrow unexpected errors\n        }\n      }\n    }\n  }\n\n  return {\n    v: 4,\n    id: options?.id ?? uuid6(step),\n    ts: new Date().toISOString(),\n    channel_values: values,\n    channel_versions: checkpoint.channel_versions,\n    versions_seen: checkpoint.versions_seen,\n  };\n}\n", "import { EmptyChannelError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\nexport type BinaryOperator<ValueType, UpdateType> = (\n  a: ValueType,\n  b: UpdateType\n) => ValueType;\n\nconst isBinaryOperatorAggregate = (\n  value: BaseChannel\n): value is BinaryOperatorAggregate<unknown, unknown> => {\n  return value != null && value.lc_graph_name === \"BinaryOperatorAggregate\";\n};\n\n/**\n * Stores the result of applying a binary operator to the current value and each new value.\n */\nexport class BinaryOperatorAggregate<\n  ValueType,\n  UpdateType = ValueType\n> extends BaseChannel<ValueType, UpdateType, ValueType> {\n  lc_graph_name = \"BinaryOperatorAggregate\";\n\n  value: ValueType | undefined;\n\n  operator: BinaryOperator<ValueType, UpdateType>;\n\n  initialValueFactory?: () => ValueType;\n\n  constructor(\n    operator: BinaryOperator<ValueType, UpdateType>,\n    initialValueFactory?: () => ValueType\n  ) {\n    super();\n\n    this.operator = operator;\n    this.initialValueFactory = initialValueFactory;\n    this.value = initialValueFactory?.();\n  }\n\n  public fromCheckpoint(checkpoint?: ValueType) {\n    const empty = new BinaryOperatorAggregate(\n      this.operator,\n      this.initialValueFactory\n    );\n    if (typeof checkpoint !== \"undefined\") {\n      empty.value = checkpoint;\n    }\n    return empty as this;\n  }\n\n  public update(values: UpdateType[]): boolean {\n    let newValues = values;\n    if (!newValues.length) return false;\n\n    if (this.value === undefined) {\n      [this.value as UpdateType] = newValues;\n      newValues = newValues.slice(1);\n    }\n\n    for (const value of newValues) {\n      if (this.value !== undefined) {\n        this.value = this.operator(this.value, value);\n      }\n    }\n    return true;\n  }\n\n  public get(): ValueType {\n    if (this.value === undefined) {\n      throw new EmptyChannelError();\n    }\n    return this.value;\n  }\n\n  public checkpoint(): ValueType {\n    if (this.value === undefined) {\n      throw new EmptyChannelError();\n    }\n    return this.value;\n  }\n\n  isAvailable(): boolean {\n    return this.value !== undefined;\n  }\n\n  /**\n   * Compare this channel with another channel for equality.\n   * Two BinaryOperatorAggregate channels are equal if they have the same operator function.\n   * This follows the Python implementation which compares operator references.\n   */\n  equals(other: BaseChannel): boolean {\n    if (this === other) return true;\n    if (!isBinaryOperatorAggregate(other)) return false;\n    return this.operator === other.operator;\n  }\n}\n", "import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n/**\n * Stores the last value received, can receive at most one value per step.\n *\n * Since `update` is only called once per step and value can only be of length 1,\n * LastValue always stores the last value of a single node. If multiple nodes attempt to\n * write to this channel in a single step, an error will be thrown.\n * @internal\n */\nexport class LastValue<Value> extends BaseChannel<Value, Value, Value> {\n  lc_graph_name = \"LastValue\";\n\n  // value is an array so we don't misinterpret an update to undefined as no write\n  value: [Value] | [] = [];\n\n  constructor(protected initialValueFactory?: () => Value) {\n    super();\n    if (initialValueFactory) {\n      this.value = [initialValueFactory()];\n    }\n  }\n\n  fromCheckpoint(checkpoint?: Value) {\n    const empty = new LastValue<Value>(this.initialValueFactory);\n    if (typeof checkpoint !== \"undefined\") {\n      empty.value = [checkpoint];\n    }\n\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      return false;\n    }\n    if (values.length !== 1) {\n      throw new InvalidUpdateError(\n        \"LastValue can only receive one value per step.\",\n        { lc_error_code: \"INVALID_CONCURRENT_GRAPH_UPDATE\" }\n      );\n    }\n\n    // eslint-disable-next-line prefer-destructuring\n    this.value = [values[values.length - 1]];\n    return true;\n  }\n\n  get(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  checkpoint(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  isAvailable(): boolean {\n    return this.value.length !== 0;\n  }\n}\n\n/**\n * Stores the last value received, but only made available after finish().\n * Once made available, clears the value.\n */\nexport class LastValueAfterFinish<Value> extends BaseChannel<\n  Value,\n  Value,\n  [Value, boolean]\n> {\n  lc_graph_name = \"LastValueAfterFinish\";\n\n  // value is an array so we don't misinterpret an update to undefined as no write\n  value: [Value] | [] = [];\n\n  finished: boolean = false;\n\n  fromCheckpoint(checkpoint?: [Value, boolean]) {\n    const empty = new LastValueAfterFinish<Value>();\n    if (typeof checkpoint !== \"undefined\") {\n      const [value, finished] = checkpoint;\n      empty.value = [value];\n      empty.finished = finished;\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      return false;\n    }\n\n    this.finished = false;\n    // eslint-disable-next-line prefer-destructuring\n    this.value = [values[values.length - 1]];\n    return true;\n  }\n\n  get(): Value {\n    if (this.value.length === 0 || !this.finished) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  checkpoint(): [Value, boolean] | undefined {\n    if (this.value.length === 0) return undefined;\n    return [this.value[0], this.finished];\n  }\n\n  consume(): boolean {\n    if (this.finished) {\n      this.finished = false;\n      this.value = [];\n      return true;\n    }\n    return false;\n  }\n\n  finish(): boolean {\n    if (!this.finished && this.value.length > 0) {\n      this.finished = true;\n      return true;\n    }\n    return false;\n  }\n\n  isAvailable(): boolean {\n    return this.value.length !== 0 && this.finished;\n  }\n}\n", "import { RunnableLike } from \"../pregel/runnable_types.js\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport { BinaryOperator, BinaryOperatorAggregate } from \"../channels/binop.js\";\nimport { LastValue } from \"../channels/last_value.js\";\n\nexport type SingleReducer<ValueType, UpdateType = ValueType> =\n  | {\n      reducer: BinaryOperator<ValueType, UpdateType>;\n      default?: () => ValueType;\n    }\n  | {\n      /**\n       * @deprecated Use `reducer` instead\n       */\n      value: BinaryOperator<ValueType, UpdateType>;\n      default?: () => ValueType;\n    }\n  | null;\n\nexport interface StateDefinition {\n  [key: string]: BaseChannel | (() => BaseChannel);\n}\n\ntype ExtractValueType<C> = C extends BaseChannel\n  ? C[\"ValueType\"]\n  : C extends () => BaseChannel\n  ? ReturnType<C>[\"ValueType\"]\n  : never;\n\ntype ExtractUpdateType<C> = C extends BaseChannel\n  ? C[\"UpdateType\"]\n  : C extends () => BaseChannel\n  ? ReturnType<C>[\"UpdateType\"]\n  : never;\n\nexport type StateType<SD extends StateDefinition> = {\n  [key in keyof SD]: ExtractValueType<SD[key]>;\n};\n\nexport type UpdateType<SD extends StateDefinition> = {\n  [key in keyof SD]?: ExtractUpdateType<SD[key]>;\n};\n\nexport type NodeType<SD extends StateDefinition> = RunnableLike<\n  StateType<SD>,\n  UpdateType<SD> | Partial<StateType<SD>>\n>;\n\n/** @ignore */\nexport interface AnnotationFunction {\n  <ValueType>(): LastValue<ValueType>;\n  <ValueType, UpdateType = ValueType>(\n    annotation: SingleReducer<ValueType, UpdateType>\n  ): BinaryOperatorAggregate<ValueType, UpdateType>;\n  Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;\n}\n\n/**\n * Should not be instantiated directly. See {@link Annotation}.\n */\nexport class AnnotationRoot<SD extends StateDefinition> {\n  lc_graph_name = \"AnnotationRoot\";\n\n  declare State: StateType<SD>;\n\n  declare Update: UpdateType<SD>;\n\n  declare Node: NodeType<SD>;\n\n  spec: SD;\n\n  constructor(s: SD) {\n    this.spec = s;\n  }\n\n  static isInstance(value: unknown): value is AnnotationRoot<StateDefinition> {\n    return (\n      typeof value === \"object\" &&\n      value !== null &&\n      \"lc_graph_name\" in value &&\n      (value as { lc_graph_name: unknown }).lc_graph_name === \"AnnotationRoot\"\n    );\n  }\n}\n\n/**\n * Helper that instantiates channels within a StateGraph state.\n *\n * Can be used as a field in an {@link Annotation.Root} wrapper in one of two ways:\n * 1. **Directly**: Creates a channel that stores the most recent value returned from a node.\n * 2. **With a reducer**: Creates a channel that applies the reducer on a node's return value.\n *\n * @example\n * ```ts\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single string key named \"currentOutput\"\n * const SimpleAnnotation = Annotation.Root({\n *   currentOutput: Annotation<string>,\n * });\n *\n * const graphBuilder = new StateGraph(SimpleAnnotation);\n *\n * // A node in the graph that returns an object with a \"currentOutput\" key\n * // replaces the value in the state. You can get the state type as shown below:\n * const myNode = (state: typeof SimpleAnnotation.State) => {\n *   return {\n *     currentOutput: \"some_new_value\",\n *   };\n * }\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n *\n * @example\n * ```ts\n * import { type BaseMessage, AIMessage } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const AnnotationWithReducer = Annotation.Root({\n *   messages: Annotation<BaseMessage[]>({\n *     // Different types are allowed for updates\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(AnnotationWithReducer);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof AnnotationWithReducer.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n * @namespace\n * @property Root\n * Helper function that instantiates a StateGraph state. See {@link Annotation} for usage.\n */\nexport const Annotation: AnnotationFunction = function <\n  ValueType,\n  UpdateType = ValueType\n>(\n  annotation?: SingleReducer<ValueType, UpdateType>\n): BaseChannel<ValueType, UpdateType> {\n  if (annotation) {\n    return getChannel<ValueType, UpdateType>(annotation);\n  } else {\n    // @ts-expect-error - Annotation without reducer\n    return new LastValue<ValueType>();\n  }\n} as AnnotationFunction;\n\nAnnotation.Root = <S extends StateDefinition>(sd: S) => new AnnotationRoot(sd);\n\nexport function getChannel<V, U = V>(\n  reducer: SingleReducer<V, U>\n): BaseChannel<V, U> {\n  if (\n    typeof reducer === \"object\" &&\n    reducer &&\n    \"reducer\" in reducer &&\n    reducer.reducer\n  ) {\n    return new BinaryOperatorAggregate(reducer.reducer, reducer.default);\n  }\n  if (\n    typeof reducer === \"object\" &&\n    reducer &&\n    \"value\" in reducer &&\n    reducer.value\n  ) {\n    return new BinaryOperatorAggregate(reducer.value, reducer.default);\n  }\n  // @ts-expect-error - Annotation without reducer\n  return new LastValue<V>();\n}\n", "import { PendingWrite } from \"@langchain/langgraph-checkpoint\";\n\n/** Special reserved node name denoting the start of a graph. */\nexport const START = \"__start__\";\n/** Special reserved node name denoting the end of a graph. */\nexport const END = \"__end__\";\nexport const INPUT = \"__input__\";\nexport const COPY = \"__copy__\";\nexport const ERROR = \"__error__\";\n\n/** Special reserved cache namespaces */\nexport const CACHE_NS_WRITES = \"__pregel_ns_writes\";\n\nexport const CONFIG_KEY_SEND = \"__pregel_send\";\n/** config key containing function used to call a node (push task) */\nexport const CONFIG_KEY_CALL = \"__pregel_call\";\nexport const CONFIG_KEY_READ = \"__pregel_read\";\nexport const CONFIG_KEY_CHECKPOINTER = \"__pregel_checkpointer\";\nexport const CONFIG_KEY_RESUMING = \"__pregel_resuming\";\nexport const CONFIG_KEY_TASK_ID = \"__pregel_task_id\";\nexport const CONFIG_KEY_STREAM = \"__pregel_stream\";\nexport const CONFIG_KEY_RESUME_VALUE = \"__pregel_resume_value\";\nexport const CONFIG_KEY_RESUME_MAP = \"__pregel_resume_map\";\nexport const CONFIG_KEY_SCRATCHPAD = \"__pregel_scratchpad\";\n/** config key containing state from previous invocation of graph for the given thread */\nexport const CONFIG_KEY_PREVIOUS_STATE = \"__pregel_previous\";\nexport const CONFIG_KEY_DURABILITY = \"__pregel_durability\";\nexport const CONFIG_KEY_CHECKPOINT_ID = \"checkpoint_id\";\nexport const CONFIG_KEY_CHECKPOINT_NS = \"checkpoint_ns\";\n\nexport const CONFIG_KEY_NODE_FINISHED = \"__pregel_node_finished\";\n\n// this one is part of public API\nexport const CONFIG_KEY_CHECKPOINT_MAP = \"checkpoint_map\";\n\nexport const CONFIG_KEY_ABORT_SIGNALS = \"__pregel_abort_signals\";\n\n/** Special channel reserved for graph interrupts */\nexport const INTERRUPT = \"__interrupt__\";\n/** Special channel reserved for graph resume */\nexport const RESUME = \"__resume__\";\n/** Special channel reserved for cases when a task exits without any writes */\nexport const NO_WRITES = \"__no_writes__\";\n/** Special channel reserved for graph return */\nexport const RETURN = \"__return__\";\n/** Special channel reserved for graph previous state */\nexport const PREVIOUS = \"__previous__\";\nexport const RUNTIME_PLACEHOLDER = \"__pregel_runtime_placeholder__\";\nexport const RECURSION_LIMIT_DEFAULT = 25;\n\nexport const TAG_HIDDEN = \"langsmith:hidden\";\nexport const TAG_NOSTREAM = \"langsmith:nostream\";\nexport const SELF = \"__self__\";\n\nexport const TASKS = \"__pregel_tasks\";\nexport const PUSH = \"__pregel_push\";\nexport const PULL = \"__pregel_pull\";\n\nexport const TASK_NAMESPACE = \"6ba7b831-9dad-11d1-80b4-00c04fd430c8\";\nexport const NULL_TASK_ID = \"00000000-0000-0000-0000-000000000000\";\n\nexport const RESERVED = [\n  TAG_HIDDEN,\n  INPUT,\n  INTERRUPT,\n  RESUME,\n  ERROR,\n  NO_WRITES,\n\n  // reserved config.configurable keys\n  CONFIG_KEY_SEND,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_DURABILITY,\n  CONFIG_KEY_STREAM,\n  CONFIG_KEY_RESUMING,\n  CONFIG_KEY_TASK_ID,\n  CONFIG_KEY_CALL,\n  CONFIG_KEY_RESUME_VALUE,\n  CONFIG_KEY_SCRATCHPAD,\n  CONFIG_KEY_PREVIOUS_STATE,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CONFIG_KEY_CHECKPOINT_NS,\n  CONFIG_KEY_CHECKPOINT_ID,\n];\n\nexport const CHECKPOINT_NAMESPACE_SEPARATOR = \"|\";\nexport const CHECKPOINT_NAMESPACE_END = \":\";\n\n/** @internal */\nconst COMMAND_SYMBOL = Symbol.for(\"langgraph.command\");\n\n/**\n * Instance of a {@link Command} class.\n *\n * This is used to avoid IntelliSense suggesting public fields\n * of {@link Command} class when a plain object is expected.\n *\n * @see {@link Command}\n * @internal\n */\nexport class CommandInstance<\n  Resume = unknown,\n  Update = Record<string, unknown>,\n  Nodes extends string = string\n> {\n  [COMMAND_SYMBOL]: CommandParams<Resume, Update, Nodes>;\n\n  constructor(args: CommandParams<Resume, Update, Nodes>) {\n    this[COMMAND_SYMBOL] = args;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface SendInterface<Node extends string = string, Args = any> {\n  node: Node;\n  args: Args;\n}\n\nexport function _isSendInterface(x: unknown): x is SendInterface {\n  const operation = x as SendInterface;\n  return (\n    operation !== null &&\n    operation !== undefined &&\n    typeof operation.node === \"string\" &&\n    operation.args !== undefined\n  );\n}\n\n/**\n *\n * A message or packet to send to a specific node in the graph.\n *\n * The `Send` class is used within a `StateGraph`'s conditional edges to\n * dynamically invoke a node with a custom state at the next step.\n *\n * Importantly, the sent state can differ from the core graph's state,\n * allowing for flexible and dynamic workflow management.\n *\n * One such example is a \"map-reduce\" workflow where your graph invokes\n * the same node multiple times in parallel with different states,\n * before aggregating the results back into the main graph's state.\n *\n * @example\n * ```typescript\n * import { Annotation, Send, StateGraph } from \"@langchain/langgraph\";\n *\n * const ChainState = Annotation.Root({\n *   subjects: Annotation<string[]>,\n *   jokes: Annotation<string[]>({\n *     reducer: (a, b) => a.concat(b),\n *   }),\n * });\n *\n * const continueToJokes = async (state: typeof ChainState.State) => {\n *   return state.subjects.map((subject) => {\n *     return new Send(\"generate_joke\", { subjects: [subject] });\n *   });\n * };\n *\n * const graph = new StateGraph(ChainState)\n *   .addNode(\"generate_joke\", (state) => ({\n *     jokes: [`Joke about ${state.subjects}`],\n *   }))\n *   .addConditionalEdges(\"__start__\", continueToJokes)\n *   .addEdge(\"generate_joke\", \"__end__\")\n *   .compile();\n *\n * const res = await graph.invoke({ subjects: [\"cats\", \"dogs\"] });\n * console.log(res);\n *\n * // Invoking with two subjects results in a generated joke for each\n * // { subjects: [\"cats\", \"dogs\"], jokes: [`Joke about cats`, `Joke about dogs`] }\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class Send<Node extends string = string, Args = any>\n  implements SendInterface<Node, Args>\n{\n  lg_name = \"Send\";\n\n  public node: Node;\n\n  public args: Args;\n\n  constructor(node: Node, args: Args) {\n    this.node = node;\n    this.args = _deserializeCommandSendObjectGraph(args) as Args;\n  }\n\n  toJSON() {\n    return { lg_name: this.lg_name, node: this.node, args: this.args };\n  }\n}\n\nexport function _isSend(x: unknown): x is Send {\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  return x instanceof Send;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Interrupt<Value = any> = {\n  id?: string;\n  value?: Value;\n};\n\n/**\n * Checks if the given graph invoke / stream chunk contains interrupt.\n *\n * @example\n * ```ts\n * import { INTERRUPT, isInterrupted } from \"@langchain/langgraph\";\n *\n * const values = await graph.invoke({ foo: \"bar\" });\n * if (isInterrupted<string>(values)) {\n *   const interrupt = values[INTERRUPT][0].value;\n * }\n * ```\n *\n * @param values - The values to check.\n * @returns `true` if the values contain an interrupt, `false` otherwise.\n */\nexport function isInterrupted<Value = unknown>(\n  values: unknown\n): values is { [INTERRUPT]: Interrupt<Value>[] } {\n  if (!values || typeof values !== \"object\") return false;\n  if (!(INTERRUPT in values)) return false;\n  return Array.isArray(values[INTERRUPT]);\n}\n\nexport type CommandParams<\n  Resume = unknown,\n  Update = Record<string, unknown>,\n  Nodes extends string = string\n> = {\n  /**\n   * A discriminator field used to identify the type of object. Must be populated when serializing.\n   *\n   * Optional because it's not required to specify this when directly constructing a {@link Command}\n   * object.\n   */\n  lg_name?: \"Command\";\n\n  /**\n   * Value to resume execution with. To be used together with {@link interrupt}.\n   */\n  resume?: Resume;\n  /**\n   * Graph to send the command to. Supported values are:\n   *   - None: the current graph (default)\n   *   - The specific name of the graph to send the command to\n   *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)\n   */\n  graph?: string;\n\n  /**\n   * Update to apply to the graph's state.\n   */\n  update?: Update | [string, unknown][];\n\n  /**\n   * Can be one of the following:\n   *   - name of the node to navigate to next (any node that belongs to the specified `graph`)\n   *   - sequence of node names to navigate to next\n   *   - `Send` object (to execute a node with the input provided)\n   *   - sequence of `Send` objects\n   */\n  goto?:\n    | Nodes\n    | SendInterface<Nodes> // eslint-disable-line @typescript-eslint/no-explicit-any\n    | (Nodes | SendInterface<Nodes>)[]; // eslint-disable-line @typescript-eslint/no-explicit-any\n};\n\n/**\n * One or more commands to update the graph's state and send messages to nodes.\n * Can be used to combine routing logic with state updates in lieu of conditional edges\n *\n * @example\n * ```ts\n * import { Annotation, Command } from \"@langchain/langgraph\";\n *\n * // Define graph state\n * const StateAnnotation = Annotation.Root({\n *   foo: Annotation<string>,\n * });\n *\n * // Define the nodes\n * const nodeA = async (_state: typeof StateAnnotation.State) => {\n *   console.log(\"Called A\");\n *   // this is a replacement for a real conditional edge function\n *   const goto = Math.random() > .5 ? \"nodeB\" : \"nodeC\";\n *   // note how Command allows you to BOTH update the graph state AND route to the next node\n *   return new Command({\n *     // this is the state update\n *     update: {\n *       foo: \"a\",\n *     },\n *     // this is a replacement for an edge\n *     goto,\n *   });\n * };\n *\n * // Nodes B and C are unchanged\n * const nodeB = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called B\");\n *   return {\n *     foo: state.foo + \"|b\",\n *   };\n * }\n *\n * const nodeC = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called C\");\n *   return {\n *     foo: state.foo + \"|c\",\n *   };\n * }\n * \n * import { StateGraph } from \"@langchain/langgraph\";\n\n * // NOTE: there are no edges between nodes A, B and C!\n * const graph = new StateGraph(StateAnnotation)\n *   .addNode(\"nodeA\", nodeA, {\n *     ends: [\"nodeB\", \"nodeC\"],\n *   })\n *   .addNode(\"nodeB\", nodeB)\n *   .addNode(\"nodeC\", nodeC)\n *   .addEdge(\"__start__\", \"nodeA\")\n *   .compile();\n * \n * await graph.invoke({ foo: \"\" });\n *\n * // Randomly oscillates between\n * // { foo: 'a|c' } and { foo: 'a|b' }\n * ```\n */\nexport class Command<\n  Resume = unknown,\n  Update extends Record<string, unknown> = Record<string, unknown>,\n  Nodes extends string = string\n> extends CommandInstance<Resume, Update, Nodes> {\n  readonly lg_name = \"Command\";\n\n  lc_direct_tool_output = true;\n\n  /**\n   * Graph to send the command to. Supported values are:\n   *   - None: the current graph (default)\n   *   - The specific name of the graph to send the command to\n   *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)\n   */\n  graph?: string;\n\n  /**\n   * Update to apply to the graph's state as a result of executing the node that is returning the command.\n   * Written to the state as if the node had simply returned this value instead of the Command object.\n   */\n  update?: Update | [string, unknown][];\n\n  /**\n   * Value to resume execution with. To be used together with {@link interrupt}.\n   */\n  resume?: Resume;\n\n  /**\n   * Can be one of the following:\n   *   - name of the node to navigate to next (any node that belongs to the specified `graph`)\n   *   - sequence of node names to navigate to next\n   *   - {@link Send} object (to execute a node with the exact input provided in the {@link Send} object)\n   *   - sequence of {@link Send} objects\n   */\n  goto?: Nodes | Send<Nodes> | (Nodes | Send<Nodes>)[] = [];\n\n  static PARENT = \"__parent__\";\n\n  constructor(args: Omit<CommandParams<Resume, Update, Nodes>, \"lg_name\">) {\n    super(args);\n    this.resume = args.resume;\n    this.graph = args.graph;\n    this.update = args.update;\n    if (args.goto) {\n      type ValidArg = Nodes | Send<Nodes, Update>;\n\n      this.goto = Array.isArray(args.goto)\n        ? (_deserializeCommandSendObjectGraph(args.goto) as ValidArg[])\n        : [_deserializeCommandSendObjectGraph(args.goto) as ValidArg];\n    }\n  }\n\n  /**\n   * Convert the update field to a list of {@link PendingWrite} tuples\n   * @returns List of {@link PendingWrite} tuples of the form `[channelKey, value]`.\n   * @internal\n   */\n  _updateAsTuples(): PendingWrite[] {\n    if (\n      this.update &&\n      typeof this.update === \"object\" &&\n      !Array.isArray(this.update)\n    ) {\n      return Object.entries(this.update);\n    } else if (\n      Array.isArray(this.update) &&\n      this.update.every(\n        (t): t is [string, unknown] =>\n          Array.isArray(t) && t.length === 2 && typeof t[0] === \"string\"\n      )\n    ) {\n      return this.update;\n    } else {\n      return [[\"__root__\", this.update]];\n    }\n  }\n\n  toJSON() {\n    let serializedGoto;\n    if (typeof this.goto === \"string\") {\n      serializedGoto = this.goto;\n    } else if (_isSend(this.goto)) {\n      serializedGoto = this.goto.toJSON();\n    } else {\n      serializedGoto = this.goto?.map((innerGoto) => {\n        if (typeof innerGoto === \"string\") {\n          return innerGoto;\n        } else {\n          return innerGoto.toJSON();\n        }\n      });\n    }\n    return {\n      lg_name: this.lg_name,\n      update: this.update,\n      resume: this.resume,\n      goto: serializedGoto,\n    };\n  }\n}\n\n/**\n * A type guard to check if the given value is a {@link Command}.\n *\n * Useful for type narrowing when working with the {@link Command} object.\n *\n * @param x - The value to check.\n * @returns `true` if the value is a {@link Command}, `false` otherwise.\n */\nexport function isCommand(x: unknown): x is Command {\n  if (typeof x !== \"object\") {\n    return false;\n  }\n\n  if (x === null || x === undefined) {\n    return false;\n  }\n\n  if (\"lg_name\" in x && x.lg_name === \"Command\") {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Reconstructs Command and Send objects from a deeply nested tree of anonymous objects\n * matching their interfaces.\n *\n * This is only exported for testing purposes. It is NOT intended to be used outside of\n * the Command and Send classes.\n *\n * @internal\n *\n * @param x - The command send tree to convert.\n * @param seen - A map of seen objects to avoid infinite loops.\n * @returns The converted command send tree.\n */\nexport function _deserializeCommandSendObjectGraph(\n  x: unknown,\n  seen: Map<object, unknown> = new Map()\n): unknown {\n  if (x !== undefined && x !== null && typeof x === \"object\") {\n    // If we've already processed this object, return the transformed version\n    if (seen.has(x)) {\n      return seen.get(x);\n    }\n\n    let result: unknown;\n\n    if (Array.isArray(x)) {\n      // Create the array first, then populate it\n      result = [];\n      // Add to seen map before processing elements to handle self-references\n      seen.set(x, result);\n\n      // Now populate the array\n      x.forEach((item, index) => {\n        (result as unknown[])[index] = _deserializeCommandSendObjectGraph(\n          item,\n          seen\n        );\n      });\n      // eslint-disable-next-line no-instanceof/no-instanceof\n    } else if (isCommand(x) && !(x instanceof Command)) {\n      result = new Command(x);\n      seen.set(x, result);\n      // eslint-disable-next-line no-instanceof/no-instanceof\n    } else if (_isSendInterface(x) && !(x instanceof Send)) {\n      result = new Send(x.node, x.args);\n      seen.set(x, result);\n    } else if (isCommand(x) || _isSend(x)) {\n      result = x;\n      seen.set(x, result);\n    } else if (\"lc_serializable\" in x && x.lc_serializable) {\n      result = x;\n      seen.set(x, result);\n    } else {\n      // Create empty object first\n      result = {};\n      // Add to seen map before processing properties to handle self-references\n      seen.set(x, result);\n\n      // Now populate the object\n      for (const [key, value] of Object.entries(x)) {\n        (result as Record<string, unknown>)[key] =\n          _deserializeCommandSendObjectGraph(value, seen);\n      }\n    }\n\n    return result;\n  }\n  return x;\n}\n", "import { RunnableConfig } from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { BaseStore } from \"@langchain/langgraph-checkpoint\";\nimport { LangGraphRunnableConfig } from \"../runnable_types.js\";\nimport {\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  CONFIG_KEY_SCRATCHPAD,\n} from \"../../constants.js\";\n\nconst COPIABLE_KEYS = [\"tags\", \"metadata\", \"callbacks\", \"configurable\"];\n\nconst CONFIG_KEYS = [\n  \"tags\",\n  \"metadata\",\n  \"callbacks\",\n  \"runName\",\n  \"maxConcurrency\",\n  \"recursionLimit\",\n  \"configurable\",\n  \"runId\",\n  \"outputKeys\",\n  \"streamMode\",\n  \"store\",\n  \"writer\",\n  \"interrupt\",\n  \"context\",\n  \"interruptBefore\",\n  \"interruptAfter\",\n  \"checkpointDuring\",\n  \"durability\",\n  \"signal\",\n];\n\nconst DEFAULT_RECURSION_LIMIT = 25;\n\nexport function ensureLangGraphConfig(\n  ...configs: (LangGraphRunnableConfig | undefined)[]\n): RunnableConfig {\n  const empty: LangGraphRunnableConfig = {\n    tags: [],\n    metadata: {},\n    callbacks: undefined,\n    recursionLimit: DEFAULT_RECURSION_LIMIT,\n    configurable: {},\n  };\n\n  const implicitConfig: RunnableConfig =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  if (implicitConfig !== undefined) {\n    for (const [k, v] of Object.entries(implicitConfig)) {\n      if (v !== undefined) {\n        if (COPIABLE_KEYS.includes(k)) {\n          let copiedValue;\n          if (Array.isArray(v)) {\n            copiedValue = [...v];\n          } else if (typeof v === \"object\") {\n            if (\n              k === \"callbacks\" &&\n              \"copy\" in v &&\n              typeof v.copy === \"function\"\n            ) {\n              copiedValue = v.copy();\n            } else {\n              copiedValue = { ...v };\n            }\n          } else {\n            copiedValue = v;\n          }\n          empty[k as keyof RunnableConfig] = copiedValue;\n        } else {\n          empty[k as keyof RunnableConfig] = v;\n        }\n      }\n    }\n  }\n\n  for (const config of configs) {\n    if (config === undefined) {\n      continue;\n    }\n\n    for (const [k, v] of Object.entries(config)) {\n      if (v !== undefined && CONFIG_KEYS.includes(k)) {\n        empty[k as keyof LangGraphRunnableConfig] = v;\n      }\n    }\n  }\n\n  for (const [key, value] of Object.entries(empty.configurable!)) {\n    empty.metadata = empty.metadata ?? {};\n    if (\n      !key.startsWith(\"__\") &&\n      (typeof value === \"string\" ||\n        typeof value === \"number\" ||\n        typeof value === \"boolean\") &&\n      !(key in empty.metadata!)\n    ) {\n      empty.metadata[key] = value;\n    }\n  }\n\n  return empty;\n}\n\n/**\n * A helper utility function that returns the {@link BaseStore} that was set when the graph was initialized\n *\n * @returns a reference to the {@link BaseStore} that was set when the graph was initialized\n */\nexport function getStore(\n  config?: LangGraphRunnableConfig\n): BaseStore | undefined {\n  const runConfig: LangGraphRunnableConfig =\n    config ?? AsyncLocalStorageProviderSingleton.getRunnableConfig();\n\n  if (runConfig === undefined) {\n    throw new Error(\n      [\n        \"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\",\n        \"If you're running `getStore` in such environment, pass the `config` from the node function directly.\",\n      ].join(\"\\n\")\n    );\n  }\n\n  return runConfig?.store;\n}\n\n/**\n * A helper utility function that returns the {@link LangGraphRunnableConfig#writer} if \"custom\" stream mode is enabled, otherwise undefined.\n *\n * @returns a reference to the {@link LangGraphRunnableConfig#writer} if \"custom\" stream mode is enabled, otherwise undefined\n */\nexport function getWriter(\n  config?: LangGraphRunnableConfig\n): ((chunk: unknown) => void) | undefined {\n  const runConfig: LangGraphRunnableConfig =\n    config ?? AsyncLocalStorageProviderSingleton.getRunnableConfig();\n\n  if (runConfig === undefined) {\n    throw new Error(\n      [\n        \"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\",\n        \"If you're running `getWriter` in such environment, pass the `config` from the node function directly.\",\n      ].join(\"\\n\")\n    );\n  }\n\n  return runConfig?.writer || runConfig?.configurable?.writer;\n}\n\n/**\n * A helper utility function that returns the {@link LangGraphRunnableConfig} that was set when the graph was initialized.\n *\n * Note: This only works when running in an environment that supports node:async_hooks and AsyncLocalStorage. If you're running this in a\n * web environment, access the LangGraphRunnableConfig from the node function directly.\n *\n * @returns the {@link LangGraphRunnableConfig} that was set when the graph was initialized\n */\nexport function getConfig(): LangGraphRunnableConfig {\n  return AsyncLocalStorageProviderSingleton.getRunnableConfig();\n}\n\n/**\n * A helper utility function that returns the input for the currently executing task\n *\n * @returns the input for the currently executing task\n */\nexport function getCurrentTaskInput<T = unknown>(\n  config?: LangGraphRunnableConfig\n): T {\n  const runConfig: LangGraphRunnableConfig =\n    config ?? AsyncLocalStorageProviderSingleton.getRunnableConfig();\n\n  if (runConfig === undefined) {\n    throw new Error(\n      [\n        \"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\",\n        \"If you're running `getCurrentTaskInput` in such environment, pass the `config` from the node function directly.\",\n      ].join(\"\\n\")\n    );\n  }\n\n  if (\n    runConfig.configurable?.[CONFIG_KEY_SCRATCHPAD]?.currentTaskInput ===\n    undefined\n  ) {\n    throw new Error(\"BUG: internal scratchpad not initialized.\");\n  }\n\n  return runConfig!.configurable![CONFIG_KEY_SCRATCHPAD]!.currentTaskInput as T;\n}\n\nexport function recastCheckpointNamespace(namespace: string): string {\n  return namespace\n    .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n    .filter((part) => !part.match(/^\\d+$/))\n    .map((part) => part.split(CHECKPOINT_NAMESPACE_END)[0])\n    .join(CHECKPOINT_NAMESPACE_SEPARATOR);\n}\n\nexport function getParentCheckpointNamespace(namespace: string): string {\n  const parts = namespace.split(CHECKPOINT_NAMESPACE_SEPARATOR);\n  while (parts.length > 1 && parts[parts.length - 1].match(/^\\d+$/)) {\n    parts.pop();\n  }\n  return parts.slice(0, -1).join(CHECKPOINT_NAMESPACE_SEPARATOR);\n}\n", "/* Converted from https://github.com/i404788/xxh3-ts\n\nBSD 2-Clause License\n\nCopyright (c) 2019, i404788\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nconst n = (n: number | string) => BigInt(n);\nconst view = (data: Uint8Array | DataView, offset: number = 0) =>\n  new DataView(data.buffer, data.byteOffset + offset, data.byteLength - offset);\n\nconst PRIME32_1 = n(\"0x9E3779B1\"); // 0b10011110001101110111100110110001\nconst PRIME32_2 = n(\"0x85EBCA77\"); // 0b10000101111010111100101001110111\nconst PRIME32_3 = n(\"0xC2B2AE3D\"); // 0b11000010101100101010111000111101\nconst PRIME64_1 = n(\"0x9E3779B185EBCA87\"); // 0b1001111000110111011110011011000110000101111010111100101010000111\nconst PRIME64_2 = n(\"0xC2B2AE3D27D4EB4F\"); // 0b1100001010110010101011100011110100100111110101001110101101001111\nconst PRIME64_3 = n(\"0x165667B19E3779F9\"); // 0b0001011001010110011001111011000110011110001101110111100111111001\nconst PRIME64_4 = n(\"0x85EBCA77C2B2AE63\"); // 0b1000010111101011110010100111011111000010101100101010111001100011\nconst PRIME64_5 = n(\"0x27D4EB2F165667C5\"); // 0b0010011111010100111010110010111100010110010101100110011111000101\nconst PRIME_MX1 = n(\"0x165667919E3779F9\"); // 0b0001011001010110011001111001000110011110001101110111100111111001\nconst PRIME_MX2 = n(\"0x9FB21C651E98DF25\"); // 0b1001111110110010000111000110010100011110100110001101111100100101\n\nconst hexToUint8Array = (hex: string) => {\n  const strLen = hex.length;\n  if (strLen % 2 !== 0) {\n    throw new Error(\"String should have an even number of characters\");\n  }\n\n  const maxLength = strLen / 2;\n  const bytes = new Uint8Array(maxLength);\n\n  let read = 0;\n  let write = 0;\n  while (write < maxLength) {\n    const slice = hex.slice(read, (read += 2));\n    bytes[write] = Number.parseInt(slice, 16);\n    write += 1;\n  }\n\n  return view(bytes);\n};\n\nconst kkey = hexToUint8Array(\n  \"b8fe6c3923a44bbe7c01812cf721ad1cded46de9839097db7240a4a4b7b3671fcb79e64eccc0e578825ad07dccff7221b8084674f743248ee03590e6813a264c3c2852bb91c300cb88d0658b1b532ea371644897a20df94e3819ef46a9deacd8a8fa763fe39c343ff9dcbbc7c70b4f1d8a51e04bcdb45931c89f7ec9d9787364eac5ac8334d3ebc3c581a0fffa1363eb170ddd51b7f0da49d316552629d4689e2b16be587d47a1fc8ff8b8d17ad031ce45cb3a8f95160428afd7fbcabb4b407e\"\n);\n\nconst mask128 = (n(1) << n(128)) - n(1);\nconst mask64 = (n(1) << n(64)) - n(1);\nconst mask32 = (n(1) << n(32)) - n(1);\nconst STRIPE_LEN = 64;\nconst ACC_NB = STRIPE_LEN / 8;\nconst _U64 = 8;\nconst _U32 = 4;\n\nfunction assert(a: boolean) {\n  if (!a) throw new Error(\"Assert failed\");\n}\n\nfunction bswap64(a: bigint) {\n  const scratchbuf = new DataView(new ArrayBuffer(8));\n  scratchbuf.setBigUint64(0, a, true);\n  return scratchbuf.getBigUint64(0, false);\n}\n\nfunction bswap32(input: bigint) {\n  let a = input;\n  a = ((a & n(0x0000ffff)) << n(16)) | ((a & n(0xffff0000)) >> n(16));\n  a = ((a & n(0x00ff00ff)) << n(8)) | ((a & n(0xff00ff00)) >> n(8));\n  return a; // 32-bit\n}\n\nfunction XXH_mult32to64(a: bigint, b: bigint) {\n  return ((a & mask32) * (b & mask32)) & mask64;\n}\n\nfunction rotl32(a: bigint, b: bigint) {\n  return ((a << b) | (a >> (n(32) - b))) & mask32;\n}\n\nfunction XXH3_accumulate_512(\n  acc: BigUint64Array,\n  dataView: DataView,\n  keyView: DataView\n) {\n  for (let i = 0; i < ACC_NB; i += 1) {\n    const data_val = dataView.getBigUint64(i * 8, true);\n    const data_key = data_val ^ keyView.getBigUint64(i * 8, true);\n    acc[i ^ 1] += data_val;\n    acc[i] += XXH_mult32to64(data_key, data_key >> n(32));\n  }\n  return acc;\n}\n\nfunction XXH3_accumulate(\n  acc: BigUint64Array,\n  dataView: DataView,\n  keyView: DataView,\n  nbStripes: number\n) {\n  for (let n = 0; n < nbStripes; n += 1) {\n    XXH3_accumulate_512(\n      acc,\n      view(dataView, n * STRIPE_LEN),\n      view(keyView, n * 8)\n    );\n  }\n  return acc;\n}\n\nfunction XXH3_scrambleAcc(acc: BigUint64Array, key: DataView) {\n  for (let i = 0; i < ACC_NB; i += 1) {\n    const key64 = key.getBigUint64(i * 8, true);\n    let acc64 = acc[i];\n    acc64 = xorshift64(acc64, n(47));\n    acc64 ^= key64;\n    acc64 *= PRIME32_1;\n    acc[i] = acc64 & mask64;\n  }\n  return acc;\n}\n\nfunction XXH3_mix2Accs(acc: BigUint64Array, key: DataView) {\n  return XXH3_mul128_fold64(\n    acc[0] ^ key.getBigUint64(0, true),\n    acc[1] ^ key.getBigUint64(_U64, true)\n  );\n}\n\nfunction XXH3_mergeAccs(acc: BigUint64Array, key: DataView, start: bigint) {\n  let result64 = start;\n\n  result64 += XXH3_mix2Accs(acc.slice(0), view(key, 0 * _U32));\n  result64 += XXH3_mix2Accs(acc.slice(2), view(key, 4 * _U32));\n  result64 += XXH3_mix2Accs(acc.slice(4), view(key, 8 * _U32));\n  result64 += XXH3_mix2Accs(acc.slice(6), view(key, 12 * _U32));\n\n  return XXH3_avalanche(result64 & mask64);\n}\n\nfunction XXH3_hashLong(\n  input: BigUint64Array,\n  data: DataView,\n  secret: DataView,\n  f_acc: (acc: BigUint64Array, data: DataView, key: DataView) => BigUint64Array,\n  f_scramble: (acc: BigUint64Array, key: DataView) => BigUint64Array\n) {\n  let acc = input;\n  const nbStripesPerBlock = Math.floor((secret.byteLength - STRIPE_LEN) / 8);\n  const block_len = STRIPE_LEN * nbStripesPerBlock;\n  const nb_blocks = Math.floor((data.byteLength - 1) / block_len);\n\n  for (let n = 0; n < nb_blocks; n += 1) {\n    acc = XXH3_accumulate(\n      acc,\n      view(data, n * block_len),\n      secret,\n      nbStripesPerBlock\n    );\n    acc = f_scramble(acc, view(secret, secret.byteLength - STRIPE_LEN));\n  }\n\n  {\n    // Partial block\n    const nbStripes = Math.floor(\n      (data.byteLength - 1 - block_len * nb_blocks) / STRIPE_LEN\n    );\n    acc = XXH3_accumulate(\n      acc,\n      view(data, nb_blocks * block_len),\n      secret,\n      nbStripes\n    );\n\n    // Last Stripe\n    acc = f_acc(\n      acc,\n      view(data, data.byteLength - STRIPE_LEN),\n      view(secret, secret.byteLength - STRIPE_LEN - 7)\n    );\n  }\n  return acc;\n}\n\nfunction XXH3_hashLong_128b(data: DataView, secret: DataView) {\n  let acc = new BigUint64Array([\n    PRIME32_3,\n    PRIME64_1,\n    PRIME64_2,\n    PRIME64_3,\n    PRIME64_4,\n    PRIME32_2,\n    PRIME64_5,\n    PRIME32_1,\n  ]);\n  assert(data.byteLength > 128);\n\n  acc = XXH3_hashLong(\n    acc,\n    data,\n    secret,\n    XXH3_accumulate_512,\n    XXH3_scrambleAcc\n  ) as BigUint64Array<ArrayBuffer>;\n\n  /* converge into final hash */\n  assert(acc.length * 8 === 64);\n  {\n    const low64 = XXH3_mergeAccs(\n      acc,\n      view(secret, 11),\n      (n(data.byteLength) * PRIME64_1) & mask64\n    );\n    const high64 = XXH3_mergeAccs(\n      acc,\n      view(secret, secret.byteLength - STRIPE_LEN - 11),\n      ~(n(data.byteLength) * PRIME64_2) & mask64\n    );\n    return (high64 << n(64)) | low64;\n  }\n}\n\nfunction XXH3_mul128_fold64(a: bigint, b: bigint) {\n  const lll = (a * b) & mask128;\n  return (lll & mask64) ^ (lll >> n(64));\n}\n\nfunction XXH3_mix16B(dataView: DataView, keyView: DataView, seed: bigint) {\n  return XXH3_mul128_fold64(\n    (dataView.getBigUint64(0, true) ^ (keyView.getBigUint64(0, true) + seed)) &\n      mask64,\n    (dataView.getBigUint64(8, true) ^ (keyView.getBigUint64(8, true) - seed)) &\n      mask64\n  );\n}\n\nfunction XXH3_mix32B(\n  acc: bigint,\n  data1: DataView,\n  data2: DataView,\n  key: DataView,\n  seed: bigint\n) {\n  let accl = acc & mask64;\n  let acch = (acc >> n(64)) & mask64;\n\n  accl += XXH3_mix16B(data1, key, seed);\n  accl ^= data2.getBigUint64(0, true) + data2.getBigUint64(8, true);\n  accl &= mask64;\n  acch += XXH3_mix16B(data2, view(key, 16), seed);\n  acch ^= data1.getBigUint64(0, true) + data1.getBigUint64(8, true);\n  acch &= mask64;\n\n  return (acch << n(64)) | accl;\n}\n\nfunction XXH3_avalanche(input: bigint) {\n  let h64 = input;\n  h64 ^= h64 >> n(37);\n  h64 *= PRIME_MX1;\n  h64 &= mask64;\n  h64 ^= h64 >> n(32);\n  return h64;\n}\n\nfunction XXH3_avalanche64(input: bigint) {\n  let h64 = input;\n  h64 ^= h64 >> n(33);\n  h64 *= PRIME64_2;\n  h64 &= mask64; // 64-bit\n  h64 ^= h64 >> n(29);\n  h64 *= PRIME64_3;\n  h64 &= mask64;\n  h64 ^= h64 >> n(32);\n  return h64;\n}\n\nfunction XXH3_len_1to3_128b(data: DataView, key32: DataView, seed: bigint) {\n  const len = data.byteLength;\n  assert(len > 0 && len <= 3);\n\n  const combined =\n    n(data.getUint8(len - 1)) |\n    n(len << 8) |\n    n(data.getUint8(0) << 16) |\n    n(data.getUint8(len >> 1) << 24);\n\n  const blow =\n    (n(key32.getUint32(0, true)) ^ n(key32.getUint32(4, true))) + seed;\n  const low = (combined ^ blow) & mask64;\n  const bhigh =\n    (n(key32.getUint32(8, true)) ^ n(key32.getUint32(12, true))) - seed;\n  const high = (rotl32(bswap32(combined), n(13)) ^ bhigh) & mask64;\n\n  return ((XXH3_avalanche64(high) & mask64) << n(64)) | XXH3_avalanche64(low);\n}\n\nfunction xorshift64(b: bigint, shift: bigint) {\n  return b ^ (b >> shift);\n}\n\nfunction XXH3_len_4to8_128b(data: DataView, key32: DataView, seed: bigint) {\n  const len = data.byteLength;\n  assert(len >= 4 && len <= 8);\n\n  {\n    const l1 = data.getUint32(0, true);\n    const l2 = data.getUint32(len - 4, true);\n    const l64 = n(l1) | (n(l2) << n(32));\n    const bitflip =\n      ((key32.getBigUint64(16, true) ^ key32.getBigUint64(24, true)) + seed) &\n      mask64;\n    const keyed = l64 ^ bitflip;\n    let m128 = (keyed * (PRIME64_1 + (n(len) << n(2)))) & mask128;\n    m128 += (m128 & mask64) << n(65);\n    m128 &= mask128;\n    m128 ^= m128 >> n(67);\n\n    return (\n      xorshift64(\n        (xorshift64(m128 & mask64, n(35)) * PRIME_MX2) & mask64,\n        n(28)\n      ) |\n      (XXH3_avalanche(m128 >> n(64)) << n(64))\n    );\n  }\n}\n\nfunction XXH3_len_9to16_128b(data: DataView, key64: DataView, seed: bigint) {\n  const len = data.byteLength;\n  assert(len >= 9 && len <= 16);\n\n  {\n    const bitflipl =\n      ((key64.getBigUint64(32, true) ^ key64.getBigUint64(40, true)) + seed) &\n      mask64;\n    const bitfliph =\n      ((key64.getBigUint64(48, true) ^ key64.getBigUint64(56, true)) - seed) &\n      mask64;\n    const ll1 = data.getBigUint64(0, true);\n    let ll2 = data.getBigUint64(len - 8, true);\n\n    let m128 = (ll1 ^ ll2 ^ bitflipl) * PRIME64_1;\n\n    const m128_l = (m128 & mask64) + (n(len - 1) << n(54));\n    m128 = (m128 & (mask128 ^ mask64)) | m128_l; // eqv. to adding only to lower 64b\n    ll2 ^= bitfliph;\n\n    m128 += (ll2 + (ll2 & mask32) * (PRIME32_2 - n(1))) << n(64);\n    m128 &= mask128;\n    m128 ^= bswap64(m128 >> n(64));\n    let h128 = (m128 & mask64) * PRIME64_2;\n    h128 += ((m128 >> n(64)) * PRIME64_2) << n(64);\n    h128 &= mask128;\n\n    return (\n      XXH3_avalanche(h128 & mask64) | (XXH3_avalanche(h128 >> n(64)) << n(64))\n    );\n  }\n}\n\nfunction XXH3_len_0to16_128b(data: DataView, seed: bigint) {\n  const len = data.byteLength;\n  assert(len <= 16);\n\n  if (len > 8) return XXH3_len_9to16_128b(data, kkey, seed);\n  if (len >= 4) return XXH3_len_4to8_128b(data, kkey, seed);\n  if (len > 0) return XXH3_len_1to3_128b(data, kkey, seed);\n\n  return (\n    XXH3_avalanche64(\n      seed ^ kkey.getBigUint64(64, true) ^ kkey.getBigUint64(72, true)\n    ) |\n    (XXH3_avalanche64(\n      seed ^ kkey.getBigUint64(80, true) ^ kkey.getBigUint64(88, true)\n    ) <<\n      n(64))\n  );\n}\n\nfunction inv64(x: bigint) {\n  // NOTE: `AND` fixes signedness (but because of 2's complement we need to re-add 1)\n  return (~x + n(1)) & mask64;\n}\n\nfunction XXH3_len_17to128_128b(data: DataView, secret: DataView, seed: bigint) {\n  let acc = (n(data.byteLength) * PRIME64_1) & mask64;\n  let i = n(data.byteLength - 1) / n(32);\n  while (i >= 0) {\n    const ni = Number(i);\n    acc = XXH3_mix32B(\n      acc,\n      view(data, 16 * ni),\n      view(data, data.byteLength - 16 * (ni + 1)),\n      view(secret, 32 * ni),\n      seed\n    );\n    i -= n(1);\n  }\n\n  let h128l = (acc + (acc >> n(64))) & mask64;\n  h128l = XXH3_avalanche(h128l);\n  let h128h =\n    (acc & mask64) * PRIME64_1 +\n    (acc >> n(64)) * PRIME64_4 +\n    ((n(data.byteLength) - seed) & mask64) * PRIME64_2;\n  h128h &= mask64;\n\n  h128h = inv64(XXH3_avalanche(h128h));\n  return h128l | (h128h << n(64));\n}\n\nfunction XXH3_len_129to240_128b(\n  data: DataView,\n  secret: DataView,\n  seed: bigint\n) {\n  let acc = (n(data.byteLength) * PRIME64_1) & mask64;\n  for (let i = 32; i < 160; i += 32) {\n    acc = XXH3_mix32B(\n      acc,\n      view(data, i - 32),\n      view(data, i - 16),\n      view(secret, i - 32),\n      seed\n    );\n  }\n  acc = XXH3_avalanche(acc & mask64) | (XXH3_avalanche(acc >> n(64)) << n(64));\n  for (let i = 160; i <= data.byteLength; i += 32) {\n    acc = XXH3_mix32B(\n      acc,\n      view(data, i - 32),\n      view(data, i - 16),\n      view(secret, 3 + i - 160),\n      seed\n    );\n  }\n  acc = XXH3_mix32B(\n    acc,\n    view(data, data.byteLength - 16),\n    view(data, data.byteLength - 32),\n    view(secret, 136 - 17 - 16),\n    inv64(seed)\n  );\n\n  let h128l = (acc + (acc >> n(64))) & mask64;\n  h128l = XXH3_avalanche(h128l);\n  let h128h =\n    (acc & mask64) * PRIME64_1 +\n    (acc >> n(64)) * PRIME64_4 +\n    ((n(data.byteLength) - seed) & mask64) * PRIME64_2;\n  h128h &= mask64;\n\n  h128h = inv64(XXH3_avalanche(h128h));\n  return h128l | (h128h << n(64));\n}\n\n// 16 byte min input\nexport function XXH3(input: Uint8Array | string, seed: bigint = n(0)) {\n  const encoder = new TextEncoder();\n  const data = view(typeof input === \"string\" ? encoder.encode(input) : input);\n  const len = data.byteLength;\n\n  const hexDigest = (data: bigint) => data.toString(16).padStart(32, \"0\");\n  if (len <= 16) return hexDigest(XXH3_len_0to16_128b(data, seed));\n  if (len <= 128) return hexDigest(XXH3_len_17to128_128b(data, kkey, seed));\n  if (len <= 240) return hexDigest(XXH3_len_129to240_128b(data, kkey, seed));\n  return hexDigest(XXH3_hashLong_128b(data, kkey));\n}\n\nexport function isXXH3(value: string): boolean {\n  // Check if the given string matches the format of XXH3 (128 bit hex digest).\n  return /^[0-9a-f]{32}$/.test(value);\n}\n", "import { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  BaseCheckpointSaver,\n  type PendingWrite,\n} from \"@langchain/langgraph-checkpoint\";\nimport { GraphInterrupt, GraphValueError } from \"./errors.js\";\nimport {\n  CONFIG_KEY_CHECKPOINT_NS,\n  CONFIG_KEY_SCRATCHPAD,\n  CONFIG_KEY_SEND,\n  CONFIG_KEY_CHECKPOINTER,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  RESUME,\n} from \"./constants.js\";\nimport { PregelScratchpad } from \"./pregel/types.js\";\nimport { XXH3 } from \"./hash.js\";\n\n/**\n * Interrupts the execution of a graph node.\n * This function can be used to pause execution of a node, and return the value of the `resume`\n * input when the graph is re-invoked using `Command`.\n * Multiple interrupts can be called within a single node, and each will be handled sequentially.\n *\n * When an interrupt is called:\n * 1. If there's a `resume` value available (from a previous `Command`), it returns that value.\n * 2. Otherwise, it throws a `GraphInterrupt` with the provided value\n * 3. The graph can be resumed by passing a `Command` with a `resume` value\n *\n * Because the `interrupt` function propagates by throwing a special `GraphInterrupt` error,\n * you should avoid using `try/catch` blocks around the `interrupt` function,\n * or if you do, ensure that the `GraphInterrupt` error is thrown again within your `catch` block.\n *\n * @param value - The value to include in the interrupt. This will be available in task.interrupts[].value\n * @returns The `resume` value provided when the graph is re-invoked with a Command\n *\n * @example\n * ```typescript\n * // Define a node that uses multiple interrupts\n * const nodeWithInterrupts = () => {\n *   // First interrupt - will pause execution and include {value: 1} in task values\n *   const answer1 = interrupt({ value: 1 });\n *\n *   // Second interrupt - only called after first interrupt is resumed\n *   const answer2 = interrupt({ value: 2 });\n *\n *   // Use the resume values\n *   return { myKey: answer1 + \" \" + answer2 };\n * };\n *\n * // Resume the graph after first interrupt\n * await graph.stream(new Command({ resume: \"answer 1\" }));\n *\n * // Resume the graph after second interrupt\n * await graph.stream(new Command({ resume: \"answer 2\" }));\n * // Final result: { myKey: \"answer 1 answer 2\" }\n * ```\n *\n * @throws {Error} If called outside the context of a graph\n * @throws {GraphInterrupt} When no resume value is available\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function interrupt<I = unknown, R = any>(value: I): R {\n  const config: RunnableConfig | undefined =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  if (!config) {\n    throw new Error(\"Called interrupt() outside the context of a graph.\");\n  }\n\n  const conf = config.configurable;\n  if (!conf) {\n    throw new Error(\"No configurable found in config\");\n  }\n\n  const checkpointer: BaseCheckpointSaver = conf[CONFIG_KEY_CHECKPOINTER];\n  if (!checkpointer) {\n    throw new GraphValueError(\"No checkpointer set\", {\n      lc_error_code: \"MISSING_CHECKPOINTER\",\n    });\n  }\n\n  // Track interrupt index\n  const scratchpad: PregelScratchpad = conf[CONFIG_KEY_SCRATCHPAD];\n  scratchpad.interruptCounter += 1;\n  const idx = scratchpad.interruptCounter;\n\n  // Find previous resume values\n  if (scratchpad.resume.length > 0 && idx < scratchpad.resume.length) {\n    conf[CONFIG_KEY_SEND]?.([[RESUME, scratchpad.resume] as PendingWrite]);\n    return scratchpad.resume[idx] as R;\n  }\n\n  // Find current resume value\n  if (scratchpad.nullResume !== undefined) {\n    if (scratchpad.resume.length !== idx) {\n      throw new Error(\n        `Resume length mismatch: ${scratchpad.resume.length} !== ${idx}`\n      );\n    }\n    const v = scratchpad.consumeNullResume();\n    scratchpad.resume.push(v);\n    conf[CONFIG_KEY_SEND]?.([[RESUME, scratchpad.resume] as PendingWrite]);\n    return v as R;\n  }\n\n  // No resume value found\n  const ns: string[] | undefined = conf[CONFIG_KEY_CHECKPOINT_NS]?.split(\n    CHECKPOINT_NAMESPACE_SEPARATOR\n  );\n\n  const id = ns ? XXH3(ns.join(CHECKPOINT_NAMESPACE_SEPARATOR)) : undefined;\n  throw new GraphInterrupt([{ id, value }]);\n}\n\ntype FilterAny<X> = (<T>() => T extends X ? 1 : 2) extends <\n  T\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n>() => T extends any ? 1 : 2\n  ? never\n  : X;\n\nexport type InferInterruptInputType<T> = T extends typeof interrupt<\n  infer I,\n  unknown\n>\n  ? I\n  : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends { [key: string]: typeof interrupt<any, any> }\n  ? { [K in keyof T]: InferInterruptInputType<T[K]> }[keyof T]\n  : unknown;\n\nexport type InferInterruptResumeType<\n  T,\n  TInner = false\n> = T extends typeof interrupt<never, infer R>\n  ? TInner extends true\n    ? FilterAny<R>\n    : R\n  : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends { [key: string]: typeof interrupt<any, any> }\n  ? { [K in keyof T]: InferInterruptResumeType<T[K], true> }[keyof T]\n  : unknown;\n", "import { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  mergeConfigs,\n  patchConfig,\n  Runnable,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { ensureLangGraphConfig } from \"./pregel/utils/config.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface RunnableCallableArgs extends Partial<any> {\n  name?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  func: (...args: any[]) => any;\n  tags?: string[];\n  trace?: boolean;\n  recurse?: boolean;\n}\n\nexport class RunnableCallable<I = unknown, O = unknown> extends Runnable<I, O> {\n  lc_namespace: string[] = [\"langgraph\"];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  func: (...args: any[]) => any;\n\n  tags?: string[];\n\n  config?: RunnableConfig;\n\n  trace: boolean = true;\n\n  recurse: boolean = true;\n\n  constructor(fields: RunnableCallableArgs) {\n    super();\n    this.name = fields.name ?? fields.func.name;\n    this.func = fields.func;\n    this.config = fields.tags ? { tags: fields.tags } : undefined;\n    this.trace = fields.trace ?? this.trace;\n    this.recurse = fields.recurse ?? this.recurse;\n  }\n\n  protected async _tracedInvoke(\n    input: I,\n    config?: Partial<RunnableConfig>,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    return new Promise<O>((resolve, reject) => {\n      const childConfig = patchConfig(config, {\n        callbacks: runManager?.getChild(),\n      });\n      void AsyncLocalStorageProviderSingleton.runWithConfig(\n        childConfig,\n        async () => {\n          try {\n            const output = await this.func(input, childConfig);\n            resolve(output);\n          } catch (e) {\n            reject(e);\n          }\n        }\n      );\n    });\n  }\n\n  async invoke(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: I,\n    options?: Partial<RunnableConfig> | undefined\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<O> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnValue: any;\n    const config = ensureLangGraphConfig(options);\n    const mergedConfig = mergeConfigs(this.config, config);\n\n    if (this.trace) {\n      returnValue = await this._callWithConfig(\n        this._tracedInvoke,\n        input,\n        mergedConfig\n      );\n    } else {\n      returnValue = await AsyncLocalStorageProviderSingleton.runWithConfig(\n        mergedConfig,\n        async () => this.func(input, mergedConfig)\n      );\n    }\n\n    if (Runnable.isRunnable(returnValue) && this.recurse) {\n      return await AsyncLocalStorageProviderSingleton.runWithConfig(\n        mergedConfig,\n        async () => returnValue.invoke(input, mergedConfig)\n      );\n    }\n\n    return returnValue;\n  }\n}\n\nexport function prefixGenerator<T, Prefix extends string>(\n  generator: Generator<T>,\n  prefix: Prefix\n): Generator<[Prefix, T]>;\n\nexport function prefixGenerator<T>(\n  generator: Generator<T>,\n  prefix?: undefined\n): Generator<T>;\n\nexport function prefixGenerator<\n  T,\n  Prefix extends string | undefined = undefined\n>(\n  generator: Generator<T>,\n  prefix?: Prefix | undefined\n): Generator<Prefix extends string ? [Prefix, T] : T>;\nexport function* prefixGenerator<\n  T,\n  Prefix extends string | undefined = undefined\n>(\n  generator: Generator<T>,\n  prefix?: Prefix | undefined\n): Generator<Prefix extends string ? [Prefix, T] : T> {\n  if (prefix === undefined) {\n    yield* generator as Generator<Prefix extends string ? [Prefix, T] : T>;\n  } else {\n    for (const value of generator) {\n      yield [prefix, value] as Prefix extends string ? [Prefix, T] : T;\n    }\n  }\n}\n\n// https://github.com/tc39/proposal-array-from-async\nexport async function gatherIterator<T>(\n  i:\n    | AsyncIterable<T>\n    | Promise<AsyncIterable<T>>\n    | Iterable<T>\n    | Promise<Iterable<T>>\n): Promise<Array<T>> {\n  const out: T[] = [];\n  for await (const item of await i) {\n    out.push(item);\n  }\n  return out;\n}\n\nexport function gatherIteratorSync<T>(i: Iterable<T>): Array<T> {\n  const out: T[] = [];\n  for (const item of i) {\n    out.push(item);\n  }\n  return out;\n}\n\nexport function patchConfigurable(\n  config: RunnableConfig | undefined,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  patch: Record<string, any>\n): RunnableConfig {\n  if (!config) {\n    return {\n      configurable: patch,\n    };\n  } else if (!(\"configurable\" in config)) {\n    return {\n      ...config,\n      configurable: patch,\n    };\n  } else {\n    return {\n      ...config,\n      configurable: {\n        ...config.configurable,\n        ...patch,\n      },\n    };\n  }\n}\n\nexport function isAsyncGeneratorFunction(\n  val: unknown\n): val is AsyncGeneratorFunction {\n  return (\n    val != null &&\n    typeof val === \"function\" &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    val instanceof Object.getPrototypeOf(async function* () {}).constructor\n  );\n}\n\nexport function isGeneratorFunction(val: unknown): val is GeneratorFunction {\n  return (\n    val != null &&\n    typeof val === \"function\" &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    val instanceof Object.getPrototypeOf(function* () {}).constructor\n  );\n}\n", "import {\n  Runnable,\n  RunnableConfig,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { _isSend, CONFIG_KEY_SEND, Send, TASKS } from \"../constants.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport { InvalidUpdateError } from \"../errors.js\";\n\ntype TYPE_SEND = (values: Array<[string, unknown]>) => void;\n\nexport const SKIP_WRITE = {\n  [Symbol.for(\"LG_SKIP_WRITE\")]: true,\n};\n\nfunction _isSkipWrite(x: unknown) {\n  return (\n    typeof x === \"object\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (x as any)?.[Symbol.for(\"LG_SKIP_WRITE\")] !== undefined\n  );\n}\n\nexport const PASSTHROUGH = {\n  [Symbol.for(\"LG_PASSTHROUGH\")]: true,\n};\n\nfunction _isPassthrough(x: unknown) {\n  return (\n    typeof x === \"object\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (x as any)?.[Symbol.for(\"LG_PASSTHROUGH\")] !== undefined\n  );\n}\n\nconst IS_WRITER = Symbol(\"IS_WRITER\");\n\n/**\n * Mapping of write channels to Runnables that return the value to be written,\n * or None to skip writing.\n */\nexport class ChannelWrite<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any\n> extends RunnableCallable<RunInput, RunInput> {\n  writes: Array<ChannelWriteEntry | ChannelWriteTupleEntry | Send>;\n\n  constructor(\n    writes: Array<ChannelWriteEntry | ChannelWriteTupleEntry | Send>,\n    tags?: string[]\n  ) {\n    const name = `ChannelWrite<${writes\n      .map((packet) => {\n        if (_isSend(packet)) {\n          return packet.node;\n        } else if (\"channel\" in packet) {\n          return packet.channel;\n        }\n        return \"...\";\n      })\n      .join(\",\")}>`;\n    super({\n      ...{ writes, name, tags },\n      func: async (input: RunInput, config?: RunnableConfig) => {\n        return this._write(input, config ?? {});\n      },\n    });\n\n    this.writes = writes;\n  }\n\n  async _write(input: unknown, config: RunnableConfig): Promise<unknown> {\n    const writes = this.writes.map((write) => {\n      if (_isChannelWriteTupleEntry(write) && _isPassthrough(write.value)) {\n        return {\n          mapper: write.mapper,\n          value: input,\n        };\n      } else if (_isChannelWriteEntry(write) && _isPassthrough(write.value)) {\n        return {\n          channel: write.channel,\n          value: input,\n          skipNone: write.skipNone,\n          mapper: write.mapper,\n        };\n      } else {\n        return write;\n      }\n    });\n    await ChannelWrite.doWrite(config, writes);\n    return input;\n  }\n\n  // TODO: Support requireAtLeastOneOf\n  static async doWrite(\n    config: RunnableConfig,\n    writes: (ChannelWriteEntry | ChannelWriteTupleEntry | Send)[]\n  ): Promise<void> {\n    // validate\n    for (const w of writes) {\n      if (_isChannelWriteEntry(w)) {\n        if (w.channel === TASKS) {\n          throw new InvalidUpdateError(\n            \"Cannot write to the reserved channel TASKS\"\n          );\n        }\n        if (_isPassthrough(w.value)) {\n          throw new InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n        }\n      }\n      if (_isChannelWriteTupleEntry(w)) {\n        if (_isPassthrough(w.value)) {\n          throw new InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n        }\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const writeEntries: [string, any][] = [];\n    for (const w of writes) {\n      if (_isSend(w)) {\n        writeEntries.push([TASKS, w]);\n      } else if (_isChannelWriteTupleEntry(w)) {\n        const mappedResult = await w.mapper.invoke(w.value, config);\n        if (mappedResult != null && mappedResult.length > 0) {\n          writeEntries.push(...mappedResult);\n        }\n      } else if (_isChannelWriteEntry(w)) {\n        const mappedValue =\n          w.mapper !== undefined\n            ? await w.mapper.invoke(w.value, config)\n            : w.value;\n        if (_isSkipWrite(mappedValue)) {\n          continue;\n        }\n        if (w.skipNone && mappedValue === undefined) {\n          continue;\n        }\n        writeEntries.push([w.channel, mappedValue]);\n      } else {\n        throw new Error(`Invalid write entry: ${JSON.stringify(w)}`);\n      }\n    }\n    const write: TYPE_SEND = config.configurable?.[CONFIG_KEY_SEND];\n    write(writeEntries);\n  }\n\n  static isWriter(runnable: RunnableLike): runnable is ChannelWrite {\n    return (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      runnable instanceof ChannelWrite ||\n      (IS_WRITER in runnable && !!runnable[IS_WRITER])\n    );\n  }\n\n  static registerWriter<T extends Runnable>(runnable: T): T {\n    return Object.defineProperty(runnable, IS_WRITER, { value: true });\n  }\n}\n\nexport interface ChannelWriteEntry {\n  channel: string;\n  value: unknown;\n  skipNone?: boolean;\n  mapper?: Runnable;\n}\n\nfunction _isChannelWriteEntry(x: unknown): x is ChannelWriteEntry {\n  return (\n    x !== undefined && typeof (x as ChannelWriteEntry).channel === \"string\"\n  );\n}\n\nexport interface ChannelWriteTupleEntry {\n  value: unknown;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper: Runnable<any, [string, any][]>;\n}\n\nfunction _isChannelWriteTupleEntry(x: unknown): x is ChannelWriteTupleEntry {\n  return (\n    x !== undefined &&\n    !_isChannelWriteEntry(x) &&\n    Runnable.isRunnable((x as ChannelWriteTupleEntry).mapper)\n  );\n}\n", "import {\n  Runnable,\n  RunnableBinding,\n  RunnableBindingArgs,\n  RunnableConfig,\n  RunnablePassthrough,\n  RunnableSequence,\n  _coerceToRunnable,\n  type RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { CONFIG_KEY_READ } from \"../constants.js\";\nimport { ChannelWrite } from \"./write.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport type { CachePolicy, RetryPolicy } from \"./utils/index.js\";\n\nexport class ChannelRead<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any\n> extends RunnableCallable {\n  lc_graph_name = \"ChannelRead\";\n\n  channel: string | Array<string>;\n\n  fresh: boolean = false;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(\n    channel: string | Array<string>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    mapper?: (args: any) => any,\n    fresh: boolean = false\n  ) {\n    super({\n      func: (_: RunInput, config: RunnableConfig) =>\n        ChannelRead.doRead(config, this.channel, this.fresh, this.mapper),\n    });\n    this.fresh = fresh;\n    this.mapper = mapper;\n    this.channel = channel;\n    this.name = Array.isArray(channel)\n      ? `ChannelRead<${channel.join(\",\")}>`\n      : `ChannelRead<${channel}>`;\n  }\n\n  static doRead<T = unknown>(\n    config: RunnableConfig,\n    channel: string | Array<string>,\n    fresh: boolean,\n    mapper?: (args: unknown) => unknown\n  ): T {\n    const read: (arg: string | string[], fresh: boolean) => unknown =\n      config.configurable?.[CONFIG_KEY_READ];\n    if (!read) {\n      throw new Error(\n        \"Runnable is not configured with a read function. Make sure to call in the context of a Pregel process\"\n      );\n    }\n    if (mapper) {\n      return mapper(read(channel, fresh)) as T;\n    } else {\n      return read(channel, fresh) as T;\n    }\n  }\n}\n\nconst defaultRunnableBound =\n  /* #__PURE__ */ new RunnablePassthrough<PregelNodeInputType>();\n\ninterface PregelNodeArgs<RunInput, RunOutput>\n  extends Partial<RunnableBindingArgs<RunInput, RunOutput>> {\n  channels: Record<string, string> | string[];\n  triggers: Array<string>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n  writers?: Runnable<RunOutput, unknown>[];\n  tags?: string[];\n  bound?: Runnable<RunInput, RunOutput>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs?: Record<string, any>;\n  config?: RunnableConfig;\n  metadata?: Record<string, unknown>;\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy;\n  subgraphs?: Runnable[];\n  ends?: string[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelNodeInputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelNodeOutputType = any;\n\nexport class PregelNode<\n  RunInput = PregelNodeInputType,\n  RunOutput = PregelNodeOutputType\n> extends RunnableBinding<RunInput, RunOutput, RunnableConfig> {\n  lc_graph_name = \"PregelNode\";\n\n  channels: Record<string, string> | string[];\n\n  triggers: string[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n\n  writers: Runnable[] = [];\n\n  bound: Runnable<RunInput, RunOutput> = defaultRunnableBound;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs: Record<string, any> = {};\n\n  metadata: Record<string, unknown> = {};\n\n  tags: string[] = [];\n\n  retryPolicy?: RetryPolicy;\n\n  cachePolicy?: CachePolicy;\n\n  subgraphs?: Runnable[];\n\n  ends?: string[];\n\n  constructor(fields: PregelNodeArgs<RunInput, RunOutput>) {\n    const {\n      channels,\n      triggers,\n      mapper,\n      writers,\n      bound,\n      kwargs,\n      metadata,\n      retryPolicy,\n      cachePolicy,\n      tags,\n      subgraphs,\n      ends,\n    } = fields;\n    const mergedTags = [\n      ...(fields.config?.tags ? fields.config.tags : []),\n      ...(tags ?? []),\n    ];\n\n    super({\n      ...fields,\n      bound:\n        fields.bound ??\n        (defaultRunnableBound as unknown as Runnable<RunInput, RunOutput>),\n      config: {\n        ...(fields.config ? fields.config : {}),\n        tags: mergedTags,\n      },\n    });\n\n    this.channels = channels;\n    this.triggers = triggers;\n    this.mapper = mapper;\n    this.writers = writers ?? this.writers;\n    this.bound = bound ?? this.bound;\n    this.kwargs = kwargs ?? this.kwargs;\n    this.metadata = metadata ?? this.metadata;\n    this.tags = mergedTags;\n    this.retryPolicy = retryPolicy;\n    this.cachePolicy = cachePolicy;\n    this.subgraphs = subgraphs;\n    this.ends = ends;\n  }\n\n  getWriters(): Array<Runnable> {\n    const newWriters = [...this.writers];\n    while (\n      newWriters.length > 1 &&\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      newWriters[newWriters.length - 1] instanceof ChannelWrite &&\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      newWriters[newWriters.length - 2] instanceof ChannelWrite\n    ) {\n      // we can combine writes if they are consecutive\n      // careful to not modify the original writers list or ChannelWrite\n      const endWriters = newWriters.slice(-2) as ChannelWrite[];\n      const combinedWrites = endWriters[0].writes.concat(endWriters[1].writes);\n      newWriters[newWriters.length - 2] = new ChannelWrite(\n        combinedWrites,\n        endWriters[0].config?.tags\n      );\n      newWriters.pop();\n    }\n    return newWriters;\n  }\n\n  getNode(): Runnable<RunInput, RunOutput> | undefined {\n    const writers = this.getWriters();\n    if (this.bound === defaultRunnableBound && writers.length === 0) {\n      return undefined;\n    } else if (this.bound === defaultRunnableBound && writers.length === 1) {\n      return writers[0];\n    } else if (this.bound === defaultRunnableBound) {\n      return new RunnableSequence({\n        first: writers[0],\n        middle: writers.slice(1, writers.length - 1),\n        last: writers[writers.length - 1],\n        omitSequenceTags: true,\n      });\n    } else if (writers.length > 0) {\n      return new RunnableSequence({\n        first: this.bound,\n        middle: writers.slice(0, writers.length - 1),\n        last: writers[writers.length - 1],\n        omitSequenceTags: true,\n      });\n    } else {\n      return this.bound;\n    }\n  }\n\n  join(channels: Array<string>): PregelNode<RunInput, RunOutput> {\n    if (!Array.isArray(channels)) {\n      throw new Error(\"channels must be a list\");\n    }\n    if (typeof this.channels !== \"object\") {\n      throw new Error(\"all channels must be named when using .join()\");\n    }\n\n    return new PregelNode<RunInput, RunOutput>({\n      channels: {\n        ...this.channels,\n        ...Object.fromEntries(channels.map((chan) => [chan, chan])),\n      },\n      triggers: this.triggers,\n      mapper: this.mapper,\n      writers: this.writers,\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      retryPolicy: this.retryPolicy,\n      cachePolicy: this.cachePolicy,\n    });\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike\n  ): PregelNode<RunInput, Exclude<NewRunOutput, Error>> {\n    if (ChannelWrite.isWriter(coerceable)) {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: [...this.writers, coerceable],\n        bound: this.bound as unknown as PregelNode<\n          RunInput,\n          Exclude<NewRunOutput, Error>\n        >,\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n        cachePolicy: this.cachePolicy,\n      });\n    } else if (this.bound === defaultRunnableBound) {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: this.writers,\n        bound: _coerceToRunnable<RunInput, NewRunOutput>(coerceable),\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n        cachePolicy: this.cachePolicy,\n      });\n    } else {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: this.writers,\n        bound: this.bound.pipe(coerceable),\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n        cachePolicy: this.cachePolicy,\n      });\n    }\n  }\n}\n", "import {\n  RunnableSequence,\n  Runnable,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport type { PregelInterface } from \"../types.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableSequence(\n  x: RunnableSequence | Runnable\n): x is RunnableSequence {\n  return \"steps\" in x && Array.isArray(x.steps);\n}\n\nexport function isPregelLike(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  x: PregelInterface<any, any> | RunnableLike<any, any, any>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): x is PregelInterface<any, any> {\n  return \"lg_is_pregel\" in x && x.lg_is_pregel === true;\n}\n\nexport function findSubgraphPregel(\n  candidate: Runnable\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): PregelInterface<any, any> | undefined {\n  const candidates = [candidate];\n  for (const candidate of candidates) {\n    if (isPregelLike(candidate)) {\n      return candidate;\n    } else if (isRunnableSequence(candidate)) {\n      candidates.push(...candidate.steps);\n    }\n  }\n  return undefined;\n}\n", "import type {\n  CheckpointPendingWrite,\n  PendingWrite,\n} from \"@langchain/langgraph-checkpoint\";\n\nimport type { BaseChannel } from \"../channels/base.js\";\nimport type { PregelExecutableTask } from \"./types.js\";\nimport {\n  _isSend,\n  Command,\n  ERROR,\n  INTERRUPT,\n  NULL_TASK_ID,\n  RESUME,\n  RETURN,\n  TAG_HIDDEN,\n  TASKS,\n} from \"../constants.js\";\nimport { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { isXXH3 } from \"../hash.js\";\n\nexport function readChannel<C extends PropertyKey>(\n  channels: Record<C, BaseChannel>,\n  chan: C,\n  catchErrors: boolean = true,\n  returnException: boolean = false\n): unknown | null {\n  try {\n    return channels[chan].get();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e: any) {\n    if (e.name === EmptyChannelError.unminifiable_name) {\n      if (returnException) {\n        return e;\n      } else if (catchErrors) {\n        return null;\n      }\n    }\n    throw e;\n  }\n}\n\nexport function readChannels<C extends PropertyKey>(\n  channels: Record<C, BaseChannel>,\n  select: C | Array<C>,\n  skipEmpty: boolean = true\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> | any {\n  if (Array.isArray(select)) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const values = {} as Record<C, any>;\n    for (const k of select) {\n      try {\n        values[k] = readChannel(channels, k, !skipEmpty);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === EmptyChannelError.unminifiable_name) {\n          continue;\n        }\n      }\n    }\n    return values;\n  } else {\n    return readChannel(channels, select);\n  }\n}\n\n/**\n * Map input chunk to a sequence of pending writes in the form (channel, value).\n */\nexport function* mapCommand(\n  cmd: Command,\n  pendingWrites: CheckpointPendingWrite[]\n): Generator<[string, string, unknown]> {\n  if (cmd.graph === Command.PARENT) {\n    throw new InvalidUpdateError(\"There is no parent graph.\");\n  }\n  if (cmd.goto) {\n    let sends;\n    if (Array.isArray(cmd.goto)) {\n      sends = cmd.goto;\n    } else {\n      sends = [cmd.goto];\n    }\n    for (const send of sends) {\n      if (_isSend(send)) {\n        yield [NULL_TASK_ID, TASKS, send];\n      } else if (typeof send === \"string\") {\n        yield [NULL_TASK_ID, `branch:to:${send}`, \"__start__\"];\n      } else {\n        throw new Error(\n          `In Command.send, expected Send or string, got ${typeof send}`\n        );\n      }\n    }\n  }\n  if (cmd.resume) {\n    if (\n      typeof cmd.resume === \"object\" &&\n      Object.keys(cmd.resume).length &&\n      Object.keys(cmd.resume).every(isXXH3)\n    ) {\n      for (const [tid, resume] of Object.entries(cmd.resume)) {\n        const existing =\n          pendingWrites\n            .filter((w) => w[0] === tid && w[1] === RESUME)\n            .map((w) => w[2])\n            .slice(0, 1) ?? [];\n        existing.push(resume);\n        yield [tid, RESUME, existing];\n      }\n    } else {\n      yield [NULL_TASK_ID, RESUME, cmd.resume];\n    }\n  }\n  if (cmd.update) {\n    if (typeof cmd.update !== \"object\" || !cmd.update) {\n      throw new Error(\n        \"Expected cmd.update to be a dict mapping channel names to update values\"\n      );\n    }\n\n    if (Array.isArray(cmd.update)) {\n      for (const [k, v] of cmd.update) {\n        yield [NULL_TASK_ID, k, v];\n      }\n    } else {\n      for (const [k, v] of Object.entries(cmd.update)) {\n        yield [NULL_TASK_ID, k, v];\n      }\n    }\n  }\n}\n\n/**\n * Map input chunk to a sequence of pending writes in the form [channel, value].\n */\nexport function* mapInput<C extends PropertyKey>(\n  inputChannels: C | Array<C>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  chunk?: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Generator<[C, any]> {\n  if (chunk !== undefined && chunk !== null) {\n    if (\n      Array.isArray(inputChannels) &&\n      typeof chunk === \"object\" &&\n      !Array.isArray(chunk)\n    ) {\n      for (const k in chunk) {\n        if (inputChannels.includes(k as C)) {\n          yield [k as C, chunk[k]];\n        }\n      }\n    } else if (Array.isArray(inputChannels)) {\n      throw new Error(\n        `Input chunk must be an object when \"inputChannels\" is an array`\n      );\n    } else {\n      yield [inputChannels, chunk];\n    }\n  }\n}\n\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n */\nexport function* mapOutputValues<C extends PropertyKey>(\n  outputChannels: C | Array<C>,\n  pendingWrites: readonly PendingWrite<C>[] | true,\n  channels: Record<C, BaseChannel>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Generator<Record<string, any>, any> {\n  if (Array.isArray(outputChannels)) {\n    if (\n      pendingWrites === true ||\n      pendingWrites.find(([chan, _]) => outputChannels.includes(chan))\n    ) {\n      yield readChannels(channels, outputChannels);\n    }\n  } else {\n    if (\n      pendingWrites === true ||\n      pendingWrites.some(([chan, _]) => chan === outputChannels)\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      yield readChannel(channels, outputChannels) as any;\n    }\n  }\n}\n\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n * @internal\n *\n * @param outputChannels - The channels to output.\n * @param tasks - The tasks to output.\n * @param cached - Whether the output is cached.\n *\n * @returns A generator that yields the output chunk (if any).\n */\nexport function* mapOutputUpdates<N extends PropertyKey, C extends PropertyKey>(\n  outputChannels: C | Array<C>,\n  tasks: readonly [PregelExecutableTask<N, C>, PendingWrite<C>[]][],\n  cached?: boolean\n): Generator<Record<N, Record<string, unknown> | unknown>> {\n  const outputTasks = tasks.filter(([task, ww]) => {\n    return (\n      (task.config === undefined || !task.config.tags?.includes(TAG_HIDDEN)) &&\n      ww[0][0] !== ERROR &&\n      ww[0][0] !== INTERRUPT\n    );\n  });\n  if (!outputTasks.length) {\n    return;\n  }\n\n  let updated: [N, Record<string, unknown>][];\n\n  if (\n    outputTasks.some(([task]) =>\n      task.writes.some(([chan, _]) => chan === RETURN)\n    )\n  ) {\n    // TODO: probably should assert that RETURN is the only \"non-special\" channel (starts with \"__\")\n    updated = outputTasks.flatMap(([task]) =>\n      task.writes\n        .filter(([chan, _]) => chan === RETURN)\n        .map(([_, value]) => [task.name, value] as [N, Record<string, unknown>])\n    );\n  } else if (!Array.isArray(outputChannels)) {\n    // special case where graph state is a single channel (MessageGraph)\n    // probably using this in functional API, too\n    updated = outputTasks.flatMap(([task]) =>\n      task.writes\n        .filter(([chan, _]) => chan === outputChannels)\n        .map(([_, value]) => [task.name, value] as [N, Record<string, unknown>])\n    );\n  } else {\n    updated = outputTasks.flatMap(([task]) => {\n      const { writes } = task;\n      const counts: Record<C, number> = {} as Record<C, number>;\n      for (const [chan] of writes) {\n        if (outputChannels.includes(chan)) {\n          counts[chan] = (counts[chan] || 0) + 1;\n        }\n      }\n\n      if ((Object.values(counts) as number[]).some((count) => count > 1)) {\n        // Multiple writes to the same channel: create separate entries\n        return writes\n          .filter(([chan]) => outputChannels.includes(chan))\n          .map(\n            ([chan, value]) =>\n              [task.name, { [chan]: value }] as [N, Record<string, unknown>]\n          );\n      } else {\n        // Single write to each channel: create a single combined entry\n        return [\n          [\n            task.name,\n            Object.fromEntries(\n              writes.filter(([chan]) => outputChannels.includes(chan))\n            ),\n          ] as [N, Record<string, unknown>],\n        ];\n      }\n    });\n  }\n\n  const grouped = {} as Record<N, unknown[]>;\n\n  for (const [node, value] of updated) {\n    if (!(node in grouped)) {\n      grouped[node] = [];\n    }\n    grouped[node].push(value);\n  }\n\n  const flattened = {} as Record<N, unknown>;\n  for (const node in grouped) {\n    if (grouped[node].length === 1) {\n      const [write] = grouped[node];\n      flattened[node] = write;\n    } else {\n      flattened[node] = grouped[node];\n    }\n  }\n\n  if (cached) {\n    flattened[\"__metadata__\" as N] = { cached };\n  }\n  yield flattened;\n}\n\nexport function single<T>(iter: IterableIterator<T>): T | null {\n  // eslint-disable-next-line no-unreachable-loop\n  for (const value of iter) {\n    return value;\n  }\n  return null;\n}\n", "import { Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport type {\n  ChannelVersions,\n  CheckpointMetadata,\n} from \"@langchain/langgraph-checkpoint\";\nimport { CONFIG_KEY_CHECKPOINT_MAP, START } from \"../../constants.js\";\n\nexport function getNullChannelVersion(currentVersions: ChannelVersions) {\n  // Short circuit for commonly used channels such as __start__\n  // (used by StateGraph)\n  const startVersion = typeof currentVersions[START];\n  if (startVersion === \"number\") return 0;\n  if (startVersion === \"string\") return \"\";\n\n  // Defer back to obtaining a first key from channel versions\n  for (const key in currentVersions) {\n    if (!Object.prototype.hasOwnProperty.call(currentVersions, key)) continue;\n    const versionType = typeof currentVersions[key];\n    if (versionType === \"number\") return 0;\n    if (versionType === \"string\") return \"\";\n    break;\n  }\n\n  return undefined;\n}\n\nexport function getNewChannelVersions(\n  previousVersions: ChannelVersions,\n  currentVersions: ChannelVersions\n): ChannelVersions {\n  // Get new channel versions\n  if (Object.keys(previousVersions).length > 0) {\n    const nullVersion = getNullChannelVersion(currentVersions);\n    return Object.fromEntries(\n      Object.entries(currentVersions).filter(\n        ([k, v]) => v > (previousVersions[k] ?? nullVersion)\n      )\n    );\n  } else {\n    return currentVersions;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value: any, defaultKey: string) {\n  return value &&\n    !Array.isArray(value) &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    !(value instanceof Date) &&\n    typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\nexport type RetryPolicy = {\n  /**\n   * Amount of time that must elapse before the first retry occurs in milliseconds.\n   * @default 500\n   */\n  initialInterval?: number;\n\n  /**\n   * Multiplier by which the interval increases after each retry.\n   * @default 2\n   */\n  backoffFactor?: number;\n\n  /**\n   * Maximum amount of time that may elapse between retries in milliseconds.\n   * @default 128000\n   */\n  maxInterval?: number;\n\n  /**\n   * Maximum amount of time that may elapse between retries.\n   * @default 3\n   */\n  maxAttempts?: number;\n\n  /** Whether to add random jitter to the interval between retries. */\n  jitter?: boolean;\n\n  /** A function that returns True for exceptions that should trigger a retry. */\n  retryOn?: (e: any) => boolean; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  /** Whether to log a warning when a retry is attempted. Defaults to true. */\n  logWarning?: boolean;\n};\n\n/**\n * Configuration for caching nodes.\n */\nexport type CachePolicy = {\n  /**\n   * A function used to generate a cache key from node's input.\n   * @returns A key for the cache.\n   */\n  keyFunc?: (args: unknown[]) => string;\n\n  /**\n   * The time to live for the cache in seconds.\n   * If not defined, the entry will never expire.\n   */\n  ttl?: number;\n};\n\nexport function patchConfigurable(\n  config: RunnableConfig | undefined,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  patch: Record<string, any>\n): RunnableConfig {\n  if (config === null) {\n    return { configurable: patch };\n  } else if (config?.configurable === undefined) {\n    return { ...config, configurable: patch };\n  } else {\n    return {\n      ...config,\n      configurable: { ...config.configurable, ...patch },\n    };\n  }\n}\n\nexport function patchCheckpointMap(\n  config: RunnableConfig,\n  metadata?: CheckpointMetadata\n): RunnableConfig {\n  const parents = metadata?.parents ?? {};\n\n  if (Object.keys(parents).length > 0) {\n    return patchConfigurable(config, {\n      [CONFIG_KEY_CHECKPOINT_MAP]: {\n        ...parents,\n        [config.configurable?.checkpoint_ns ?? \"\"]:\n          config.configurable?.checkpoint_id,\n      },\n    });\n  } else {\n    return config;\n  }\n}\n\n/**\n * Combine multiple abort signals into a single abort signal.\n * @param signals - The abort signals to combine.\n * @returns A combined abort signal and a dispose function to remove the abort listener if unused.\n */\nexport function combineAbortSignals(...x: (AbortSignal | undefined)[]): {\n  signal: AbortSignal | undefined;\n  dispose?: () => void;\n} {\n  const signals = [...new Set(x.filter(Boolean))] as AbortSignal[];\n\n  if (signals.length === 0) {\n    return { signal: undefined, dispose: undefined };\n  }\n\n  if (signals.length === 1) {\n    return { signal: signals[0], dispose: undefined };\n  }\n\n  const combinedController = new AbortController();\n  const listener = () => {\n    const reason = signals.find((s) => s.aborted)?.reason;\n    combinedController.abort(reason);\n    signals.forEach((s) => s.removeEventListener(\"abort\", listener));\n  };\n\n  signals.forEach((s) => s.addEventListener(\"abort\", listener, { once: true }));\n\n  const hasAlreadyAbortedSignal = signals.find((s) => s.aborted);\n  if (hasAlreadyAbortedSignal) {\n    combinedController.abort(hasAlreadyAbortedSignal.reason);\n  }\n\n  return {\n    signal: combinedController.signal,\n    dispose: () => {\n      signals.forEach((s) => s.removeEventListener(\"abort\", listener));\n    },\n  };\n}\n\n/**\n * Combine multiple callbacks into a single callback.\n * @param callback1 - The first callback to combine.\n * @param callback2 - The second callback to combine.\n * @returns A single callback that is a combination of the input callbacks.\n */\nexport const combineCallbacks = (\n  callback1?: Callbacks,\n  callback2?: Callbacks\n): Callbacks | undefined => {\n  if (!callback1 && !callback2) {\n    return undefined;\n  }\n\n  if (!callback1) {\n    return callback2;\n  }\n\n  if (!callback2) {\n    return callback1;\n  }\n  if (Array.isArray(callback1) && Array.isArray(callback2)) {\n    return [...callback1, ...callback2];\n  }\n  if (Array.isArray(callback1)) {\n    return [...callback1, callback2] as Callbacks;\n  }\n  if (Array.isArray(callback2)) {\n    return [callback1, ...callback2];\n  }\n  return [callback1, callback2] as Callbacks;\n};\n", "import type { Runnable, RunnableConfig } from \"@langchain/core/runnables\";\nimport type {\n  All,\n  PendingWrite,\n  CheckpointMetadata,\n  BaseCheckpointSaver,\n  BaseStore,\n  CheckpointListOptions,\n  BaseCache,\n} from \"@langchain/langgraph-checkpoint\";\nimport { Graph as DrawableGraph } from \"@langchain/core/runnables/graph\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport type { BaseMessage } from \"@langchain/core/messages\";\nimport type { BaseChannel } from \"../channels/base.js\";\nimport type { PregelNode } from \"./read.js\";\nimport type { Interrupt } from \"../constants.js\";\nimport { CachePolicy, RetryPolicy } from \"./utils/index.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\n\n/**\n * Selects the type of output you'll receive when streaming from the graph. See [Streaming](/langgraphjs/how-tos/#streaming) for more details.\n */\nexport type StreamMode =\n  | \"values\"\n  | \"updates\"\n  | \"debug\"\n  | \"messages\"\n  | \"checkpoints\"\n  | \"tasks\"\n  | \"custom\";\n\nexport type Durability = \"exit\" | \"async\" | \"sync\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelInputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelOutputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype StreamMessageOutput = [BaseMessage, Record<string, any>];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype StreamDebugOutput = Record<string, any>;\n\ntype StreamCheckpointsOutput<StreamValues> = {\n  values: StreamValues;\n  next: string[];\n  config: RunnableConfig;\n  metadata?: CheckpointMetadata;\n  parentConfig?: RunnableConfig | undefined;\n  tasks: PregelTaskDescription[];\n};\n\ninterface StreamTasksOutputBase {\n  id: string;\n  name: string;\n  interrupts: Interrupt[];\n}\n\ninterface StreamTasksCreateOutput<StreamValues> extends StreamTasksOutputBase {\n  input: StreamValues;\n  triggers: string[];\n}\n\ninterface StreamTasksResultOutput<Keys, StreamUpdates>\n  extends StreamTasksOutputBase {\n  result: [Keys, StreamUpdates][];\n}\n\ntype StreamTasksOutput<StreamUpdates, StreamValues, Nodes = string> =\n  | StreamTasksCreateOutput<StreamValues>\n  | StreamTasksResultOutput<Nodes, StreamUpdates>;\n\ntype DefaultStreamMode = \"updates\";\n\nexport type IsEventStream<T> = [T] extends [\"text/event-stream\"]\n  ? [\"text/event-stream\"] extends [T]\n    ? true\n    : false\n  : false;\n\nexport type StreamOutputMap<\n  TStreamMode extends StreamMode | StreamMode[] | undefined,\n  TStreamSubgraphs extends boolean,\n  StreamUpdates,\n  StreamValues,\n  Nodes,\n  NodeReturnType,\n  StreamCustom,\n  TEncoding extends \"text/event-stream\" | undefined\n> = IsEventStream<TEncoding> extends true\n  ? Uint8Array\n  : (\n      undefined extends TStreamMode\n        ? []\n        : StreamMode | StreamMode[] extends TStreamMode\n        ? TStreamMode extends StreamMode[]\n          ? TStreamMode[number]\n          : TStreamMode\n        : TStreamMode extends StreamMode[]\n        ? TStreamMode[number]\n        : []\n    ) extends infer Multiple extends StreamMode\n  ? [TStreamSubgraphs] extends [true]\n    ? {\n        values: [string[], \"values\", StreamValues];\n        updates: [\n          string[],\n          \"updates\",\n          NodeReturnType extends Record<string, unknown>\n            ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n            : Record<Nodes extends string ? Nodes : string, StreamUpdates>\n        ];\n        messages: [string[], \"messages\", StreamMessageOutput];\n        custom: [string[], \"custom\", StreamCustom];\n        checkpoints: [\n          string[],\n          \"checkpoints\",\n          StreamCheckpointsOutput<StreamValues>\n        ];\n        tasks: [\n          string[],\n          \"tasks\",\n          StreamTasksOutput<StreamUpdates, StreamValues>\n        ];\n        debug: [string[], \"debug\", StreamDebugOutput];\n      }[Multiple]\n    : {\n        values: [\"values\", StreamValues];\n        updates: [\n          \"updates\",\n          NodeReturnType extends Record<string, unknown>\n            ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n            : Record<Nodes extends string ? Nodes : string, StreamUpdates>\n        ];\n        messages: [\"messages\", StreamMessageOutput];\n        custom: [\"custom\", StreamCustom];\n        checkpoints: [\"checkpoints\", StreamCheckpointsOutput<StreamValues>];\n        tasks: [\"tasks\", StreamTasksOutput<StreamUpdates, StreamValues, Nodes>];\n        debug: [\"debug\", StreamDebugOutput];\n      }[Multiple]\n  : (\n      undefined extends TStreamMode ? DefaultStreamMode : TStreamMode\n    ) extends infer Single extends StreamMode\n  ? [TStreamSubgraphs] extends [true]\n    ? {\n        values: [string[], StreamValues];\n        updates: [\n          string[],\n          NodeReturnType extends Record<string, unknown>\n            ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n            : Record<Nodes extends string ? Nodes : string, StreamUpdates>\n        ];\n        messages: [string[], StreamMessageOutput];\n        custom: [string[], StreamCustom];\n        checkpoints: [string[], StreamCheckpointsOutput<StreamValues>];\n        tasks: [\n          string[],\n          StreamTasksOutput<StreamUpdates, StreamValues, Nodes>\n        ];\n        debug: [string[], StreamDebugOutput];\n      }[Single]\n    : {\n        values: StreamValues;\n        updates: NodeReturnType extends Record<string, unknown>\n          ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n          : Record<Nodes extends string ? Nodes : string, StreamUpdates>;\n        messages: StreamMessageOutput;\n        custom: StreamCustom;\n        checkpoints: StreamCheckpointsOutput<StreamValues>;\n        tasks: StreamTasksOutput<StreamUpdates, StreamValues, Nodes>;\n        debug: StreamDebugOutput;\n      }[Single]\n  : never;\n\n/**\n * Configuration options for executing a Pregel graph.\n * These options control how the graph executes, what data is streamed, and how interrupts are handled.\n *\n * @typeParam Nodes - Mapping of node names to their {@link PregelNode} implementations\n * @typeParam Channels - Mapping of channel names to their {@link BaseChannel} implementations\n * @typeParam ContextType - Type of context that can be passed to the graph\n */\nexport interface PregelOptions<\n  Nodes extends StrRecord<string, PregelNode>,\n  Channels extends StrRecord<string, BaseChannel>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextType extends Record<string, any> = Record<string, any>,\n  TStreamMode extends StreamMode | StreamMode[] | undefined =\n    | StreamMode\n    | StreamMode[]\n    | undefined,\n  TSubgraphs extends boolean = boolean,\n  TEncoding extends \"text/event-stream\" | undefined =\n    | \"text/event-stream\"\n    | undefined\n> extends RunnableConfig<ContextType> {\n  /**\n   * Controls what information is streamed during graph execution.\n   * Multiple modes can be enabled simultaneously.\n   *\n   * Supported modes:\n   * - \"values\": Streams complete state after each step\n   * - \"updates\": Streams only state changes after each step\n   * - \"messages\": Streams messages from within nodes\n   * - \"custom\": Streams custom events from within nodes\n   * - \"debug\": Streams detailed execution events for tracing & debugging\n   *\n   * @example\n   * ```typescript\n   * // Stream only values\n   * streamMode: \"values\"\n   *\n   * // Stream both values and debug info\n   * streamMode: [\"values\", \"debug\"]\n   * ```\n   *\n   * @default [\"values\"]\n   */\n  streamMode?: TStreamMode;\n\n  /**\n   * Specifies which channel keys to retrieve from the checkpoint when resuming execution.\n   * This is an advanced option that you generally don't need to set manually.\n   * The graph will automatically determine the appropriate input keys based on its configuration.\n   */\n  inputKeys?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * Specifies which channel keys to include in the output stream and final result.\n   * Use this to filter which parts of the graph state you want to observe.\n   *\n   * @example\n   * ```typescript\n   * // Stream only the 'result' channel\n   * outputKeys: \"result\"\n   *\n   * // Stream multiple channels\n   * outputKeys: [\"result\", \"intermediateState\"]\n   * ```\n   */\n  outputKeys?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * List of nodes where execution should be interrupted BEFORE the node runs.\n   * Can be used for debugging and advanced state manipulation use cases. For\n   * human-in-the-loop workflows, developers should prefer the\n   * @link {interrupt} function instead.\n   *\n   * When interrupted, a resume @link {Command} must be provided to continue\n   * execution.\n   *\n   * @example\n   * ```typescript\n   * // Interrupt before specific nodes\n   * interruptBefore: [\"humanReview\", \"qualityCheck\"]\n   *\n   * // Interrupt before all nodes\n   * interruptBefore: \"all\"\n   * ```\n   */\n  interruptBefore?: All | Array<keyof Nodes>;\n\n  /**\n   * List of nodes where execution should be interrupted AFTER the node runs.\n   * Similar to interruptBefore, but interrupts after node completion.\n   * Useful when the node's output needs to be reviewed before proceeding.\n   *\n   * @example\n   * ```typescript\n   * // Interrupt after specific nodes\n   * interruptAfter: [\"generateContent\", \"analyze\"]\n   *\n   * // Interrupt after all nodes\n   * interruptAfter: \"all\"\n   * ```\n   */\n  interruptAfter?: All | Array<keyof Nodes>;\n\n  /**\n   * Enables detailed debug logging during graph execution.\n   * When enabled, prints information about:\n   * - Task execution\n   * - Channel updates\n   * - Checkpoint writes\n   *\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * Whether to include subgraph execution details in the stream.\n   * When true, state updates from nested graphs will also be streamed.\n   *\n   * @default false\n   */\n  subgraphs?: TSubgraphs;\n\n  /**\n   * Whether to checkpoint intermediate steps, defaults to `true`.\n   * If `false`, only the final checkpoint is saved.\n   * @deprecated Use `durability` instead.\n   */\n  checkpointDuring?: boolean;\n\n  /**\n   * Whether to checkpoint during the run (or only at the end/interruption).\n   * - `\"async\"`: Save checkpoint asynchronously while the next step executes (default).\n   * - `\"sync\"`: Save checkpoint synchronously before the next step starts.\n   * - `\"exit\"`: Save checkpoint only when the graph exits.\n   * @default \"async\"\n   */\n  durability?: Durability;\n\n  /**\n   * A shared value store that allows you to store and retrieve state across\n   * threads. Useful for implementing long-term memory patterns.\n   */\n  store?: BaseStore;\n\n  /**\n   * Optional cache for the graph, useful for caching tasks.\n   */\n  cache?: BaseCache;\n\n  /**\n   * Static context for the graph run, like `userId`, `dbConnection` etc.\n   */\n  context?: ContextType;\n\n  /**\n   * The encoding to use for the stream.\n   * - `undefined`: Use the default format.\n   * - `\"text/event-stream\"`: Use the Server-Sent Events format.\n   * @default undefined\n   */\n  encoding?: TEncoding;\n}\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype StrRecord<K extends string, T> = {\n  [P in K]: T;\n};\n\nexport interface PregelInterface<\n  Nodes extends StrRecord<string, PregelNode>,\n  Channels extends StrRecord<string, BaseChannel>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextType extends Record<string, any> = StrRecord<string, any>\n> {\n  lg_is_pregel: boolean;\n\n  withConfig(config: RunnableConfig): PregelInterface<Nodes, Channels>;\n\n  getGraphAsync(\n    config: RunnableConfig & { xray?: boolean | number }\n  ): Promise<DrawableGraph>;\n\n  /** @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release. */\n  getSubgraphs(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Generator<[string, PregelInterface<any, any>]>;\n\n  getSubgraphsAsync(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<[string, PregelInterface<any, any>]>;\n\n  getState(\n    config: RunnableConfig,\n    options?: { subgraphs?: boolean }\n  ): Promise<StateSnapshot>;\n\n  getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot>;\n\n  updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: keyof Nodes | string\n  ): Promise<RunnableConfig>;\n\n  stream(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nodes, Channels, ContextType>>\n  ): Promise<IterableReadableStream<PregelOutputType>>;\n\n  invoke(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nodes, Channels, ContextType>>\n  ): Promise<PregelOutputType>;\n}\n\n/**\n * Parameters for creating a Pregel graph.\n * @internal\n */\nexport type PregelParams<\n  Nodes extends StrRecord<string, PregelNode>,\n  Channels extends StrRecord<string, BaseChannel>\n> = {\n  /**\n   * The name of the graph. @see {@link Runnable.name}\n   */\n  name?: string;\n\n  /**\n   * The nodes in the graph.\n   */\n  nodes: Nodes;\n\n  /**\n   * The channels in the graph.\n   */\n  channels: Channels;\n\n  /**\n   * Whether to validate the graph.\n   *\n   * @default true\n   */\n  autoValidate?: boolean;\n\n  /**\n   * The stream mode for the graph run. See [Streaming](/langgraphjs/how-tos/#streaming) for more details.\n   *\n   * @default [\"values\"]\n   */\n  streamMode?: StreamMode | StreamMode[];\n\n  /**\n   * The input channels for the graph run.\n   */\n  inputChannels: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * The output channels for the graph run.\n   */\n  outputChannels: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * After processing one of the nodes named in this list, the graph will be interrupted and a resume {@link Command} must be provided to proceed with the execution of this thread.\n   * @default []\n   */\n  interruptAfter?: Array<keyof Nodes> | All;\n\n  /**\n   * Before processing one of the nodes named in this list, the graph will be interrupted and a resume {@link Command} must be provided to proceed with the execution of this thread.\n   * @default []\n   */\n  interruptBefore?: Array<keyof Nodes> | All;\n\n  /**\n   * The channels to stream from the graph run.\n   * @default []\n   */\n  streamChannels?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * @default undefined\n   */\n  stepTimeout?: number;\n\n  /**\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * The {@link BaseCheckpointSaver | checkpointer} to use for the graph run.\n   */\n  checkpointer?: BaseCheckpointSaver | boolean;\n\n  /**\n   * The default retry policy for this graph. For defaults, see {@link RetryPolicy}.\n   */\n  retryPolicy?: RetryPolicy;\n\n  /**\n   * The configuration for the graph run.\n   */\n  config?: LangGraphRunnableConfig;\n\n  /**\n   * External key-value store.\n   */\n  store?: BaseStore;\n\n  /**\n   * Storage used for node caching.\n   */\n  cache?: BaseCache;\n\n  /**\n   * The trigger to node mapping for the graph run.\n   * @internal\n   */\n  triggerToNodes?: Record<string, string[]>;\n\n  /**\n   * Interrupt helper function.\n   * @internal\n   */\n  userInterrupt?: unknown;\n};\n\nexport interface PregelTaskDescription {\n  readonly id: string;\n  readonly name: string;\n  readonly error?: unknown;\n  readonly interrupts: Interrupt[];\n  readonly state?: LangGraphRunnableConfig | StateSnapshot;\n  readonly path?: TaskPath;\n  readonly result?: unknown;\n}\n\ninterface CacheKey {\n  ns: string[];\n  key: string;\n  ttl?: number;\n}\n\nexport interface PregelExecutableTask<\n  NodeKey extends PropertyKey,\n  ChannelKey extends PropertyKey\n> {\n  readonly name: NodeKey;\n  readonly input: unknown;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly proc: Runnable<any, any, LangGraphRunnableConfig>;\n  readonly writes: PendingWrite<ChannelKey>[];\n  readonly config?: LangGraphRunnableConfig;\n  readonly triggers: Array<string>;\n  readonly retry_policy?: RetryPolicy;\n  readonly cache_key?: CacheKey;\n  readonly id: string;\n  readonly path?: TaskPath;\n  readonly subgraphs?: Runnable[];\n  readonly writers: Runnable[];\n}\n\nexport interface StateSnapshot {\n  /**\n   * Current values of channels\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly values: Record<string, any> | any;\n  /**\n   * Nodes to execute in the next step, if any\n   */\n  readonly next: Array<string>;\n  /**\n   * Config used to fetch this snapshot\n   */\n  readonly config: RunnableConfig;\n  /**\n   * Metadata about the checkpoint\n   */\n  readonly metadata?: CheckpointMetadata;\n  /**\n   * Time when the snapshot was created\n   */\n  readonly createdAt?: string;\n  /**\n   * Config used to fetch the parent snapshot, if any\n   * @default undefined\n   */\n  readonly parentConfig?: RunnableConfig | undefined;\n  /**\n   * Tasks to execute in this step. If already attempted, may contain an error.\n   */\n  readonly tasks: PregelTaskDescription[];\n}\n\n/**\n * Options for subscribing to multiple channels.\n */\nexport type MultipleChannelSubscriptionOptions = {\n  /**\n   * Optional tags to associate with the subscription.\n   */\n  tags?: string[];\n};\n\n/**\n * Options for subscribing to a single channel.\n */\nexport type SingleChannelSubscriptionOptions = {\n  /**\n   * When specified, the channel mapping will be an object with this key pointing\n   * to the array of channels to subscribe to. Otherwise, the channel mapping\n   * will be an array of channels.\n   */\n  key?: string;\n  /**\n   * Optional tags to associate with the subscription.\n   */\n  tags?: string[];\n};\n\n/**\n * Options for getting the state of the graph.\n */\nexport type GetStateOptions = {\n  /**\n   * Whether to include subgraph states.\n   * @default false\n   */\n  subgraphs?: boolean;\n};\n\n/**\n * Used for storing/retrieving internal execution state.\n *\n * @internal\n */\nexport type PregelScratchpad<Resume = unknown> = {\n  /** Counter for tracking call invocations */\n  callCounter: number;\n  /** Counter for tracking interrupts */\n  interruptCounter: number;\n  /** List of resume values */\n  resume: Resume[];\n  /** Single resume value for null task ID */\n  nullResume: Resume;\n\n  consumeNullResume: () => Resume | undefined;\n  /** Counter for tracking subgraph invocations */\n  subgraphCounter: number;\n\n  /** The input to the currently executing task */\n  currentTaskInput: unknown;\n};\n\n/**\n * @internal\n */\nexport type PregelAbortSignals = {\n  /** Aborts when the user calls `stream.cancel()` or aborts the {@link AbortSignal} that they passed in via the `signal` option */\n  externalAbortSignal?: AbortSignal;\n\n  /**\n   * Aborts when the currently executing task throws any error other than a {@link GraphBubbleUp}\n   */\n  timeoutAbortSignal?: AbortSignal;\n\n  /**\n   * A reference to the AbortSignal that is passed to the node. Aborts on step timeout, stream cancel, or when an error is thrown.\n   */\n  composedAbortSignal?: AbortSignal;\n};\n\nexport type CallOptions = {\n  func: (...args: unknown[]) => unknown | Promise<unknown>;\n  name: string;\n  input: unknown;\n  cache?: CachePolicy;\n  retry?: RetryPolicy;\n  callbacks?: unknown;\n};\n\nexport class Call {\n  func: (...args: unknown[]) => unknown | Promise<unknown>;\n\n  name: string;\n\n  input: unknown;\n\n  retry?: RetryPolicy;\n\n  cache?: CachePolicy;\n\n  callbacks?: unknown;\n\n  readonly __lg_type = \"call\";\n\n  constructor({ func, name, input, retry, cache, callbacks }: CallOptions) {\n    this.func = func;\n    this.name = name;\n    this.input = input;\n    this.retry = retry;\n    this.cache = cache;\n    this.callbacks = callbacks;\n  }\n}\n\nexport function isCall(value: unknown): value is Call {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"__lg_type\" in value &&\n    value.__lg_type === \"call\"\n  );\n}\n\nexport type SimpleTaskPath = [string, string | number];\nexport type VariadicTaskPath = [string, ...(string | number)[], boolean];\nexport type CallTaskPath =\n  | [string, ...(string | number)[], Call]\n  | [string, TaskPath, ...(string | number)[], Call];\nexport type TaskPath = SimpleTaskPath | CallTaskPath | VariadicTaskPath;\n", "import {\n  Runnable,\n  RunnableConfig,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { CONFIG_KEY_CALL, RETURN, TAG_HIDDEN } from \"../constants.js\";\nimport { ChannelWrite, PASSTHROUGH } from \"./write.js\";\nimport { CachePolicy, RetryPolicy } from \"./utils/index.js\";\nimport { RunnableCallable, type RunnableCallableArgs } from \"../utils.js\";\nimport { EntrypointFunc, EntrypointReturnT, TaskFunc } from \"../func/types.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\n\n/**\n * Wraps a user function in a Runnable that writes the returned value to the RETURN channel.\n */\nexport function getRunnableForFunc<ArgsT extends unknown[], OutputT>(\n  name: string,\n  func: TaskFunc<ArgsT, OutputT>\n): Runnable<ArgsT, OutputT, LangGraphRunnableConfig> {\n  const run = new RunnableCallable<ArgsT, OutputT>({\n    func: (input: ArgsT) => func(...input),\n    name,\n    trace: false,\n    recurse: false,\n  } as RunnableCallableArgs);\n\n  return new RunnableSequence<ArgsT, OutputT>({\n    name,\n    first: run,\n    last: new ChannelWrite<OutputT>(\n      [{ channel: RETURN, value: PASSTHROUGH }],\n      [TAG_HIDDEN]\n    ),\n  });\n}\n\nexport function getRunnableForEntrypoint<InputT, OutputT>(\n  name: string,\n  func: EntrypointFunc<InputT, OutputT>\n): Runnable<InputT, EntrypointReturnT<OutputT>, LangGraphRunnableConfig> {\n  const run = new RunnableCallable<InputT, EntrypointReturnT<OutputT>>({\n    func: (input: InputT, config: LangGraphRunnableConfig) => {\n      return func(input, config);\n    },\n    name,\n    trace: false,\n    recurse: false,\n  });\n\n  return run;\n}\n\nexport type CallWrapperOptions<ArgsT extends unknown[], OutputT> = {\n  func: TaskFunc<ArgsT, OutputT>;\n  name: string;\n  retry?: RetryPolicy;\n  cache?: CachePolicy;\n};\n\nexport function call<ArgsT extends unknown[], OutputT>(\n  { func, name, cache, retry }: CallWrapperOptions<ArgsT, OutputT>,\n  ...args: ArgsT\n): Promise<OutputT> {\n  const config =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig() as RunnableConfig;\n  if (typeof config.configurable?.[CONFIG_KEY_CALL] === \"function\") {\n    return config.configurable[CONFIG_KEY_CALL](func, name, args, {\n      retry,\n      cache,\n      callbacks: config.callbacks,\n    });\n  }\n  throw new Error(\n    \"Async local storage not initialized. Please call initializeAsyncLocalStorageSingleton() before using this function.\"\n  );\n}\n", "/* eslint-disable no-param-reassign */\nimport {\n  mergeConfigs,\n  patchConfig,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  All,\n  BaseCheckpointSaver,\n  Checkpoint,\n  ReadonlyCheckpoint,\n  copyCheckpoint,\n  type PendingWrite,\n  type PendingWriteValue,\n  uuid5,\n  maxChannelVersion,\n  BaseStore,\n  CheckpointPendingWrite,\n  SendProtocol,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n  getOnlyChannels,\n} from \"../channels/base.js\";\nimport { PregelNode } from \"./read.js\";\nimport { readChannel, readChannels } from \"./io.js\";\nimport {\n  _isSend,\n  _isSendInterface,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_TASK_ID,\n  CONFIG_KEY_SEND,\n  INTERRUPT,\n  RESERVED,\n  Send,\n  TAG_HIDDEN,\n  TASKS,\n  CHECKPOINT_NAMESPACE_END,\n  PUSH,\n  PULL,\n  RESUME,\n  NULL_TASK_ID,\n  CONFIG_KEY_SCRATCHPAD,\n  RETURN,\n  ERROR,\n  NO_WRITES,\n  CONFIG_KEY_PREVIOUS_STATE,\n  PREVIOUS,\n  CACHE_NS_WRITES,\n  CONFIG_KEY_RESUME_MAP,\n  START,\n} from \"../constants.js\";\nimport {\n  Call,\n  isCall,\n  PregelExecutableTask,\n  PregelScratchpad,\n  PregelTaskDescription,\n  SimpleTaskPath,\n  TaskPath,\n  VariadicTaskPath,\n} from \"./types.js\";\nimport { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { getNullChannelVersion } from \"./utils/index.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { getRunnableForFunc } from \"./call.js\";\nimport { IterableReadableWritableStream } from \"./stream.js\";\nimport { XXH3 } from \"../hash.js\";\nimport { Topic } from \"../channels/topic.js\";\n\n/**\n * Construct a type with a set of properties K of type T\n */\nexport type StrRecord<K extends string, T> = {\n  [P in K]: T;\n};\n\nexport type WritesProtocol<C = string> = {\n  name: string;\n  writes: PendingWrite<C>[];\n  triggers: string[];\n  path?: TaskPath;\n};\n\nexport const increment = (current?: number) => {\n  return current !== undefined ? current + 1 : 1;\n};\n\nfunction triggersNextStep(\n  updatedChannels: Set<string>,\n  triggerToNodes: Record<string, string[]> | undefined\n) {\n  if (triggerToNodes == null) return false;\n\n  for (const chan of updatedChannels) {\n    if (triggerToNodes[chan]) return true;\n  }\n\n  return false;\n}\n\n// Avoids unnecessary double iteration\nfunction maxChannelMapVersion(\n  channelVersions: Record<string, number | string>\n): number | string | undefined {\n  let maxVersion: number | string | undefined;\n  for (const chan in channelVersions) {\n    if (!Object.prototype.hasOwnProperty.call(channelVersions, chan)) continue;\n    if (maxVersion == null) {\n      maxVersion = channelVersions[chan];\n    } else {\n      maxVersion = maxChannelVersion(maxVersion, channelVersions[chan]);\n    }\n  }\n  return maxVersion;\n}\n\nexport function shouldInterrupt<N extends PropertyKey, C extends PropertyKey>(\n  checkpoint: Checkpoint,\n  interruptNodes: All | N[],\n  tasks: PregelExecutableTask<N, C>[]\n): boolean {\n  const nullVersion = getNullChannelVersion(checkpoint.channel_versions);\n  const seen = checkpoint.versions_seen[INTERRUPT] ?? {};\n\n  let anyChannelUpdated = false;\n\n  if (\n    (checkpoint.channel_versions[START] ?? nullVersion) >\n    (seen[START] ?? nullVersion)\n  ) {\n    anyChannelUpdated = true;\n  } else {\n    for (const chan in checkpoint.channel_versions) {\n      if (\n        !Object.prototype.hasOwnProperty.call(checkpoint.channel_versions, chan)\n      )\n        continue;\n\n      if (checkpoint.channel_versions[chan] > (seen[chan] ?? nullVersion)) {\n        anyChannelUpdated = true;\n        break;\n      }\n    }\n  }\n\n  const anyTriggeredNodeInInterruptNodes = tasks.some((task) =>\n    interruptNodes === \"*\"\n      ? !task.config?.tags?.includes(TAG_HIDDEN)\n      : interruptNodes.includes(task.name)\n  );\n\n  return anyChannelUpdated && anyTriggeredNodeInInterruptNodes;\n}\n\nexport function _localRead<Cc extends Record<string, BaseChannel>>(\n  checkpoint: ReadonlyCheckpoint,\n  channels: Cc,\n  task: WritesProtocol<keyof Cc>,\n  select: Array<keyof Cc> | keyof Cc,\n  fresh: boolean = false\n): Record<string, unknown> | unknown {\n  let updated = new Set<keyof Cc>();\n\n  if (!Array.isArray(select)) {\n    for (const [c] of task.writes) {\n      if (c === select) {\n        updated = new Set([c]);\n        break;\n      }\n    }\n    updated = updated || new Set();\n  } else {\n    updated = new Set(\n      select.filter((c) => task.writes.some(([key, _]) => key === c))\n    );\n  }\n\n  let values: Record<string, unknown>;\n\n  if (fresh && updated.size > 0) {\n    const localChannels = Object.fromEntries(\n      Object.entries(channels).filter(([k, _]) => updated.has(k as keyof Cc))\n    ) as Partial<Cc>;\n\n    const newCheckpoint = createCheckpoint(checkpoint, localChannels as Cc, -1);\n    const newChannels = emptyChannels(localChannels as Cc, newCheckpoint);\n\n    _applyWrites(\n      copyCheckpoint(newCheckpoint),\n      newChannels,\n      [task],\n      undefined,\n      undefined\n    );\n    values = readChannels({ ...channels, ...newChannels }, select);\n  } else {\n    values = readChannels(channels, select);\n  }\n\n  return values;\n}\n\nexport function _localWrite(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  commit: (writes: [string, any][]) => any,\n  processes: Record<string, PregelNode>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  writes: [string, any][]\n) {\n  for (const [chan, value] of writes) {\n    if ([PUSH, TASKS].includes(chan) && value != null) {\n      if (!_isSend(value)) {\n        throw new InvalidUpdateError(\n          `Invalid packet type, expected SendProtocol, got ${JSON.stringify(\n            value\n          )}`\n        );\n      }\n      if (!(value.node in processes)) {\n        throw new InvalidUpdateError(\n          `Invalid node name \"${value.node}\" in Send packet`\n        );\n      }\n    }\n  }\n  commit(writes);\n}\n\nconst IGNORE = new Set<string | number | symbol>([\n  NO_WRITES,\n  PUSH,\n  RESUME,\n  INTERRUPT,\n  RETURN,\n  ERROR,\n]);\n\nexport function _applyWrites<Cc extends Record<string, BaseChannel>>(\n  checkpoint: Checkpoint,\n  channels: Cc,\n  tasks: WritesProtocol<keyof Cc>[],\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getNextVersion: ((version: any) => any) | undefined,\n  triggerToNodes: Record<string, string[]> | undefined\n): Set<string> {\n  // Sort tasks by first 3 path elements for deterministic order\n  // Later path parts (like task IDs) are ignored for sorting\n  tasks.sort((a, b) => {\n    const aPath = a.path?.slice(0, 3) || [];\n    const bPath = b.path?.slice(0, 3) || [];\n\n    // Compare each path element\n    for (let i = 0; i < Math.min(aPath.length, bPath.length); i += 1) {\n      if (aPath[i] < bPath[i]) return -1;\n      if (aPath[i] > bPath[i]) return 1;\n    }\n\n    // If one path is shorter, it comes first\n    return aPath.length - bPath.length;\n  });\n\n  // if no task has triggers this is applying writes from the null task only\n  // so we don't do anything other than update the channels written to\n  const bumpStep = tasks.some((task) => task.triggers.length > 0);\n\n  // Filter out non instances of BaseChannel\n  const onlyChannels = getOnlyChannels(channels);\n\n  // Update seen versions\n  for (const task of tasks) {\n    checkpoint.versions_seen[task.name] ??= {};\n    for (const chan of task.triggers) {\n      if (chan in checkpoint.channel_versions) {\n        checkpoint.versions_seen[task.name][chan] =\n          checkpoint.channel_versions[chan];\n      }\n    }\n  }\n\n  // Find the highest version of all channels\n  let maxVersion = maxChannelMapVersion(checkpoint.channel_versions);\n\n  // Consume all channels that were read\n  const channelsToConsume = new Set(\n    tasks\n      .flatMap((task) => task.triggers)\n      .filter((chan) => !RESERVED.includes(chan))\n  );\n\n  let usedNewVersion = false;\n  for (const chan of channelsToConsume) {\n    if (chan in onlyChannels && onlyChannels[chan].consume()) {\n      if (getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n        usedNewVersion = true;\n      }\n    }\n  }\n\n  // Group writes by channel\n  const pendingWritesByChannel = {} as Record<keyof Cc, PendingWriteValue[]>;\n  for (const task of tasks) {\n    for (const [chan, val] of task.writes) {\n      if (IGNORE.has(chan)) {\n        // do nothing\n      } else if (chan in onlyChannels) {\n        pendingWritesByChannel[chan] ??= [];\n        pendingWritesByChannel[chan].push(val);\n      }\n    }\n  }\n\n  // Find the highest version of all channels\n  if (maxVersion != null && getNextVersion != null) {\n    maxVersion = usedNewVersion ? getNextVersion(maxVersion) : maxVersion;\n  }\n\n  const updatedChannels: Set<string> = new Set();\n  // Apply writes to channels\n  for (const [chan, vals] of Object.entries(pendingWritesByChannel)) {\n    if (chan in onlyChannels) {\n      const channel = onlyChannels[chan];\n      let updated;\n      try {\n        updated = channel.update(vals);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === InvalidUpdateError.unminifiable_name) {\n          const wrappedError = new InvalidUpdateError(\n            `Invalid update for channel \"${chan}\" with values ${JSON.stringify(\n              vals\n            )}: ${e.message}`\n          );\n          wrappedError.lc_error_code = e.lc_error_code;\n          throw wrappedError;\n        } else {\n          throw e;\n        }\n      }\n      if (updated && getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n\n        // unavailable channels can't trigger tasks, so don't add them\n        if (channel.isAvailable()) updatedChannels.add(chan);\n      }\n    }\n  }\n\n  // Channels that weren't updated in this step are notified of a new step\n  if (bumpStep) {\n    for (const chan in onlyChannels) {\n      if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;\n\n      const channel = onlyChannels[chan];\n      if (channel.isAvailable() && !updatedChannels.has(chan)) {\n        const updated = channel.update([]);\n\n        if (updated && getNextVersion !== undefined) {\n          checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n\n          // unavailable channels can't trigger tasks, so don't add them\n          if (channel.isAvailable()) updatedChannels.add(chan);\n        }\n      }\n    }\n  }\n\n  // If this is (tentatively) the last superstep, notify all channels of finish\n  if (bumpStep && !triggersNextStep(updatedChannels, triggerToNodes)) {\n    for (const chan in onlyChannels) {\n      if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;\n\n      const channel = onlyChannels[chan];\n      if (channel.finish() && getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n\n        // unavailable channels can't trigger tasks, so don't add them\n        if (channel.isAvailable()) updatedChannels.add(chan);\n      }\n    }\n  }\n\n  return updatedChannels;\n}\n\nfunction* candidateNodes(\n  checkpoint: ReadonlyCheckpoint,\n  processes: StrRecord<string, PregelNode>,\n  extra: NextTaskExtraFields\n) {\n  // This section is an optimization that allows which\n  // nodes will be active during the next step.\n  // When there's information about:\n  // 1. Which channels were updated in the previous step\n  // 2. Which nodes are triggered by which channels\n  // Then we can determine which nodes should be triggered\n  // in the next step without having to cycle through all nodes.\n  if (extra.updatedChannels != null && extra.triggerToNodes != null) {\n    const triggeredNodes = new Set<string>();\n\n    // Get all nodes that have triggers associated with an updated channel\n    for (const channel of extra.updatedChannels) {\n      const nodeIds = extra.triggerToNodes[channel];\n      for (const id of nodeIds ?? []) triggeredNodes.add(id);\n    }\n\n    // Sort the nodes to ensure deterministic order\n    yield* [...triggeredNodes].sort();\n    return;\n  }\n\n  // If there are no values in checkpoint, no need to run\n  // through all the PULL candidates\n  const isEmptyChannelVersions = (() => {\n    for (const chan in checkpoint.channel_versions) {\n      if (checkpoint.channel_versions[chan] !== null) return false;\n    }\n    return true;\n  })();\n\n  if (isEmptyChannelVersions) return;\n  for (const name in processes) {\n    if (!Object.prototype.hasOwnProperty.call(processes, name)) continue;\n    yield name;\n  }\n}\n\nexport type NextTaskExtraFields = {\n  step: number;\n  isResuming?: boolean;\n  checkpointer?: BaseCheckpointSaver;\n  manager?: CallbackManagerForChainRun;\n  store?: BaseStore;\n  stream?: IterableReadableWritableStream;\n  triggerToNodes?: Record<string, string[]>;\n  updatedChannels?: Set<string>;\n};\n\nexport type NextTaskExtraFieldsWithStore = NextTaskExtraFields & {\n  store?: BaseStore;\n};\n\nexport type NextTaskExtraFieldsWithoutStore = NextTaskExtraFields & {\n  store?: never;\n};\n\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: false,\n  extra: NextTaskExtraFieldsWithoutStore\n): Record<string, PregelTaskDescription>;\n\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: true,\n  extra: NextTaskExtraFieldsWithStore\n): Record<string, PregelExecutableTask<keyof Nn, keyof Cc>>;\n\n/**\n * Prepare the set of tasks that will make up the next Pregel step.\n * This is the union of all PUSH tasks (Sends) and PULL tasks (nodes triggered\n * by edges).\n */\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFieldsWithStore | NextTaskExtraFieldsWithoutStore\n):\n  | Record<string, PregelTaskDescription>\n  | Record<string, PregelExecutableTask<keyof Nn, keyof Cc>> {\n  const tasks:\n    | Record<string, PregelExecutableTask<keyof Nn, keyof Cc>>\n    | Record<string, PregelTaskDescription> = {};\n\n  // Consume pending tasks\n  const tasksChannel = channels[TASKS] as Topic<SendProtocol> | undefined;\n\n  if (tasksChannel?.isAvailable()) {\n    const len = tasksChannel.get().length;\n    for (let i = 0; i < len; i += 1) {\n      const task = _prepareSingleTask(\n        [PUSH, i],\n        checkpoint,\n        pendingWrites,\n        processes,\n        channels,\n        config,\n        forExecution,\n        extra\n      );\n      if (task !== undefined) {\n        tasks[task.id] = task;\n      }\n    }\n  }\n\n  // Check if any processes should be run in next step\n  // If so, prepare the values to be passed to them\n  for (const name of candidateNodes(checkpoint, processes, extra)) {\n    const task = _prepareSingleTask(\n      [PULL, name],\n      checkpoint,\n      pendingWrites,\n      processes,\n      channels,\n      config,\n      forExecution,\n      extra\n    );\n    if (task !== undefined) {\n      tasks[task.id] = task;\n    }\n  }\n  return tasks;\n}\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: SimpleTaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: false,\n  extra: NextTaskExtraFields\n): PregelTaskDescription | undefined;\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: TaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: true,\n  extra: NextTaskExtraFields\n): PregelExecutableTask<keyof Nn, keyof Cc> | undefined;\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: TaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFieldsWithStore\n): PregelTaskDescription | PregelExecutableTask<keyof Nn, keyof Cc> | undefined;\n\n/**\n * Prepares a single task for the next Pregel step, given a task path, which\n * uniquely identifies a PUSH or PULL task within the graph.\n */\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: TaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: LangGraphRunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFields\n):\n  | PregelTaskDescription\n  | PregelExecutableTask<keyof Nn, keyof Cc>\n  | undefined {\n  const { step, checkpointer, manager } = extra;\n  const configurable = config.configurable ?? {};\n  const parentNamespace = configurable.checkpoint_ns ?? \"\";\n\n  if (taskPath[0] === PUSH && isCall(taskPath[taskPath.length - 1])) {\n    const call = taskPath[taskPath.length - 1] as Call;\n    const proc = getRunnableForFunc(call.name, call.func);\n    const triggers = [PUSH];\n    const checkpointNamespace =\n      parentNamespace === \"\"\n        ? call.name\n        : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${call.name}`;\n    const id = uuid5(\n      JSON.stringify([\n        checkpointNamespace,\n        step.toString(),\n        call.name,\n        PUSH,\n        taskPath[1],\n        taskPath[2],\n      ]),\n      checkpoint.id\n    );\n    const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${id}`;\n\n    // we append `true` to the task path to indicate that a call is being made\n    // so we should not return interrupts from this task (responsibility lies with the parent)\n    const outputTaskPath = [...taskPath.slice(0, 3), true] as VariadicTaskPath;\n    const metadata = {\n      langgraph_step: step,\n      langgraph_node: call.name,\n      langgraph_triggers: triggers,\n      langgraph_path: outputTaskPath,\n      langgraph_checkpoint_ns: taskCheckpointNamespace,\n    };\n    if (forExecution) {\n      const writes: [keyof Cc, unknown][] = [];\n      const task = {\n        name: call.name,\n        input: call.input,\n        proc,\n        writes,\n        config: patchConfig(\n          mergeConfigs(config, {\n            metadata,\n            store: extra.store ?? config.store,\n          }),\n          {\n            runName: call.name,\n            callbacks: manager?.getChild(`graph:step:${step}`),\n            configurable: {\n              [CONFIG_KEY_TASK_ID]: id,\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              [CONFIG_KEY_SEND]: (writes_: PendingWrite[]) =>\n                _localWrite(\n                  (items: PendingWrite<keyof Cc>[]) => writes.push(...items),\n                  processes,\n                  writes_\n                ),\n              [CONFIG_KEY_READ]: (\n                select_: Array<keyof Cc> | keyof Cc,\n                fresh_: boolean = false\n              ) =>\n                _localRead(\n                  checkpoint,\n                  channels,\n                  {\n                    name: call.name,\n                    writes: writes as PendingWrite[],\n                    triggers,\n                    path: outputTaskPath,\n                  },\n                  select_,\n                  fresh_\n                ),\n              [CONFIG_KEY_CHECKPOINTER]:\n                checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n              [CONFIG_KEY_CHECKPOINT_MAP]: {\n                ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                [parentNamespace]: checkpoint.id,\n              },\n              [CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                pendingWrites: pendingWrites ?? [],\n                taskId: id,\n                currentTaskInput: call.input,\n                resumeMap: config.configurable?.[CONFIG_KEY_RESUME_MAP],\n                namespaceHash: XXH3(taskCheckpointNamespace),\n              }),\n              [CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[PREVIOUS],\n              checkpoint_id: undefined,\n              checkpoint_ns: taskCheckpointNamespace,\n            },\n          }\n        ),\n        triggers,\n        retry_policy: call.retry,\n        cache_key: call.cache\n          ? {\n              key: XXH3((call.cache.keyFunc ?? JSON.stringify)([call.input])),\n              ns: [CACHE_NS_WRITES, call.name ?? \"__dynamic__\"],\n              ttl: call.cache.ttl,\n            }\n          : undefined,\n        id,\n        path: outputTaskPath,\n        writers: [],\n      } satisfies PregelExecutableTask<keyof Nn, keyof Cc>;\n      return task;\n    } else {\n      return {\n        id,\n        name: call.name,\n        interrupts: [],\n        path: outputTaskPath,\n      };\n    }\n  } else if (taskPath[0] === PUSH) {\n    const index =\n      typeof taskPath[1] === \"number\"\n        ? taskPath[1]\n        : parseInt(taskPath[1] as string, 10);\n\n    if (!channels[TASKS]?.isAvailable()) {\n      return undefined;\n    }\n\n    const sends = channels[TASKS].get() as SendProtocol[];\n    if (index < 0 || index >= sends.length) {\n      return undefined;\n    }\n\n    const packet =\n      _isSendInterface(sends[index]) && !_isSend(sends[index])\n        ? new Send(sends[index].node, sends[index].args)\n        : sends[index];\n\n    if (!_isSendInterface(packet)) {\n      console.warn(\n        `Ignoring invalid packet ${JSON.stringify(packet)} in pending sends.`\n      );\n      return undefined;\n    }\n    if (!(packet.node in processes)) {\n      console.warn(\n        `Ignoring unknown node name ${packet.node} in pending sends.`\n      );\n      return undefined;\n    }\n    const triggers = [PUSH];\n    const checkpointNamespace =\n      parentNamespace === \"\"\n        ? packet.node\n        : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${packet.node}`;\n    const taskId = uuid5(\n      JSON.stringify([\n        checkpointNamespace,\n        step.toString(),\n        packet.node,\n        PUSH,\n        index.toString(),\n      ]),\n      checkpoint.id\n    );\n    const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;\n    let metadata = {\n      langgraph_step: step,\n      langgraph_node: packet.node,\n      langgraph_triggers: triggers,\n      langgraph_path: taskPath.slice(0, 3),\n      langgraph_checkpoint_ns: taskCheckpointNamespace,\n    };\n    if (forExecution) {\n      const proc = processes[packet.node];\n      const node = proc.getNode();\n      if (node !== undefined) {\n        if (proc.metadata !== undefined) {\n          metadata = { ...metadata, ...proc.metadata };\n        }\n        const writes: [keyof Cc, unknown][] = [];\n        return {\n          name: packet.node,\n          input: packet.args,\n          proc: node,\n          subgraphs: proc.subgraphs,\n          writes,\n          config: patchConfig(\n            mergeConfigs(config, {\n              metadata,\n              tags: proc.tags,\n              store: extra.store ?? config.store,\n            }),\n            {\n              runName: packet.node,\n              callbacks: manager?.getChild(`graph:step:${step}`),\n              configurable: {\n                [CONFIG_KEY_TASK_ID]: taskId,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                [CONFIG_KEY_SEND]: (writes_: PendingWrite[]) =>\n                  _localWrite(\n                    (items: PendingWrite<keyof Cc>[]) => writes.push(...items),\n                    processes,\n                    writes_\n                  ),\n                [CONFIG_KEY_READ]: (\n                  select_: Array<keyof Cc> | keyof Cc,\n                  fresh_: boolean = false\n                ) =>\n                  _localRead(\n                    checkpoint,\n                    channels,\n                    {\n                      name: packet.node,\n                      writes: writes as PendingWrite[],\n                      triggers,\n                      path: taskPath,\n                    },\n                    select_,\n                    fresh_\n                  ),\n                [CONFIG_KEY_CHECKPOINTER]:\n                  checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n                [CONFIG_KEY_CHECKPOINT_MAP]: {\n                  ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                  [parentNamespace]: checkpoint.id,\n                },\n                [CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                  pendingWrites: pendingWrites ?? [],\n                  taskId,\n                  currentTaskInput: packet.args,\n                  resumeMap: config.configurable?.[CONFIG_KEY_RESUME_MAP],\n                  namespaceHash: XXH3(taskCheckpointNamespace),\n                }),\n                [CONFIG_KEY_PREVIOUS_STATE]:\n                  checkpoint.channel_values[PREVIOUS],\n                checkpoint_id: undefined,\n                checkpoint_ns: taskCheckpointNamespace,\n              },\n            }\n          ),\n          triggers,\n          retry_policy: proc.retryPolicy,\n          cache_key: proc.cachePolicy\n            ? {\n                key: XXH3(\n                  (proc.cachePolicy.keyFunc ?? JSON.stringify)([packet.args])\n                ),\n                ns: [CACHE_NS_WRITES, proc.name ?? \"__dynamic__\", packet.node],\n                ttl: proc.cachePolicy.ttl,\n              }\n            : undefined,\n          id: taskId,\n          path: taskPath,\n          writers: proc.getWriters(),\n        } satisfies PregelExecutableTask<keyof Nn, keyof Cc>;\n      }\n    } else {\n      return {\n        id: taskId,\n        name: packet.node,\n        interrupts: [],\n        path: taskPath,\n      } satisfies PregelTaskDescription;\n    }\n  } else if (taskPath[0] === PULL) {\n    const name = taskPath[1].toString();\n    const proc = processes[name];\n    if (proc === undefined) {\n      return undefined;\n    }\n\n    // Check if this task already has successful writes in the pending writes\n    if (pendingWrites?.length) {\n      // Find the task ID for this node/path\n      const checkpointNamespace =\n        parentNamespace === \"\"\n          ? name\n          : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n\n      const taskId = uuid5(\n        JSON.stringify([\n          checkpointNamespace,\n          step.toString(),\n          name,\n          PULL,\n          name,\n        ]),\n        checkpoint.id\n      );\n\n      // Check if there are successful writes (not ERROR) for this task ID\n      const hasSuccessfulWrites = pendingWrites.some(\n        (w) => w[0] === taskId && w[1] !== ERROR\n      );\n\n      // If task completed successfully, don't include it in next tasks\n      if (hasSuccessfulWrites) {\n        return undefined;\n      }\n    }\n\n    const nullVersion = getNullChannelVersion(checkpoint.channel_versions);\n    if (nullVersion === undefined) {\n      return undefined;\n    }\n    const seen = checkpoint.versions_seen[name] ?? {};\n\n    // Find the first trigger that is available and has a new version\n    const trigger = proc.triggers.find((chan) => {\n      if (!channels[chan].isAvailable()) return false;\n\n      return (\n        (checkpoint.channel_versions[chan] ?? nullVersion) >\n        (seen[chan] ?? nullVersion)\n      );\n    });\n\n    // If any of the channels read by this process were updated\n    if (trigger !== undefined) {\n      const val = _procInput(proc, channels, forExecution);\n      if (val === undefined) {\n        return undefined;\n      }\n      const checkpointNamespace =\n        parentNamespace === \"\"\n          ? name\n          : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n      const taskId = uuid5(\n        JSON.stringify([\n          checkpointNamespace,\n          step.toString(),\n          name,\n          PULL,\n          [trigger],\n        ]),\n        checkpoint.id\n      );\n      const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;\n      let metadata = {\n        langgraph_step: step,\n        langgraph_node: name,\n        langgraph_triggers: [trigger],\n        langgraph_path: taskPath,\n        langgraph_checkpoint_ns: taskCheckpointNamespace,\n      };\n      if (forExecution) {\n        const node = proc.getNode();\n        if (node !== undefined) {\n          if (proc.metadata !== undefined) {\n            metadata = { ...metadata, ...proc.metadata };\n          }\n          const writes: [keyof Cc, unknown][] = [];\n          return {\n            name,\n            input: val,\n            proc: node,\n            subgraphs: proc.subgraphs,\n            writes,\n            config: patchConfig(\n              mergeConfigs(config, {\n                metadata,\n                tags: proc.tags,\n                store: extra.store ?? config.store,\n              }),\n              {\n                runName: name,\n                callbacks: manager?.getChild(`graph:step:${step}`),\n                configurable: {\n                  [CONFIG_KEY_TASK_ID]: taskId,\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  [CONFIG_KEY_SEND]: (writes_: PendingWrite[]) =>\n                    _localWrite(\n                      (items: PendingWrite<keyof Cc>[]) => {\n                        writes.push(...items);\n                      },\n                      processes,\n                      writes_\n                    ),\n                  [CONFIG_KEY_READ]: (\n                    select_: Array<keyof Cc> | keyof Cc,\n                    fresh_: boolean = false\n                  ) =>\n                    _localRead(\n                      checkpoint,\n                      channels,\n                      {\n                        name,\n                        writes: writes as PendingWrite[],\n                        triggers: [trigger],\n                        path: taskPath,\n                      },\n                      select_,\n                      fresh_\n                    ),\n                  [CONFIG_KEY_CHECKPOINTER]:\n                    checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n                  [CONFIG_KEY_CHECKPOINT_MAP]: {\n                    ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                    [parentNamespace]: checkpoint.id,\n                  },\n                  [CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                    pendingWrites: pendingWrites ?? [],\n                    taskId,\n                    currentTaskInput: val,\n                    resumeMap: config.configurable?.[CONFIG_KEY_RESUME_MAP],\n                    namespaceHash: XXH3(taskCheckpointNamespace),\n                  }),\n                  [CONFIG_KEY_PREVIOUS_STATE]:\n                    checkpoint.channel_values[PREVIOUS],\n                  checkpoint_id: undefined,\n                  checkpoint_ns: taskCheckpointNamespace,\n                },\n              }\n            ),\n            triggers: [trigger],\n            retry_policy: proc.retryPolicy,\n            cache_key: proc.cachePolicy\n              ? {\n                  key: XXH3(\n                    (proc.cachePolicy.keyFunc ?? JSON.stringify)([val])\n                  ),\n                  ns: [CACHE_NS_WRITES, proc.name ?? \"__dynamic__\", name],\n                  ttl: proc.cachePolicy.ttl,\n                }\n              : undefined,\n            id: taskId,\n            path: taskPath,\n            writers: proc.getWriters(),\n          } satisfies PregelExecutableTask<keyof Nn, keyof Cc>;\n        }\n      } else {\n        return {\n          id: taskId,\n          name,\n          interrupts: [],\n          path: taskPath,\n        } satisfies PregelTaskDescription;\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n *  Function injected under CONFIG_KEY_READ in task config, to read current state.\n *  Used by conditional edges to read a copy of the state with reflecting the writes\n *  from that node only.\n *\n * @internal\n */\nfunction _procInput(\n  proc: PregelNode,\n  channels: StrRecord<string, BaseChannel>,\n  forExecution: boolean\n) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let val: any;\n\n  if (typeof proc.channels === \"object\" && !Array.isArray(proc.channels)) {\n    val = {};\n    for (const [k, chan] of Object.entries(proc.channels)) {\n      if (proc.triggers.includes(chan)) {\n        try {\n          val[k] = readChannel(channels, chan, false);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          if (e.name === EmptyChannelError.unminifiable_name) {\n            return undefined;\n          } else {\n            throw e;\n          }\n        }\n      } else if (chan in channels) {\n        try {\n          val[k] = readChannel(channels, chan, false);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          if (e.name === EmptyChannelError.unminifiable_name) {\n            continue;\n          } else {\n            throw e;\n          }\n        }\n      }\n    }\n  } else if (Array.isArray(proc.channels)) {\n    let successfulRead = false;\n    for (const chan of proc.channels) {\n      try {\n        val = readChannel(channels, chan, false);\n        successfulRead = true;\n        break;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === EmptyChannelError.unminifiable_name) {\n          continue;\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (!successfulRead) {\n      return undefined;\n    }\n  } else {\n    throw new Error(\n      `Invalid channels type, expected list or dict, got ${proc.channels}`\n    );\n  }\n\n  // If the process has a mapper, apply it to the value\n  if (forExecution && proc.mapper !== undefined) {\n    val = proc.mapper(val);\n  }\n\n  return val;\n}\n\n/**\n * Remove any values belonging to UntrackedValue channels from a Send packet\n * before checkpointing.\n *\n * Send is often called with state to be passed to the destination node,\n * which may contain UntrackedValues at the top level.\n *\n * @internal\n */\nexport function sanitizeUntrackedValuesInSend(\n  packet: Send,\n  channels: StrRecord<string, BaseChannel>\n): Send {\n  if (typeof packet.args !== \"object\" || packet.args === null) {\n    // Not a dict-like arg\n    return packet;\n  }\n\n  // Top-level keys should be channel names\n  const sanitizedArg: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(packet.args)) {\n    const channel = channels[key];\n    // Check if channel is an UntrackedValue by its lc_graph_name\n    if (!channel || channel.lc_graph_name !== \"UntrackedValue\") {\n      sanitizedArg[key] = value;\n    }\n  }\n\n  return new Send(packet.node, sanitizedArg);\n}\n\nfunction _scratchpad({\n  pendingWrites,\n  taskId,\n  currentTaskInput,\n  resumeMap,\n  namespaceHash,\n}: {\n  pendingWrites: CheckpointPendingWrite[];\n  taskId: string;\n  currentTaskInput: unknown;\n  resumeMap: Record<string, unknown> | undefined;\n  namespaceHash: string;\n}): PregelScratchpad {\n  const nullResume = pendingWrites.find(\n    ([writeTaskId, chan]) => writeTaskId === NULL_TASK_ID && chan === RESUME\n  )?.[2];\n\n  const resume = (() => {\n    const result = pendingWrites\n      .filter(\n        ([writeTaskId, chan]) => writeTaskId === taskId && chan === RESUME\n      )\n      .flatMap(([_writeTaskId, _chan, resume]) => resume);\n\n    if (resumeMap != null && namespaceHash in resumeMap) {\n      const mappedResume = resumeMap[namespaceHash];\n      result.push(mappedResume);\n    }\n\n    return result;\n  })();\n\n  const scratchpad = {\n    callCounter: 0,\n    interruptCounter: -1,\n    resume,\n    nullResume,\n    subgraphCounter: 0,\n    currentTaskInput,\n    consumeNullResume: () => {\n      if (scratchpad.nullResume) {\n        delete scratchpad.nullResume;\n        pendingWrites.splice(\n          pendingWrites.findIndex(\n            ([writeTaskId, chan]) =>\n              writeTaskId === NULL_TASK_ID && chan === RESUME\n          ),\n          1\n        );\n        return nullResume;\n      }\n\n      return undefined;\n    },\n  };\n  return scratchpad;\n}\n", "import { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  CheckpointMetadata,\n  CheckpointPendingWrite,\n  PendingWrite,\n} from \"@langchain/langgraph-checkpoint\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport {\n  ERROR,\n  Interrupt,\n  INTERRUPT,\n  RETURN,\n  TAG_HIDDEN,\n} from \"../constants.js\";\nimport { EmptyChannelError } from \"../errors.js\";\nimport {\n  PregelExecutableTask,\n  PregelTaskDescription,\n  StateSnapshot,\n} from \"./types.js\";\nimport { readChannels } from \"./io.js\";\nimport { findSubgraphPregel } from \"./utils/subgraph.js\";\n\ntype ConsoleColors = {\n  start: string;\n  end: string;\n};\n\ntype ConsoleColorMap = {\n  [key: string]: ConsoleColors;\n};\n\nconst COLORS_MAP: ConsoleColorMap = {\n  blue: {\n    start: \"\\x1b[34m\",\n    end: \"\\x1b[0m\",\n  },\n  green: {\n    start: \"\\x1b[32m\",\n    end: \"\\x1b[0m\",\n  },\n  yellow: {\n    start: \"\\x1b[33;1m\",\n    end: \"\\x1b[0m\",\n  },\n};\n\n/**\n * Wrap some text in a color for printing to the console.\n */\nexport const wrap = (color: ConsoleColors, text: string): string =>\n  `${color.start}${text}${color.end}`;\n\nexport function printCheckpoint<Value>(\n  step: number,\n  channels: Record<string, BaseChannel<Value>>\n) {\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, \"[langgraph/checkpoint]\")}`,\n      `Finishing step ${step}. Channel values:\\n`,\n      `\\n${JSON.stringify(\n        Object.fromEntries(_readChannels<Value>(channels)),\n        null,\n        2\n      )}`,\n    ].join(\"\")\n  );\n}\n\nexport function* _readChannels<Value>(\n  channels: Record<string, BaseChannel<Value>>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): IterableIterator<[string, any]> {\n  for (const [name, channel] of Object.entries(channels)) {\n    try {\n      yield [name, channel.get()];\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      if (error.name === EmptyChannelError.unminifiable_name) {\n        // Skip the channel if it's empty\n        continue;\n      } else {\n        throw error; // Re-throw the error if it's not an EmptyChannelError\n      }\n    }\n  }\n}\n\nexport function* mapDebugTasks<N extends PropertyKey, C extends PropertyKey>(\n  tasks: readonly PregelExecutableTask<N, C>[]\n) {\n  for (const { id, name, input, config, triggers, writes } of tasks) {\n    if (config?.tags?.includes(TAG_HIDDEN)) continue;\n\n    const interrupts = writes\n      .filter(([writeId, n]) => {\n        return writeId === id && n === INTERRUPT;\n      })\n      .map(([, v]) => {\n        return v;\n      });\n    yield { id, name, input, triggers, interrupts };\n  }\n}\n\nfunction isMultipleChannelWrite(\n  value: unknown\n): value is { $writes: unknown[] } {\n  if (typeof value !== \"object\" || value === null) return false;\n  return \"$writes\" in value && Array.isArray(value.$writes);\n}\n\nfunction mapTaskResultWrites(writes: PendingWrite<unknown>[]) {\n  const result: Record<string, unknown> = {};\n\n  for (const [channel, value] of writes) {\n    const strChannel = String(channel);\n\n    if (strChannel in result) {\n      const channelWrites = isMultipleChannelWrite(result[strChannel])\n        ? result[strChannel].$writes\n        : [result[strChannel]];\n\n      channelWrites.push(value);\n      result[strChannel] = { $writes: channelWrites };\n    } else {\n      result[strChannel] = value;\n    }\n  }\n  return result;\n}\n\nexport function* mapDebugTaskResults<\n  N extends PropertyKey,\n  C extends PropertyKey\n>(\n  tasks: readonly [PregelExecutableTask<N, C>, PendingWrite<C>[]][],\n  streamChannels: PropertyKey | Array<PropertyKey>\n) {\n  for (const [{ id, name, config }, writes] of tasks) {\n    if (config?.tags?.includes(TAG_HIDDEN)) continue;\n    yield {\n      id,\n      name,\n      result: mapTaskResultWrites(\n        writes.filter(([channel]) => {\n          return Array.isArray(streamChannels)\n            ? streamChannels.includes(channel)\n            : channel === streamChannels;\n        })\n      ),\n      interrupts: writes.filter((w) => w[0] === INTERRUPT).map((w) => w[1]),\n    };\n  }\n}\n\ntype ChannelKey = string | number | symbol;\n\nexport function* mapDebugCheckpoint<\n  N extends PropertyKey,\n  C extends PropertyKey\n>(\n  config: RunnableConfig,\n  channels: Record<string, BaseChannel>,\n  streamChannels: string | string[],\n  metadata: CheckpointMetadata,\n  tasks: readonly PregelExecutableTask<N, C>[],\n  pendingWrites: CheckpointPendingWrite[],\n  parentConfig: RunnableConfig | undefined,\n  outputKeys: ChannelKey | ChannelKey[]\n) {\n  function formatConfig(config: RunnableConfig) {\n    // https://stackoverflow.com/a/78298178\n    type CamelToSnake<\n      T extends string,\n      A extends string = \"\"\n    > = T extends `${infer F}${infer R}`\n      ? CamelToSnake<\n          R,\n          `${A}${F extends Lowercase<F> ? F : `_${Lowercase<F>}`}`\n        >\n      : A;\n\n    // make sure the config is consistent with Python\n    const pyConfig: Partial<\n      Record<CamelToSnake<keyof RunnableConfig>, unknown>\n    > = {};\n\n    if (config.callbacks != null) pyConfig.callbacks = config.callbacks;\n    if (config.configurable != null)\n      pyConfig.configurable = config.configurable;\n    if (config.maxConcurrency != null)\n      pyConfig.max_concurrency = config.maxConcurrency;\n\n    if (config.metadata != null) pyConfig.metadata = config.metadata;\n    if (config.recursionLimit != null)\n      pyConfig.recursion_limit = config.recursionLimit;\n    if (config.runId != null) pyConfig.run_id = config.runId;\n    if (config.runName != null) pyConfig.run_name = config.runName;\n    if (config.tags != null) pyConfig.tags = config.tags;\n\n    return pyConfig;\n  }\n\n  const parentNs = config.configurable?.checkpoint_ns;\n  const taskStates: Record<string, RunnableConfig | StateSnapshot> = {};\n\n  for (const task of tasks) {\n    const candidates = task.subgraphs?.length ? task.subgraphs : [task.proc];\n    if (!candidates.find(findSubgraphPregel)) continue;\n\n    let taskNs = `${task.name as string}:${task.id}`;\n    if (parentNs) taskNs = `${parentNs}|${taskNs}`;\n\n    taskStates[task.id] = {\n      configurable: {\n        thread_id: config.configurable?.thread_id,\n        checkpoint_ns: taskNs,\n      },\n    };\n  }\n\n  yield {\n    config: formatConfig(config),\n    values: readChannels(channels, streamChannels),\n    metadata,\n    next: tasks.map((task) => task.name),\n    tasks: tasksWithWrites(tasks, pendingWrites, taskStates, outputKeys),\n    parentConfig: parentConfig ? formatConfig(parentConfig) : undefined,\n  };\n}\n\nexport function tasksWithWrites<N extends PropertyKey, C extends PropertyKey>(\n  tasks: PregelTaskDescription[] | readonly PregelExecutableTask<N, C>[],\n  pendingWrites: CheckpointPendingWrite[],\n  states: Record<string, RunnableConfig | StateSnapshot> | undefined,\n  outputKeys: ChannelKey[] | ChannelKey\n): PregelTaskDescription[] {\n  return tasks.map((task): PregelTaskDescription => {\n    const error = pendingWrites.find(\n      ([id, n]) => id === task.id && n === ERROR\n    )?.[2];\n\n    const interrupts = pendingWrites\n      .filter(([id, n]) => id === task.id && n === INTERRUPT)\n      .map(([, , v]) => v) as Interrupt[];\n\n    const result = (() => {\n      if (error || interrupts.length || !pendingWrites.length) return undefined;\n\n      const idx = pendingWrites.findIndex(\n        ([tid, n]) => tid === task.id && n === RETURN\n      );\n\n      if (idx >= 0) return pendingWrites[idx][2];\n\n      if (typeof outputKeys === \"string\") {\n        return pendingWrites.find(\n          ([tid, n]) => tid === task.id && n === outputKeys\n        )?.[2];\n      }\n\n      if (Array.isArray(outputKeys)) {\n        const results = pendingWrites\n          .filter(([tid, n]) => tid === task.id && outputKeys.includes(n))\n          .map(([, n, v]) => [n, v] as PendingWrite<C>);\n\n        if (!results.length) return undefined;\n        return mapTaskResultWrites(results);\n      }\n\n      return undefined;\n    })();\n\n    if (error) {\n      return {\n        id: task.id,\n        name: task.name as string,\n        path: task.path,\n        error,\n        interrupts,\n        result,\n      };\n    }\n\n    const taskState = states?.[task.id];\n    return {\n      id: task.id,\n      name: task.name as string,\n      path: task.path,\n      interrupts,\n      ...(taskState !== undefined ? { state: taskState } : {}),\n      result,\n    };\n  });\n}\n\nexport function printStepCheckpoint(\n  step: number,\n  channels: Record<string, BaseChannel<unknown>>,\n  whitelist: string[]\n): void {\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, `[${step}:checkpoint]`)}`,\n      `\\x1b[1m State at the end of step ${step}:\\x1b[0m\\n`,\n      JSON.stringify(readChannels(channels, whitelist), null, 2),\n    ].join(\"\")\n  );\n}\n\nexport function printStepTasks<N extends PropertyKey, C extends PropertyKey>(\n  step: number,\n  nextTasks: readonly PregelExecutableTask<N, C>[]\n): void {\n  const nTasks = nextTasks.length;\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, `[${step}:tasks]`)}`,\n      `\\x1b[1m Starting step ${step} with ${nTasks} task${\n        nTasks === 1 ? \"\" : \"s\"\n      }:\\x1b[0m\\n`,\n      nextTasks\n        .map(\n          (task) =>\n            `- ${wrap(COLORS_MAP.green, String(task.name))} -> ${JSON.stringify(\n              task.input,\n              null,\n              2\n            )}`\n        )\n        .join(\"\\n\"),\n    ].join(\"\")\n  );\n}\n\nexport function printStepWrites(\n  step: number,\n  writes: PendingWrite[],\n  whitelist: string[]\n): void {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const byChannel: Record<string, any[]> = {};\n\n  for (const [channel, value] of writes) {\n    if (whitelist.includes(channel)) {\n      if (!byChannel[channel]) {\n        byChannel[channel] = [];\n      }\n      byChannel[channel].push(value);\n    }\n  }\n\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, `[${step}:writes]`)}`,\n      `\\x1b[1m Finished step ${step} with writes to ${\n        Object.keys(byChannel).length\n      } channel${Object.keys(byChannel).length !== 1 ? \"s\" : \"\"}:\\x1b[0m\\n`,\n      Object.entries(byChannel)\n        .map(\n          ([name, vals]) =>\n            `- ${wrap(COLORS_MAP.yellow, name)} -> ${vals\n              .map((v) => JSON.stringify(v))\n              .join(\", \")}`\n        )\n        .join(\"\\n\"),\n    ].join(\"\")\n  );\n}\n", "import { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport type { StreamMode, StreamOutputMap } from \"./types.js\";\n\n// [namespace, streamMode, payload]\nexport type StreamChunk = [string[], StreamMode, unknown];\n\ntype StreamCheckpointsOutput<StreamValues> = StreamOutputMap<\n  \"checkpoints\",\n  false,\n  StreamValues,\n  unknown,\n  string,\n  unknown,\n  unknown,\n  undefined\n>;\n\ntype AnyStreamOutput = StreamOutputMap<\n  StreamMode[],\n  true,\n  unknown,\n  unknown,\n  string,\n  unknown,\n  unknown,\n  undefined\n>;\n\n/**\n * A wrapper around an IterableReadableStream that allows for aborting the stream when\n * {@link cancel} is called.\n */\nexport class IterableReadableStreamWithAbortSignal<\n  T\n> extends IterableReadableStream<T> {\n  protected _abortController: AbortController;\n\n  protected _innerReader: ReadableStreamDefaultReader<T>;\n\n  /**\n   * @param readableStream - The stream to wrap.\n   * @param abortController - The abort controller to use. Optional. One will be created if not provided.\n   */\n  constructor(\n    readableStream: ReadableStream<T>,\n    abortController?: AbortController\n  ) {\n    const reader = readableStream.getReader();\n    const ac = abortController ?? new AbortController();\n    super({\n      start(controller: ReadableStreamDefaultController<T>) {\n        return pump();\n        function pump(): Promise<T | undefined> {\n          return reader.read().then(({ done, value }) => {\n            // When no more data needs to be consumed, close the stream\n            if (done) {\n              controller.close();\n              return;\n            }\n            // Enqueue the next data chunk into our target stream\n            controller.enqueue(value);\n            return pump();\n          });\n        }\n      },\n    });\n    this._abortController = ac;\n    this._innerReader = reader;\n  }\n\n  /**\n   * Aborts the stream, abandoning any pending operations in progress. Calling this triggers an\n   * {@link AbortSignal} that is propagated to the tasks that are producing the data for this stream.\n   * @param reason - The reason for aborting the stream. Optional.\n   */\n  override async cancel(reason?: unknown) {\n    this._abortController.abort(reason);\n    this._innerReader.releaseLock();\n  }\n\n  /**\n   * The {@link AbortSignal} for the stream. Aborted when {@link cancel} is called.\n   */\n  get signal() {\n    return this._abortController.signal;\n  }\n}\n\nexport class IterableReadableWritableStream extends IterableReadableStream<StreamChunk> {\n  modes: Set<StreamMode>;\n\n  private controller: ReadableStreamDefaultController;\n\n  private passthroughFn?: (chunk: StreamChunk) => void;\n\n  private _closed: boolean = false;\n\n  get closed() {\n    return this._closed;\n  }\n\n  constructor(params: {\n    passthroughFn?: (chunk: StreamChunk) => void;\n    modes: Set<StreamMode>;\n  }) {\n    let streamControllerPromiseResolver: (\n      controller: ReadableStreamDefaultController\n    ) => void;\n    const streamControllerPromise: Promise<ReadableStreamDefaultController> =\n      new Promise<ReadableStreamDefaultController>((resolve) => {\n        streamControllerPromiseResolver = resolve;\n      });\n\n    super({\n      start: (controller) => {\n        streamControllerPromiseResolver!(controller);\n      },\n    });\n\n    // .start() will always be called before the stream can be interacted\n    // with anyway\n    void streamControllerPromise.then((controller) => {\n      this.controller = controller;\n    });\n\n    this.passthroughFn = params.passthroughFn;\n    this.modes = params.modes;\n  }\n\n  push(chunk: StreamChunk) {\n    this.passthroughFn?.(chunk);\n    this.controller.enqueue(chunk);\n  }\n\n  close() {\n    try {\n      this.controller.close();\n    } catch (e) {\n      // pass\n    } finally {\n      this._closed = true;\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  error(e: any) {\n    this.controller.error(e);\n  }\n}\n\nfunction _stringifyAsDict(obj: unknown) {\n  return JSON.stringify(obj, function (key: string | number, value: unknown) {\n    const rawValue = this[key];\n    if (\n      rawValue != null &&\n      typeof rawValue === \"object\" &&\n      \"toDict\" in rawValue &&\n      typeof rawValue.toDict === \"function\"\n    ) {\n      const { type, data } = rawValue.toDict();\n      return { ...data, type };\n    }\n\n    return value;\n  });\n}\n\nfunction _serializeError(error: unknown) {\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  if (error instanceof Error) {\n    return { error: error.name, message: error.message };\n  }\n  return { error: \"Error\", message: JSON.stringify(error) };\n}\n\nfunction _isRunnableConfig(\n  config: unknown\n): config is RunnableConfig & { configurable: Record<string, unknown> } {\n  if (typeof config !== \"object\" || config == null) return false;\n  return (\n    \"configurable\" in config &&\n    typeof config.configurable === \"object\" &&\n    config.configurable != null\n  );\n}\n\nfunction _extractCheckpointFromConfig(\n  config: RunnableConfig | null | undefined\n) {\n  if (!_isRunnableConfig(config) || !config.configurable.thread_id) {\n    return null;\n  }\n\n  return {\n    thread_id: config.configurable.thread_id,\n    checkpoint_ns: config.configurable.checkpoint_ns || \"\",\n    checkpoint_id: config.configurable.checkpoint_id || null,\n    checkpoint_map: config.configurable.checkpoint_map || null,\n  };\n}\n\nfunction _serializeConfig(config: unknown) {\n  if (_isRunnableConfig(config)) {\n    const configurable = Object.fromEntries(\n      Object.entries(config.configurable).filter(\n        ([key]) => !key.startsWith(\"__\")\n      )\n    );\n\n    const newConfig = { ...config, configurable };\n    delete newConfig.callbacks;\n    return newConfig;\n  }\n\n  return config;\n}\n\nfunction _serializeCheckpoint(payload: StreamCheckpointsOutput<unknown>) {\n  const result: Record<string, unknown> = {\n    ...payload,\n    checkpoint: _extractCheckpointFromConfig(payload.config),\n    parent_checkpoint: _extractCheckpointFromConfig(payload.parentConfig),\n\n    config: _serializeConfig(payload.config),\n    parent_config: _serializeConfig(payload.parentConfig),\n\n    tasks: payload.tasks.map((task) => {\n      if (_isRunnableConfig(task.state)) {\n        const checkpoint = _extractCheckpointFromConfig(task.state);\n        if (checkpoint != null) {\n          const cloneTask: Record<string, unknown> = { ...task, checkpoint };\n          delete cloneTask.state;\n          return cloneTask;\n        }\n      }\n\n      return task;\n    }),\n  };\n\n  delete result.parentConfig;\n  return result;\n}\n\nexport function toEventStream(stream: AsyncGenerator) {\n  const encoder = new TextEncoder();\n  return new ReadableStream<Uint8Array>({\n    async start(controller) {\n      const enqueueChunk = (sse: {\n        id?: string;\n        event: string;\n        data: unknown;\n      }) => {\n        controller.enqueue(\n          encoder.encode(\n            `event: ${sse.event}\\ndata: ${_stringifyAsDict(sse.data)}\\n\\n`\n          )\n        );\n      };\n\n      try {\n        for await (const payload of stream) {\n          const [ns, mode, chunk] = payload as AnyStreamOutput;\n\n          let data: unknown = chunk;\n          if (mode === \"debug\") {\n            const debugChunk = chunk;\n\n            if (debugChunk.type === \"checkpoint\") {\n              data = {\n                ...debugChunk,\n                payload: _serializeCheckpoint(debugChunk.payload),\n              };\n            }\n          }\n\n          if (mode === \"checkpoints\") {\n            data = _serializeCheckpoint(chunk);\n          }\n\n          const event = ns?.length ? `${mode}|${ns.join(\"|\")}` : mode;\n          enqueueChunk({ event, data });\n        }\n      } catch (error) {\n        enqueueChunk({ event: \"error\", data: _serializeError(error) });\n      }\n\n      controller.close();\n    },\n  });\n}\n", "import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport type { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  BaseCheckpointSaver,\n  Checkpoint,\n  CheckpointTuple,\n  copyCheckpoint,\n  emptyCheckpoint,\n  PendingWrite,\n  CheckpointPendingWrite,\n  CheckpointMetadata,\n  All,\n  BaseStore,\n  AsyncBatchedStore,\n  WRITES_IDX_MAP,\n  BaseCache,\n  CacheFullKey,\n  CacheNamespace,\n} from \"@langchain/langgraph-checkpoint\";\n\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n} from \"../channels/base.js\";\nimport type {\n  Call,\n  CallTaskPath,\n  Durability,\n  PregelExecutableTask,\n  PregelScratchpad,\n  StreamMode,\n} from \"./types.js\";\nimport {\n  isCommand,\n  _isSend,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_RESUMING,\n  CONFIG_KEY_STREAM,\n  ERROR,\n  INPUT,\n  INTERRUPT,\n  NULL_TASK_ID,\n  RESUME,\n  TAG_HIDDEN,\n  TASKS,\n  PUSH,\n  CONFIG_KEY_SCRATCHPAD,\n  CONFIG_KEY_CHECKPOINT_NS,\n  CHECKPOINT_NAMESPACE_END,\n  CONFIG_KEY_CHECKPOINT_ID,\n  CONFIG_KEY_RESUME_MAP,\n  START,\n} from \"../constants.js\";\nimport {\n  _applyWrites,\n  _prepareNextTasks,\n  _prepareSingleTask,\n  increment,\n  shouldInterrupt,\n  sanitizeUntrackedValuesInSend,\n  WritesProtocol,\n} from \"./algo.js\";\nimport {\n  gatherIterator,\n  gatherIteratorSync,\n  prefixGenerator,\n} from \"../utils.js\";\nimport {\n  mapCommand,\n  mapInput,\n  mapOutputUpdates,\n  mapOutputValues,\n  readChannels,\n} from \"./io.js\";\nimport {\n  EmptyInputError,\n  GraphInterrupt,\n  isGraphInterrupt,\n} from \"../errors.js\";\nimport { getNewChannelVersions, patchConfigurable } from \"./utils/index.js\";\nimport {\n  mapDebugTasks,\n  mapDebugCheckpoint,\n  mapDebugTaskResults,\n  printStepTasks,\n} from \"./debug.js\";\nimport { PregelNode } from \"./read.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { IterableReadableWritableStream, StreamChunk } from \"./stream.js\";\nimport { isXXH3 } from \"../hash.js\";\n\nconst INPUT_DONE = Symbol.for(\"INPUT_DONE\");\nconst INPUT_RESUMING = Symbol.for(\"INPUT_RESUMING\");\nconst DEFAULT_LOOP_LIMIT = 25;\n\nexport type PregelLoopInitializeParams = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any | Command;\n  config: RunnableConfig;\n  checkpointer?: BaseCheckpointSaver;\n  outputKeys: string | string[];\n  streamKeys: string | string[];\n  nodes: Record<string, PregelNode>;\n  channelSpecs: Record<string, BaseChannel>;\n  stream: IterableReadableWritableStream;\n  store?: BaseStore;\n  cache?: BaseCache<PendingWrite<string>[]>;\n  interruptAfter: string[] | All;\n  interruptBefore: string[] | All;\n  durability: Durability;\n  manager?: CallbackManagerForChainRun;\n  debug: boolean;\n  triggerToNodes: Record<string, string[]>;\n};\n\ntype PregelLoopParams = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any | Command;\n  config: RunnableConfig;\n  checkpointer?: BaseCheckpointSaver;\n  checkpoint: Checkpoint;\n  checkpointMetadata: CheckpointMetadata;\n  checkpointPreviousVersions: Record<string, string | number>;\n  checkpointPendingWrites: CheckpointPendingWrite[];\n  checkpointConfig: RunnableConfig;\n  channels: Record<string, BaseChannel>;\n  step: number;\n  stop: number;\n  outputKeys: string | string[];\n  streamKeys: string | string[];\n  nodes: Record<string, PregelNode>;\n  checkpointNamespace: string[];\n  skipDoneTasks: boolean;\n  isNested: boolean;\n  manager?: CallbackManagerForChainRun;\n  stream: IterableReadableWritableStream;\n  store?: AsyncBatchedStore;\n  cache?: BaseCache<PendingWrite<string>[]>;\n  prevCheckpointConfig: RunnableConfig | undefined;\n  interruptAfter: string[] | All;\n  interruptBefore: string[] | All;\n  durability: Durability;\n  debug: boolean;\n  triggerToNodes: Record<string, string[]>;\n};\n\nfunction createDuplexStream(...streams: IterableReadableWritableStream[]) {\n  return new IterableReadableWritableStream({\n    passthroughFn: (value: StreamChunk) => {\n      for (const stream of streams) {\n        if (stream.modes.has(value[1])) {\n          stream.push(value);\n        }\n      }\n    },\n    modes: new Set(streams.flatMap((s) => Array.from(s.modes))),\n  });\n}\n\nclass AsyncBatchedCache extends BaseCache<PendingWrite<string>[]> {\n  protected cache: BaseCache<PendingWrite<string>[]>;\n\n  private queue: Promise<unknown> = Promise.resolve();\n\n  constructor(cache: BaseCache<unknown>) {\n    super();\n    this.cache = cache as BaseCache<PendingWrite<string>[]>;\n  }\n\n  async get(keys: CacheFullKey[]) {\n    return this.enqueueOperation(\"get\", keys);\n  }\n\n  async set(\n    pairs: {\n      key: CacheFullKey;\n      value: PendingWrite<string>[];\n      ttl?: number;\n    }[]\n  ) {\n    return this.enqueueOperation(\"set\", pairs);\n  }\n\n  async clear(namespaces: CacheNamespace[]) {\n    return this.enqueueOperation(\"clear\", namespaces);\n  }\n\n  async stop() {\n    await this.queue;\n  }\n\n  private enqueueOperation<Type extends \"get\" | \"set\" | \"clear\">(\n    type: Type,\n    ...args: Parameters<(typeof this.cache)[Type]>\n  ) {\n    const newPromise = this.queue.then(() => {\n      // @ts-expect-error Tuple type warning\n      return this.cache[type](...args) as Promise<\n        ReturnType<(typeof this.cache)[Type]>\n      >;\n    });\n\n    this.queue = newPromise.then(\n      () => void 0,\n      () => void 0\n    );\n\n    return newPromise;\n  }\n}\n\nexport class PregelLoop {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected input?: any | Command;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  output: any;\n\n  config: LangGraphRunnableConfig;\n\n  protected checkpointer?: BaseCheckpointSaver;\n\n  protected checkpointerGetNextVersion: (current: number | undefined) => number;\n\n  channels: Record<string, BaseChannel>;\n\n  protected checkpoint: Checkpoint;\n\n  protected checkpointIdSaved: string | undefined;\n\n  protected checkpointConfig: RunnableConfig;\n\n  checkpointMetadata: CheckpointMetadata;\n\n  protected checkpointNamespace: string[];\n\n  protected checkpointPendingWrites: CheckpointPendingWrite[] = [];\n\n  protected checkpointPreviousVersions: Record<string, string | number>;\n\n  step: number;\n\n  protected stop: number;\n\n  protected durability: Durability;\n\n  protected outputKeys: string | string[];\n\n  protected streamKeys: string | string[];\n\n  protected nodes: Record<string, PregelNode>;\n\n  protected skipDoneTasks: boolean;\n\n  protected prevCheckpointConfig: RunnableConfig | undefined;\n\n  protected updatedChannels: Set<string> | undefined;\n\n  status:\n    | \"pending\"\n    | \"done\"\n    | \"interrupt_before\"\n    | \"interrupt_after\"\n    | \"out_of_steps\" = \"pending\";\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tasks: Record<string, PregelExecutableTask<any, any>> = {};\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  stream: IterableReadableWritableStream;\n\n  checkpointerPromises: Promise<unknown>[] = [];\n\n  isNested: boolean;\n\n  protected _checkpointerChainedPromise: Promise<unknown> = Promise.resolve();\n\n  store?: AsyncBatchedStore;\n\n  cache?: AsyncBatchedCache;\n\n  manager?: CallbackManagerForChainRun;\n\n  interruptAfter: string[] | All;\n\n  interruptBefore: string[] | All;\n\n  toInterrupt: PregelExecutableTask<string, string>[] = [];\n\n  debug: boolean = false;\n\n  triggerToNodes: Record<string, string[]>;\n\n  get isResuming() {\n    let hasChannelVersions = false;\n    if (START in this.checkpoint.channel_versions) {\n      // For common channels, we can short-circuit the check\n      hasChannelVersions = true;\n    } else {\n      for (const chan in this.checkpoint.channel_versions) {\n        if (\n          Object.prototype.hasOwnProperty.call(\n            this.checkpoint.channel_versions,\n            chan\n          )\n        ) {\n          hasChannelVersions = true;\n          break;\n        }\n      }\n    }\n\n    const configHasResumingFlag =\n      this.config.configurable?.[CONFIG_KEY_RESUMING] !== undefined;\n    const configIsResuming =\n      configHasResumingFlag && this.config.configurable?.[CONFIG_KEY_RESUMING];\n\n    const inputIsNullOrUndefined =\n      this.input === null || this.input === undefined;\n    const inputIsCommandResuming =\n      isCommand(this.input) && this.input.resume != null;\n    const inputIsResuming = this.input === INPUT_RESUMING;\n\n    const runIdMatchesPrevious =\n      !this.isNested &&\n      this.config.metadata?.run_id !== undefined &&\n      (this.checkpointMetadata as { run_id?: unknown })?.run_id !== undefined &&\n      this.config.metadata.run_id ===\n        (this.checkpointMetadata as { run_id?: unknown })?.run_id;\n\n    return (\n      hasChannelVersions &&\n      (configIsResuming ||\n        inputIsNullOrUndefined ||\n        inputIsCommandResuming ||\n        inputIsResuming ||\n        runIdMatchesPrevious)\n    );\n  }\n\n  constructor(params: PregelLoopParams) {\n    this.input = params.input;\n    this.checkpointer = params.checkpointer;\n    // TODO: if managed values no longer needs graph we can replace with\n    // managed_specs, channel_specs\n    if (this.checkpointer !== undefined) {\n      this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(\n        this.checkpointer\n      );\n    } else {\n      this.checkpointerGetNextVersion = increment;\n    }\n    this.checkpoint = params.checkpoint;\n    this.checkpointMetadata = params.checkpointMetadata;\n    this.checkpointPreviousVersions = params.checkpointPreviousVersions;\n    this.channels = params.channels;\n    this.checkpointPendingWrites = params.checkpointPendingWrites;\n    this.step = params.step;\n    this.stop = params.stop;\n    this.config = params.config;\n    this.checkpointConfig = params.checkpointConfig;\n    this.isNested = params.isNested;\n    this.manager = params.manager;\n    this.outputKeys = params.outputKeys;\n    this.streamKeys = params.streamKeys;\n    this.nodes = params.nodes;\n    this.skipDoneTasks = params.skipDoneTasks;\n    this.store = params.store;\n    this.cache = params.cache ? new AsyncBatchedCache(params.cache) : undefined;\n    this.stream = params.stream;\n    this.checkpointNamespace = params.checkpointNamespace;\n    this.prevCheckpointConfig = params.prevCheckpointConfig;\n    this.interruptAfter = params.interruptAfter;\n    this.interruptBefore = params.interruptBefore;\n    this.durability = params.durability;\n    this.debug = params.debug;\n    this.triggerToNodes = params.triggerToNodes;\n  }\n\n  static async initialize(params: PregelLoopInitializeParams) {\n    let { config, stream } = params;\n    if (\n      stream !== undefined &&\n      config.configurable?.[CONFIG_KEY_STREAM] !== undefined\n    ) {\n      stream = createDuplexStream(\n        stream,\n        config.configurable[CONFIG_KEY_STREAM]\n      );\n    }\n    const skipDoneTasks = config.configurable\n      ? !(\"checkpoint_id\" in config.configurable)\n      : true;\n\n    const scratchpad = config.configurable?.[CONFIG_KEY_SCRATCHPAD] as\n      | PregelScratchpad\n      | undefined;\n\n    if (config.configurable && scratchpad) {\n      if (scratchpad.subgraphCounter > 0) {\n        config = patchConfigurable(config, {\n          [CONFIG_KEY_CHECKPOINT_NS]: [\n            config.configurable[CONFIG_KEY_CHECKPOINT_NS],\n            scratchpad.subgraphCounter.toString(),\n          ].join(CHECKPOINT_NAMESPACE_SEPARATOR),\n        });\n      }\n\n      scratchpad.subgraphCounter += 1;\n    }\n\n    const isNested = CONFIG_KEY_READ in (config.configurable ?? {});\n    if (\n      !isNested &&\n      config.configurable?.checkpoint_ns !== undefined &&\n      config.configurable?.checkpoint_ns !== \"\"\n    ) {\n      config = patchConfigurable(config, {\n        checkpoint_ns: \"\",\n        checkpoint_id: undefined,\n      });\n    }\n    let checkpointConfig = config;\n    if (\n      config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] !== undefined &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP]?.[\n        config.configurable?.checkpoint_ns\n      ]\n    ) {\n      checkpointConfig = patchConfigurable(config, {\n        checkpoint_id:\n          config.configurable[CONFIG_KEY_CHECKPOINT_MAP][\n            config.configurable?.checkpoint_ns\n          ],\n      });\n    }\n    const checkpointNamespace =\n      config.configurable?.checkpoint_ns?.split(\n        CHECKPOINT_NAMESPACE_SEPARATOR\n      ) ?? [];\n\n    const saved: CheckpointTuple = (await params.checkpointer?.getTuple(\n      checkpointConfig\n    )) ?? {\n      config,\n      checkpoint: emptyCheckpoint(),\n      metadata: { source: \"input\", step: -2, parents: {} },\n      pendingWrites: [],\n    };\n    checkpointConfig = {\n      ...config,\n      ...saved.config,\n      configurable: {\n        checkpoint_ns: \"\",\n        ...config.configurable,\n        ...saved.config.configurable,\n      },\n    };\n    const prevCheckpointConfig = saved.parentConfig;\n    const checkpoint = copyCheckpoint(saved.checkpoint);\n    const checkpointMetadata = { ...saved.metadata } as CheckpointMetadata;\n    const checkpointPendingWrites = saved.pendingWrites ?? [];\n\n    const channels = emptyChannels(params.channelSpecs, checkpoint);\n\n    const step = (checkpointMetadata.step ?? 0) + 1;\n    const stop = step + (config.recursionLimit ?? DEFAULT_LOOP_LIMIT) + 1;\n    const checkpointPreviousVersions = { ...checkpoint.channel_versions };\n\n    const store = params.store\n      ? new AsyncBatchedStore(params.store)\n      : undefined;\n\n    if (store) {\n      // Start the store. This is a batch store, so it will run continuously\n      await store.start();\n    }\n    return new PregelLoop({\n      input: params.input,\n      config,\n      checkpointer: params.checkpointer,\n      checkpoint,\n      checkpointMetadata,\n      checkpointConfig,\n      prevCheckpointConfig,\n      checkpointNamespace,\n      channels,\n      isNested,\n      manager: params.manager,\n      skipDoneTasks,\n      step,\n      stop,\n      checkpointPreviousVersions,\n      checkpointPendingWrites,\n      outputKeys: params.outputKeys ?? [],\n      streamKeys: params.streamKeys ?? [],\n      nodes: params.nodes,\n      stream,\n      store,\n      cache: params.cache,\n      interruptAfter: params.interruptAfter,\n      interruptBefore: params.interruptBefore,\n      durability: params.durability,\n      debug: params.debug,\n      triggerToNodes: params.triggerToNodes,\n    });\n  }\n\n  protected _checkpointerPutAfterPrevious(input: {\n    config: RunnableConfig;\n    checkpoint: Checkpoint;\n    metadata: CheckpointMetadata;\n    newVersions: Record<string, string | number>;\n  }) {\n    this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(\n      () => {\n        return this.checkpointer?.put(\n          input.config,\n          input.checkpoint,\n          input.metadata,\n          input.newVersions\n        );\n      }\n    );\n    this.checkpointerPromises.push(this._checkpointerChainedPromise);\n  }\n\n  /**\n   * Put writes for a task, to be read by the next tick.\n   * @param taskId\n   * @param writes\n   */\n  putWrites(taskId: string, writes: PendingWrite<string>[]) {\n    let writesCopy = writes;\n    if (writesCopy.length === 0) return;\n\n    // deduplicate writes to special channels, last write wins\n    if (writesCopy.every(([key]) => key in WRITES_IDX_MAP)) {\n      writesCopy = Array.from(\n        new Map(writesCopy.map((w) => [w[0], w])).values()\n      );\n    }\n\n    // Check if any channels are UntrackedValue (manual loop for perf)\n    let hasUntrackedChannels = false;\n    for (const key in this.channels) {\n      if (Object.prototype.hasOwnProperty.call(this.channels, key)) {\n        const channel = this.channels[key];\n        if (channel.lc_graph_name === \"UntrackedValue\") {\n          hasUntrackedChannels = true;\n          break;\n        }\n      }\n    }\n\n    // Sanitize writes for checkpointing: remove UntrackedValue writes and sanitize Send packets\n    let writesToSave = writesCopy;\n    if (hasUntrackedChannels) {\n      writesToSave = writesCopy\n        .filter(([c]) => {\n          // Don't persist UntrackedValue channel writes\n          const channel = this.channels[c];\n          return !channel || channel.lc_graph_name !== \"UntrackedValue\";\n        })\n        .map(([c, v]) => {\n          // Sanitize UntrackedValues nested within Send packets\n          if (c === TASKS && _isSend(v)) {\n            return [c, sanitizeUntrackedValuesInSend(v, this.channels)] as [\n              string,\n              unknown\n            ];\n          }\n          return [c, v] as [string, unknown];\n        });\n    }\n\n    // remove existing writes for this task\n    this.checkpointPendingWrites = this.checkpointPendingWrites.filter(\n      (w) => w[0] !== taskId\n    );\n\n    // save writes\n    for (const [c, v] of writesToSave) {\n      this.checkpointPendingWrites.push([taskId, c, v]);\n    }\n\n    const config = patchConfigurable(this.checkpointConfig, {\n      [CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? \"\",\n      [CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id,\n    });\n\n    if (this.durability !== \"exit\" && this.checkpointer != null) {\n      this.checkpointerPromises.push(\n        // Use sanitized writes for checkpointer\n        this.checkpointer.putWrites(config, writesToSave, taskId)\n      );\n    }\n\n    if (this.tasks) {\n      this._outputWrites(taskId, writesCopy);\n    }\n\n    if (!writes.length || !this.cache || !this.tasks) {\n      return;\n    }\n\n    // only cache tasks with a cache key\n    const task = this.tasks[taskId];\n    if (task == null || task.cache_key == null) {\n      return;\n    }\n\n    // only cache successful tasks\n    if (writes[0][0] === ERROR || writes[0][0] === INTERRUPT) {\n      return;\n    }\n\n    void this.cache.set([\n      {\n        key: [task.cache_key.ns, task.cache_key.key],\n        value: task.writes,\n        ttl: task.cache_key.ttl,\n      },\n    ]);\n  }\n\n  _outputWrites(taskId: string, writes: [string, unknown][], cached = false) {\n    const task = this.tasks[taskId];\n    if (task !== undefined) {\n      if (\n        task.config !== undefined &&\n        (task.config.tags ?? []).includes(TAG_HIDDEN)\n      ) {\n        return;\n      }\n\n      if (writes.length > 0) {\n        if (writes[0][0] === INTERRUPT) {\n          // in `algo.ts` we append a bool to the task path to indicate\n          // whether or not a call was present. If so, we don't emit the\n          // the interrupt as it'll be emitted by the parent.\n          if (\n            task.path?.[0] === PUSH &&\n            task.path?.[task.path.length - 1] === true\n          )\n            return;\n\n          const interruptWrites = writes\n            .filter((w) => w[0] === INTERRUPT)\n            .flatMap((w) => w[1] as string[]);\n\n          this._emit([\n            [\"updates\", { [INTERRUPT]: interruptWrites }],\n            [\"values\", { [INTERRUPT]: interruptWrites }],\n          ]);\n        } else if (writes[0][0] !== ERROR) {\n          this._emit(\n            gatherIteratorSync(\n              prefixGenerator(\n                mapOutputUpdates(this.outputKeys, [[task, writes]], cached),\n                \"updates\"\n              )\n            )\n          );\n        }\n      }\n      if (!cached) {\n        this._emit(\n          gatherIteratorSync(\n            prefixGenerator(\n              mapDebugTaskResults([[task, writes]], this.streamKeys),\n              \"tasks\"\n            )\n          )\n        );\n      }\n    }\n  }\n\n  async _matchCachedWrites() {\n    if (!this.cache) return [];\n\n    const matched: {\n      task: PregelExecutableTask<string, string>;\n      result: unknown;\n    }[] = [];\n\n    const serializeKey = ([ns, key]: CacheFullKey) => {\n      return `ns:${ns.join(\",\")}|key:${key}`;\n    };\n\n    const keys: CacheFullKey[] = [];\n    const keyMap: Record<string, PregelExecutableTask<string, string>> = {};\n\n    for (const task of Object.values(this.tasks)) {\n      if (task.cache_key != null && !task.writes.length) {\n        keys.push([task.cache_key.ns, task.cache_key.key]);\n        keyMap[serializeKey([task.cache_key.ns, task.cache_key.key])] = task;\n      }\n    }\n\n    if (keys.length === 0) return [];\n    const cache = await this.cache.get(keys);\n\n    for (const { key, value } of cache) {\n      const task = keyMap[serializeKey(key)];\n      if (task != null) {\n        // update the task with the cached writes\n        task.writes.push(...value);\n        matched.push({ task, result: value });\n      }\n    }\n\n    return matched;\n  }\n\n  /**\n   * Execute a single iteration of the Pregel loop.\n   * Returns true if more iterations are needed.\n   * @param params\n   */\n  async tick(params: { inputKeys?: string | string[] }): Promise<boolean> {\n    if (this.store && !this.store.isRunning) {\n      await this.store?.start();\n    }\n    const { inputKeys = [] } = params;\n    if (this.status !== \"pending\") {\n      throw new Error(\n        `Cannot tick when status is no longer \"pending\". Current status: \"${this.status}\"`\n      );\n    }\n    if (![INPUT_DONE, INPUT_RESUMING].includes(this.input)) {\n      await this._first(inputKeys);\n    } else if (this.toInterrupt.length > 0) {\n      this.status = \"interrupt_before\";\n      throw new GraphInterrupt();\n    } else if (\n      Object.values(this.tasks).every((task) => task.writes.length > 0)\n    ) {\n      // finish superstep\n      const writes = Object.values(this.tasks).flatMap((t) => t.writes);\n      // All tasks have finished\n      this.updatedChannels = _applyWrites(\n        this.checkpoint,\n        this.channels,\n        Object.values(this.tasks),\n        this.checkpointerGetNextVersion,\n        this.triggerToNodes\n      );\n      // produce values output\n      const valuesOutput = await gatherIterator(\n        prefixGenerator(\n          mapOutputValues(this.outputKeys, writes, this.channels),\n          \"values\"\n        )\n      );\n      this._emit(valuesOutput);\n      // clear pending writes\n      this.checkpointPendingWrites = [];\n      await this._putCheckpoint({ source: \"loop\" });\n      // after execution, check if we should interrupt\n      if (\n        shouldInterrupt(\n          this.checkpoint,\n          this.interruptAfter,\n          Object.values(this.tasks)\n        )\n      ) {\n        this.status = \"interrupt_after\";\n        throw new GraphInterrupt();\n      }\n\n      // unset resuming flag\n      if (this.config.configurable?.[CONFIG_KEY_RESUMING] !== undefined) {\n        delete this.config.configurable?.[CONFIG_KEY_RESUMING];\n      }\n    } else {\n      return false;\n    }\n    if (this.step > this.stop) {\n      this.status = \"out_of_steps\";\n      return false;\n    }\n\n    const nextTasks = _prepareNextTasks(\n      this.checkpoint,\n      this.checkpointPendingWrites,\n      this.nodes,\n      this.channels,\n      this.config,\n      true,\n      {\n        step: this.step,\n        checkpointer: this.checkpointer,\n        isResuming: this.isResuming,\n        manager: this.manager,\n        store: this.store,\n        stream: this.stream,\n        triggerToNodes: this.triggerToNodes,\n        updatedChannels: this.updatedChannels,\n      }\n    );\n    this.tasks = nextTasks;\n\n    // Produce debug output\n    if (this.checkpointer) {\n      this._emit(\n        await gatherIterator(\n          prefixGenerator(\n            mapDebugCheckpoint(\n              this.checkpointConfig,\n              this.channels,\n              this.streamKeys,\n              this.checkpointMetadata,\n              Object.values(this.tasks),\n              this.checkpointPendingWrites,\n              this.prevCheckpointConfig,\n              this.outputKeys\n            ),\n            \"checkpoints\"\n          )\n        )\n      );\n    }\n\n    if (Object.values(this.tasks).length === 0) {\n      this.status = \"done\";\n      return false;\n    }\n    // if there are pending writes from a previous loop, apply them\n    if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {\n      for (const [tid, k, v] of this.checkpointPendingWrites) {\n        if (k === ERROR || k === INTERRUPT || k === RESUME) {\n          continue;\n        }\n        const task = Object.values(this.tasks).find((t) => t.id === tid);\n        if (task) {\n          task.writes.push([k, v]);\n        }\n      }\n      for (const task of Object.values(this.tasks)) {\n        if (task.writes.length > 0) {\n          this._outputWrites(task.id, task.writes, true);\n        }\n      }\n    }\n    // if all tasks have finished, re-tick\n    if (Object.values(this.tasks).every((task) => task.writes.length > 0)) {\n      return this.tick({ inputKeys });\n    }\n\n    // Before execution, check if we should interrupt\n    if (\n      shouldInterrupt(\n        this.checkpoint,\n        this.interruptBefore,\n        Object.values(this.tasks)\n      )\n    ) {\n      this.status = \"interrupt_before\";\n      throw new GraphInterrupt();\n    }\n\n    // Produce debug output\n    const debugOutput = await gatherIterator(\n      prefixGenerator(mapDebugTasks(Object.values(this.tasks)), \"tasks\")\n    );\n    this._emit(debugOutput);\n\n    return true;\n  }\n\n  async finishAndHandleError(error?: Error) {\n    // persist current checkpoint and writes\n    if (\n      this.durability === \"exit\" &&\n      // if it's a top graph\n      (!this.isNested ||\n        // or a nested graph with error or interrupt\n        typeof error !== \"undefined\" ||\n        // or a nested graph with checkpointer: true\n        this.checkpointNamespace.every(\n          (part) => !part.includes(CHECKPOINT_NAMESPACE_END)\n        ))\n    ) {\n      this._putCheckpoint(this.checkpointMetadata);\n      this._flushPendingWrites();\n    }\n\n    const suppress = this._suppressInterrupt(error);\n    if (suppress || error === undefined) {\n      this.output = readChannels(this.channels, this.outputKeys);\n    }\n    if (suppress) {\n      // emit one last \"values\" event, with pending writes applied\n      if (\n        this.tasks !== undefined &&\n        this.checkpointPendingWrites.length > 0 &&\n        Object.values(this.tasks).some((task) => task.writes.length > 0)\n      ) {\n        this.updatedChannels = _applyWrites(\n          this.checkpoint,\n          this.channels,\n          Object.values(this.tasks),\n          this.checkpointerGetNextVersion,\n          this.triggerToNodes\n        );\n\n        this._emit(\n          gatherIteratorSync(\n            prefixGenerator(\n              mapOutputValues(\n                this.outputKeys,\n                Object.values(this.tasks).flatMap((t) => t.writes),\n                this.channels\n              ),\n              \"values\"\n            )\n          )\n        );\n      }\n\n      // Emit INTERRUPT event\n      if (isGraphInterrupt(error) && !error.interrupts.length) {\n        this._emit([\n          [\"updates\", { [INTERRUPT]: [] }],\n          [\"values\", { [INTERRUPT]: [] }],\n        ]);\n      }\n    }\n    return suppress;\n  }\n\n  async acceptPush(\n    task: PregelExecutableTask<string, string>,\n    writeIdx: number,\n    call?: Call\n  ): Promise<PregelExecutableTask<string, string> | void> {\n    if (\n      this.interruptAfter?.length > 0 &&\n      shouldInterrupt(this.checkpoint, this.interruptAfter, [task])\n    ) {\n      this.toInterrupt.push(task);\n      return;\n    }\n\n    const pushed = _prepareSingleTask(\n      [PUSH, task.path ?? [], writeIdx, task.id, call] as CallTaskPath,\n      this.checkpoint,\n      this.checkpointPendingWrites,\n      this.nodes,\n      this.channels,\n      task.config ?? {},\n      true,\n      {\n        step: this.step,\n        checkpointer: this.checkpointer,\n        manager: this.manager,\n        store: this.store,\n        stream: this.stream,\n      }\n    );\n\n    if (!pushed) return;\n    if (\n      this.interruptBefore?.length > 0 &&\n      shouldInterrupt(this.checkpoint, this.interruptBefore, [pushed])\n    ) {\n      this.toInterrupt.push(pushed);\n      return;\n    }\n\n    this._emit(\n      gatherIteratorSync(prefixGenerator(mapDebugTasks([pushed]), \"tasks\"))\n    );\n\n    if (this.debug) printStepTasks(this.step, [pushed]);\n    this.tasks[pushed.id] = pushed;\n    if (this.skipDoneTasks) this._matchWrites({ [pushed.id]: pushed });\n\n    const tasks = await this._matchCachedWrites();\n    for (const { task } of tasks) {\n      this._outputWrites(task.id, task.writes, true);\n    }\n\n    return pushed;\n  }\n\n  protected _suppressInterrupt(e?: Error): boolean {\n    return isGraphInterrupt(e) && !this.isNested;\n  }\n\n  protected async _first(inputKeys: string | string[]) {\n    /*\n     * Resuming from previous checkpoint requires\n     * - finding a previous checkpoint\n     * - receiving null input (outer graph) or RESUMING flag (subgraph)\n     */\n\n    const { configurable } = this.config;\n\n    // take resume value from parent\n    const scratchpad = configurable?.[\n      CONFIG_KEY_SCRATCHPAD\n    ] as PregelScratchpad;\n\n    if (scratchpad && scratchpad.nullResume !== undefined) {\n      this.putWrites(NULL_TASK_ID, [[RESUME, scratchpad.nullResume]]);\n    }\n\n    // map command to writes\n    if (isCommand(this.input)) {\n      const hasResume = this.input.resume != null;\n\n      if (\n        this.input.resume != null &&\n        typeof this.input.resume === \"object\" &&\n        Object.keys(this.input.resume).every(isXXH3)\n      ) {\n        this.config.configurable ??= {};\n        this.config.configurable[CONFIG_KEY_RESUME_MAP] = this.input.resume;\n      }\n\n      if (hasResume && this.checkpointer == null) {\n        throw new Error(\"Cannot use Command(resume=...) without checkpointer\");\n      }\n\n      const writes: { [key: string]: PendingWrite[] } = {};\n\n      // group writes by task id\n      for (const [tid, key, value] of mapCommand(\n        this.input,\n        this.checkpointPendingWrites\n      )) {\n        writes[tid] ??= [];\n        writes[tid].push([key, value]);\n      }\n      if (Object.keys(writes).length === 0) {\n        throw new EmptyInputError(\"Received empty Command input\");\n      }\n\n      // save writes\n      for (const [tid, ws] of Object.entries(writes)) {\n        this.putWrites(tid, ws);\n      }\n    }\n\n    // apply null writes\n    const nullWrites = (this.checkpointPendingWrites ?? [])\n      .filter((w) => w[0] === NULL_TASK_ID)\n      .map((w) => w.slice(1)) as PendingWrite<string>[];\n    if (nullWrites.length > 0) {\n      _applyWrites(\n        this.checkpoint,\n        this.channels,\n        [\n          {\n            name: INPUT,\n            writes: nullWrites,\n            triggers: [],\n          },\n        ],\n        this.checkpointerGetNextVersion,\n        this.triggerToNodes\n      );\n    }\n    const isCommandUpdateOrGoto =\n      isCommand(this.input) && nullWrites.length > 0;\n    if (this.isResuming || isCommandUpdateOrGoto) {\n      for (const channelName in this.channels) {\n        if (!Object.prototype.hasOwnProperty.call(this.channels, channelName))\n          continue;\n        if (this.checkpoint.channel_versions[channelName] !== undefined) {\n          const version = this.checkpoint.channel_versions[channelName];\n          this.checkpoint.versions_seen[INTERRUPT] = {\n            ...this.checkpoint.versions_seen[INTERRUPT],\n            [channelName]: version,\n          };\n        }\n      }\n      // produce values output\n      const valuesOutput = await gatherIterator(\n        prefixGenerator(\n          mapOutputValues(this.outputKeys, true, this.channels),\n          \"values\"\n        )\n      );\n      this._emit(valuesOutput);\n    }\n    if (this.isResuming) {\n      this.input = INPUT_RESUMING;\n    } else if (isCommandUpdateOrGoto) {\n      // we need to create a new checkpoint for Command(update=...) or Command(goto=...)\n      // in case the result of Command(goto=...) is an interrupt.\n      // If not done, the checkpoint containing the interrupt will be lost.\n      await this._putCheckpoint({ source: \"input\" });\n      this.input = INPUT_DONE;\n    } else {\n      // map inputs to channel updates\n      const inputWrites = await gatherIterator(mapInput(inputKeys, this.input));\n      if (inputWrites.length > 0) {\n        const discardTasks = _prepareNextTasks(\n          this.checkpoint,\n          this.checkpointPendingWrites,\n          this.nodes,\n          this.channels,\n          this.config,\n          true,\n          { step: this.step }\n        );\n        this.updatedChannels = _applyWrites(\n          this.checkpoint,\n          this.channels,\n          (Object.values(discardTasks) as WritesProtocol[]).concat([\n            {\n              name: INPUT,\n              writes: inputWrites as PendingWrite[],\n              triggers: [],\n            },\n          ]),\n          this.checkpointerGetNextVersion,\n          this.triggerToNodes\n        );\n        // save input checkpoint\n        await this._putCheckpoint({ source: \"input\" });\n\n        this.input = INPUT_DONE;\n      } else if (!(CONFIG_KEY_RESUMING in (this.config.configurable ?? {}))) {\n        throw new EmptyInputError(\n          `Received no input writes for ${JSON.stringify(inputKeys, null, 2)}`\n        );\n      } else {\n        // done with input\n        this.input = INPUT_DONE;\n      }\n    }\n    if (!this.isNested) {\n      this.config = patchConfigurable(this.config, {\n        [CONFIG_KEY_RESUMING]: this.isResuming,\n      });\n    }\n  }\n\n  protected _emit(values: [StreamMode, unknown][]) {\n    for (const [mode, payload] of values) {\n      if (this.stream.modes.has(mode)) {\n        this.stream.push([this.checkpointNamespace, mode, payload]);\n      }\n\n      // debug mode is a \"checkpoints\" or \"tasks\" wrapped in an object\n      // TODO: consider deprecating this in 1.x\n      if (\n        (mode === \"checkpoints\" || mode === \"tasks\") &&\n        this.stream.modes.has(\"debug\")\n      ) {\n        const step = mode === \"checkpoints\" ? this.step - 1 : this.step;\n        const timestamp = new Date().toISOString();\n        const type = (() => {\n          if (mode === \"checkpoints\") {\n            return \"checkpoint\";\n          } else if (\n            typeof payload === \"object\" &&\n            payload != null &&\n            \"result\" in payload\n          ) {\n            return \"task_result\";\n          } else {\n            return \"task\";\n          }\n        })();\n\n        this.stream.push([\n          this.checkpointNamespace,\n          \"debug\",\n          { step, type, timestamp, payload },\n        ]);\n      }\n    }\n  }\n\n  protected _putCheckpoint(\n    inputMetadata: Omit<CheckpointMetadata, \"step\" | \"parents\">\n  ) {\n    const exiting = this.checkpointMetadata === inputMetadata;\n\n    const doCheckpoint =\n      this.checkpointer != null && (this.durability !== \"exit\" || exiting);\n\n    const storeCheckpoint = (checkpoint: Checkpoint) => {\n      // store the previous checkpoint config for debug events\n      this.prevCheckpointConfig = this.checkpointConfig?.configurable\n        ?.checkpoint_id\n        ? this.checkpointConfig\n        : undefined;\n\n      // child graphs keep at most one checkpoint per parent checkpoint\n      // this is achieved by writing child checkpoints as progress is made\n      // (so that error recovery / resuming from interrupt don't lose work)\n      // but doing so always with an id equal to that of the parent checkpoint\n      this.checkpointConfig = patchConfigurable(this.checkpointConfig, {\n        [CONFIG_KEY_CHECKPOINT_NS]:\n          this.config.configurable?.checkpoint_ns ?? \"\",\n      });\n\n      const channelVersions = { ...this.checkpoint.channel_versions };\n      const newVersions = getNewChannelVersions(\n        this.checkpointPreviousVersions,\n        channelVersions\n      );\n      this.checkpointPreviousVersions = channelVersions;\n      // save it, without blocking\n      // if there's a previous checkpoint save in progress, wait for it\n      // ensuring checkpointers receive checkpoints in order\n      void this._checkpointerPutAfterPrevious({\n        config: { ...this.checkpointConfig },\n        checkpoint: copyCheckpoint(checkpoint),\n        metadata: { ...this.checkpointMetadata },\n        newVersions,\n      });\n      this.checkpointConfig = {\n        ...this.checkpointConfig,\n        configurable: {\n          ...this.checkpointConfig.configurable,\n          checkpoint_id: this.checkpoint.id,\n        },\n      };\n    };\n\n    if (!exiting) {\n      this.checkpointMetadata = {\n        ...inputMetadata,\n        step: this.step,\n        parents: this.config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] ?? {},\n      };\n    }\n\n    // create new checkpoint\n    this.checkpoint = createCheckpoint(\n      this.checkpoint,\n      doCheckpoint ? this.channels : undefined,\n      this.step,\n      exiting ? { id: this.checkpoint.id } : undefined\n    );\n\n    // Bail if no checkpointer\n    if (doCheckpoint) storeCheckpoint(this.checkpoint);\n\n    if (!exiting) {\n      // increment step\n      this.step += 1;\n    }\n  }\n\n  protected _flushPendingWrites() {\n    if (this.checkpointer == null) return;\n    if (this.checkpointPendingWrites.length === 0) return;\n\n    // patch config\n    const config = patchConfigurable(this.checkpointConfig, {\n      [CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? \"\",\n      [CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id,\n    });\n\n    // group writes by task id\n    const byTask: Record<string, PendingWrite<string>[]> = {};\n    for (const [tid, key, value] of this.checkpointPendingWrites) {\n      byTask[tid] ??= [];\n      byTask[tid].push([key, value]);\n    }\n\n    // submit writes to checkpointer\n    for (const [tid, ws] of Object.entries(byTask)) {\n      this.checkpointerPromises.push(\n        this.checkpointer.putWrites(config, ws, tid)\n      );\n    }\n  }\n\n  protected _matchWrites(\n    tasks: Record<string, PregelExecutableTask<string, string>>\n  ) {\n    for (const [tid, k, v] of this.checkpointPendingWrites) {\n      if (k === ERROR || k === INTERRUPT || k === RESUME) {\n        continue;\n      }\n      const task = Object.values(tasks).find((t) => t.id === tid);\n      if (task) {\n        task.writes.push([k, v]);\n      }\n    }\n    for (const task of Object.values(tasks)) {\n      if (task.writes.length > 0) {\n        this._outputWrites(task.id, task.writes, true);\n      }\n    }\n  }\n}\n", "import {\n  BaseCallbackHandler,\n  HandleLLMNewTokenCallbackFields,\n  NewTokenIndices,\n} from \"@langchain/core/callbacks/base\";\nimport {\n  AIMessageChunk,\n  BaseMessage,\n  isBaseMessage,\n  isBaseMessageChunk,\n  isToolMessage,\n} from \"@langchain/core/messages\";\nimport { Serialized } from \"@langchain/core/load/serializable\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  LLMResult,\n} from \"@langchain/core/outputs\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\n\nimport { TAG_HIDDEN, TAG_NOSTREAM } from \"../constants.js\";\nimport { StreamChunk } from \"./stream.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Meta = [string[], Record<string, any>];\n\nfunction isChatGenerationChunk(x: unknown): x is ChatGenerationChunk {\n  return isBaseMessage((x as ChatGenerationChunk)?.message);\n}\n\n/**\n * A callback handler that implements stream_mode=messages.\n * Collects messages from (1) chat model stream events and (2) node outputs.\n */\n// TODO: Make this import and explicitly implement the\n// CallbackHandlerPrefersStreaming interface once we drop support for core 0.2\nexport class StreamMessagesHandler extends BaseCallbackHandler {\n  name = \"StreamMessagesHandler\";\n\n  streamFn: (streamChunk: StreamChunk) => void;\n\n  metadatas: Record<string, Meta | undefined> = {};\n\n  seen: Record<string, BaseMessage> = {};\n\n  emittedChatModelRunIds: Record<string, boolean> = {};\n\n  stableMessageIdMap: Record<string, string> = {};\n\n  lc_prefer_streaming = true;\n\n  constructor(streamFn: (streamChunk: StreamChunk) => void) {\n    super();\n    this.streamFn = streamFn;\n  }\n\n  _emit(\n    meta: Meta,\n    message: BaseMessage,\n    runId: string | undefined,\n    dedupe = false\n  ) {\n    if (\n      dedupe &&\n      message.id !== undefined &&\n      this.seen[message.id] !== undefined\n    ) {\n      return;\n    }\n\n    let messageId = message.id;\n\n    if (runId != null) {\n      if (isToolMessage(message)) {\n        // Distinguish tool messages by tool call ID.\n        messageId ??= `run-${runId}-tool-${message.tool_call_id}`;\n      } else {\n        // For instance in ChatAnthropic, the first chunk has an message ID\n        // but the subsequent chunks do not. To avoid clients seeing two messages\n        // we rename the message ID if it's being auto-set to `run-${runId}`\n        // (see https://github.com/langchain-ai/langchainjs/pull/6646).\n        if (messageId == null || messageId === `run-${runId}`) {\n          messageId =\n            this.stableMessageIdMap[runId] ?? messageId ?? `run-${runId}`;\n        }\n\n        this.stableMessageIdMap[runId] ??= messageId;\n      }\n    }\n\n    if (messageId !== message.id) {\n      // eslint-disable-next-line no-param-reassign\n      message.id = messageId;\n\n      // eslint-disable-next-line no-param-reassign\n      message.lc_kwargs.id = messageId;\n    }\n\n    if (message.id != null) this.seen[message.id] = message;\n    this.streamFn([meta[0], \"messages\", [message, meta[1]]]);\n  }\n\n  handleChatModelStart(\n    _llm: Serialized,\n    _messages: BaseMessage[][],\n    runId: string,\n    _parentRunId?: string,\n    _extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    name?: string\n  ) {\n    if (\n      metadata &&\n      // Include legacy LangGraph SDK tag\n      (!tags || (!tags.includes(TAG_NOSTREAM) && !tags.includes(\"nostream\")))\n    ) {\n      this.metadatas[runId] = [\n        (metadata.langgraph_checkpoint_ns as string).split(\"|\"),\n        { tags, name, ...metadata },\n      ];\n    }\n  }\n\n  handleLLMNewToken(\n    token: string,\n    _idx: NewTokenIndices,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ) {\n    const chunk = fields?.chunk;\n    this.emittedChatModelRunIds[runId] = true;\n    if (this.metadatas[runId] !== undefined) {\n      if (isChatGenerationChunk(chunk)) {\n        this._emit(this.metadatas[runId], chunk.message, runId);\n      } else {\n        this._emit(\n          this.metadatas[runId],\n          new AIMessageChunk({ content: token }),\n          runId\n        );\n      }\n    }\n  }\n\n  handleLLMEnd(output: LLMResult, runId: string) {\n    // Filter out runs that we do not have metadata for\n    if (this.metadatas[runId] === undefined) return;\n\n    // In JS, non-streaming runs do not call handleLLMNewToken at the model level\n    if (!this.emittedChatModelRunIds[runId]) {\n      const chatGeneration = output.generations?.[0]?.[0] as ChatGeneration;\n      if (isBaseMessage(chatGeneration?.message)) {\n        this._emit(this.metadatas[runId], chatGeneration?.message, runId, true);\n      }\n      delete this.emittedChatModelRunIds[runId];\n    }\n    delete this.metadatas[runId];\n    delete this.stableMessageIdMap[runId];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handleLLMError(_err: any, runId: string) {\n    delete this.metadatas[runId];\n  }\n\n  handleChainStart(\n    _chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    _parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    _runType?: string,\n    name?: string\n  ) {\n    if (\n      metadata !== undefined &&\n      name === metadata.langgraph_node &&\n      (tags === undefined || !tags.includes(TAG_HIDDEN))\n    ) {\n      this.metadatas[runId] = [\n        (metadata.langgraph_checkpoint_ns as string).split(\"|\"),\n        { tags, name, ...metadata },\n      ];\n\n      if (typeof inputs === \"object\") {\n        for (const value of Object.values(inputs)) {\n          if (\n            (isBaseMessage(value) || isBaseMessageChunk(value)) &&\n            value.id !== undefined\n          ) {\n            this.seen[value.id] = value;\n          } else if (Array.isArray(value)) {\n            for (const item of value) {\n              if (\n                (isBaseMessage(item) || isBaseMessageChunk(item)) &&\n                item.id !== undefined\n              ) {\n                this.seen[item.id] = item;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  handleChainEnd(outputs: ChainValues, runId: string) {\n    const metadata = this.metadatas[runId];\n    delete this.metadatas[runId];\n    if (metadata !== undefined) {\n      if (isBaseMessage(outputs)) {\n        this._emit(metadata, outputs, runId, true);\n      } else if (Array.isArray(outputs)) {\n        for (const value of outputs) {\n          if (isBaseMessage(value)) {\n            this._emit(metadata, value, runId, true);\n          }\n        }\n      } else if (outputs != null && typeof outputs === \"object\") {\n        for (const value of Object.values(outputs)) {\n          if (isBaseMessage(value)) {\n            this._emit(metadata, value, runId, true);\n          } else if (Array.isArray(value)) {\n            for (const item of value) {\n              if (isBaseMessage(item)) {\n                this._emit(metadata, item, runId, true);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handleChainError(_err: any, runId: string) {\n    delete this.metadatas[runId];\n  }\n}\n", "import { Command, CONFIG_KEY_RESUMING } from \"../constants.js\";\nimport { isGraphBubbleUp, isParentCommand } from \"../errors.js\";\nimport { PregelExecutableTask } from \"./types.js\";\nimport { getParentCheckpointNamespace } from \"./utils/config.js\";\nimport { patchConfigurable, type RetryPolicy } from \"./utils/index.js\";\n\nexport const DEFAULT_INITIAL_INTERVAL = 500;\nexport const DEFAULT_BACKOFF_FACTOR = 2;\nexport const DEFAULT_MAX_INTERVAL = 128000;\nexport const DEFAULT_MAX_RETRIES = 3;\n\nconst DEFAULT_STATUS_NO_RETRY = [\n  400, // Bad Request\n  401, // Unauthorized\n  402, // Payment Required\n  403, // Forbidden\n  404, // Not Found\n  405, // Method Not Allowed\n  406, // Not Acceptable\n  407, // Proxy Authentication Required\n  409, // Conflict\n];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst DEFAULT_RETRY_ON_HANDLER = (error: any) => {\n  if (\n    error.message.startsWith(\"Cancel\") ||\n    error.message.startsWith(\"AbortError\") ||\n    error.name === \"AbortError\"\n  ) {\n    return false;\n  }\n\n  // Thrown when interrupt is called without a checkpointer\n  if (error.name === \"GraphValueError\") {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((error as any)?.code === \"ECONNABORTED\") {\n    return false;\n  }\n\n  const status =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (error as any)?.response?.status ?? (error as any)?.status;\n  if (status && DEFAULT_STATUS_NO_RETRY.includes(+status)) {\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((error as any)?.error?.code === \"insufficient_quota\") {\n    return false;\n  }\n  return true;\n};\n\nexport type SettledPregelTask = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  task: PregelExecutableTask<any, any>;\n  error: Error;\n  signalAborted?: boolean;\n};\n\nexport async function _runWithRetry<\n  N extends PropertyKey,\n  C extends PropertyKey\n>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  pregelTask: PregelExecutableTask<N, C>,\n  retryPolicy?: RetryPolicy,\n  configurable?: Record<string, unknown>,\n  signal?: AbortSignal\n): Promise<{\n  task: PregelExecutableTask<N, C>;\n  result: unknown;\n  error: Error | undefined;\n  signalAborted?: boolean;\n}> {\n  const resolvedRetryPolicy = pregelTask.retry_policy ?? retryPolicy;\n  let interval =\n    resolvedRetryPolicy !== undefined\n      ? resolvedRetryPolicy.initialInterval ?? DEFAULT_INITIAL_INTERVAL\n      : 0;\n  let attempts = 0;\n  let error;\n  let result;\n\n  let { config } = pregelTask;\n  if (configurable) config = patchConfigurable(config, configurable);\n  config = { ...config, signal };\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (signal?.aborted) {\n      // no need to throw here - we'll throw from the runner, instead.\n      // there's just no point in retrying if the user has requested an abort.\n      break;\n    }\n    // Clear any writes from previous attempts\n    pregelTask.writes.splice(0, pregelTask.writes.length);\n    error = undefined;\n    try {\n      result = await pregelTask.proc.invoke(pregelTask.input, config);\n      break;\n    } catch (e: unknown) {\n      error = e;\n      (error as { pregelTaskId: string }).pregelTaskId = pregelTask.id;\n      if (isParentCommand(error)) {\n        const ns: string = config?.configurable?.checkpoint_ns;\n        const cmd = error.command;\n        if (cmd.graph === ns) {\n          // this command is for the current graph, handle it\n          for (const writer of pregelTask.writers) {\n            await writer.invoke(cmd, config);\n          }\n          error = undefined;\n          break;\n        } else if (cmd.graph === Command.PARENT) {\n          // this command is for the parent graph, assign it to the parent\n          const parentNs = getParentCheckpointNamespace(ns);\n          error.command = new Command({\n            ...error.command,\n            graph: parentNs,\n          });\n        }\n      }\n      if (isGraphBubbleUp(error)) {\n        break;\n      }\n      if (resolvedRetryPolicy === undefined) {\n        break;\n      }\n      attempts += 1;\n      // check if we should give up\n      if (\n        attempts >= (resolvedRetryPolicy.maxAttempts ?? DEFAULT_MAX_RETRIES)\n      ) {\n        break;\n      }\n      const retryOn = resolvedRetryPolicy.retryOn ?? DEFAULT_RETRY_ON_HANDLER;\n      if (!retryOn(error)) {\n        break;\n      }\n      interval = Math.min(\n        resolvedRetryPolicy.maxInterval ?? DEFAULT_MAX_INTERVAL,\n        interval * (resolvedRetryPolicy.backoffFactor ?? DEFAULT_BACKOFF_FACTOR)\n      );\n      const intervalWithJitter = resolvedRetryPolicy.jitter\n        ? Math.floor(interval + Math.random() * 1000)\n        : interval;\n      // sleep before retrying\n      // eslint-disable-next-line no-promise-executor-return\n      await new Promise((resolve) => setTimeout(resolve, intervalWithJitter));\n      // log the retry\n      const errorName =\n        (error as Error).name ??\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ((error as Error).constructor as any).unminifiable_name ??\n        (error as Error).constructor.name;\n      if (resolvedRetryPolicy?.logWarning ?? true) {\n        console.log(\n          `Retrying task \"${String(pregelTask.name)}\" after ${interval.toFixed(\n            2\n          )}ms (attempt ${attempts}) after ${errorName}: ${error}`\n        );\n      }\n\n      // signal subgraphs to resume (if available)\n      config = patchConfigurable(config, { [CONFIG_KEY_RESUMING]: true });\n    }\n  }\n  return {\n    task: pregelTask,\n    result,\n    error: error as Error | undefined,\n    signalAborted: signal?.aborted,\n  };\n}\n", "import { PendingWrite } from \"@langchain/langgraph-checkpoint\";\nimport {\n  Call,\n  PregelAbortSignals,\n  PregelExecutableTask,\n  PregelScratchpad,\n} from \"./types.js\";\nimport {\n  CachePolicy,\n  combineAbortSignals,\n  patchConfigurable,\n  RetryPolicy,\n} from \"./utils/index.js\";\nimport {\n  CONFIG_KEY_SCRATCHPAD,\n  ERROR,\n  INTERRUPT,\n  RESUME,\n  NO_WRITES,\n  TAG_HIDDEN,\n  RETURN,\n  CONFIG_KEY_CALL,\n  CONFIG_KEY_ABORT_SIGNALS,\n} from \"../constants.js\";\nimport { GraphBubbleUp, isGraphBubbleUp, isGraphInterrupt } from \"../errors.js\";\nimport { _runWithRetry, SettledPregelTask } from \"./retry.js\";\nimport { PregelLoop } from \"./loop.js\";\n\nconst PROMISE_ADDED_SYMBOL = Symbol.for(\"promiseAdded\");\n\nfunction createPromiseBarrier() {\n  const barrier: {\n    next: () => void;\n    wait: Promise<unknown>;\n  } = {\n    next: () => void 0,\n    wait: Promise.resolve(PROMISE_ADDED_SYMBOL),\n  };\n\n  function waitHandler(resolve: (value: typeof PROMISE_ADDED_SYMBOL) => void) {\n    barrier.next = () => {\n      barrier.wait = new Promise(waitHandler);\n      resolve(PROMISE_ADDED_SYMBOL);\n    };\n  }\n  barrier.wait = new Promise(waitHandler);\n  return barrier;\n}\n\n/**\n * Options for the {@link PregelRunner#tick} method.\n */\nexport type TickOptions = {\n  /**\n   * The deadline before which all tasks must be completed.\n   */\n  timeout?: number;\n\n  /**\n   * An optional {@link AbortSignal} to cancel processing of tasks.\n   */\n  signal?: AbortSignal;\n\n  /**\n   * The {@link RetryPolicy} to use for the tick.\n   */\n  retryPolicy?: RetryPolicy;\n\n  /**\n   * An optional callback to be called after all task writes are completed.\n   */\n  onStepWrite?: (step: number, writes: PendingWrite[]) => void;\n\n  /**\n   * The maximum number of tasks to execute concurrently.\n   */\n  maxConcurrency?: number;\n};\n\n/**\n * Responsible for handling task execution on each tick of the {@link PregelLoop}.\n */\nexport class PregelRunner {\n  private nodeFinished?: (id: string) => void;\n\n  private loop: PregelLoop;\n\n  /**\n   * Construct a new PregelRunner, which executes tasks from the provided PregelLoop.\n   * @param loop - The PregelLoop that produces tasks for this runner to execute.\n   */\n  constructor({\n    loop,\n    nodeFinished,\n  }: {\n    loop: PregelLoop;\n    nodeFinished?: (id: string) => void;\n  }) {\n    this.loop = loop;\n    this.nodeFinished = nodeFinished;\n  }\n\n  /**\n   * Execute tasks from the current step of the PregelLoop.\n   *\n   * Note: this method does NOT call {@link PregelLoop}#tick. That must be handled externally.\n   * @param options - Options for the execution.\n   */\n  async tick(options: TickOptions = {}) {\n    const { timeout, retryPolicy, onStepWrite, maxConcurrency } = options;\n\n    const nodeErrors: Set<Error> = new Set();\n    let graphBubbleUp: GraphBubbleUp | undefined;\n\n    const exceptionSignalController = new AbortController();\n    const exceptionSignal = exceptionSignalController.signal;\n    const stepTimeoutSignal = timeout\n      ? AbortSignal.timeout(timeout)\n      : undefined;\n\n    // Start task execution\n    const pendingTasks = Object.values(this.loop.tasks).filter(\n      (t) => t.writes.length === 0\n    );\n\n    const { signals, disposeCombinedSignal } = this._initializeAbortSignals({\n      exceptionSignal,\n      stepTimeoutSignal,\n      signal: options.signal,\n    });\n\n    const taskStream = this._executeTasksWithRetry(pendingTasks, {\n      signals,\n      retryPolicy,\n      maxConcurrency,\n    });\n\n    for await (const { task, error, signalAborted } of taskStream) {\n      this._commit(task, error);\n      if (isGraphInterrupt(error)) {\n        graphBubbleUp = error;\n      } else if (isGraphBubbleUp(error) && !isGraphInterrupt(graphBubbleUp)) {\n        graphBubbleUp = error;\n      } else if (error && (nodeErrors.size === 0 || !signalAborted)) {\n        /*\n         * The goal here is to capture the exception that causes the graph to terminate early. In\n         * theory it's possible for multiple nodes to throw, so this also handles the edge case of\n         * capturing concurrent exceptions thrown before the node saw an abort. This is checked via\n         * the signalAborted flag, which records the state of the abort signal at the time the node\n         * execution finished.\n         *\n         * There is a case however where one node throws some error causing us to trigger an abort,\n         * which then causes other concurrently executing nodes to throw their own AbortErrors. In\n         * this case we don't care about reporting the abort errors thrown by the other nodes,\n         * because they don't tell the user anything about what caused the graph execution to\n         * terminate early, so we ignore them (and any other errors that occur after the node sees\n         * an abort signal).\n         */\n        exceptionSignalController.abort();\n        nodeErrors.add(error);\n      }\n    }\n\n    disposeCombinedSignal?.();\n\n    onStepWrite?.(\n      this.loop.step,\n      Object.values(this.loop.tasks)\n        .map((task) => task.writes)\n        .flat()\n    );\n\n    if (nodeErrors.size === 1) {\n      throw Array.from(nodeErrors)[0];\n    } else if (nodeErrors.size > 1) {\n      throw new AggregateError(\n        Array.from(nodeErrors),\n        `Multiple errors occurred during superstep ${this.loop.step}. See the \"errors\" field of this exception for more details.`\n      );\n    }\n\n    if (isGraphInterrupt(graphBubbleUp)) {\n      throw graphBubbleUp;\n    }\n\n    if (isGraphBubbleUp(graphBubbleUp) && this.loop.isNested) {\n      throw graphBubbleUp;\n    }\n  }\n\n  /**\n   * Initializes the current AbortSignals for the PregelRunner, handling the various ways that\n   * AbortSignals must be chained together so that the PregelLoop can be interrupted if necessary\n   * while still allowing nodes to gracefully exit.\n   *\n   * This method must only be called once per PregelRunner#tick. It has the side effect of updating\n   * the PregelLoop#config with the new AbortSignals so they may be propagated correctly to future\n   * ticks and subgraph calls.\n   *\n   * @param options - Options for the initialization.\n   * @returns The current abort signals.\n   * @internal\n   */\n  private _initializeAbortSignals({\n    exceptionSignal,\n    stepTimeoutSignal,\n    signal,\n  }: {\n    exceptionSignal: AbortSignal;\n    stepTimeoutSignal?: AbortSignal;\n    signal?: AbortSignal;\n  }): { signals: PregelAbortSignals; disposeCombinedSignal?: () => void } {\n    const previousSignals = (this.loop.config.configurable?.[\n      CONFIG_KEY_ABORT_SIGNALS\n    ] ?? {}) as PregelAbortSignals;\n\n    // We always inherit the external abort signal from AsyncLocalStorage,\n    // since that's the only way the signal is inherited by the subgraph calls.\n    const externalAbortSignal = previousSignals.externalAbortSignal ?? signal;\n\n    // inherit the step timeout signal from parent graph\n    const timeoutAbortSignal =\n      stepTimeoutSignal ?? previousSignals.timeoutAbortSignal;\n\n    const { signal: composedAbortSignal, dispose: disposeCombinedSignal } =\n      combineAbortSignals(\n        externalAbortSignal,\n        timeoutAbortSignal,\n        exceptionSignal\n      );\n\n    const signals: PregelAbortSignals = {\n      externalAbortSignal,\n      timeoutAbortSignal,\n      composedAbortSignal,\n    };\n\n    this.loop.config = patchConfigurable(this.loop.config, {\n      [CONFIG_KEY_ABORT_SIGNALS]: signals,\n    });\n\n    return { signals, disposeCombinedSignal };\n  }\n\n  /**\n   * Concurrently executes tasks with the requested retry policy, yielding a {@link SettledPregelTask} for each task as it completes.\n   * @param tasks - The tasks to execute.\n   * @param options - Options for the execution.\n   */\n  private async *_executeTasksWithRetry(\n    tasks: PregelExecutableTask<string, string>[],\n    options?: {\n      signals?: PregelAbortSignals;\n      retryPolicy?: RetryPolicy;\n      maxConcurrency?: number;\n    }\n  ): AsyncGenerator<SettledPregelTask> {\n    const { retryPolicy, maxConcurrency, signals } = options ?? {};\n\n    const barrier = createPromiseBarrier();\n    const executingTasksMap: Record<\n      string,\n      Promise<{\n        task: PregelExecutableTask<string, string>;\n        result?: unknown;\n        error?: Error;\n      }>\n    > = {};\n\n    const thisCall = {\n      executingTasksMap,\n      barrier,\n      retryPolicy,\n      scheduleTask: async (\n        task: PregelExecutableTask<string, string>,\n        writeIdx: number,\n        call?: Call\n      ) => this.loop.acceptPush(task, writeIdx, call),\n    };\n\n    if (signals?.composedAbortSignal?.aborted) {\n      // note: don't use throwIfAborted here because it throws a DOMException,\n      // which isn't consistent with how we throw on abort below.\n      throw new Error(\"Abort\");\n    }\n\n    let startedTasksCount = 0;\n\n    let listener: (() => void) | undefined;\n    const timeoutOrCancelSignal = combineAbortSignals(\n      signals?.externalAbortSignal,\n      signals?.timeoutAbortSignal\n    );\n\n    const abortPromise = timeoutOrCancelSignal.signal\n      ? new Promise<never>((_resolve, reject) => {\n          listener = () => reject(new Error(\"Abort\"));\n          timeoutOrCancelSignal.signal?.addEventListener(\"abort\", listener, {\n            once: true,\n          });\n        })\n      : undefined;\n\n    while (\n      (startedTasksCount === 0 || Object.keys(executingTasksMap).length > 0) &&\n      tasks.length\n    ) {\n      for (\n        ;\n        Object.values(executingTasksMap).length <\n          (maxConcurrency ?? tasks.length) && startedTasksCount < tasks.length;\n        startedTasksCount += 1\n      ) {\n        const task = tasks[startedTasksCount];\n\n        executingTasksMap[task.id] = _runWithRetry(\n          task,\n          retryPolicy,\n          { [CONFIG_KEY_CALL]: call?.bind(thisCall, this, task) },\n          signals?.composedAbortSignal\n        ).catch((error) => {\n          return {\n            task,\n            error,\n            signalAborted: signals?.composedAbortSignal?.aborted,\n          };\n        });\n      }\n\n      const settledTask = await Promise.race([\n        ...Object.values(executingTasksMap),\n        ...(abortPromise ? [abortPromise] : []),\n        barrier.wait,\n      ]);\n\n      if (settledTask === PROMISE_ADDED_SYMBOL) {\n        continue;\n      }\n\n      yield settledTask as SettledPregelTask;\n\n      if (listener != null) {\n        timeoutOrCancelSignal.signal?.removeEventListener(\"abort\", listener);\n        timeoutOrCancelSignal.dispose?.();\n      }\n\n      delete executingTasksMap[(settledTask as SettledPregelTask).task.id];\n    }\n  }\n\n  /**\n   * Determines what writes to apply based on whether the task completed successfully, and what type of error occurred.\n   *\n   * Throws an error if the error is a {@link GraphBubbleUp} error and {@link PregelLoop}#isNested is true.\n   *\n   * @param task - The task to commit.\n   * @param error - The error that occurred, if any.\n   */\n  private _commit(task: PregelExecutableTask<string, string>, error?: Error) {\n    if (error !== undefined) {\n      if (isGraphInterrupt(error)) {\n        if (error.interrupts.length) {\n          const interrupts: PendingWrite<string>[] = error.interrupts.map(\n            (interrupt) => [INTERRUPT, interrupt]\n          );\n          const resumes = task.writes.filter((w) => w[0] === RESUME);\n          if (resumes.length) {\n            interrupts.push(...resumes);\n          }\n          this.loop.putWrites(task.id, interrupts);\n        }\n      } else if (isGraphBubbleUp(error) && task.writes.length) {\n        this.loop.putWrites(task.id, task.writes);\n      } else {\n        this.loop.putWrites(task.id, [\n          [ERROR, { message: error.message, name: error.name }],\n        ]);\n      }\n    } else {\n      if (\n        this.nodeFinished &&\n        (task.config?.tags == null || !task.config.tags.includes(TAG_HIDDEN))\n      ) {\n        this.nodeFinished(String(task.name));\n      }\n\n      if (task.writes.length === 0) {\n        // Add no writes marker\n        task.writes.push([NO_WRITES, null]);\n      }\n\n      // Save task writes to checkpointer\n      this.loop.putWrites(task.id, task.writes);\n    }\n  }\n}\n\nasync function call(\n  this: {\n    executingTasksMap: Record<\n      string,\n      Promise<{\n        task: PregelExecutableTask<string, string>;\n        result?: unknown;\n        error?: Error;\n      }>\n    >;\n\n    barrier: {\n      next: () => void;\n      wait: Promise<unknown>;\n    };\n\n    retryPolicy?: RetryPolicy;\n\n    scheduleTask: (\n      task: PregelExecutableTask<string, string>,\n      writeIdx: number,\n      call?: Call\n    ) => Promise<PregelExecutableTask<string, string> | void>;\n  },\n  runner: PregelRunner,\n  task: PregelExecutableTask<string, string>,\n  func: (...args: unknown[]) => unknown | Promise<unknown>,\n  name: string,\n  input: unknown,\n  options: {\n    retry?: RetryPolicy;\n    cache?: CachePolicy;\n    callbacks?: unknown;\n  } = {}\n): Promise<unknown> {\n  // Schedule PUSH tasks, collect promises\n  const scratchpad = task.config?.configurable?.[CONFIG_KEY_SCRATCHPAD] as\n    | PregelScratchpad<unknown>\n    | undefined;\n\n  if (!scratchpad) {\n    throw new Error(\n      `BUG: No scratchpad found on task ${task.name}__${task.id}`\n    );\n  }\n\n  const cnt = scratchpad.callCounter;\n  scratchpad.callCounter += 1;\n\n  // schedule the next task, if the callback returns one\n  const wcall = new Call({\n    func,\n    name,\n    input,\n    cache: options.cache,\n    retry: options.retry,\n    callbacks: options.callbacks,\n  });\n  const nextTask = await this.scheduleTask(task, cnt, wcall);\n  if (!nextTask) return undefined;\n\n  // Check if this task is already running\n  const existingPromise = this.executingTasksMap[nextTask.id];\n\n  if (existingPromise !== undefined) {\n    // If the parent task was retried, the next task might already be running\n    return existingPromise;\n  }\n\n  if (nextTask.writes.length > 0) {\n    // If it already ran, return the result\n    const returns = nextTask.writes.filter(([c]) => c === RETURN);\n    const errors = nextTask.writes.filter(([c]) => c === ERROR);\n\n    if (returns.length > 0) {\n      // Task completed successfully\n      if (returns.length === 1) return Promise.resolve(returns[0][1]);\n\n      // should be unreachable\n      throw new Error(\n        `BUG: multiple returns found for task ${nextTask.name}__${nextTask.id}`\n      );\n    }\n\n    if (errors.length > 0) {\n      // Task failed\n      if (errors.length === 1) {\n        const errorValue = errors[0][1];\n        const error =\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          errorValue instanceof Error\n            ? errorValue\n            : new Error(String(errorValue));\n\n        return Promise.reject(error);\n      }\n\n      // the only way this should happen is if the task executes multiple times and writes aren't cleared\n      throw new Error(\n        `BUG: multiple errors found for task ${nextTask.name}__${nextTask.id}`\n      );\n    }\n\n    return undefined;\n  } else {\n    // Schedule the next task with retry\n    const prom = _runWithRetry<string, string>(nextTask, options.retry, {\n      [CONFIG_KEY_CALL]: call.bind(this, runner, nextTask),\n    });\n\n    this.executingTasksMap[nextTask.id] = prom;\n    this.barrier.next();\n\n    return prom.then(({ result, error }) => {\n      if (error) return Promise.reject(error);\n      return result;\n    });\n  }\n}\n", "import { All } from \"@langchain/langgraph-checkpoint\";\nimport { BaseChannel } from \"../channels/index.js\";\nimport { INTERRUPT } from \"../constants.js\";\nimport { PregelNode } from \"./read.js\";\n\nexport class GraphValidationError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"GraphValidationError\";\n  }\n}\n\nexport function validateGraph<\n  Nn extends Record<string, PregelNode>,\n  Cc extends Record<string, BaseChannel>\n>({\n  nodes,\n  channels,\n  inputChannels,\n  outputChannels,\n  streamChannels,\n  interruptAfterNodes,\n  interruptBeforeNodes,\n}: {\n  nodes: Nn;\n  channels: Cc;\n  inputChannels: keyof Cc | Array<keyof Cc>;\n  outputChannels: keyof Cc | Array<keyof Cc>;\n  streamChannels?: keyof Cc | Array<keyof Cc>;\n  interruptAfterNodes?: Array<keyof Nn> | All;\n  interruptBeforeNodes?: Array<keyof Nn> | All;\n}): void {\n  if (!channels) {\n    throw new GraphValidationError(\"Channels not provided\");\n  }\n\n  const subscribedChannels = new Set<keyof Cc>();\n  const allOutputChannels = new Set<keyof Cc>();\n\n  for (const [name, node] of Object.entries(nodes)) {\n    if (name === INTERRUPT) {\n      throw new GraphValidationError(`\"Node name ${INTERRUPT} is reserved\"`);\n    }\n    if (node.constructor === PregelNode) {\n      node.triggers.forEach((trigger) => subscribedChannels.add(trigger));\n    } else {\n      throw new GraphValidationError(\n        `Invalid node type ${typeof node}, expected PregelNode`\n      );\n    }\n  }\n\n  // side effect: update channels\n  for (const chan of subscribedChannels) {\n    if (!(chan in channels)) {\n      throw new GraphValidationError(\n        `Subscribed channel '${String(chan)}' not in channels`\n      );\n    }\n  }\n\n  if (!Array.isArray(inputChannels)) {\n    if (!subscribedChannels.has(inputChannels)) {\n      throw new GraphValidationError(\n        `Input channel ${String(\n          inputChannels\n        )} is not subscribed to by any node`\n      );\n    }\n  } else {\n    if (inputChannels.every((channel) => !subscribedChannels.has(channel))) {\n      throw new GraphValidationError(\n        `None of the input channels ${inputChannels} are subscribed to by any node`\n      );\n    }\n  }\n\n  if (!Array.isArray(outputChannels)) {\n    allOutputChannels.add(outputChannels);\n  } else {\n    outputChannels.forEach((chan) => allOutputChannels.add(chan));\n  }\n\n  if (streamChannels && !Array.isArray(streamChannels)) {\n    allOutputChannels.add(streamChannels);\n  } else if (Array.isArray(streamChannels)) {\n    streamChannels.forEach((chan) => allOutputChannels.add(chan));\n  }\n\n  for (const chan of allOutputChannels) {\n    if (!(chan in channels)) {\n      throw new GraphValidationError(\n        `Output channel '${String(chan)}' not in channels`\n      );\n    }\n  }\n\n  // validate interrupt before/after\n  if (interruptAfterNodes && interruptAfterNodes !== \"*\") {\n    for (const node of interruptAfterNodes) {\n      if (!(node in nodes)) {\n        throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n      }\n    }\n  }\n\n  if (interruptBeforeNodes && interruptBeforeNodes !== \"*\") {\n    for (const node of interruptBeforeNodes) {\n      if (!(node in nodes)) {\n        throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n      }\n    }\n  }\n}\n\nexport function validateKeys<Cc extends Record<string, BaseChannel>>(\n  keys: keyof Cc | Array<keyof Cc>,\n  channels: Cc\n): void {\n  if (Array.isArray(keys)) {\n    for (const key of keys) {\n      if (!(key in channels)) {\n        throw new Error(`Key ${String(key)} not found in channels`);\n      }\n    }\n  } else {\n    if (!(keys in channels)) {\n      throw new Error(`Key ${String(keys)} not found in channels`);\n    }\n  }\n}\n", "import { EmptyChannelError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n/**\n * A configurable PubSub Topic.\n */\nexport class Topic<Value> extends BaseChannel<\n  Array<Value>,\n  Value | Value[],\n  [Value[], Value[]]\n> {\n  lc_graph_name = \"Topic\";\n\n  unique = false;\n\n  accumulate = false;\n\n  seen: Set<Value>;\n\n  values: Value[];\n\n  constructor(fields?: {\n    /**\n     * Whether to only add unique values to the topic. If `true`, only unique values (using reference equality) will be added to the topic.\n     */\n    unique?: boolean;\n    /**\n     * Whether to accumulate values across steps. If `false`, the channel will be emptied after each step.\n     */\n    accumulate?: boolean;\n  }) {\n    super();\n\n    this.unique = fields?.unique ?? this.unique;\n    this.accumulate = fields?.accumulate ?? this.accumulate;\n    // State\n    this.seen = new Set<Value>();\n    this.values = [];\n  }\n\n  public fromCheckpoint(checkpoint?: [Value[], Value[]]) {\n    const empty = new Topic<Value>({\n      unique: this.unique,\n      accumulate: this.accumulate,\n    });\n    if (typeof checkpoint !== \"undefined\") {\n      empty.seen = new Set(checkpoint[0]);\n      // eslint-disable-next-line prefer-destructuring\n      empty.values = checkpoint[1];\n    }\n    return empty as this;\n  }\n\n  public update(values: Array<Value | Value[]>): boolean {\n    let updated = false;\n    if (!this.accumulate) {\n      updated = this.values.length > 0;\n      this.values = [];\n    }\n    const flatValues = values.flat() as Value[];\n    if (flatValues.length > 0) {\n      if (this.unique) {\n        for (const value of flatValues) {\n          if (!this.seen.has(value)) {\n            updated = true;\n            this.seen.add(value);\n            this.values.push(value);\n          }\n        }\n      } else {\n        updated = true;\n        this.values.push(...flatValues);\n      }\n    }\n    return updated;\n  }\n\n  public get(): Array<Value> {\n    if (this.values.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.values;\n  }\n\n  public checkpoint(): [Value[], Value[]] {\n    return [[...this.seen], this.values];\n  }\n\n  isAvailable(): boolean {\n    return this.values.length !== 0;\n  }\n}\n", "/* eslint-disable no-param-reassign */\nimport {\n  _coerceToRunnable,\n  getCallbackManagerForConfig,\n  mergeConfigs,\n  patchConfig,\n  Runnable,\n  RunnableConfig,\n  RunnableFunc,\n  RunnableLike,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport type { StreamEvent } from \"@langchain/core/tracers/log_stream\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport {\n  All,\n  BaseCache,\n  BaseCheckpointSaver,\n  BaseStore,\n  CheckpointListOptions,\n  CheckpointMetadata,\n  CheckpointTuple,\n  compareChannelVersions,\n  copyCheckpoint,\n  emptyCheckpoint,\n  PendingWrite,\n  SCHEDULED,\n  SendProtocol,\n  uuid5,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n  getOnlyChannels,\n} from \"../channels/base.js\";\nimport {\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_NODE_FINISHED,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_SEND,\n  CONFIG_KEY_STREAM,\n  CONFIG_KEY_TASK_ID,\n  COPY,\n  END,\n  ERROR,\n  INPUT,\n  INTERRUPT,\n  Interrupt,\n  isInterrupted,\n  NULL_TASK_ID,\n  PUSH,\n  CONFIG_KEY_DURABILITY,\n  CONFIG_KEY_CHECKPOINT_NS,\n  type CommandInstance,\n  TASKS,\n} from \"../constants.js\";\nimport {\n  GraphRecursionError,\n  GraphValueError,\n  InvalidUpdateError,\n} from \"../errors.js\";\nimport { gatherIterator, patchConfigurable } from \"../utils.js\";\nimport {\n  _applyWrites,\n  _localRead,\n  _prepareNextTasks,\n  StrRecord,\n  WritesProtocol,\n} from \"./algo.js\";\nimport {\n  printStepCheckpoint,\n  printStepTasks,\n  printStepWrites,\n  tasksWithWrites,\n} from \"./debug.js\";\nimport { mapInput, readChannels } from \"./io.js\";\nimport { PregelLoop } from \"./loop.js\";\nimport { StreamMessagesHandler } from \"./messages.js\";\nimport { PregelNode } from \"./read.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { PregelRunner } from \"./runner.js\";\nimport {\n  IterableReadableStreamWithAbortSignal,\n  IterableReadableWritableStream,\n  toEventStream,\n} from \"./stream.js\";\nimport type {\n  Durability,\n  GetStateOptions,\n  MultipleChannelSubscriptionOptions,\n  PregelExecutableTask,\n  PregelInputType,\n  PregelInterface,\n  PregelOptions,\n  PregelOutputType,\n  PregelParams,\n  SingleChannelSubscriptionOptions,\n  StateSnapshot,\n  StreamMode,\n  StreamOutputMap,\n} from \"./types.js\";\nimport {\n  ensureLangGraphConfig,\n  getConfig,\n  recastCheckpointNamespace,\n} from \"./utils/config.js\";\nimport {\n  _coerceToDict,\n  combineAbortSignals,\n  combineCallbacks,\n  getNewChannelVersions,\n  patchCheckpointMap,\n  RetryPolicy,\n} from \"./utils/index.js\";\nimport { findSubgraphPregel } from \"./utils/subgraph.js\";\nimport { validateGraph, validateKeys } from \"./validate.js\";\nimport { ChannelWrite, ChannelWriteEntry, PASSTHROUGH } from \"./write.js\";\nimport { Topic } from \"../channels/topic.js\";\nimport { interrupt } from \"../interrupt.js\";\n\ntype WriteValue = Runnable | RunnableFunc<unknown, unknown> | unknown;\ntype StreamEventsOptions = Parameters<Runnable[\"streamEvents\"]>[2];\n\n/**\n * Utility class for working with channels in the Pregel system.\n * Provides static methods for subscribing to channels and writing to them.\n *\n * Channels are the communication pathways between nodes in a Pregel graph.\n * They enable message passing and state updates between different parts of the graph.\n */\nexport class Channel {\n  /**\n   * Creates a PregelNode that subscribes to a single channel.\n   * This is used to define how nodes receive input from channels.\n   *\n   * @example\n   * ```typescript\n   * // Subscribe to a single channel\n   * const node = Channel.subscribeTo(\"messages\");\n   *\n   * // Subscribe to multiple channels\n   * const node = Channel.subscribeTo([\"messages\", \"state\"]);\n   *\n   * // Subscribe with a custom key\n   * const node = Channel.subscribeTo(\"messages\", { key: \"chat\" });\n   * ```\n   *\n   * @param channel Single channel name to subscribe to\n   * @param options Subscription options\n   * @returns A PregelNode configured to receive from the specified channels\n   * @throws {Error} If a key is specified when subscribing to multiple channels\n   */\n  static subscribeTo(\n    channel: string,\n    options?: SingleChannelSubscriptionOptions\n  ): PregelNode;\n\n  /**\n   * Creates a PregelNode that subscribes to multiple channels.\n   * This is used to define how nodes receive input from channels.\n   *\n   * @example\n   * ```typescript\n   * // Subscribe to a single channel\n   * const node = Channel.subscribeTo(\"messages\");\n   *\n   * // Subscribe to multiple channels\n   * const node = Channel.subscribeTo([\"messages\", \"state\"]);\n   *\n   * // Subscribe with a custom key\n   * const node = Channel.subscribeTo(\"messages\", { key: \"chat\" });\n   * ```\n   *\n   * @param channels Single channel name to subscribe to\n   * @param options Subscription options\n   * @returns A PregelNode configured to receive from the specified channels\n   * @throws {Error} If a key is specified when subscribing to multiple channels\n   */\n  static subscribeTo(\n    channels: string[],\n    options?: MultipleChannelSubscriptionOptions\n  ): PregelNode;\n\n  static subscribeTo(\n    channels: string | string[],\n    options?:\n      | SingleChannelSubscriptionOptions\n      | MultipleChannelSubscriptionOptions\n  ): PregelNode {\n    const { key, tags } = {\n      key: undefined,\n      tags: undefined,\n      ...(options ?? {}),\n    };\n    if (Array.isArray(channels) && key !== undefined) {\n      throw new Error(\n        \"Can't specify a key when subscribing to multiple channels\"\n      );\n    }\n\n    let channelMappingOrArray: string[] | Record<string, string>;\n\n    if (typeof channels === \"string\") {\n      if (key) {\n        channelMappingOrArray = { [key]: channels };\n      } else {\n        channelMappingOrArray = [channels];\n      }\n    } else {\n      channelMappingOrArray = Object.fromEntries(\n        channels.map((chan) => [chan, chan])\n      );\n    }\n\n    const triggers: string[] = Array.isArray(channels) ? channels : [channels];\n\n    return new PregelNode({\n      channels: channelMappingOrArray,\n      triggers,\n      tags,\n    });\n  }\n\n  /**\n   * Creates a ChannelWrite that specifies how to write values to channels.\n   * This is used to define how nodes send output to channels.\n   *\n   * @example\n   * ```typescript\n   * // Write to multiple channels\n   * const write = Channel.writeTo([\"output\", \"state\"]);\n   *\n   * // Write with specific values\n   * const write = Channel.writeTo([\"output\"], {\n   *   state: \"completed\",\n   *   result: calculateResult()\n   * });\n   *\n   * // Write with a transformation function\n   * const write = Channel.writeTo([\"output\"], {\n   *   result: (x) => processResult(x)\n   * });\n   * ```\n   *\n   * @param channels - Array of channel names to write to\n   * @param writes - Optional map of channel names to values or transformations\n   * @returns A ChannelWrite object that can be used to write to the specified channels\n   */\n  static writeTo(\n    channels: string[],\n    writes?: Record<string, WriteValue>\n  ): ChannelWrite {\n    const channelWriteEntries: Array<ChannelWriteEntry> = [];\n\n    for (const channel of channels) {\n      channelWriteEntries.push({\n        channel,\n        value: PASSTHROUGH,\n        skipNone: false,\n      });\n    }\n\n    for (const [key, value] of Object.entries(writes ?? {})) {\n      if (Runnable.isRunnable(value) || typeof value === \"function\") {\n        channelWriteEntries.push({\n          channel: key,\n          value: PASSTHROUGH,\n          skipNone: true,\n          mapper: _coerceToRunnable(value as RunnableLike),\n        });\n      } else {\n        channelWriteEntries.push({\n          channel: key,\n          value,\n          skipNone: false,\n        });\n      }\n    }\n\n    return new ChannelWrite(channelWriteEntries);\n  }\n}\n\nexport type { PregelInputType, PregelOptions, PregelOutputType };\n\n// This is a workaround to allow Pregel to override `invoke` / `stream` and `withConfig`\n// without having to adhere to the types in the `Runnable` class (thanks to `any`).\n// Alternatively we could mark those methods with @ts-ignore / @ts-expect-error,\n// but these do not get carried over when building via `tsc`.\nclass PartialRunnable<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig\n> extends Runnable<RunInput, RunOutput, CallOptions> {\n  lc_namespace = [\"langgraph\", \"pregel\"];\n\n  override invoke(\n    _input: RunInput,\n    _options?: Partial<CallOptions>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    throw new Error(\"Not implemented\");\n  }\n\n  // Overriden by `Pregel`\n  override withConfig(_config: CallOptions): typeof this {\n    return super.withConfig(_config) as typeof this;\n  }\n\n  // Overriden by `Pregel`\n  override stream(\n    input: RunInput,\n    options?: Partial<CallOptions>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<IterableReadableStream<any>> {\n    return super.stream(input, options);\n  }\n}\n\n/**\n * The Pregel class is the core runtime engine of LangGraph, implementing a message-passing graph computation model\n * inspired by [Google's Pregel system](https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/).\n * It provides the foundation for building reliable, controllable agent workflows that can evolve state over time.\n *\n * Key features:\n * - Message passing between nodes in discrete \"supersteps\"\n * - Built-in persistence layer through checkpointers\n * - First-class streaming support for values, updates, and events\n * - Human-in-the-loop capabilities via interrupts\n * - Support for parallel node execution within supersteps\n *\n * The Pregel class is not intended to be instantiated directly by consumers. Instead, use the following higher-level APIs:\n * - {@link StateGraph}: The main graph class for building agent workflows\n *   - Compiling a {@link StateGraph} will return a {@link CompiledGraph} instance, which extends `Pregel`\n * - Functional API: A declarative approach using tasks and entrypoints\n *   - A `Pregel` instance is returned by the {@link entrypoint} function\n *\n * @example\n * ```typescript\n * // Using StateGraph API\n * const graph = new StateGraph(annotation)\n *   .addNode(\"nodeA\", myNodeFunction)\n *   .addEdge(\"nodeA\", \"nodeB\")\n *   .compile();\n *\n * // The compiled graph is a Pregel instance\n * const result = await graph.invoke(input);\n * ```\n *\n * @example\n * ```typescript\n * // Using Functional API\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * // Define tasks that can be composed\n * const addOne = task(\"add\", async (x: number) => x + 1);\n *\n * // Create a workflow using the entrypoint function\n * const workflow = entrypoint({\n *   name: \"workflow\",\n *   checkpointer: new MemorySaver()\n * }, async (numbers: number[]) => {\n *   // Tasks can be run in parallel\n *   const results = await Promise.all(numbers.map(n => addOne(n)));\n *   return results;\n * });\n *\n * // The workflow is a Pregel instance\n * const result = await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @typeParam Nodes - Mapping of node names to their {@link PregelNode} implementations\n * @typeParam Channels - Mapping of channel names to their {@link BaseChannel} or {@link ManagedValueSpec} implementations\n * @typeParam ContextType - Type of context that can be passed to the graph\n * @typeParam InputType - Type of input values accepted by the graph\n * @typeParam OutputType - Type of output values produced by the graph\n */\nexport class Pregel<\n    Nodes extends StrRecord<string, PregelNode>,\n    Channels extends StrRecord<string, BaseChannel>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ContextType extends Record<string, any> = StrRecord<string, any>,\n    InputType = PregelInputType,\n    OutputType = PregelOutputType,\n    StreamUpdatesType = InputType,\n    StreamValuesType = OutputType,\n    NodeReturnType = unknown,\n    CommandType = CommandInstance,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    StreamCustom = any\n  >\n  extends PartialRunnable<\n    InputType | CommandType | null,\n    OutputType,\n    PregelOptions<Nodes, Channels, ContextType>\n  >\n  implements PregelInterface<Nodes, Channels, ContextType>\n{\n  /**\n   * Name of the class when serialized\n   * @internal\n   */\n  static lc_name() {\n    return \"LangGraph\";\n  }\n\n  /** @internal Used for type inference */\n  declare \"~InputType\": InputType;\n\n  /** @internal Used for type inference */\n  declare \"~OutputType\": OutputType;\n\n  /** @internal LangChain namespace for serialization necessary because Pregel extends Runnable */\n  lc_namespace = [\"langgraph\", \"pregel\"];\n\n  /** @internal Flag indicating this is a Pregel instance - necessary for serialization */\n  lg_is_pregel = true;\n\n  /** The nodes in the graph, mapping node names to their PregelNode instances */\n  nodes: Nodes;\n\n  /** The channels in the graph, mapping channel names to their BaseChannel or ManagedValueSpec instances */\n  channels: Channels;\n\n  /**\n   * The input channels for the graph. These channels receive the initial input when the graph is invoked.\n   * Can be a single channel key or an array of channel keys.\n   */\n  inputChannels: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * The output channels for the graph. These channels contain the final output when the graph completes.\n   * Can be a single channel key or an array of channel keys.\n   */\n  outputChannels: keyof Channels | Array<keyof Channels>;\n\n  /** Whether to automatically validate the graph structure when it is compiled. Defaults to true. */\n  autoValidate: boolean = true;\n\n  /**\n   * The streaming modes enabled for this graph. Defaults to [\"values\"].\n   * Supported modes:\n   * - \"values\": Streams the full state after each step\n   * - \"updates\": Streams state updates after each step\n   * - \"messages\": Streams messages from within nodes\n   * - \"custom\": Streams custom events from within nodes\n   * - \"debug\": Streams events related to the execution of the graph - useful for tracing & debugging graph execution\n   */\n  streamMode: StreamMode[] = [\"values\"];\n\n  /**\n   * Optional channels to stream. If not specified, all channels will be streamed.\n   * Can be a single channel key or an array of channel keys.\n   */\n  streamChannels?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * Optional array of node names or \"all\" to interrupt after executing these nodes.\n   * Used for implementing human-in-the-loop workflows.\n   */\n  interruptAfter?: Array<keyof Nodes> | All;\n\n  /**\n   * Optional array of node names or \"all\" to interrupt before executing these nodes.\n   * Used for implementing human-in-the-loop workflows.\n   */\n  interruptBefore?: Array<keyof Nodes> | All;\n\n  /** Optional timeout in milliseconds for the execution of each superstep */\n  stepTimeout?: number;\n\n  /** Whether to enable debug logging. Defaults to false. */\n  debug: boolean = false;\n\n  /**\n   * Optional checkpointer for persisting graph state.\n   * When provided, saves a checkpoint of the graph state at every superstep.\n   * When false or undefined, checkpointing is disabled, and the graph will not be able to save or restore state.\n   */\n  checkpointer?: BaseCheckpointSaver | boolean;\n\n  /** Optional retry policy for handling failures in node execution */\n  retryPolicy?: RetryPolicy;\n\n  /** The default configuration for graph execution, can be overridden on a per-invocation basis */\n  config?: LangGraphRunnableConfig;\n\n  /**\n   * Optional long-term memory store for the graph, allows for persistence & retrieval of data across threads\n   */\n  store?: BaseStore;\n\n  /**\n   * Optional cache for the graph, useful for caching tasks.\n   */\n  cache?: BaseCache;\n\n  /**\n   * Optional interrupt helper function.\n   * @internal\n   */\n  private userInterrupt?: unknown;\n\n  /**\n   * The trigger to node mapping for the graph run.\n   * @internal\n   */\n  private triggerToNodes: Record<string, string[]> = {};\n\n  /**\n   * Constructor for Pregel - meant for internal use only.\n   *\n   * @internal\n   */\n  constructor(fields: PregelParams<Nodes, Channels>) {\n    super(fields);\n\n    let { streamMode } = fields;\n    if (streamMode != null && !Array.isArray(streamMode)) {\n      streamMode = [streamMode];\n    }\n\n    this.nodes = fields.nodes;\n    this.channels = fields.channels;\n\n    if (\n      TASKS in this.channels &&\n      \"lc_graph_name\" in this.channels[TASKS] &&\n      this.channels[TASKS].lc_graph_name !== \"Topic\"\n    ) {\n      throw new Error(\n        `Channel '${TASKS}' is reserved and cannot be used in the graph.`\n      );\n    } else {\n      (this.channels as Record<string, BaseChannel>)[TASKS] =\n        new Topic<SendProtocol>({ accumulate: false });\n    }\n\n    this.autoValidate = fields.autoValidate ?? this.autoValidate;\n    this.streamMode = streamMode ?? this.streamMode;\n    this.inputChannels = fields.inputChannels;\n    this.outputChannels = fields.outputChannels;\n    this.streamChannels = fields.streamChannels ?? this.streamChannels;\n    this.interruptAfter = fields.interruptAfter;\n    this.interruptBefore = fields.interruptBefore;\n    this.stepTimeout = fields.stepTimeout ?? this.stepTimeout;\n    this.debug = fields.debug ?? this.debug;\n    this.checkpointer = fields.checkpointer;\n    this.retryPolicy = fields.retryPolicy;\n    this.config = fields.config;\n    this.store = fields.store;\n    this.cache = fields.cache;\n    this.name = fields.name;\n    this.triggerToNodes = fields.triggerToNodes ?? this.triggerToNodes;\n    this.userInterrupt = fields.userInterrupt;\n\n    if (this.autoValidate) {\n      this.validate();\n    }\n  }\n\n  /**\n   * Creates a new instance of the Pregel graph with updated configuration.\n   * This method follows the immutable pattern - instead of modifying the current instance,\n   * it returns a new instance with the merged configuration.\n   *\n   * @example\n   * ```typescript\n   * // Create a new instance with debug enabled\n   * const debugGraph = graph.withConfig({ debug: true });\n   *\n   * // Create a new instance with a specific thread ID\n   * const threadGraph = graph.withConfig({\n   *   configurable: { thread_id: \"123\" }\n   * });\n   * ```\n   *\n   * @param config - The configuration to merge with the current configuration\n   * @returns A new Pregel instance with the merged configuration\n   */\n  override withConfig(\n    config: Omit<LangGraphRunnableConfig, \"store\" | \"writer\" | \"interrupt\">\n  ): typeof this {\n    const mergedConfig = mergeConfigs(this.config, config);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new (this.constructor as any)({ ...this, config: mergedConfig });\n  }\n\n  /**\n   * Validates the graph structure to ensure it is well-formed.\n   * Checks for:\n   * - No orphaned nodes\n   * - Valid input/output channel configurations\n   * - Valid interrupt configurations\n   *\n   * @returns this - The Pregel instance for method chaining\n   * @throws {GraphValidationError} If the graph structure is invalid\n   */\n  validate(): this {\n    validateGraph<Nodes, Channels>({\n      nodes: this.nodes,\n      channels: this.channels,\n      outputChannels: this.outputChannels,\n      inputChannels: this.inputChannels,\n      streamChannels: this.streamChannels,\n      interruptAfterNodes: this.interruptAfter,\n      interruptBeforeNodes: this.interruptBefore,\n    });\n\n    for (const [name, node] of Object.entries(this.nodes)) {\n      for (const trigger of node.triggers) {\n        this.triggerToNodes[trigger] ??= [];\n        this.triggerToNodes[trigger].push(name);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets a list of all channels that should be streamed.\n   * If streamChannels is specified, returns those channels.\n   * Otherwise, returns all channels in the graph.\n   *\n   * @returns Array of channel keys to stream\n   */\n  get streamChannelsList(): Array<keyof Channels> {\n    if (Array.isArray(this.streamChannels)) {\n      return this.streamChannels;\n    } else if (this.streamChannels) {\n      return [this.streamChannels];\n    } else {\n      return Object.keys(this.channels);\n    }\n  }\n\n  /**\n   * Gets the channels to stream in their original format.\n   * If streamChannels is specified, returns it as-is (either single key or array).\n   * Otherwise, returns all channels in the graph as an array.\n   *\n   * @returns Channel keys to stream, either as a single key or array\n   */\n  get streamChannelsAsIs(): keyof Channels | Array<keyof Channels> {\n    if (this.streamChannels) {\n      return this.streamChannels;\n    } else {\n      return Object.keys(this.channels);\n    }\n  }\n\n  /**\n   * Gets a drawable representation of the graph structure.\n   * This is an async version of getGraph() and is the preferred method to use.\n   *\n   * @param config - Configuration for generating the graph visualization\n   * @returns A representation of the graph that can be visualized\n   */\n  async getGraphAsync(config: RunnableConfig) {\n    return this.getGraph(config);\n  }\n\n  /**\n   * Gets all subgraphs within this graph.\n   * A subgraph is a Pregel instance that is nested within a node of this graph.\n   *\n   * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.\n   * @param namespace - Optional namespace to filter subgraphs\n   * @param recurse - Whether to recursively get subgraphs of subgraphs\n   * @returns Generator yielding tuples of [name, subgraph]\n   */\n  *getSubgraphs(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Generator<[string, Pregel<any, any>]> {\n    for (const [name, node] of Object.entries(this.nodes)) {\n      // filter by prefix\n      if (namespace !== undefined) {\n        if (!namespace.startsWith(name)) {\n          continue;\n        }\n      }\n      // find the subgraph if any\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      type SubgraphPregelType = Pregel<any, any> | undefined;\n\n      const candidates = node.subgraphs?.length ? node.subgraphs : [node.bound];\n\n      for (const candidate of candidates) {\n        const graph = findSubgraphPregel(candidate) as SubgraphPregelType;\n\n        if (graph !== undefined) {\n          if (name === namespace) {\n            yield [name, graph];\n            return;\n          }\n\n          if (namespace === undefined) {\n            yield [name, graph];\n          }\n\n          if (recurse) {\n            let newNamespace = namespace;\n            if (namespace !== undefined) {\n              newNamespace = namespace.slice(name.length + 1);\n            }\n            for (const [subgraphName, subgraph] of graph.getSubgraphs(\n              newNamespace,\n              recurse\n            )) {\n              yield [\n                `${name}${CHECKPOINT_NAMESPACE_SEPARATOR}${subgraphName}`,\n                subgraph,\n              ];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets all subgraphs within this graph asynchronously.\n   * A subgraph is a Pregel instance that is nested within a node of this graph.\n   *\n   * @param namespace - Optional namespace to filter subgraphs\n   * @param recurse - Whether to recursively get subgraphs of subgraphs\n   * @returns AsyncGenerator yielding tuples of [name, subgraph]\n   */\n  async *getSubgraphsAsync(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<[string, Pregel<any, any>]> {\n    yield* this.getSubgraphs(namespace, recurse);\n  }\n\n  /**\n   * Prepares a state snapshot from saved checkpoint data.\n   * This is an internal method used by getState and getStateHistory.\n   *\n   * @param config - Configuration for preparing the snapshot\n   * @param saved - Optional saved checkpoint data\n   * @param subgraphCheckpointer - Optional checkpointer for subgraphs\n   * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels\n   * @returns A snapshot of the graph state\n   * @internal\n   */\n  protected async _prepareStateSnapshot({\n    config,\n    saved,\n    subgraphCheckpointer,\n    applyPendingWrites = false,\n  }: {\n    config: RunnableConfig;\n    saved?: CheckpointTuple;\n    subgraphCheckpointer?: BaseCheckpointSaver;\n    applyPendingWrites?: boolean;\n  }): Promise<StateSnapshot> {\n    if (saved === undefined) {\n      return {\n        values: {},\n        next: [],\n        config,\n        tasks: [],\n      };\n    }\n\n    // Create all channels\n    const channels = emptyChannels(\n      this.channels as Record<string, BaseChannel>,\n      saved.checkpoint\n    );\n\n    // Apply null writes first (from NULL_TASK_ID)\n    if (saved.pendingWrites?.length) {\n      const nullWrites = saved.pendingWrites\n        .filter(([taskId, _]) => taskId === NULL_TASK_ID)\n        .map(\n          ([_, channel, value]) => [String(channel), value] as [string, unknown]\n        );\n\n      if (nullWrites.length > 0) {\n        _applyWrites(\n          saved.checkpoint,\n          channels,\n          [\n            {\n              name: INPUT,\n              writes: nullWrites as PendingWrite[],\n              triggers: [],\n            },\n          ],\n          undefined,\n          this.triggerToNodes\n        );\n      }\n    }\n\n    // Prepare next tasks\n    const nextTasks = Object.values(\n      _prepareNextTasks(\n        saved.checkpoint,\n        saved.pendingWrites,\n        this.nodes,\n        channels,\n        saved.config,\n        true,\n        { step: (saved.metadata?.step ?? -1) + 1, store: this.store }\n      )\n    );\n\n    // Find subgraphs\n    const subgraphs = await gatherIterator(this.getSubgraphsAsync());\n    const parentNamespace = saved.config.configurable?.checkpoint_ns ?? \"\";\n    const taskStates: Record<string, RunnableConfig | StateSnapshot> = {};\n\n    // Prepare task states for subgraphs\n    for (const task of nextTasks) {\n      const matchingSubgraph = subgraphs.find(([name]) => name === task.name);\n      if (!matchingSubgraph) {\n        continue;\n      }\n      // assemble checkpoint_ns for this task\n      let taskNs = `${String(task.name)}${CHECKPOINT_NAMESPACE_END}${task.id}`;\n      if (parentNamespace) {\n        taskNs = `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${taskNs}`;\n      }\n      if (subgraphCheckpointer === undefined) {\n        // set config as signal that subgraph checkpoints exist\n        const config: RunnableConfig = {\n          configurable: {\n            thread_id: saved.config.configurable?.thread_id,\n            checkpoint_ns: taskNs,\n          },\n        };\n        taskStates[task.id] = config;\n      } else {\n        // get the state of the subgraph\n        const subgraphConfig: RunnableConfig = {\n          configurable: {\n            [CONFIG_KEY_CHECKPOINTER]: subgraphCheckpointer,\n            thread_id: saved.config.configurable?.thread_id,\n            checkpoint_ns: taskNs,\n          },\n        };\n        const pregel = matchingSubgraph[1];\n        taskStates[task.id] = await pregel.getState(subgraphConfig, {\n          subgraphs: true,\n        });\n      }\n    }\n\n    // Apply pending writes to tasks and then to channels if applyPendingWrites is true\n    if (applyPendingWrites && saved.pendingWrites?.length) {\n      // Map task IDs to task objects for easy lookup\n      const nextTaskById = Object.fromEntries(\n        nextTasks.map((task) => [task.id, task])\n      );\n\n      // Apply pending writes to the appropriate tasks\n      for (const [taskId, channel, value] of saved.pendingWrites) {\n        // Skip special channels and tasks not in nextTasks\n        if ([ERROR, INTERRUPT, SCHEDULED].includes(channel)) {\n          continue;\n        }\n        if (!(taskId in nextTaskById)) {\n          continue;\n        }\n        // Add the write to the task\n        nextTaskById[taskId].writes.push([String(channel), value]);\n      }\n\n      // Apply writes from tasks that have writes\n      const tasksWithWrites = nextTasks.filter(\n        (task) => task.writes.length > 0\n      );\n      if (tasksWithWrites.length > 0) {\n        _applyWrites(\n          saved.checkpoint,\n          channels,\n          tasksWithWrites as unknown as WritesProtocol[],\n          undefined,\n          this.triggerToNodes\n        );\n      }\n    }\n\n    // Preserve thread_id from the config in metadata\n    let metadata = saved?.metadata;\n    if (metadata && saved?.config?.configurable?.thread_id) {\n      metadata = {\n        ...metadata,\n        thread_id: saved.config.configurable.thread_id as string,\n      } as CheckpointMetadata;\n    }\n\n    // Filter next tasks - only include tasks without writes\n    const nextList = nextTasks\n      .filter((task) => task.writes.length === 0)\n      .map((task) => task.name as string);\n\n    // assemble the state snapshot\n    return {\n      values: readChannels(\n        channels,\n        this.streamChannelsAsIs as string | string[]\n      ),\n      next: nextList,\n      tasks: tasksWithWrites(\n        nextTasks,\n        saved?.pendingWrites ?? [],\n        taskStates,\n        this.streamChannelsAsIs\n      ),\n      metadata,\n      config: patchCheckpointMap(saved.config, saved.metadata),\n      createdAt: saved.checkpoint.ts,\n      parentConfig: saved.parentConfig,\n    };\n  }\n\n  /**\n   * Gets the current state of the graph.\n   * Requires a checkpointer to be configured.\n   *\n   * @param config - Configuration for retrieving the state\n   * @param options - Additional options\n   * @returns A snapshot of the current graph state\n   * @throws {GraphValueError} If no checkpointer is configured\n   */\n  async getState(\n    config: RunnableConfig,\n    options?: GetStateOptions\n  ): Promise<StateSnapshot> {\n    const checkpointer =\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\", {\n        lc_error_code: \"MISSING_CHECKPOINTER\",\n      });\n    }\n\n    const checkpointNamespace: string =\n      config.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      // remove task_ids from checkpoint_ns\n      const recastNamespace = recastCheckpointNamespace(checkpointNamespace);\n      for await (const [name, subgraph] of this.getSubgraphsAsync(\n        recastNamespace,\n        true\n      )) {\n        if (name === recastNamespace) {\n          return await subgraph.getState(\n            patchConfigurable(config, {\n              [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n            }),\n            { subgraphs: options?.subgraphs }\n          );\n        }\n      }\n      throw new Error(\n        `Subgraph with namespace \"${recastNamespace}\" not found.`\n      );\n    }\n\n    const mergedConfig = mergeConfigs(this.config, config);\n    const saved = await checkpointer.getTuple(config);\n    const snapshot = await this._prepareStateSnapshot({\n      config: mergedConfig,\n      saved,\n      subgraphCheckpointer: options?.subgraphs ? checkpointer : undefined,\n      applyPendingWrites: !config.configurable?.checkpoint_id,\n    });\n    return snapshot;\n  }\n\n  /**\n   * Gets the history of graph states.\n   * Requires a checkpointer to be configured.\n   * Useful for:\n   * - Debugging execution history\n   * - Implementing time travel\n   * - Analyzing graph behavior\n   *\n   * @param config - Configuration for retrieving the history\n   * @param options - Options for filtering the history\n   * @returns An async iterator of state snapshots\n   * @throws {Error} If no checkpointer is configured\n   */\n  async *getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot> {\n    const checkpointer: BaseCheckpointSaver =\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\", {\n        lc_error_code: \"MISSING_CHECKPOINTER\",\n      });\n    }\n\n    const checkpointNamespace: string =\n      config.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      const recastNamespace = recastCheckpointNamespace(checkpointNamespace);\n\n      // find the subgraph with the matching name\n      for await (const [name, pregel] of this.getSubgraphsAsync(\n        recastNamespace,\n        true\n      )) {\n        if (name === recastNamespace) {\n          yield* pregel.getStateHistory(\n            patchConfigurable(config, {\n              [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n            }),\n            options\n          );\n          return;\n        }\n      }\n      throw new Error(\n        `Subgraph with namespace \"${recastNamespace}\" not found.`\n      );\n    }\n\n    const mergedConfig = mergeConfigs(this.config, config, {\n      configurable: { checkpoint_ns: checkpointNamespace },\n    });\n\n    for await (const checkpointTuple of checkpointer.list(\n      mergedConfig,\n      options\n    )) {\n      yield this._prepareStateSnapshot({\n        config: checkpointTuple.config,\n        saved: checkpointTuple,\n      });\n    }\n  }\n\n  /**\n   * Apply updates to the graph state in bulk.\n   * Requires a checkpointer to be configured.\n   *\n   * This method is useful for recreating a thread\n   * from a list of updates, especially if a checkpoint\n   * is created as a result of multiple tasks.\n   *\n   * @internal The API might change in the future.\n   *\n   * @param startConfig - Configuration for the update\n   * @param updates - The list of updates to apply to graph state\n   * @returns Updated configuration\n   * @throws {GraphValueError} If no checkpointer is configured\n   * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.\n   */\n  async bulkUpdateState(\n    startConfig: LangGraphRunnableConfig,\n    supersteps: Array<{\n      updates: Array<{\n        values?: Record<string, unknown> | unknown;\n        asNode?: keyof Nodes | string;\n      }>;\n    }>\n  ): Promise<RunnableConfig> {\n    const checkpointer: BaseCheckpointSaver | undefined =\n      startConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\", {\n        lc_error_code: \"MISSING_CHECKPOINTER\",\n      });\n    }\n    if (supersteps.length === 0) {\n      throw new Error(\"No supersteps provided\");\n    }\n\n    if (supersteps.some((s) => s.updates.length === 0)) {\n      throw new Error(\"No updates provided\");\n    }\n\n    // delegate to subgraph\n    const checkpointNamespace: string =\n      startConfig.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      startConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      // remove task_ids from checkpoint_ns\n      const recastNamespace = recastCheckpointNamespace(checkpointNamespace);\n      // find the subgraph with the matching name\n      // eslint-disable-next-line no-unreachable-loop\n      for await (const [, pregel] of this.getSubgraphsAsync(\n        recastNamespace,\n        true\n      )) {\n        return await pregel.bulkUpdateState(\n          patchConfigurable(startConfig, {\n            [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n          }),\n          supersteps\n        );\n      }\n      throw new Error(`Subgraph \"${recastNamespace}\" not found`);\n    }\n\n    const updateSuperStep = async (\n      inputConfig: LangGraphRunnableConfig,\n      updates: {\n        values?: Record<string, unknown> | unknown;\n        asNode?: keyof Nodes | string;\n        taskId?: string;\n      }[]\n    ) => {\n      // get last checkpoint\n      const config = this.config\n        ? mergeConfigs(this.config, inputConfig)\n        : inputConfig;\n      const saved = await checkpointer.getTuple(config);\n      const checkpoint =\n        saved !== undefined\n          ? copyCheckpoint(saved.checkpoint)\n          : emptyCheckpoint();\n      const checkpointPreviousVersions = {\n        ...saved?.checkpoint.channel_versions,\n      };\n      const step = saved?.metadata?.step ?? -1;\n\n      // merge configurable fields with previous checkpoint config\n      let checkpointConfig = patchConfigurable(config, {\n        checkpoint_ns: config.configurable?.checkpoint_ns ?? \"\",\n      });\n      let checkpointMetadata = config.metadata ?? {};\n      if (saved?.config.configurable) {\n        checkpointConfig = patchConfigurable(config, saved.config.configurable);\n        checkpointMetadata = {\n          ...saved.metadata,\n          ...checkpointMetadata,\n        };\n      }\n\n      // Find last node that updated the state, if not provided\n      const { values, asNode } = updates[0];\n      if (values == null && asNode === undefined) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot create empty checkpoint with multiple updates`\n          );\n        }\n\n        const nextConfig = await checkpointer.put(\n          checkpointConfig,\n          createCheckpoint(checkpoint, undefined, step),\n          {\n            source: \"update\",\n            step: step + 1,\n            parents: saved?.metadata?.parents ?? {},\n          },\n          {}\n        );\n        return patchCheckpointMap(\n          nextConfig,\n          saved ? saved.metadata : undefined\n        );\n      }\n\n      // update channels\n      const channels = emptyChannels(\n        this.channels as Record<string, BaseChannel>,\n        checkpoint\n      );\n\n      if (values === null && asNode === END) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot apply multiple updates when clearing state`\n          );\n        }\n\n        if (saved) {\n          // tasks for this checkpoint\n          const nextTasks = _prepareNextTasks(\n            checkpoint,\n            saved.pendingWrites || [],\n            this.nodes,\n            channels,\n            saved.config,\n            true,\n            {\n              step: (saved.metadata?.step ?? -1) + 1,\n              checkpointer,\n              store: this.store,\n            }\n          );\n\n          // apply null writes\n          const nullWrites = (saved.pendingWrites || [])\n            .filter((w) => w[0] === NULL_TASK_ID)\n            .map((w) => w.slice(1)) as PendingWrite<string>[];\n          if (nullWrites.length > 0) {\n            _applyWrites(\n              checkpoint,\n              channels,\n              [\n                {\n                  name: INPUT,\n                  writes: nullWrites,\n                  triggers: [],\n                },\n              ],\n              checkpointer.getNextVersion.bind(checkpointer),\n              this.triggerToNodes\n            );\n          }\n          // apply writes from tasks that already ran\n          for (const [taskId, k, v] of saved.pendingWrites || []) {\n            if ([ERROR, INTERRUPT, SCHEDULED].includes(k)) {\n              continue;\n            }\n            if (!(taskId in nextTasks)) {\n              continue;\n            }\n            nextTasks[taskId].writes.push([k, v]);\n          }\n          // clear all current tasks\n          _applyWrites(\n            checkpoint,\n            channels,\n            Object.values(nextTasks) as WritesProtocol<string>[],\n            checkpointer.getNextVersion.bind(checkpointer),\n            this.triggerToNodes\n          );\n        }\n        // save checkpoint\n        const nextConfig = await checkpointer.put(\n          checkpointConfig,\n          createCheckpoint(checkpoint, channels, step),\n          {\n            ...checkpointMetadata,\n            source: \"update\",\n            step: step + 1,\n            parents: saved?.metadata?.parents ?? {},\n          },\n          getNewChannelVersions(\n            checkpointPreviousVersions,\n            checkpoint.channel_versions\n          )\n        );\n        return patchCheckpointMap(\n          nextConfig,\n          saved ? saved.metadata : undefined\n        );\n      }\n\n      if (asNode === COPY) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot copy checkpoint with multiple updates`\n          );\n        }\n\n        if (saved == null) {\n          throw new InvalidUpdateError(`Cannot copy a non-existent checkpoint`);\n        }\n\n        const isCopyWithUpdates = (\n          values: unknown\n        ): values is [values: unknown, asNode: string][] => {\n          if (!Array.isArray(values)) return false;\n          if (values.length === 0) return false;\n          return values.every((v) => Array.isArray(v) && v.length === 2);\n        };\n\n        const nextCheckpoint = createCheckpoint(checkpoint, undefined, step);\n        const nextConfig = await checkpointer.put(\n          saved.parentConfig ??\n            patchConfigurable(saved.config, { checkpoint_id: undefined }),\n          nextCheckpoint,\n          {\n            source: \"fork\",\n            step: step + 1,\n            parents: saved.metadata?.parents ?? {},\n          },\n          {}\n        );\n\n        // We want to both clone a checkpoint and update state in one go.\n        // Reuse the same task ID if possible.\n        if (isCopyWithUpdates(values)) {\n          // figure out the task IDs for the next update checkpoint\n          const nextTasks = _prepareNextTasks(\n            nextCheckpoint,\n            saved.pendingWrites,\n            this.nodes,\n            channels,\n            nextConfig,\n            false,\n            { step: step + 2 }\n          );\n\n          const tasksGroupBy = Object.values(nextTasks).reduce<\n            Record<string, { id: string }[]>\n          >((acc, { name, id }) => {\n            acc[name] ??= [];\n            acc[name].push({ id });\n            return acc;\n          }, {});\n\n          const userGroupBy = values.reduce<\n            Record<\n              string,\n              { values: unknown; asNode: string; taskId?: string }[]\n            >\n          >((acc, item) => {\n            const [values, asNode] = item;\n            acc[asNode] ??= [];\n\n            const targetIdx = acc[asNode].length;\n            const taskId = tasksGroupBy[asNode]?.[targetIdx]?.id;\n            acc[asNode].push({ values, asNode, taskId });\n\n            return acc;\n          }, {});\n\n          return updateSuperStep(\n            patchCheckpointMap(nextConfig, saved.metadata),\n            Object.values(userGroupBy).flat()\n          );\n        }\n\n        return patchCheckpointMap(nextConfig, saved.metadata);\n      }\n\n      if (asNode === INPUT) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot apply multiple updates when updating as input`\n          );\n        }\n\n        const inputWrites = await gatherIterator(\n          mapInput(this.inputChannels, values)\n        );\n        if (inputWrites.length === 0) {\n          throw new InvalidUpdateError(\n            `Received no input writes for ${JSON.stringify(\n              this.inputChannels,\n              null,\n              2\n            )}`\n          );\n        }\n\n        // apply to checkpoint\n        _applyWrites(\n          checkpoint,\n          channels,\n          [\n            {\n              name: INPUT,\n              writes: inputWrites as PendingWrite[],\n              triggers: [],\n            },\n          ],\n          checkpointer.getNextVersion.bind(this.checkpointer),\n          this.triggerToNodes\n        );\n\n        // apply input write to channels\n        const nextStep =\n          saved?.metadata?.step != null ? saved.metadata.step + 1 : -1;\n        const nextConfig = await checkpointer.put(\n          checkpointConfig,\n          createCheckpoint(checkpoint, channels, nextStep),\n          {\n            source: \"input\",\n            step: nextStep,\n            parents: saved?.metadata?.parents ?? {},\n          },\n          getNewChannelVersions(\n            checkpointPreviousVersions,\n            checkpoint.channel_versions\n          )\n        );\n\n        // Store the writes\n        await checkpointer.putWrites(\n          nextConfig,\n          inputWrites as PendingWrite[],\n          uuid5(INPUT, checkpoint.id)\n        );\n\n        return patchCheckpointMap(\n          nextConfig,\n          saved ? saved.metadata : undefined\n        );\n      }\n\n      // apply pending writes, if not on specific checkpoint\n      if (\n        config.configurable?.checkpoint_id === undefined &&\n        saved?.pendingWrites !== undefined &&\n        saved.pendingWrites.length > 0\n      ) {\n        // tasks for this checkpoint\n        const nextTasks = _prepareNextTasks(\n          checkpoint,\n          saved.pendingWrites,\n          this.nodes,\n          channels,\n          saved.config,\n          true,\n          {\n            store: this.store,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            checkpointer: this.checkpointer as any,\n            step: (saved.metadata?.step ?? -1) + 1,\n          }\n        );\n        // apply null writes\n        const nullWrites = (saved.pendingWrites ?? [])\n          .filter((w) => w[0] === NULL_TASK_ID)\n          .map((w) => w.slice(1)) as PendingWrite<string>[];\n        if (nullWrites.length > 0) {\n          _applyWrites(\n            saved.checkpoint,\n            channels,\n            [{ name: INPUT, writes: nullWrites, triggers: [] }],\n            undefined,\n            this.triggerToNodes\n          );\n        }\n        // apply writes\n        for (const [tid, k, v] of saved.pendingWrites) {\n          if (\n            [ERROR, INTERRUPT, SCHEDULED].includes(k) ||\n            nextTasks[tid] === undefined\n          ) {\n            continue;\n          }\n          nextTasks[tid].writes.push([k, v]);\n        }\n        const tasks = Object.values(nextTasks).filter((task) => {\n          return task.writes.length > 0;\n        });\n        if (tasks.length > 0) {\n          _applyWrites(\n            checkpoint,\n            channels,\n            tasks as WritesProtocol[],\n            undefined,\n            this.triggerToNodes\n          );\n        }\n      }\n      const nonNullVersion = Object.values(checkpoint.versions_seen)\n        .map((seenVersions) => {\n          return Object.values(seenVersions);\n        })\n        .flat()\n        .find((v) => !!v);\n\n      const validUpdates: Array<{\n        values: Record<string, unknown> | unknown;\n        asNode: keyof Nodes | string;\n        taskId?: string;\n      }> = [];\n\n      if (updates.length === 1) {\n        // eslint-disable-next-line prefer-const\n        let { values, asNode, taskId } = updates[0];\n        if (asNode === undefined && Object.keys(this.nodes).length === 1) {\n          // if only one node, use it\n          [asNode] = Object.keys(this.nodes);\n        } else if (asNode === undefined && nonNullVersion === undefined) {\n          if (\n            typeof this.inputChannels === \"string\" &&\n            this.nodes[this.inputChannels] !== undefined\n          ) {\n            asNode = this.inputChannels;\n          }\n        } else if (asNode === undefined) {\n          const lastSeenByNode = Object.entries(checkpoint.versions_seen)\n            .map(([n, seen]) => {\n              return Object.values(seen).map((v) => {\n                return [v, n] as const;\n              });\n            })\n            .flat()\n            .filter(([_, v]) => v !== INTERRUPT)\n            .sort(([aNumber], [bNumber]) =>\n              compareChannelVersions(aNumber, bNumber)\n            );\n          // if two nodes updated the state at the same time, it's ambiguous\n          if (lastSeenByNode) {\n            if (lastSeenByNode.length === 1) {\n              // eslint-disable-next-line prefer-destructuring\n              asNode = lastSeenByNode[0][1];\n            } else if (\n              lastSeenByNode[lastSeenByNode.length - 1][0] !==\n              lastSeenByNode[lastSeenByNode.length - 2][0]\n            ) {\n              // eslint-disable-next-line prefer-destructuring\n              asNode = lastSeenByNode[lastSeenByNode.length - 1][1];\n            }\n          }\n        }\n\n        if (asNode === undefined) {\n          throw new InvalidUpdateError(`Ambiguous update, specify \"asNode\"`);\n        }\n\n        validUpdates.push({ values, asNode, taskId });\n      } else {\n        for (const { asNode, values, taskId } of updates) {\n          if (asNode == null) {\n            throw new InvalidUpdateError(\n              `\"asNode\" is required when applying multiple updates`\n            );\n          }\n\n          validUpdates.push({ values, asNode, taskId });\n        }\n      }\n\n      const tasks: PregelExecutableTask<keyof Nodes, keyof Channels>[] = [];\n      for (const { asNode, values, taskId } of validUpdates) {\n        if (this.nodes[asNode] === undefined) {\n          throw new InvalidUpdateError(\n            `Node \"${asNode.toString()}\" does not exist`\n          );\n        }\n\n        // run all writers of the chosen node\n        const writers = this.nodes[asNode].getWriters();\n        if (!writers.length) {\n          throw new InvalidUpdateError(\n            `No writers found for node \"${asNode.toString()}\"`\n          );\n        }\n        tasks.push({\n          name: asNode,\n          input: values,\n          proc:\n            writers.length > 1\n              ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                RunnableSequence.from(writers as any, {\n                  omitSequenceTags: true,\n                })\n              : writers[0],\n          writes: [],\n          triggers: [INTERRUPT],\n          id: taskId ?? uuid5(INTERRUPT, checkpoint.id),\n          writers: [],\n        });\n      }\n\n      for (const task of tasks) {\n        // execute task\n        await task.proc.invoke(\n          task.input,\n          patchConfig<LangGraphRunnableConfig>(\n            {\n              ...config,\n              store: config?.store ?? this.store,\n            },\n            {\n              runName: config.runName ?? `${this.getName()}UpdateState`,\n              configurable: {\n                [CONFIG_KEY_SEND]: (items: [keyof Channels, unknown][]) =>\n                  task.writes.push(...items),\n                [CONFIG_KEY_READ]: (\n                  select_: Array<keyof Channels> | keyof Channels,\n                  fresh_: boolean = false\n                ) =>\n                  _localRead(\n                    checkpoint,\n                    channels,\n                    // TODO: Why does keyof StrRecord allow number and symbol?\n                    task as PregelExecutableTask<string, string>,\n                    select_ as string | string[],\n                    fresh_\n                  ),\n              },\n            }\n          )\n        );\n      }\n\n      for (const task of tasks) {\n        // channel writes are saved to current checkpoint\n        const channelWrites = task.writes.filter((w) => w[0] !== PUSH);\n        // save task writes\n        if (saved !== undefined && channelWrites.length > 0) {\n          await checkpointer.putWrites(\n            checkpointConfig,\n            channelWrites as PendingWrite[],\n            task.id\n          );\n        }\n      }\n\n      // apply to checkpoint\n      // TODO: Why does keyof StrRecord allow number and symbol?\n      _applyWrites(\n        checkpoint,\n        channels,\n        tasks as PregelExecutableTask<string, string>[],\n        checkpointer.getNextVersion.bind(this.checkpointer),\n        this.triggerToNodes\n      );\n\n      const newVersions = getNewChannelVersions(\n        checkpointPreviousVersions,\n        checkpoint.channel_versions\n      );\n      const nextConfig = await checkpointer.put(\n        checkpointConfig,\n        createCheckpoint(checkpoint, channels, step + 1),\n        {\n          source: \"update\",\n          step: step + 1,\n          parents: saved?.metadata?.parents ?? {},\n        },\n        newVersions\n      );\n\n      for (const task of tasks) {\n        // push writes are saved to next checkpoint\n        const pushWrites = task.writes.filter((w) => w[0] === PUSH);\n\n        if (pushWrites.length > 0) {\n          await checkpointer.putWrites(\n            nextConfig,\n            pushWrites as PendingWrite[],\n            task.id\n          );\n        }\n      }\n\n      return patchCheckpointMap(nextConfig, saved ? saved.metadata : undefined);\n    };\n\n    let currentConfig = startConfig;\n    for (const { updates } of supersteps) {\n      currentConfig = await updateSuperStep(currentConfig, updates);\n    }\n\n    return currentConfig;\n  }\n\n  /**\n   * Updates the state of the graph with new values.\n   * Requires a checkpointer to be configured.\n   *\n   * This method can be used for:\n   * - Implementing human-in-the-loop workflows\n   * - Modifying graph state during breakpoints\n   * - Integrating external inputs into the graph\n   *\n   * @param inputConfig - Configuration for the update\n   * @param values - The values to update the state with\n   * @param asNode - Optional node name to attribute the update to\n   * @returns Updated configuration\n   * @throws {GraphValueError} If no checkpointer is configured\n   * @throws {InvalidUpdateError} If the update cannot be attributed to a node\n   */\n  async updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: keyof Nodes | string\n  ): Promise<RunnableConfig> {\n    return this.bulkUpdateState(inputConfig, [\n      { updates: [{ values, asNode }] },\n    ]);\n  }\n\n  /**\n   * Gets the default values for various graph configuration options.\n   * This is an internal method used to process and normalize configuration options.\n   *\n   * @param config - The input configuration options\n   * @returns A tuple containing normalized values for:\n   * - debug mode\n   * - stream modes\n   * - input keys\n   * - output keys\n   * - remaining config\n   * - interrupt before nodes\n   * - interrupt after nodes\n   * - checkpointer\n   * - store\n   * - whether stream mode is single\n   * - node cache\n   * - whether checkpoint during is enabled\n   * @internal\n   */\n  _defaults(config: PregelOptions<Nodes, Channels>): [\n    boolean, // debug\n    StreamMode[], // stream mode\n    string | string[], // input keys\n    string | string[], // output keys\n    LangGraphRunnableConfig, // config without pregel keys\n    All | string[], // interrupt before\n    All | string[], // interrupt after\n    BaseCheckpointSaver | undefined, // checkpointer\n    BaseStore | undefined, // store\n    boolean, // stream mode single\n    BaseCache | undefined, // node cache\n    Durability // durability\n  ] {\n    const {\n      debug,\n      streamMode,\n      inputKeys,\n      outputKeys,\n      interruptAfter,\n      interruptBefore,\n      ...rest\n    } = config;\n    let streamModeSingle = true;\n    const defaultDebug = debug !== undefined ? debug : this.debug;\n\n    let defaultOutputKeys = outputKeys;\n    if (defaultOutputKeys === undefined) {\n      defaultOutputKeys = this.streamChannelsAsIs;\n    } else {\n      validateKeys(defaultOutputKeys, this.channels);\n    }\n\n    let defaultInputKeys = inputKeys;\n    if (defaultInputKeys === undefined) {\n      defaultInputKeys = this.inputChannels;\n    } else {\n      validateKeys(defaultInputKeys, this.channels);\n    }\n\n    const defaultInterruptBefore =\n      interruptBefore ?? this.interruptBefore ?? [];\n\n    const defaultInterruptAfter = interruptAfter ?? this.interruptAfter ?? [];\n\n    let defaultStreamMode: StreamMode[];\n    if (streamMode !== undefined) {\n      defaultStreamMode = Array.isArray(streamMode) ? streamMode : [streamMode];\n      streamModeSingle = typeof streamMode === \"string\";\n    } else {\n      // if being called as a node in another graph, default to values mode\n      // but don't overwrite `streamMode`if provided\n      if (config.configurable?.[CONFIG_KEY_TASK_ID] !== undefined) {\n        defaultStreamMode = [\"values\"];\n      } else {\n        defaultStreamMode = this.streamMode;\n      }\n\n      streamModeSingle = true;\n    }\n\n    let defaultCheckpointer: BaseCheckpointSaver | undefined;\n    if (this.checkpointer === false) {\n      defaultCheckpointer = undefined;\n    } else if (\n      config !== undefined &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] !== undefined\n    ) {\n      defaultCheckpointer = config.configurable[CONFIG_KEY_CHECKPOINTER];\n    } else if (this.checkpointer === true) {\n      throw new Error(\"checkpointer: true cannot be used for root graphs.\");\n    } else {\n      defaultCheckpointer = this.checkpointer;\n    }\n    const defaultStore: BaseStore | undefined = config.store ?? this.store;\n    const defaultCache: BaseCache | undefined = config.cache ?? this.cache;\n\n    if (config.durability != null && config.checkpointDuring != null) {\n      throw new Error(\n        \"Cannot use both `durability` and `checkpointDuring` at the same time.\"\n      );\n    }\n\n    const checkpointDuringDurability: Durability | undefined = (() => {\n      if (config.checkpointDuring == null) return undefined;\n      if (config.checkpointDuring === false) return \"exit\";\n      return \"async\";\n    })();\n\n    const defaultDurability: Durability =\n      config.durability ??\n      checkpointDuringDurability ??\n      config?.configurable?.[CONFIG_KEY_DURABILITY] ??\n      \"async\";\n\n    return [\n      defaultDebug,\n      defaultStreamMode,\n      defaultInputKeys as string | string[],\n      defaultOutputKeys as string | string[],\n      rest,\n      defaultInterruptBefore as All | string[],\n      defaultInterruptAfter as All | string[],\n      defaultCheckpointer,\n      defaultStore,\n      streamModeSingle,\n      defaultCache,\n      defaultDurability,\n    ];\n  }\n\n  /**\n   * Streams the execution of the graph, emitting state updates as they occur.\n   * This is the primary method for observing graph execution in real-time.\n   *\n   * Stream modes:\n   * - \"values\": Emits complete state after each step\n   * - \"updates\": Emits only state changes after each step\n   * - \"debug\": Emits detailed debug information\n   * - \"messages\": Emits messages from within nodes\n   * - \"custom\": Emits custom events from within nodes\n   * - \"checkpoints\": Emits checkpoints from within nodes\n   * - \"tasks\": Emits tasks from within nodes\n   *\n   * @param input - The input to start graph execution with\n   * @param options - Configuration options for streaming\n   * @returns An async iterable stream of graph state updates\n   */\n  override async stream<\n    TStreamMode extends StreamMode | StreamMode[] | undefined,\n    TSubgraphs extends boolean,\n    TEncoding extends \"text/event-stream\" | undefined\n  >(\n    input: InputType | CommandType | null,\n    options?: Partial<\n      PregelOptions<\n        Nodes,\n        Channels,\n        ContextType,\n        TStreamMode,\n        TSubgraphs,\n        TEncoding\n      >\n    >\n  ): Promise<\n    IterableReadableStream<\n      StreamOutputMap<\n        TStreamMode,\n        TSubgraphs,\n        StreamUpdatesType,\n        StreamValuesType,\n        keyof Nodes,\n        NodeReturnType,\n        StreamCustom,\n        TEncoding\n      >\n    >\n  > {\n    // The ensureConfig method called internally defaults recursionLimit to 25 if not\n    // passed directly in `options`.\n    // There is currently no way in _streamIterator to determine whether this was\n    // set by by ensureConfig or manually by the user, so we specify the bound value here\n    // and override if it is passed as an explicit param in `options`.\n    const abortController = new AbortController();\n\n    const config = {\n      recursionLimit: this.config?.recursionLimit,\n      ...options,\n      signal: combineAbortSignals(options?.signal, abortController.signal)\n        .signal,\n    };\n\n    const stream = await super.stream(input, config);\n    return new IterableReadableStreamWithAbortSignal(\n      options?.encoding === \"text/event-stream\"\n        ? toEventStream(stream)\n        : stream,\n      abortController\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n  override streamEvents(\n    input: InputType | CommandType | null,\n    options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n      version: \"v1\" | \"v2\";\n    },\n    streamOptions?: StreamEventsOptions\n  ): IterableReadableStream<StreamEvent>;\n\n  override streamEvents(\n    input: InputType | CommandType | null,\n    options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: StreamEventsOptions\n  ): IterableReadableStream<Uint8Array>;\n\n  override streamEvents(\n    input: InputType | CommandType | null,\n    options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n      version: \"v1\" | \"v2\";\n    },\n    streamOptions?: StreamEventsOptions\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    const abortController = new AbortController();\n\n    const config = {\n      recursionLimit: this.config?.recursionLimit,\n      ...options,\n      // Similar to `stream`, we need to pass the `config.callbacks` here,\n      // otherwise the user-provided callback will get lost in `ensureLangGraphConfig`.\n\n      // extend the callbacks with the ones from the config\n      callbacks: combineCallbacks(this.config?.callbacks, options?.callbacks),\n      signal: combineAbortSignals(options?.signal, abortController.signal)\n        .signal,\n    };\n\n    return new IterableReadableStreamWithAbortSignal(\n      super.streamEvents(input, config, streamOptions),\n      abortController\n    );\n  }\n\n  /**\n   * Validates the input for the graph.\n   * @param input - The input to validate\n   * @returns The validated input\n   * @internal\n   */\n  protected async _validateInput(input: PregelInputType) {\n    return input;\n  }\n\n  /**\n   * Validates the context options for the graph.\n   * @param context - The context options to validate\n   * @returns The validated context options\n   * @internal\n   */\n  protected async _validateContext(\n    context: Partial<LangGraphRunnableConfig[\"context\"]>\n  ): Promise<LangGraphRunnableConfig[\"context\"]> {\n    return context;\n  }\n\n  /**\n   * Internal iterator used by stream() to generate state updates.\n   * This method handles the core logic of graph execution and streaming.\n   *\n   * @param input - The input to start graph execution with\n   * @param options - Configuration options for streaming\n   * @returns AsyncGenerator yielding state updates\n   * @internal\n   */\n  override async *_streamIterator(\n    input: PregelInputType | Command,\n    options?: Partial<PregelOptions<Nodes, Channels>>\n  ): AsyncGenerator<PregelOutputType> {\n    // Skip LGP encoding option is `streamEvents` is used\n    const streamEncoding =\n      \"version\" in (options ?? {}) ? undefined : options?.encoding ?? undefined;\n    const streamSubgraphs = options?.subgraphs;\n    const inputConfig = ensureLangGraphConfig(this.config, options);\n    if (\n      inputConfig.recursionLimit === undefined ||\n      inputConfig.recursionLimit < 1\n    ) {\n      throw new Error(`Passed \"recursionLimit\" must be at least 1.`);\n    }\n    if (\n      this.checkpointer !== undefined &&\n      this.checkpointer !== false &&\n      inputConfig.configurable === undefined\n    ) {\n      throw new Error(\n        `Checkpointer requires one or more of the following \"configurable\" keys: \"thread_id\", \"checkpoint_ns\", \"checkpoint_id\"`\n      );\n    }\n\n    const validInput = await this._validateInput(input);\n    const { runId, ...restConfig } = inputConfig;\n    // assign defaults\n    const [\n      debug,\n      streamMode,\n      ,\n      outputKeys,\n      config,\n      interruptBefore,\n      interruptAfter,\n      checkpointer,\n      store,\n      streamModeSingle,\n      cache,\n      durability,\n    ] = this._defaults(restConfig);\n\n    // At entrypoint, `configurable` is an alias for `context`.\n    if (typeof config.context !== \"undefined\") {\n      config.context = await this._validateContext(config.context);\n    } else {\n      config.configurable = await this._validateContext(config.configurable);\n    }\n\n    const stream = new IterableReadableWritableStream({\n      modes: new Set(streamMode),\n    });\n\n    // set up subgraph checkpointing\n    if (this.checkpointer === true) {\n      config.configurable ??= {};\n      const ns: string = config.configurable[CONFIG_KEY_CHECKPOINT_NS] ?? \"\";\n      config.configurable[CONFIG_KEY_CHECKPOINT_NS] = ns\n        .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n        .map((part) => part.split(CHECKPOINT_NAMESPACE_END)[0])\n        .join(CHECKPOINT_NAMESPACE_SEPARATOR);\n    }\n\n    // set up messages stream mode\n    if (streamMode.includes(\"messages\")) {\n      const messageStreamer = new StreamMessagesHandler((chunk) =>\n        stream.push(chunk)\n      );\n      const { callbacks } = config;\n      if (callbacks === undefined) {\n        config.callbacks = [messageStreamer];\n      } else if (Array.isArray(callbacks)) {\n        config.callbacks = callbacks.concat(messageStreamer);\n      } else {\n        const copiedCallbacks = callbacks.copy();\n        copiedCallbacks.addHandler(messageStreamer, true);\n        config.callbacks = copiedCallbacks;\n      }\n    }\n\n    config.writer ??= (chunk: unknown) => {\n      if (!streamMode.includes(\"custom\")) return;\n      const ns = (\n        getConfig()?.configurable?.[CONFIG_KEY_CHECKPOINT_NS] as\n          | string\n          | undefined\n      )\n        ?.split(CHECKPOINT_NAMESPACE_SEPARATOR)\n        .slice(0, -1);\n\n      stream.push([ns ?? [], \"custom\", chunk]);\n    };\n\n    config.interrupt ??= (this.userInterrupt as typeof interrupt) ?? interrupt;\n\n    const callbackManager = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager?.handleChainStart(\n      this.toJSON(), // chain\n      _coerceToDict(input, \"input\"), // inputs\n      runId, // run_id\n      undefined, // run_type\n      undefined, // tags\n      undefined, // metadata\n      config?.runName ?? this.getName() // run_name\n    );\n\n    const channelSpecs = getOnlyChannels(this.channels);\n    let loop: PregelLoop | undefined;\n    let loopError: unknown;\n\n    /**\n     * The PregelLoop will yield events from concurrent tasks as soon as they are\n     * generated. Each task can push multiple events onto the stream in any order.\n     *\n     * We use a separate background method and stream here in order to yield events\n     * from the loop to the main stream and therefore back to the user as soon as\n     * they are available.\n     */\n    const createAndRunLoop = async () => {\n      try {\n        loop = await PregelLoop.initialize({\n          input: validInput,\n          config,\n          checkpointer,\n          nodes: this.nodes,\n          channelSpecs,\n          outputKeys,\n          streamKeys: this.streamChannelsAsIs as string | string[],\n          store,\n          cache: cache as BaseCache<PendingWrite<string>[]>,\n          stream,\n          interruptAfter,\n          interruptBefore,\n          manager: runManager,\n          debug: this.debug,\n          triggerToNodes: this.triggerToNodes,\n          durability,\n        });\n\n        const runner = new PregelRunner({\n          loop,\n          nodeFinished: config.configurable?.[CONFIG_KEY_NODE_FINISHED],\n        });\n\n        if (options?.subgraphs) {\n          loop.config.configurable = {\n            ...loop.config.configurable,\n            [CONFIG_KEY_STREAM]: loop.stream,\n          };\n        }\n        await this._runLoop({ loop, runner, debug, config });\n\n        // wait for checkpoints to be persisted\n        if (durability === \"sync\") {\n          await Promise.all(loop?.checkpointerPromises ?? []);\n        }\n      } catch (e) {\n        loopError = e;\n      } finally {\n        try {\n          // Call `.stop()` again incase it was not called in the loop, e.g due to an error.\n          if (loop) {\n            await loop.store?.stop();\n            await loop.cache?.stop();\n          }\n          await Promise.all(loop?.checkpointerPromises ?? []);\n        } catch (e) {\n          loopError = loopError ?? e;\n        }\n        if (loopError) {\n          // \"Causes any future interactions with the associated stream to error\".\n          // Wraps ReadableStreamDefaultController#error:\n          // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/error\n          stream.error(loopError);\n        } else {\n          // Will end the iterator outside of this method,\n          // keeping previously enqueued chunks.\n          // Wraps ReadableStreamDefaultController#close:\n          // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/close\n          stream.close();\n        }\n      }\n    };\n    const runLoopPromise = createAndRunLoop();\n\n    try {\n      for await (const chunk of stream) {\n        if (chunk === undefined) {\n          throw new Error(\"Data structure error.\");\n        }\n        const [namespace, mode, payload] = chunk;\n        if (streamMode.includes(mode)) {\n          if (streamEncoding === \"text/event-stream\") {\n            if (streamSubgraphs) {\n              yield [namespace, mode, payload];\n            } else {\n              yield [null, mode, payload];\n            }\n            continue;\n          }\n          if (streamSubgraphs && !streamModeSingle) {\n            yield [namespace, mode, payload];\n          } else if (!streamModeSingle) {\n            yield [mode, payload];\n          } else if (streamSubgraphs) {\n            yield [namespace, payload];\n          } else {\n            yield payload;\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(loopError);\n      throw e;\n    } finally {\n      await runLoopPromise;\n    }\n    await runManager?.handleChainEnd(\n      loop?.output ?? {},\n      runId, // run_id\n      undefined, // run_type\n      undefined, // tags\n      undefined // metadata\n    );\n  }\n\n  /**\n   * Run the graph with a single input and config.\n   * @param input The input to the graph.\n   * @param options The configuration to use for the run.\n   */\n  override async invoke(\n    input: InputType | CommandType | null,\n    options?: Partial<\n      Omit<PregelOptions<Nodes, Channels, ContextType>, \"encoding\">\n    >\n  ): Promise<OutputType> {\n    const streamMode = options?.streamMode ?? \"values\";\n    const config = {\n      ...options,\n      outputKeys: options?.outputKeys ?? this.outputChannels,\n      streamMode,\n      encoding: undefined,\n    };\n    const chunks = [];\n    const stream = await this.stream(input, config);\n    const interruptChunks: Interrupt[][] = [];\n\n    let latest: OutputType | undefined;\n\n    for await (const chunk of stream) {\n      if (streamMode === \"values\") {\n        if (isInterrupted(chunk)) {\n          interruptChunks.push(chunk[INTERRUPT]);\n        } else {\n          latest = chunk as OutputType;\n        }\n      } else {\n        chunks.push(chunk);\n      }\n    }\n\n    if (streamMode === \"values\") {\n      if (interruptChunks.length > 0) {\n        const interrupts = interruptChunks.flat(1);\n        if (latest == null) return { [INTERRUPT]: interrupts } as OutputType;\n        if (typeof latest === \"object\") {\n          return { ...latest, [INTERRUPT]: interrupts };\n        }\n      }\n\n      return latest as OutputType;\n    }\n    return chunks as OutputType;\n  }\n\n  private async _runLoop(params: {\n    loop: PregelLoop;\n    runner: PregelRunner;\n    config: RunnableConfig;\n    debug: boolean;\n  }): Promise<void> {\n    const { loop, runner, debug, config } = params;\n    let tickError;\n    try {\n      while (\n        await loop.tick({ inputKeys: this.inputChannels as string | string[] })\n      ) {\n        for (const { task } of await loop._matchCachedWrites()) {\n          loop._outputWrites(task.id, task.writes, true);\n        }\n\n        if (debug) {\n          printStepCheckpoint(\n            loop.checkpointMetadata.step,\n            loop.channels,\n            this.streamChannelsList as string[]\n          );\n        }\n        if (debug) {\n          printStepTasks(loop.step, Object.values(loop.tasks));\n        }\n        await runner.tick({\n          timeout: this.stepTimeout,\n          retryPolicy: this.retryPolicy,\n          onStepWrite: (step, writes) => {\n            if (debug) {\n              printStepWrites(\n                step,\n                writes,\n                this.streamChannelsList as string[]\n              );\n            }\n          },\n          maxConcurrency: config.maxConcurrency,\n          signal: config.signal,\n        });\n      }\n      if (loop.status === \"out_of_steps\") {\n        throw new GraphRecursionError(\n          [\n            `Recursion limit of ${config.recursionLimit} reached`,\n            \"without hitting a stop condition. You can increase the\",\n            `limit by setting the \"recursionLimit\" config key.`,\n          ].join(\" \"),\n          {\n            lc_error_code: \"GRAPH_RECURSION_LIMIT\",\n          }\n        );\n      }\n    } catch (e) {\n      tickError = e as Error;\n      const suppress = await loop.finishAndHandleError(tickError);\n      if (!suppress) {\n        throw e;\n      }\n    } finally {\n      if (tickError === undefined) {\n        await loop.finishAndHandleError();\n      }\n    }\n  }\n\n  async clearCache(): Promise<void> {\n    await this.cache?.clear([]);\n  }\n}\n", "import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n/**\n * Stores the value received in the step immediately preceding, clears after.\n */\nexport class EphemeralValue<Value> extends BaseChannel<Value, Value, Value> {\n  lc_graph_name = \"EphemeralValue\";\n\n  guard: boolean;\n\n  // value is an array so we don't misinterpret an update to undefined as no write\n  value: [Value] | [] = [];\n\n  constructor(guard: boolean = true) {\n    super();\n    this.guard = guard;\n  }\n\n  fromCheckpoint(checkpoint?: Value) {\n    const empty = new EphemeralValue<Value>(this.guard);\n    if (typeof checkpoint !== \"undefined\") {\n      empty.value = [checkpoint];\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      const updated = this.value.length > 0;\n      // If there are no updates for this specific channel at the end of the step, wipe it.\n      this.value = [];\n      return updated;\n    }\n    if (values.length !== 1 && this.guard) {\n      throw new InvalidUpdateError(\n        \"EphemeralValue can only receive one value per step.\"\n      );\n    }\n\n    // eslint-disable-next-line prefer-destructuring\n    this.value = [values[values.length - 1]];\n    return true;\n  }\n\n  get(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  checkpoint(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  isAvailable(): boolean {\n    return this.value.length !== 0;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  _coerceToRunnable,\n  Runnable,\n  RunnableConfig,\n  RunnableInterface,\n  RunnableIOSchema,\n  type RunnableLike as LangChainRunnableLike,\n} from \"@langchain/core/runnables\";\nimport {\n  Node as DrawableGraphNode,\n  Graph as DrawableGraph,\n} from \"@langchain/core/runnables/graph\";\nimport { All, BaseCheckpointSaver } from \"@langchain/langgraph-checkpoint\";\nimport { z } from \"zod/v4\";\nimport { validate as isUuid } from \"uuid\";\nimport type {\n  RunnableLike,\n  LangGraphRunnableConfig,\n} from \"../pregel/runnable_types.js\";\nimport { PregelNode } from \"../pregel/read.js\";\nimport { Channel, Pregel } from \"../pregel/index.js\";\nimport type { PregelParams } from \"../pregel/types.js\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport { EphemeralValue } from \"../channels/ephemeral_value.js\";\nimport { ChannelWrite, PASSTHROUGH } from \"../pregel/write.js\";\nimport {\n  _isSend,\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  END,\n  Send,\n  START,\n  TAG_HIDDEN,\n} from \"../constants.js\";\nimport {\n  gatherIterator,\n  gatherIteratorSync,\n  RunnableCallable,\n} from \"../utils.js\";\nimport {\n  InvalidUpdateError,\n  NodeInterrupt,\n  UnreachableNodeError,\n} from \"../errors.js\";\nimport { StateDefinition, StateType } from \"./annotation.js\";\nimport { isPregelLike } from \"../pregel/utils/subgraph.js\";\n\nexport interface BranchOptions<\n  IO,\n  N extends string,\n  CallOptions extends LangGraphRunnableConfig = LangGraphRunnableConfig\n> {\n  source: N;\n  path: RunnableLike<IO, BranchPathReturnValue, CallOptions>;\n  pathMap?: Record<string, N | typeof END> | (N | typeof END)[];\n}\n\nexport type BranchPathReturnValue =\n  | string\n  | Send\n  | (string | Send)[]\n  | Promise<string | Send | (string | Send)[]>;\n\ntype NodeAction<S, U, C extends StateDefinition> = RunnableLike<\n  S,\n  U extends object ? U & Record<string, any> : U, // eslint-disable-line @typescript-eslint/no-explicit-any\n  LangGraphRunnableConfig<StateType<C>>\n>;\n\nexport class Branch<\n  IO,\n  N extends string,\n  CallOptions extends LangGraphRunnableConfig = LangGraphRunnableConfig\n> {\n  path: Runnable<IO, BranchPathReturnValue, CallOptions>;\n\n  ends?: Record<string, N | typeof END>;\n\n  constructor(options: Omit<BranchOptions<IO, N, CallOptions>, \"source\">) {\n    if (Runnable.isRunnable(options.path)) {\n      this.path = options.path as Runnable<\n        IO,\n        BranchPathReturnValue,\n        CallOptions\n      >;\n    } else {\n      this.path = _coerceToRunnable(\n        options.path as LangChainRunnableLike<\n          IO,\n          BranchPathReturnValue,\n          CallOptions\n        >\n      ).withConfig({ runName: `Branch` } as CallOptions);\n    }\n    this.ends = Array.isArray(options.pathMap)\n      ? options.pathMap.reduce((acc, n) => {\n          acc[n] = n;\n          return acc;\n        }, {} as Record<string, N | typeof END>)\n      : options.pathMap;\n  }\n\n  run(\n    writer: (\n      dests: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => Runnable | void | Promise<void>,\n    reader?: (config: CallOptions) => IO\n  ) {\n    return ChannelWrite.registerWriter(\n      new RunnableCallable({\n        name: \"<branch_run>\",\n        trace: false,\n        func: async (input: IO, config: CallOptions) => {\n          try {\n            return await this._route(input, config, writer, reader);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } catch (e: any) {\n            // Detect & warn if NodeInterrupt is thrown in a conditional edge\n            if (e.name === NodeInterrupt.unminifiable_name) {\n              console.warn(\n                \"[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.\\n\" +\n                  \"NodeInterrupt should only be thrown inside a node, not in edge conditions.\"\n              );\n            }\n            throw e;\n          }\n        },\n      })\n    );\n  }\n\n  async _route(\n    input: IO,\n    config: CallOptions,\n    writer: (\n      dests: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => Runnable | void | Promise<void>,\n    reader?: (config: CallOptions) => IO\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<Runnable | any> {\n    let result = await this.path.invoke(\n      reader ? reader(config) : input,\n      config\n    );\n    if (!Array.isArray(result)) {\n      result = [result];\n    }\n\n    let destinations: (string | Send)[];\n    if (this.ends) {\n      destinations = result.map((r) => (_isSend(r) ? r : this.ends![r]));\n    } else {\n      destinations = result;\n    }\n    if (destinations.some((dest) => !dest)) {\n      throw new Error(\"Branch condition returned unknown or null destination\");\n    }\n    if (destinations.filter(_isSend).some((packet) => packet.node === END)) {\n      throw new InvalidUpdateError(\"Cannot send a packet to the END node\");\n    }\n    const writeResult = await writer(destinations, config);\n    return writeResult ?? input;\n  }\n}\n\nexport type NodeSpec<RunInput, RunOutput> = {\n  runnable: Runnable<RunInput, RunOutput>;\n  metadata?: Record<string, unknown>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  subgraphs?: Pregel<any, any>[];\n  ends?: string[];\n  defer?: boolean;\n};\n\nexport type AddNodeOptions<Nodes extends string = string> = {\n  metadata?: Record<string, unknown>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  subgraphs?: Pregel<any, any>[];\n  ends?: Nodes[];\n  defer?: boolean;\n};\n\nexport class Graph<\n  N extends string = typeof START | typeof END,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  NodeSpecType extends NodeSpec<RunInput, RunOutput> = NodeSpec<\n    RunInput,\n    RunOutput\n  >,\n  C extends StateDefinition = StateDefinition\n> {\n  nodes: Record<N, NodeSpecType>;\n\n  edges: Set<[N | typeof START, N | typeof END]>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  branches: Record<string, Record<string, Branch<RunInput, N, any>>>;\n\n  entryPoint?: string;\n\n  compiled = false;\n\n  constructor() {\n    this.nodes = {} as Record<N, NodeSpecType>;\n    this.edges = new Set();\n    this.branches = {};\n  }\n\n  protected warnIfCompiled(message: string): void {\n    if (this.compiled) {\n      console.warn(message);\n    }\n  }\n\n  get allEdges(): Set<[string, string]> {\n    return this.edges;\n  }\n\n  addNode<K extends string, NodeInput = RunInput, NodeOutput = RunOutput>(\n    nodes:\n      | Record<K, NodeAction<NodeInput, NodeOutput, C>>\n      | [\n          key: K,\n          action: NodeAction<NodeInput, NodeOutput, C>,\n          options?: AddNodeOptions\n        ][]\n  ): Graph<N | K, RunInput, RunOutput>;\n\n  addNode<K extends string, NodeInput = RunInput, NodeOutput = RunOutput>(\n    key: K,\n    action: NodeAction<NodeInput, NodeOutput, C>,\n    options?: AddNodeOptions\n  ): Graph<N | K, RunInput, RunOutput>;\n\n  addNode<K extends string, NodeInput = RunInput, NodeOutput = RunOutput>(\n    ...args:\n      | [\n          key: K,\n          action: NodeAction<NodeInput, NodeOutput, C>,\n          options?: AddNodeOptions\n        ]\n      | [\n          nodes:\n            | Record<K, NodeAction<NodeInput, NodeOutput, C>>\n            | [\n                key: K,\n                action: NodeAction<NodeInput, NodeOutput, C>,\n                options?: AddNodeOptions\n              ][]\n        ]\n  ): Graph<N | K, RunInput, RunOutput> {\n    function isMutlipleNodes(\n      args: unknown[]\n    ): args is [\n      nodes:\n        | Record<K, NodeAction<NodeInput, RunOutput, C>>\n        | [\n            key: K,\n            action: NodeAction<NodeInput, RunOutput, C>,\n            options?: AddNodeOptions\n          ][],\n      options?: AddNodeOptions\n    ] {\n      return args.length >= 1 && typeof args[0] !== \"string\";\n    }\n\n    const nodes = (\n      isMutlipleNodes(args) // eslint-disable-line no-nested-ternary\n        ? Array.isArray(args[0])\n          ? args[0]\n          : Object.entries(args[0])\n        : [[args[0], args[1], args[2]]]\n    ) as [K, NodeAction<NodeInput, RunOutput, C>, AddNodeOptions][];\n\n    if (nodes.length === 0) {\n      throw new Error(\"No nodes provided in `addNode`\");\n    }\n\n    for (const [key, action, options] of nodes) {\n      for (const reservedChar of [\n        CHECKPOINT_NAMESPACE_SEPARATOR,\n        CHECKPOINT_NAMESPACE_END,\n      ]) {\n        if (key.includes(reservedChar)) {\n          throw new Error(\n            `\"${reservedChar}\" is a reserved character and is not allowed in node names.`\n          );\n        }\n      }\n      this.warnIfCompiled(\n        `Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n      );\n\n      if (key in this.nodes) {\n        throw new Error(`Node \\`${key}\\` already present.`);\n      }\n      if (key === END) {\n        throw new Error(`Node \\`${key}\\` is reserved.`);\n      }\n\n      const runnable = _coerceToRunnable<RunInput, RunOutput>(\n        // Account for arbitrary state due to Send API\n        action as RunnableLike<RunInput, RunOutput>\n      );\n\n      this.nodes[key as unknown as N] = {\n        runnable,\n        metadata: options?.metadata,\n        subgraphs: isPregelLike(runnable) ? [runnable] : options?.subgraphs,\n        ends: options?.ends,\n      } as NodeSpecType;\n    }\n\n    return this as Graph<N | K, RunInput, RunOutput, NodeSpecType>;\n  }\n\n  addEdge(startKey: N | typeof START, endKey: N | typeof END): this {\n    this.warnIfCompiled(\n      `Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n    );\n\n    if (startKey === END) {\n      throw new Error(\"END cannot be a start node\");\n    }\n    if (endKey === START) {\n      throw new Error(\"START cannot be an end node\");\n    }\n    if (\n      Array.from(this.edges).some(([start]) => start === startKey) &&\n      !(\"channels\" in this)\n    ) {\n      throw new Error(\n        `Already found path for ${startKey}. For multiple edges, use StateGraph.`\n      );\n    }\n\n    this.edges.add([startKey, endKey]);\n\n    return this;\n  }\n\n  addConditionalEdges(\n    source: BranchOptions<RunInput, N, LangGraphRunnableConfig<StateType<C>>>\n  ): this;\n\n  addConditionalEdges(\n    source: N,\n    path: RunnableLike<\n      RunInput,\n      BranchPathReturnValue,\n      LangGraphRunnableConfig<StateType<C>>\n    >,\n    pathMap?: BranchOptions<\n      RunInput,\n      N,\n      LangGraphRunnableConfig<StateType<C>>\n    >[\"pathMap\"]\n  ): this;\n\n  addConditionalEdges(\n    source:\n      | N\n      | BranchOptions<RunInput, N, LangGraphRunnableConfig<StateType<C>>>,\n    path?: RunnableLike<\n      RunInput,\n      BranchPathReturnValue,\n      LangGraphRunnableConfig<StateType<C>>\n    >,\n    pathMap?: BranchOptions<\n      RunInput,\n      N,\n      LangGraphRunnableConfig<StateType<C>>\n    >[\"pathMap\"]\n  ): this {\n    const options: BranchOptions<\n      RunInput,\n      N,\n      LangGraphRunnableConfig<StateType<C>>\n    > = typeof source === \"object\" ? source : { source, path: path!, pathMap };\n\n    this.warnIfCompiled(\n      \"Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.\"\n    );\n    if (!Runnable.isRunnable(options.path)) {\n      const pathDisplayValues = Array.isArray(options.pathMap)\n        ? options.pathMap.join(\",\")\n        : Object.keys(options.pathMap ?? {}).join(\",\");\n      options.path = _coerceToRunnable(\n        options.path as LangChainRunnableLike<\n          RunInput,\n          BranchPathReturnValue,\n          LangGraphRunnableConfig<StateType<C>>\n        >\n      ).withConfig({\n        runName: `Branch<${options.source}${\n          pathDisplayValues !== \"\" ? `,${pathDisplayValues}` : \"\"\n        }>`.slice(0, 63),\n      });\n    }\n    // find a name for condition\n    const name =\n      options.path.getName() === \"RunnableLambda\"\n        ? \"condition\"\n        : options.path.getName();\n    // validate condition\n    if (this.branches[options.source] && this.branches[options.source][name]) {\n      throw new Error(\n        `Condition \\`${name}\\` already present for node \\`${source}\\``\n      );\n    }\n    // save it\n    this.branches[options.source] ??= {};\n    this.branches[options.source][name] = new Branch(options);\n    return this;\n  }\n\n  /**\n   * @deprecated use `addEdge(START, key)` instead\n   */\n  setEntryPoint(key: N): this {\n    this.warnIfCompiled(\n      \"Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph.\"\n    );\n\n    return this.addEdge(START, key);\n  }\n\n  /**\n   * @deprecated use `addEdge(key, END)` instead\n   */\n  setFinishPoint(key: N): this {\n    this.warnIfCompiled(\n      \"Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph.\"\n    );\n\n    return this.addEdge(key, END);\n  }\n\n  compile({\n    checkpointer,\n    interruptBefore,\n    interruptAfter,\n    name,\n  }: {\n    checkpointer?: BaseCheckpointSaver | false;\n    interruptBefore?: N[] | All;\n    interruptAfter?: N[] | All;\n    name?: string;\n  } = {}): CompiledGraph<N> {\n    // validate the graph\n    this.validate([\n      ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n      ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n    ]);\n\n    // create empty compiled graph\n    const compiled = new CompiledGraph({\n      builder: this,\n      checkpointer,\n      interruptAfter,\n      interruptBefore,\n      autoValidate: false,\n      nodes: {} as Record<N | typeof START, PregelNode<RunInput, RunOutput>>,\n      channels: {\n        [START]: new EphemeralValue(),\n        [END]: new EphemeralValue(),\n      } as Record<N | typeof START | typeof END | string, BaseChannel>,\n      inputChannels: START,\n      outputChannels: END,\n      streamChannels: [] as N[],\n      streamMode: \"values\",\n      name,\n    });\n\n    // attach nodes, edges and branches\n    for (const [key, node] of Object.entries<NodeSpec<RunInput, RunOutput>>(\n      this.nodes\n    )) {\n      compiled.attachNode(key as N, node);\n    }\n    for (const [start, end] of this.edges) {\n      compiled.attachEdge(start, end);\n    }\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const [name, branch] of Object.entries(branches)) {\n        compiled.attachBranch(start as N, name, branch);\n      }\n    }\n\n    return compiled.validate();\n  }\n\n  validate(interrupt?: string[]): void {\n    // assemble sources\n    const allSources = new Set([...this.allEdges].map(([src, _]) => src));\n    for (const [start] of Object.entries(this.branches)) {\n      allSources.add(start);\n    }\n\n    // validate sources\n    for (const source of allSources) {\n      if (source !== START && !(source in this.nodes)) {\n        throw new Error(`Found edge starting at unknown node \\`${source}\\``);\n      }\n    }\n\n    // assemble targets\n    const allTargets = new Set([...this.allEdges].map(([_, target]) => target));\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const branch of Object.values(branches)) {\n        if (branch.ends != null) {\n          for (const end of Object.values(branch.ends)) {\n            allTargets.add(end);\n          }\n        } else {\n          allTargets.add(END);\n          for (const node of Object.keys(this.nodes)) {\n            if (node !== start) {\n              allTargets.add(node);\n            }\n          }\n        }\n      }\n    }\n    for (const node of Object.values<NodeSpecType>(this.nodes)) {\n      for (const target of node.ends ?? []) {\n        allTargets.add(target);\n      }\n    }\n    // validate targets\n    for (const node of Object.keys(this.nodes)) {\n      if (!allTargets.has(node)) {\n        throw new UnreachableNodeError(\n          [\n            `Node \\`${node}\\` is not reachable.`,\n            \"\",\n            \"If you are returning Command objects from your node,\",\n            'make sure you are passing names of potential destination nodes as an \"ends\" array',\n            'into \".addNode(..., { ends: [\"node1\", \"node2\"] })\".',\n          ].join(\"\\n\"),\n          {\n            lc_error_code: \"UNREACHABLE_NODE\",\n          }\n        );\n      }\n    }\n    for (const target of allTargets) {\n      if (target !== END && !(target in this.nodes)) {\n        throw new Error(`Found edge ending at unknown node \\`${target}\\``);\n      }\n    }\n\n    // validate interrupts\n    if (interrupt) {\n      for (const node of interrupt) {\n        if (!(node in this.nodes)) {\n          throw new Error(`Interrupt node \\`${node}\\` is not present`);\n        }\n      }\n    }\n\n    this.compiled = true;\n  }\n}\n\nexport class CompiledGraph<\n  N extends string,\n  State = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  Update = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  ContextType extends Record<string, any> = Record<string, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n  InputType = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  OutputType = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  NodeReturnType = unknown,\n  CommandType = unknown,\n  StreamCustomType = any // eslint-disable-line @typescript-eslint/no-explicit-any\n> extends Pregel<\n  Record<N | typeof START, PregelNode<State, Update>>,\n  Record<N | typeof START | typeof END | string, BaseChannel>,\n  ContextType & Record<string, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n  InputType,\n  OutputType,\n  InputType,\n  OutputType,\n  NodeReturnType,\n  CommandType,\n  StreamCustomType\n> {\n  declare \"~NodeType\": N;\n\n  declare \"~NodeReturnType\": NodeReturnType;\n\n  declare \"~RunInput\": Update;\n\n  declare \"~RunOutput\": State;\n\n  builder: Graph<N, State, Update>;\n\n  constructor({\n    builder,\n    ...rest\n  }: { builder: Graph<N, State, Update> } & PregelParams<\n    Record<N | typeof START, PregelNode<State, Update>>,\n    Record<N | typeof START | typeof END | string, BaseChannel>\n  >) {\n    super(rest);\n    this.builder = builder;\n  }\n\n  attachNode(key: N, node: NodeSpec<State, Update>): void {\n    this.channels[key] = new EphemeralValue();\n    this.nodes[key] = new PregelNode({\n      channels: [],\n      triggers: [],\n      metadata: node.metadata,\n      subgraphs: node.subgraphs,\n      ends: node.ends,\n    })\n      .pipe(node.runnable)\n      .pipe(\n        new ChannelWrite([{ channel: key, value: PASSTHROUGH }], [TAG_HIDDEN])\n      );\n    (this.streamChannels as N[]).push(key);\n  }\n\n  attachEdge(start: N | typeof START, end: N | typeof END): void {\n    if (end === END) {\n      if (start === START) {\n        throw new Error(\"Cannot have an edge from START to END\");\n      }\n      this.nodes[start].writers.push(\n        new ChannelWrite([{ channel: END, value: PASSTHROUGH }], [TAG_HIDDEN])\n      );\n    } else {\n      this.nodes[end].triggers.push(start);\n      (this.nodes[end].channels as string[]).push(start);\n    }\n  }\n\n  attachBranch(\n    start: N | typeof START,\n    name: string,\n    branch: Branch<State, N>\n  ) {\n    // add hidden start node\n    if (start === START && !this.nodes[START]) {\n      this.nodes[START] = Channel.subscribeTo(START, { tags: [TAG_HIDDEN] });\n    }\n\n    // attach branch writer\n    this.nodes[start].pipe(\n      branch.run((dests) => {\n        const writes = dests.map((dest) => {\n          if (_isSend(dest)) {\n            return dest;\n          }\n          return {\n            channel: dest === END ? END : `branch:${start}:${name}:${dest}`,\n            value: PASSTHROUGH,\n          };\n        });\n        return new ChannelWrite(writes, [TAG_HIDDEN]);\n      })\n    );\n\n    // attach branch readers\n    const ends = branch.ends\n      ? Object.values(branch.ends)\n      : (Object.keys(this.nodes) as N[]);\n    for (const end of ends) {\n      if (end !== END) {\n        const channelName = `branch:${start}:${name}:${end}`;\n        (this.channels as Record<string, BaseChannel>)[channelName] =\n          new EphemeralValue();\n        this.nodes[end].triggers.push(channelName);\n        (this.nodes[end].channels as string[]).push(channelName);\n      }\n    }\n  }\n\n  /**\n   * Returns a drawable representation of the computation graph.\n   */\n  override async getGraphAsync(\n    config?: RunnableConfig & { xray?: boolean | number }\n  ): Promise<DrawableGraph> {\n    const xray = config?.xray;\n    const graph = new DrawableGraph();\n    const startNodes: Record<string, DrawableGraphNode> = {\n      [START]: graph.addNode({ schema: z.any() }, START),\n    };\n    const endNodes: Record<string, DrawableGraphNode> = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let subgraphs: Record<string, CompiledGraph<any>> = {};\n    if (xray) {\n      subgraphs = Object.fromEntries(\n        (await gatherIterator(this.getSubgraphsAsync())).filter(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (x): x is [string, CompiledGraph<any>] => isCompiledGraph(x[1])\n        )\n      );\n    }\n\n    function addEdge(\n      start: string,\n      end: string,\n      label?: string,\n      conditional = false\n    ) {\n      if (end === END && endNodes[END] === undefined) {\n        endNodes[END] = graph.addNode({ schema: z.any() }, END);\n      }\n      if (startNodes[start] === undefined) {\n        return;\n      }\n      if (endNodes[end] === undefined) {\n        throw new Error(`End node ${end} not found!`);\n      }\n      return graph.addEdge(\n        startNodes[start],\n        endNodes[end],\n        label !== end ? label : undefined,\n        conditional\n      );\n    }\n\n    for (const [key, nodeSpec] of Object.entries(this.builder.nodes) as [\n      N,\n      NodeSpec<State, Update>\n    ][]) {\n      const displayKey = _escapeMermaidKeywords(key);\n      const node = nodeSpec.runnable;\n      const metadata = nodeSpec.metadata ?? {};\n      if (\n        this.interruptBefore?.includes(key) &&\n        this.interruptAfter?.includes(key)\n      ) {\n        metadata.__interrupt = \"before,after\";\n      } else if (this.interruptBefore?.includes(key)) {\n        metadata.__interrupt = \"before\";\n      } else if (this.interruptAfter?.includes(key)) {\n        metadata.__interrupt = \"after\";\n      }\n      if (xray) {\n        const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n        const drawableSubgraph =\n          subgraphs[key] !== undefined\n            ? await subgraphs[key].getGraphAsync({\n                ...config,\n                xray: newXrayValue,\n              })\n            : node.getGraph(config);\n\n        drawableSubgraph.trimFirstNode();\n        drawableSubgraph.trimLastNode();\n\n        if (Object.keys(drawableSubgraph.nodes).length > 1) {\n          const [e, s] = graph.extend(drawableSubgraph, displayKey);\n          if (e === undefined) {\n            throw new Error(\n              `Could not extend subgraph \"${key}\" due to missing entrypoint.`\n            );\n          }\n\n          // TODO: Remove default name once we stop supporting core 0.2.0\n          // eslint-disable-next-line no-inner-declarations\n          function _isRunnableInterface(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            thing: any\n          ): thing is RunnableInterface {\n            return thing ? thing.lc_runnable : false;\n          }\n          // eslint-disable-next-line no-inner-declarations\n          function _nodeDataStr(\n            id: string | undefined,\n            data: RunnableInterface | RunnableIOSchema\n          ): string {\n            if (id !== undefined && !isUuid(id)) {\n              return id;\n            } else if (_isRunnableInterface(data)) {\n              try {\n                let dataStr = data.getName();\n                dataStr = dataStr.startsWith(\"Runnable\")\n                  ? dataStr.slice(\"Runnable\".length)\n                  : dataStr;\n                return dataStr;\n              } catch (error) {\n                return data.getName();\n              }\n            } else {\n              return data.name ?? \"UnknownSchema\";\n            }\n          }\n          // TODO: Remove casts when we stop supporting core 0.2.0\n          if (s !== undefined) {\n            startNodes[displayKey] = {\n              name: _nodeDataStr(s.id, s.data),\n              ...s,\n            } as DrawableGraphNode;\n          }\n          endNodes[displayKey] = {\n            name: _nodeDataStr(e.id, e.data),\n            ...e,\n          } as DrawableGraphNode;\n        } else {\n          // TODO: Remove when we stop supporting core 0.2.0\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const newNode = graph.addNode(node, displayKey, metadata);\n          startNodes[displayKey] = newNode;\n          endNodes[displayKey] = newNode;\n        }\n      } else {\n        // TODO: Remove when we stop supporting core 0.2.0\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const newNode = graph.addNode(node, displayKey, metadata);\n        startNodes[displayKey] = newNode;\n        endNodes[displayKey] = newNode;\n      }\n    }\n    const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n      if (a < b) {\n        return -1;\n      } else if (b > a) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    for (const [start, end] of sortedEdges) {\n      addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n    }\n    for (const [start, branches] of Object.entries(this.builder.branches)) {\n      const defaultEnds: Record<string, string> = {\n        ...Object.fromEntries(\n          Object.keys(this.builder.nodes)\n            .filter((k) => k !== start)\n            .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])\n        ),\n        [END]: END,\n      };\n      for (const branch of Object.values(branches)) {\n        let ends;\n        if (branch.ends !== undefined) {\n          ends = branch.ends;\n        } else {\n          ends = defaultEnds;\n        }\n        for (const [label, end] of Object.entries(ends)) {\n          addEdge(\n            _escapeMermaidKeywords(start),\n            _escapeMermaidKeywords(end),\n            label,\n            true\n          );\n        }\n      }\n    }\n    for (const [key, node] of Object.entries(this.builder.nodes) as [\n      N,\n      NodeSpec<State, Update>\n    ][]) {\n      if (node.ends !== undefined) {\n        for (const end of node.ends) {\n          addEdge(\n            _escapeMermaidKeywords(key),\n            _escapeMermaidKeywords(end),\n            undefined,\n            true\n          );\n        }\n      }\n    }\n    return graph;\n  }\n\n  /**\n   * Returns a drawable representation of the computation graph.\n   *\n   * @deprecated Use getGraphAsync instead. The async method will be the default in the next minor core release.\n   */\n  override getGraph(\n    config?: RunnableConfig & { xray?: boolean | number }\n  ): DrawableGraph {\n    const xray = config?.xray;\n    const graph = new DrawableGraph();\n    const startNodes: Record<string, DrawableGraphNode> = {\n      [START]: graph.addNode(\n        {\n          schema: z.any(),\n        },\n        START\n      ),\n    };\n    const endNodes: Record<string, DrawableGraphNode> = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let subgraphs: Record<string, CompiledGraph<any>> = {};\n    if (xray) {\n      subgraphs = Object.fromEntries(\n        gatherIteratorSync(this.getSubgraphs()).filter(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (x): x is [string, CompiledGraph<any>] => isCompiledGraph(x[1])\n        )\n      );\n    }\n\n    function addEdge(\n      start: string,\n      end: string,\n      label?: string,\n      conditional = false\n    ) {\n      if (end === END && endNodes[END] === undefined) {\n        endNodes[END] = graph.addNode({ schema: z.any() }, END);\n      }\n      return graph.addEdge(\n        startNodes[start],\n        endNodes[end],\n        label !== end ? label : undefined,\n        conditional\n      );\n    }\n\n    for (const [key, nodeSpec] of Object.entries(this.builder.nodes) as [\n      N,\n      NodeSpec<State, Update>\n    ][]) {\n      const displayKey = _escapeMermaidKeywords(key);\n      const node = nodeSpec.runnable;\n      const metadata = nodeSpec.metadata ?? {};\n      if (\n        this.interruptBefore?.includes(key) &&\n        this.interruptAfter?.includes(key)\n      ) {\n        metadata.__interrupt = \"before,after\";\n      } else if (this.interruptBefore?.includes(key)) {\n        metadata.__interrupt = \"before\";\n      } else if (this.interruptAfter?.includes(key)) {\n        metadata.__interrupt = \"after\";\n      }\n      if (xray) {\n        const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n        const drawableSubgraph =\n          subgraphs[key] !== undefined\n            ? subgraphs[key].getGraph({\n                ...config,\n                xray: newXrayValue,\n              })\n            : node.getGraph(config);\n        drawableSubgraph.trimFirstNode();\n        drawableSubgraph.trimLastNode();\n        if (Object.keys(drawableSubgraph.nodes).length > 1) {\n          const [e, s] = graph.extend(drawableSubgraph, displayKey);\n          if (e === undefined) {\n            throw new Error(\n              `Could not extend subgraph \"${key}\" due to missing entrypoint.`\n            );\n          }\n\n          // TODO: Remove default name once we stop supporting core 0.2.0\n          // eslint-disable-next-line no-inner-declarations\n          function _isRunnableInterface(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            thing: any\n          ): thing is RunnableInterface {\n            return thing ? thing.lc_runnable : false;\n          }\n          // eslint-disable-next-line no-inner-declarations\n          function _nodeDataStr(\n            id: string | undefined,\n            data: RunnableInterface | RunnableIOSchema\n          ): string {\n            if (id !== undefined && !isUuid(id)) {\n              return id;\n            } else if (_isRunnableInterface(data)) {\n              try {\n                let dataStr = data.getName();\n                dataStr = dataStr.startsWith(\"Runnable\")\n                  ? dataStr.slice(\"Runnable\".length)\n                  : dataStr;\n                return dataStr;\n              } catch (error) {\n                return data.getName();\n              }\n            } else {\n              return data.name ?? \"UnknownSchema\";\n            }\n          }\n          // TODO: Remove casts when we stop supporting core 0.2.0\n          if (s !== undefined) {\n            startNodes[displayKey] = {\n              name: _nodeDataStr(s.id, s.data),\n              ...s,\n            } as DrawableGraphNode;\n          }\n          endNodes[displayKey] = {\n            name: _nodeDataStr(e.id, e.data),\n            ...e,\n          } as DrawableGraphNode;\n        } else {\n          // TODO: Remove when we stop supporting core 0.2.0\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const newNode = graph.addNode(node, displayKey, metadata);\n          startNodes[displayKey] = newNode;\n          endNodes[displayKey] = newNode;\n        }\n      } else {\n        // TODO: Remove when we stop supporting core 0.2.0\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const newNode = graph.addNode(node, displayKey, metadata);\n        startNodes[displayKey] = newNode;\n        endNodes[displayKey] = newNode;\n      }\n    }\n    const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n      if (a < b) {\n        return -1;\n      } else if (b > a) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    for (const [start, end] of sortedEdges) {\n      addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n    }\n    for (const [start, branches] of Object.entries(this.builder.branches)) {\n      const defaultEnds: Record<string, string> = {\n        ...Object.fromEntries(\n          Object.keys(this.builder.nodes)\n            .filter((k) => k !== start)\n            .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])\n        ),\n        [END]: END,\n      };\n      for (const branch of Object.values(branches)) {\n        let ends;\n        if (branch.ends !== undefined) {\n          ends = branch.ends;\n        } else {\n          ends = defaultEnds;\n        }\n        for (const [label, end] of Object.entries(ends)) {\n          addEdge(\n            _escapeMermaidKeywords(start),\n            _escapeMermaidKeywords(end),\n            label,\n            true\n          );\n        }\n      }\n    }\n    return graph;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isCompiledGraph(x: unknown): x is CompiledGraph<any> {\n  return (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (x as CompiledGraph<any>).attachNode === \"function\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (x as CompiledGraph<any>).attachEdge === \"function\"\n  );\n}\n\nfunction _escapeMermaidKeywords(key: string) {\n  if (key === \"subgraph\") {\n    return `\"${key}\"`;\n  }\n  return key;\n}\n", "import type {\n  StandardSchemaV1,\n  StandardJSONSchemaV1,\n  StandardTypedV1,\n} from \"@standard-schema/spec\";\n\ninterface CombinedProps<Input = unknown, Output = Input>\n  extends StandardSchemaV1.Props<Input, Output>,\n    StandardJSONSchemaV1.Props<Input, Output> {}\n\n/**\n * SerializableSchema is the core interface for any schema used by LangGraph state.\n *\n * @template Input - The type of input data the schema can be used to validate.\n * @template Output - The type of output produced after validation, post-refinement/coercion.\n *\n * @remarks\n * - SerializableSchema provides a single property, `~standard`, which must conform to\n *   both `StandardSchemaV1.Props` and `StandardJSONSchemaV1.Props`.\n * - This ensures all schemas are compatible with both runtime validation (e.g., type checks,\n *   coercion, custom refinements) and structured schema export/generation (e.g., producing\n *   a compatible JSON Schema).\n * - A value matching SerializableSchema can be passed directly to LangGraph state\n *   definitions, reducers, or other schema-accepting APIs.\n *\n * @example\n * ```ts\n * import { z } from \"zod\";\n *\n * // complies with SerializableSchema\n * const zodSchema = z.object({ x: z.string() });\n *\n * // Use in a StateObject definition:\n * const AgentState = new StateObject({\n *   data: schema\n * });\n * ```\n */\nexport interface SerializableSchema<Input = unknown, Output = Input> {\n  \"~standard\": CombinedProps<Input, Output>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace SerializableSchema {\n  /**\n   * Infers the type of input expected by a SerializableSchema.\n   *\n   * @template T - A SerializableSchema instance.\n   * @returns The type of data that may be passed to the schema for validation.\n   *\n   * @example\n   * ```ts\n   * type MyInput = SerializableSchema.InferInput<typeof schema>;\n   * ```\n   */\n  export type InferInput<T extends SerializableSchema> =\n    StandardTypedV1.InferInput<T>;\n\n  /**\n   * Infers the output type yielded by a SerializableSchema, after parsing or coercion.\n   *\n   * @template T - A SerializableSchema instance.\n   * @returns The type produced by successfully validating/coercing input data.\n   *\n   * @example\n   * ```ts\n   * type MyOutput = SerializableSchema.InferOutput<typeof schema>;\n   * ```\n   */\n  export type InferOutput<T extends SerializableSchema> =\n    StandardTypedV1.InferOutput<T>;\n}\n\n/**\n * Type guard to check if a given value is a Standard Schema V1 object.\n *\n * @remarks\n * A Standard Schema object is expected to have a `~standard` property with a `validate` function.\n * This guard does NOT check for JSON schema support.\n *\n * @typeParam Input - The type of input validated by this schema.\n * @typeParam Output - The type of output produced after validation.\n * @param schema - The value to test.\n * @returns True if the schema conforms to the Standard Schema interface.\n *\n * @example\n * ```ts\n * if (isStandardSchema(mySchema)) {\n *   const result = mySchema[\"~standard\"].validate(input);\n * }\n * ```\n */\nexport function isStandardSchema<Input = unknown, Output = Input>(\n  schema: StandardSchemaV1<Input, Output>\n): schema is StandardSchemaV1<Input, Output>;\nexport function isStandardSchema<Input = unknown, Output = Input>(\n  schema: unknown\n): schema is StandardSchemaV1<Input, Output>;\nexport function isStandardSchema<Input = unknown, Output = Input>(\n  schema: StandardSchemaV1<Input, Output> | unknown\n): schema is StandardSchemaV1<Input, Output> {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    \"~standard\" in schema &&\n    typeof schema[\"~standard\"] === \"object\" &&\n    schema[\"~standard\"] !== null &&\n    \"validate\" in schema[\"~standard\"]\n  );\n}\n\n/**\n * Type guard to check if a given value is a Standard JSON Schema V1 object.\n *\n * @remarks\n * A Standard JSON Schema object is expected to have a `~standard` property with a `jsonSchema` function.\n * This may be used to generate a JSON Schema (for UI/form tooling, documentation, etc).\n *\n * @typeParam Input - The type of input described by this JSON schema.\n * @typeParam Output - The type of output described by this JSON schema.\n * @param schema - The value to test.\n * @returns True if the schema exposes JSON schema generation.\n *\n * @example\n * ```ts\n * if (isStandardJSONSchema(mySchema)) {\n *   const jschema = mySchema[\"~standard\"].jsonSchema();\n * }\n * ```\n */\nexport function isStandardJSONSchema<Input = unknown, Output = Input>(\n  schema: StandardJSONSchemaV1<Input, Output>\n): schema is StandardJSONSchemaV1<Input, Output>;\nexport function isStandardJSONSchema<Input = unknown, Output = Input>(\n  schema: unknown\n): schema is StandardJSONSchemaV1<Input, Output>;\nexport function isStandardJSONSchema<Input = unknown, Output = Input>(\n  schema: StandardJSONSchemaV1<Input, Output> | unknown\n): schema is StandardJSONSchemaV1<Input, Output> {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    \"~standard\" in schema &&\n    typeof schema[\"~standard\"] === \"object\" &&\n    schema[\"~standard\"] !== null &&\n    \"jsonSchema\" in schema[\"~standard\"]\n  );\n}\n\n/**\n * Type guard to check if a given value is a `SerializableSchema`, i.e.\n * both a Standard Schema and a Standard JSON Schema object.\n *\n * @remarks\n * This checks for both the presence of a Standard Schema V1 interface\n * and the ability to generate a JSON schema.\n *\n * @typeParam Input - The type of input described by the schema.\n * @typeParam Output - The type of output described by the schema.\n * @param schema - The value to test.\n * @returns True if the schema is a valid `SerializableSchema`.\n *\n * @example\n * ```ts\n * if (isSerializableSchema(schema)) {\n *   schema[\"~standard\"].validate(data);\n *   const json = schema[\"~standard\"].jsonSchema();\n * }\n * ```\n */\nexport function isSerializableSchema<Input = unknown, Output = Input>(\n  schema: SerializableSchema<Input, Output>\n): schema is SerializableSchema<Input, Output>;\nexport function isSerializableSchema<Input = unknown, Output = Input>(\n  schema: unknown\n): schema is SerializableSchema<Input, Output>;\nexport function isSerializableSchema<Input = unknown, Output = Input>(\n  schema: SerializableSchema<Input, Output> | unknown\n): schema is SerializableSchema<Input, Output> {\n  return isStandardSchema(schema) && isStandardJSONSchema(schema);\n}\n", "/**\n * Adapter utilities for working with Standard Schema.\n */\nimport type { SerializableSchema } from \"./types.js\";\nimport { isStandardJSONSchema, isStandardSchema } from \"./types.js\";\n\n/**\n * Get the JSON schema from a SerializableSchema.\n */\nexport function getJsonSchemaFromSchema(\n  schema: SerializableSchema | unknown\n): Record<string, unknown> | undefined {\n  if (isStandardJSONSchema(schema)) {\n    try {\n      const standard = schema[\"~standard\"];\n      return standard.jsonSchema.input({ target: \"draft-07\" });\n    } catch {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Detect if a schema has a default value by validating `undefined`.\n *\n * Uses the Standard Schema `~standard.validate` API to detect defaults.\n * If the schema accepts `undefined` and returns a value, that value is the default.\n *\n * This approach is library-agnostic and works with any Standard Schema compliant\n * library (Zod, Valibot, ArkType, etc.) without needing to introspect internals.\n *\n * @param schema - The schema to check for a default value.\n * @returns A factory function returning the default, or undefined if no default exists.\n *\n * @example\n * ```ts\n * const getter = getSchemaDefaultGetter(z.string().default(\"hello\"));\n * getter?.(); // \"hello\"\n *\n * const noDefault = getSchemaDefaultGetter(z.string());\n * noDefault; // undefined\n * ```\n */\nexport function getSchemaDefaultGetter(\n  schema: SerializableSchema | unknown\n): (() => unknown) | undefined {\n  if (schema == null) {\n    return undefined;\n  }\n\n  if (!isStandardSchema(schema)) {\n    return undefined;\n  }\n\n  try {\n    const result = schema[\"~standard\"].validate(undefined);\n\n    // Handle sync result (not a Promise)\n    // Default values are always synchronous - async validation only happens\n    // with async refinements, which don't affect default value resolution.\n    if (\n      result &&\n      typeof result === \"object\" &&\n      !(\"then\" in result && typeof result.then === \"function\")\n    ) {\n      const syncResult = result as { issues?: unknown; value?: unknown };\n      if (!syncResult.issues) {\n        const defaultValue = syncResult.value;\n        return () => defaultValue;\n      }\n    }\n  } catch {\n    // Validation threw - no default\n  }\n\n  return undefined;\n}\n", "import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n// Sentinel value for missing/unset\nconst MISSING = Symbol.for(\"langgraph.channel.missing\");\n\n/**\n * Stores the last value received, never checkpointed.\n *\n * This channel stores values during graph execution but does NOT persist\n * the value to checkpoints. On restoration from a checkpoint, the value\n * will be reset to empty (or the initial value if provided).\n *\n * Useful for transient state like:\n * - Database connections\n * - Temporary caches\n * - Runtime-only configuration\n *\n * @internal\n */\nexport class UntrackedValueChannel<Value> extends BaseChannel<\n  Value,\n  Value,\n  undefined\n> {\n  lc_graph_name = \"UntrackedValue\";\n\n  /**\n   * If true, throws an error when multiple values are received in a single step.\n   * If false, stores the last value received.\n   */\n  guard: boolean;\n\n  /**\n   * The current value. MISSING sentinel indicates no value has been set.\n   */\n  private _value: Value | typeof MISSING = MISSING;\n\n  /**\n   * Optional factory function for the initial value.\n   */\n  private initialValueFactory?: () => Value;\n\n  constructor(options?: {\n    guard?: boolean;\n    initialValueFactory?: () => Value;\n  }) {\n    super();\n    this.guard = options?.guard ?? true;\n    this.initialValueFactory = options?.initialValueFactory;\n    if (this.initialValueFactory) {\n      this._value = this.initialValueFactory();\n    }\n  }\n\n  /**\n   * Return a new channel, ignoring the checkpoint since we don't persist.\n   * The initial value (if any) is restored.\n   */\n  fromCheckpoint(_checkpoint?: undefined): this {\n    const empty = new UntrackedValueChannel<Value>({\n      guard: this.guard,\n      initialValueFactory: this.initialValueFactory,\n    });\n    return empty as this;\n  }\n\n  /**\n   * Update the channel with the given values.\n   * If guard is true, throws if more than one value is received.\n   */\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      return false;\n    }\n\n    if (values.length !== 1 && this.guard) {\n      throw new InvalidUpdateError(\n        \"UntrackedValue(guard=true) can receive only one value per step. \" +\n          \"Use guard=false if you want to store any one of multiple values.\",\n        { lc_error_code: \"INVALID_CONCURRENT_GRAPH_UPDATE\" }\n      );\n    }\n\n    this._value = values[values.length - 1];\n    return true;\n  }\n\n  /**\n   * Get the current value.\n   * @throws EmptyChannelError if no value has been set.\n   */\n  get(): Value {\n    if (this._value === MISSING) {\n      throw new EmptyChannelError();\n    }\n    return this._value;\n  }\n\n  /**\n   * Always returns undefined - untracked values are never checkpointed.\n   */\n  checkpoint(): undefined {\n    return undefined;\n  }\n\n  /**\n   * Return true if a value has been set.\n   */\n  isAvailable(): boolean {\n    return this._value !== MISSING;\n  }\n}\n", "import type { SerializableSchema } from \"../types.js\";\n\n/**\n * Symbol for runtime identification of ReducedValue instances.\n */\nexport const REDUCED_VALUE_SYMBOL = Symbol.for(\"langgraph.state.reduced_value\");\n\ninterface ReducedValueInitBase<Value = unknown> {\n  /**\n   * The reducer function that determines how new input values are combined with the current state.\n   * Receives the current output value and a new input value, and must return the updated output.\n   *\n   * @param current - The current value held in state.\n   * @param next - The new input value to apply to the reducer.\n   * @returns The next value to be stored in state.\n   *\n   * @remarks\n   * - The logic for updating state in response to new inputs lives in this function.\n   */\n  reducer: (current: Value, next: Value) => Value;\n\n  /**\n   * Optional extra fields to be added to the exported JSON Schema for documentation or additional constraints.\n   *\n   * @remarks\n   * - Use this property to attach metadata or documentation to the generated JSON Schema representation\n   *   of this value.\n   * - These fields are merged into the generated schema, which can assist with code generation, UI hints,\n   *   or external documentation.\n   */\n  jsonSchemaExtra?: Record<string, unknown>;\n}\n\ninterface ReducedValueInitWithSchema<Value = unknown, Input = Value> {\n  /**\n   * Schema describing the type and validation logic for reducer input values.\n   *\n   * @remarks\n   * - If provided, new values passed to the reducer will be validated using this schema before reduction.\n   * - This allows the reducer to accept inputs distinct from the type stored in the state (output type).\n   */\n  inputSchema: SerializableSchema<unknown, Input>;\n\n  /**\n   * The reducer function that determines how new input values are combined with the current state.\n   * Receives the current output value and a new input value (validated using `inputSchema`), and returns the updated output.\n   *\n   * @param current - The current value held in state.\n   * @param next - The new validated input value to be applied.\n   * @returns The next value to be stored in state.\n   *\n   * @remarks\n   * - The logic for updating state in response to new inputs lives in this function.\n   */\n  reducer: (current: Value, next: Input) => Value;\n\n  /**\n   * Optional extra fields to be added to the exported JSON Schema for documentation or additional constraints.\n   *\n   * @remarks\n   * - Use this property to attach metadata or documentation to the generated JSON Schema representation\n   *   of this value.\n   * - These fields are merged into the generated schema, which can assist with code generation, UI hints,\n   *   or external documentation.\n   */\n  jsonSchemaExtra?: Record<string, unknown>;\n}\n\n/**\n * Initialization options for {@link ReducedValue}.\n *\n * Two forms are supported:\n * 1. Provide only a reducer (and optionally `jsonSchemaExtra`)in this case, the reducer's inputs are validated using the output value schema.\n * 2. Provide an explicit `inputSchema` field to distinguish the reducer's input type from the stored/output type.\n *\n * @template Value - The type of value stored and produced after reduction.\n * @template Input - The type of inputs accepted by the reducer.\n *\n * @property inputSchema - The schema describing reducer inputs. If omitted, will use the value schema.\n * @property reducer - A function that receives the current output value and a new input, and returns the new output.\n * @property jsonSchemaExtra - (Optional) Extra fields to merge into the exported JSON Schema for documentation or additional constraints.\n */\nexport type ReducedValueInit<Value = unknown, Input = Value> =\n  | ReducedValueInitWithSchema<Value, Input>\n  | ReducedValueInitBase<Value>;\n\n/**\n * Represents a state field whose value is computed and updated using a reducer function.\n *\n * {@link ReducedValue} allows you to define accumulators, counters, aggregators, or other fields\n * whose value is determined incrementally by applying a reducer to incoming updates.\n *\n * Each time a new input is provided, the reducer function is called with the current output\n * and the new input, producing an updated value. Input validation can be controlled separately\n * from output validation by providing an explicit input schema.\n *\n * @template Value - The type of the value stored in state and produced by reduction.\n * @template Input - The type of updates accepted by the reducer.\n *\n * @example\n * // Accumulator with distinct input validation\n * const Sum = new ReducedValue(z.number(), {\n *   inputSchema: z.number().min(1),\n *   reducer: (total, toAdd) => total + toAdd\n * });\n *\n * @example\n * // Simple running max, using only the value schema\n * const Max = new ReducedValue(z.number(), {\n *   reducer: (current, next) => Math.max(current, next)\n * });\n */\nexport class ReducedValue<Value = unknown, Input = Value> {\n  /**\n   * Instance marker for runtime identification.\n   * @internal\n   */\n  protected readonly [REDUCED_VALUE_SYMBOL] = true as const;\n\n  /**\n   * The schema that describes the type of value stored in state (i.e., after reduction).\n   * Note: We use `unknown` for the input type to allow schemas with `.default()` wrappers,\n   * where the input type includes `undefined`.\n   */\n  readonly valueSchema: SerializableSchema<unknown, Value>;\n\n  /**\n   * The schema used to validate reducer inputs.\n   * If not specified explicitly, this defaults to `valueSchema`.\n   */\n  readonly inputSchema: SerializableSchema<unknown, Input | Value>;\n\n  /**\n   * The reducer function that combines a current output value and an incoming input.\n   */\n  readonly reducer: (current: Value, next: Input) => Value;\n\n  /**\n   * Optional extra fields to merge into the generated JSON Schema (e.g., for documentation or constraints).\n   */\n  readonly jsonSchemaExtra?: Record<string, unknown>;\n\n  /**\n   * Represents the value stored after all reductions.\n   */\n  declare ValueType: Value;\n\n  /**\n   * Represents the type that may be provided as input on each update.\n   */\n  declare InputType: Input;\n\n  /**\n   * Constructs a ReducedValue instance, which combines a value schema and a reducer function (plus optional input schema).\n   *\n   * @param valueSchema - The schema that describes the type of value stored in state (the \"running total\").\n   * @param init - An object specifying the reducer function (required), inputSchema (optional), and jsonSchemaExtra (optional).\n   */\n  constructor(\n    valueSchema: SerializableSchema<unknown, Value>,\n    init: ReducedValueInitWithSchema<Value, Input>\n  );\n\n  constructor(\n    valueSchema: SerializableSchema<Input, Value>,\n    init: ReducedValueInitBase<Value>\n  );\n\n  constructor(\n    valueSchema: SerializableSchema<unknown, Value>,\n    init: ReducedValueInit<Value, Input>\n  ) {\n    this.reducer = init.reducer as (current: Value, next: Input) => Value;\n    this.jsonSchemaExtra = init.jsonSchemaExtra;\n    this.valueSchema = valueSchema;\n    this.inputSchema = \"inputSchema\" in init ? init.inputSchema : valueSchema;\n    this.jsonSchemaExtra = init.jsonSchemaExtra;\n  }\n\n  /**\n   * Type guard to check if a value is a ReducedValue instance.\n   */\n  static isInstance<Value = unknown, Input = Value>(\n    value: ReducedValue<Value, Input>\n  ): value is ReducedValue<Value, Input>;\n\n  static isInstance(value: unknown): value is ReducedValue;\n\n  static isInstance<Value = unknown, Input = Value>(\n    value: ReducedValue<Value, Input> | unknown\n  ): value is ReducedValue<Value, Input> {\n    return (\n      typeof value === \"object\" &&\n      value !== null &&\n      REDUCED_VALUE_SYMBOL in value &&\n      value[REDUCED_VALUE_SYMBOL] === true\n    );\n  }\n}\n", "import type { SerializableSchema } from \"../types.js\";\n\n/**\n * Symbol for runtime identification of UntrackedValue instances.\n */\nexport const UNTRACKED_VALUE_SYMBOL = Symbol.for(\n  \"langgraph.state.untracked_value\"\n);\n\n/**\n * Initialization options for {@link UntrackedValue}.\n */\nexport interface UntrackedValueInit {\n  /**\n   * If true (default), throws an error if multiple updates are made in a single step.\n   * If false, only the last value is kept per step.\n   */\n  guard?: boolean;\n}\n\n/**\n * Represents a state field whose value is transient and never checkpointed.\n *\n * Use {@link UntrackedValue} for state fields that should be tracked for the lifetime\n * of the process, but should not participate in durable checkpoints or recovery.\n *\n * @typeParam Value - The type of value stored in this field.\n *\n * @example\n * // Create an untracked in-memory cache\n * const cache = new UntrackedValue<Record<string, number>>();\n *\n * // Use with a type schema for basic runtime validation\n * import { z } from \"zod\";\n * const tempSession = new UntrackedValue(z.object({ token: z.string() }), { guard: false });\n *\n * // You can customize whether to throw on multiple updates per step:\n * const session = new UntrackedValue(undefined, { guard: false });\n */\nexport class UntrackedValue<Value = unknown> {\n  /**\n   * Instance marker for runtime identification.\n   * @internal\n   */\n  protected readonly [UNTRACKED_VALUE_SYMBOL] = true as const;\n\n  /**\n   * Optional schema describing the type and shape of the value stored in this field.\n   *\n   * If provided, this can be used for runtime validation or code generation.\n   */\n  readonly schema?: SerializableSchema<Value>;\n\n  /**\n   * Whether to guard against multiple updates to this untracked value in a single step.\n   *\n   * - If `true` (default), throws an error if multiple updates are received in one step.\n   * - If `false`, only the last value from that step is kept, others are ignored.\n   *\n   * This helps prevent accidental state replacement within a step.\n   */\n  readonly guard: boolean;\n\n  /**\n   * Represents the type of value stored in this untracked state field.\n   */\n  declare ValueType: Value;\n\n  /**\n   * Create a new untracked value state field.\n   *\n   * @param schema - Optional type schema describing the value (e.g. a Zod schema).\n   * @param init - Optional options for tracking updates or enabling multiple-writes-per-step.\n   */\n  constructor(schema?: SerializableSchema<Value>, init?: UntrackedValueInit) {\n    this.schema = schema;\n    this.guard = init?.guard ?? true;\n  }\n\n  /**\n   * Type guard to check if a value is an UntrackedValue instance.\n   */\n  static isInstance<Value = unknown>(\n    value: UntrackedValue<Value>\n  ): value is UntrackedValue<Value>;\n\n  static isInstance(value: unknown): value is UntrackedValue;\n\n  static isInstance<Value = unknown>(\n    value: UntrackedValue<Value> | unknown\n  ): value is UntrackedValue<Value> {\n    return (\n      typeof value === \"object\" &&\n      value !== null &&\n      UNTRACKED_VALUE_SYMBOL in value\n    );\n  }\n}\n", "import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\nexport const areSetsEqual = <T>(a: Set<T>, b: Set<T>) =>\n  a.size === b.size && [...a].every((value) => b.has(value));\n\n/**\n * A channel that waits until all named values are received before making the value available.\n *\n * This ensures that if node N and node M both write to channel C, the value of C will not be updated\n * until N and M have completed updating.\n */\nexport class NamedBarrierValue<Value> extends BaseChannel<\n  void,\n  Value,\n  Value[]\n> {\n  lc_graph_name = \"NamedBarrierValue\";\n\n  names: Set<Value>; // Names of nodes that we want to wait for.\n\n  seen: Set<Value>;\n\n  constructor(names: Set<Value>) {\n    super();\n    this.names = names;\n    this.seen = new Set<Value>();\n  }\n\n  fromCheckpoint(checkpoint?: Value[]) {\n    const empty = new NamedBarrierValue<Value>(this.names);\n    if (typeof checkpoint !== \"undefined\") {\n      empty.seen = new Set(checkpoint);\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    let updated = false;\n    for (const nodeName of values) {\n      if (this.names.has(nodeName)) {\n        if (!this.seen.has(nodeName)) {\n          this.seen.add(nodeName);\n          updated = true;\n        }\n      } else {\n        throw new InvalidUpdateError(\n          `Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(\n            this.names\n          )}`\n        );\n      }\n    }\n    return updated;\n  }\n\n  // If we have not yet seen all the node names we want to wait for,\n  // throw an error to prevent continuing.\n  get(): void {\n    if (!areSetsEqual(this.names, this.seen)) {\n      throw new EmptyChannelError();\n    }\n    return undefined;\n  }\n\n  checkpoint(): Value[] {\n    return [...this.seen];\n  }\n\n  consume(): boolean {\n    if (this.seen && this.names && areSetsEqual(this.seen, this.names)) {\n      this.seen = new Set<Value>();\n      return true;\n    }\n    return false;\n  }\n\n  isAvailable(): boolean {\n    return !!this.names && areSetsEqual(this.names, this.seen);\n  }\n}\n\n/**\n * A channel that waits until all named values are received before making the value ready to be made available.\n * It is only made available after finish() is called.\n * @internal\n */\nexport class NamedBarrierValueAfterFinish<Value> extends BaseChannel<\n  void,\n  Value,\n  [Value[], boolean]\n> {\n  lc_graph_name = \"NamedBarrierValueAfterFinish\";\n\n  names: Set<Value>; // Names of nodes that we want to wait for.\n\n  seen: Set<Value>;\n\n  finished: boolean;\n\n  constructor(names: Set<Value>) {\n    super();\n    this.names = names;\n    this.seen = new Set<Value>();\n    this.finished = false;\n  }\n\n  fromCheckpoint(checkpoint?: [Value[], boolean]) {\n    const empty = new NamedBarrierValueAfterFinish<Value>(this.names);\n    if (typeof checkpoint !== \"undefined\") {\n      const [seen, finished] = checkpoint;\n      empty.seen = new Set(seen);\n      empty.finished = finished;\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    let updated = false;\n    for (const nodeName of values) {\n      if (this.names.has(nodeName) && !this.seen.has(nodeName)) {\n        this.seen.add(nodeName);\n        updated = true;\n      } else if (!this.names.has(nodeName)) {\n        throw new InvalidUpdateError(\n          `Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(\n            this.names\n          )}`\n        );\n      }\n    }\n    return updated;\n  }\n\n  get(): void {\n    if (!this.finished || !areSetsEqual(this.names, this.seen)) {\n      throw new EmptyChannelError();\n    }\n    return undefined;\n  }\n\n  checkpoint(): [Value[], boolean] {\n    return [[...this.seen], this.finished];\n  }\n\n  consume(): boolean {\n    if (\n      this.finished &&\n      this.seen &&\n      this.names &&\n      areSetsEqual(this.seen, this.names)\n    ) {\n      this.seen = new Set<Value>();\n      this.finished = false;\n      return true;\n    }\n    return false;\n  }\n\n  finish(): boolean {\n    if (!this.finished && !!this.names && areSetsEqual(this.names, this.seen)) {\n      this.finished = true;\n      return true;\n    }\n    return false;\n  }\n\n  isAvailable(): boolean {\n    return this.finished && !!this.names && areSetsEqual(this.names, this.seen);\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { JSONSchema } from \"@langchain/core/utils/json_schema\";\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\n\nimport type { RunnableLike } from \"../pregel/runnable_types.js\";\nimport {\n  BaseChannel,\n  LastValue,\n  BinaryOperatorAggregate,\n} from \"../channels/index.js\";\nimport { UntrackedValueChannel } from \"../channels/untracked_value.js\";\n\nimport type { SerializableSchema } from \"./types.js\";\nimport { isStandardSchema } from \"./types.js\";\nimport { getJsonSchemaFromSchema, getSchemaDefaultGetter } from \"./adapter.js\";\nimport { ReducedValue } from \"./values/reduced.js\";\nimport { UntrackedValue } from \"./values/untracked.js\";\n\nconst STATE_SCHEMA_SYMBOL = Symbol.for(\"langgraph.state.state_schema\");\n\n/**\n * Maps a single StateSchema field definition to its corresponding Channel type.\n *\n * This utility type inspects the type of the field and returns an appropriate\n * `BaseChannel` type, parameterized with the state \"value\" and \"input\" types according to the field's shape.\n *\n * Rules:\n * - If the field (`F`) is a `ReducedValue<V, I>`, the channel will store values of type `V`\n *   and accept input of type `I`.\n * - If the field is a `UntrackedValue<V>`, the channel will store and accept values of type `V`.\n * - If the field is a `SerializableSchema<I, O>`, the channel will store values of type `O`\n *   (the schema's output/validated value) and accept input of type `I`.\n * - For all other types, a generic `BaseChannel<unknown, unknown>` is used as fallback.\n *\n * @template F - The StateSchema field type to map to a Channel type.\n *\n * @example\n * ```typescript\n * type MyField = ReducedValue<number, string>;\n * type ChannelType = StateSchemaFieldToChannel<MyField>;\n * // ChannelType is BaseChannel<number, string>\n * ```\n */\nexport type StateSchemaFieldToChannel<F> = F extends ReducedValue<\n  infer V,\n  infer I\n>\n  ? BaseChannel<V, I>\n  : F extends UntrackedValue<infer V>\n  ? BaseChannel<V, V>\n  : F extends SerializableSchema<infer I, infer O>\n  ? BaseChannel<O, I>\n  : BaseChannel<unknown, unknown>;\n\n/**\n * Converts StateSchema fields into a strongly-typed\n * State Definition object, where each field is mapped to its channel type.\n *\n * This utility type is used internally to create the shape of the state channels for a given schema,\n * substituting each field with the result of `StateSchemaFieldToChannel`.\n *\n * If you define a state schema as:\n * ```typescript\n * const fields = {\n *   a: ReducedValue<number, string>(),\n *   b: UntrackedValue<boolean>(),\n *   c: SomeSerializableSchemaType, // SerializableSchema<in, out>\n * }\n * ```\n * then `StateSchemaFieldsToStateDefinition<typeof fields>` yields:\n * ```typescript\n * {\n *   a: BaseChannel<number, string>;\n *   b: BaseChannel<boolean, boolean>;\n *   c: BaseChannel<typeof schema's output type, typeof schema's input type>;\n * }\n * ```\n *\n * @template TFields - The mapping of field names to StateSchema field types.\n * @returns An object type mapping field names to channel types.\n *\n * @see StateSchemaFieldToChannel\n */\nexport type StateSchemaFieldsToStateDefinition<\n  TFields extends StateSchemaFields\n> = {\n  [K in keyof TFields]: StateSchemaFieldToChannel<TFields[K]>;\n};\n\n/**\n * Valid field types for StateSchema.\n * Either a LangGraph state value type or a raw schema (e.g., Zod schema).\n */\nexport type StateSchemaField<Input = unknown, Output = Input> =\n  | ReducedValue<Input, Output>\n  | UntrackedValue<Output>\n  | SerializableSchema<Input, Output>;\n\n/**\n * Init object for StateSchema constructor.\n * Uses `any` to allow variance in generic types (e.g., ReducedValue<string, string[]>).\n */\nexport type StateSchemaFields = {\n  [key: string]: StateSchemaField<any, any>;\n};\n\n/**\n * Infer the State type from a StateSchemaFields.\n * This is the type of the full state object.\n *\n * - ReducedValue<Value, Input>  Value (the stored type)\n * - UntrackedValue<Value>  Value\n * - SerializableSchema<Input, Output>  Output (the validated type)\n */\nexport type InferStateSchemaValue<TFields extends StateSchemaFields> = {\n  [K in keyof TFields]: TFields[K] extends ReducedValue<any, any>\n    ? TFields[K][\"ValueType\"]\n    : TFields[K] extends UntrackedValue<any>\n    ? TFields[K][\"ValueType\"]\n    : TFields[K] extends SerializableSchema<any, infer TOutput>\n    ? TOutput\n    : never;\n};\n\n/**\n * Infer the Update type from a StateSchemaFields.\n * This is the type for partial updates to state.\n *\n * - ReducedValue<Value, Input>  Input (the reducer input type)\n * - UntrackedValue<Value>  Value\n * - SerializableSchema<Input, Output>  Input (what you provide)\n */\nexport type InferStateSchemaUpdate<TFields extends StateSchemaFields> = {\n  [K in keyof TFields]?: TFields[K] extends ReducedValue<any, any>\n    ? TFields[K][\"InputType\"]\n    : TFields[K] extends UntrackedValue<any>\n    ? TFields[K][\"ValueType\"]\n    : TFields[K] extends SerializableSchema<infer TInput, any>\n    ? TInput\n    : never;\n};\n\n/**\n * StateSchema provides a unified API for defining LangGraph state schemas.\n *\n * @example\n * ```ts\n * import { z } from \"zod\";\n * import { StateSchema, ReducedValue, MessagesValue } from \"@langchain/langgraph\";\n *\n * const AgentState = new StateSchema({\n *   // Prebuilt messages value\n *   messages: MessagesValue,\n *   // Basic LastValue channel from any standard schema\n *   currentStep: z.string(),\n *   // LastValue with native default\n *   count: z.number().default(0),\n *   // ReducedValue for fields needing reducers\n *   history: new ReducedValue(\n *     z.array(z.string()).default(() => []),\n *     {\n *       inputSchema: z.string(),\n *       reducer: (current, next) => [...current, next],\n *     }\n *   ),\n * });\n *\n * // Extract types\n * type State = typeof AgentState.State;\n * type Update = typeof AgentState.Update;\n *\n * // Use in StateGraph\n * const graph = new StateGraph(AgentState);\n * ```\n */\nexport class StateSchema<TFields extends StateSchemaFields> {\n  /**\n   * Symbol for runtime identification.\n   * @internal Used by isInstance for runtime type checking\n   */\n  // @ts-expect-error - Symbol is read via `in` operator in isInstance\n  private readonly [STATE_SCHEMA_SYMBOL] = true;\n\n  /**\n   * Type declaration for the full state type.\n   * Use: `typeof myState.State`\n   */\n  declare State: InferStateSchemaValue<TFields>;\n\n  /**\n   * Type declaration for the update type.\n   * Use: `typeof myState.Update`\n   */\n  declare Update: InferStateSchemaUpdate<TFields>;\n\n  /**\n   * Type declaration for node functions.\n   * Use: `typeof myState.Node` to type node functions outside the graph builder.\n   *\n   * @example\n   * ```typescript\n   * const AgentState = new StateSchema({\n   *   count: z.number().default(0),\n   * });\n   *\n   * const myNode: typeof AgentState.Node = (state) => {\n   *   return { count: state.count + 1 };\n   * };\n   * ```\n   */\n  declare Node: RunnableLike<\n    InferStateSchemaValue<TFields>,\n    InferStateSchemaUpdate<TFields>\n  >;\n\n  constructor(readonly fields: TFields) {}\n\n  /**\n   * Get the channel definitions for use with StateGraph.\n   * This converts the StateSchema fields into BaseChannel instances.\n   */\n  getChannels(): Record<string, BaseChannel> {\n    const channels: Record<string, BaseChannel> = {};\n\n    for (const [key, value] of Object.entries(this.fields)) {\n      if (ReducedValue.isInstance(value)) {\n        // ReducedValue -> BinaryOperatorAggregate\n        const defaultGetter = getSchemaDefaultGetter(value.valueSchema);\n        channels[key] = new BinaryOperatorAggregate(\n          value.reducer,\n          defaultGetter\n        );\n      } else if (UntrackedValue.isInstance(value)) {\n        // UntrackedValue -> UntrackedValueChannel\n        const defaultGetter = value.schema\n          ? getSchemaDefaultGetter(value.schema)\n          : undefined;\n        channels[key] = new UntrackedValueChannel({\n          guard: value.guard,\n          initialValueFactory: defaultGetter,\n        });\n      } else if (isStandardSchema(value)) {\n        // Plain schema -> LastValue channel\n        const defaultGetter = getSchemaDefaultGetter(value);\n        channels[key] = new LastValue(defaultGetter);\n      } else {\n        throw new Error(\n          `Invalid state field \"${key}\": must be a schema, ReducedValue, UntrackedValue, or ManagedValue`\n        );\n      }\n    }\n\n    return channels;\n  }\n\n  /**\n   * Get the JSON schema for the full state type.\n   * Used by Studio and API for schema introspection.\n   */\n  getJsonSchema(): JSONSchema {\n    const properties: Record<string, JSONSchema> = {};\n    const required: string[] = [];\n\n    for (const [key, value] of Object.entries(this.fields)) {\n      let fieldSchema: JSONSchema | undefined;\n\n      if (ReducedValue.isInstance(value)) {\n        fieldSchema = getJsonSchemaFromSchema(value.valueSchema) as JSONSchema;\n        if (fieldSchema && value.jsonSchemaExtra) {\n          fieldSchema = { ...fieldSchema, ...value.jsonSchemaExtra };\n        }\n      } else if (UntrackedValue.isInstance(value)) {\n        fieldSchema = value.schema\n          ? (getJsonSchemaFromSchema(value.schema) as JSONSchema)\n          : undefined;\n      } else if (isStandardSchema(value)) {\n        fieldSchema = getJsonSchemaFromSchema(value) as JSONSchema;\n      }\n\n      if (fieldSchema) {\n        properties[key] = fieldSchema;\n\n        // Field is required if it doesn't have a default\n        let hasDefault = false;\n        if (ReducedValue.isInstance(value)) {\n          hasDefault = getSchemaDefaultGetter(value.valueSchema) !== undefined;\n        } else if (UntrackedValue.isInstance(value)) {\n          hasDefault = value.schema\n            ? getSchemaDefaultGetter(value.schema) !== undefined\n            : false;\n        } else {\n          hasDefault = getSchemaDefaultGetter(value) !== undefined;\n        }\n\n        if (!hasDefault) {\n          required.push(key);\n        }\n      }\n    }\n\n    return {\n      type: \"object\",\n      properties,\n      required: required.length > 0 ? required : undefined,\n    };\n  }\n\n  /**\n   * Get the JSON schema for the update/input type.\n   * All fields are optional in updates.\n   */\n  getInputJsonSchema(): JSONSchema {\n    const properties: Record<string, JSONSchema> = {};\n\n    for (const [key, value] of Object.entries(this.fields)) {\n      let fieldSchema: JSONSchema | undefined;\n\n      if (ReducedValue.isInstance(value)) {\n        // Use input schema for updates\n        fieldSchema = getJsonSchemaFromSchema(value.inputSchema) as JSONSchema;\n      } else if (UntrackedValue.isInstance(value)) {\n        fieldSchema = value.schema\n          ? (getJsonSchemaFromSchema(value.schema) as JSONSchema)\n          : undefined;\n      } else if (isStandardSchema(value)) {\n        fieldSchema = getJsonSchemaFromSchema(value) as JSONSchema;\n      }\n\n      if (fieldSchema) {\n        properties[key] = fieldSchema;\n      }\n    }\n\n    return {\n      type: \"object\",\n      properties,\n    };\n  }\n\n  /**\n   * Get the list of channel keys (excluding managed values).\n   */\n  getChannelKeys(): string[] {\n    return Object.entries(this.fields).map(([key]) => key);\n  }\n\n  /**\n   * Get all keys (channels + managed values).\n   */\n  getAllKeys(): string[] {\n    return Object.keys(this.fields);\n  }\n\n  /**\n   * Validate input data against the schema.\n   * This validates each field using its corresponding schema.\n   *\n   * @param data - The input data to validate\n   * @returns The validated data with coerced types\n   */\n  async validateInput<T>(data: T): Promise<T> {\n    if (data == null || typeof data !== \"object\") {\n      return data;\n    }\n\n    const result: Record<string, unknown> = {};\n\n    for (const [key, value] of Object.entries(data)) {\n      const fieldDef = this.fields[key];\n\n      if (fieldDef === undefined) {\n        // Unknown field, pass through\n        result[key] = value;\n        continue;\n      }\n\n      // Get the schema to use for validation\n      let schema: StandardSchemaV1 | undefined;\n\n      if (ReducedValue.isInstance(fieldDef)) {\n        schema = fieldDef.inputSchema;\n      } else if (UntrackedValue.isInstance(fieldDef)) {\n        schema = fieldDef.schema;\n      } else if (isStandardSchema(fieldDef)) {\n        schema = fieldDef;\n      }\n\n      if (schema) {\n        // Validate using standard schema\n        const validationResult = await schema[\"~standard\"].validate(value);\n        if (validationResult.issues) {\n          throw new Error(\n            `Validation failed for field \"${key}\": ${JSON.stringify(\n              validationResult.issues\n            )}`\n          );\n        }\n        result[key] = validationResult.value;\n      } else {\n        // No schema or not a standard schema, pass through\n        result[key] = value;\n      }\n    }\n\n    return result as T;\n  }\n\n  /**\n   * Type guard to check if a value is a StateSchema instance.\n   *\n   * @param value - The value to check.\n   * @returns True if the value is a StateSchema instance with the correct runtime tag.\n   */\n  static isInstance<TFields extends StateSchemaFields>(\n    value: StateSchema<TFields>\n  ): value is StateSchema<TFields>;\n\n  static isInstance(value: unknown): value is StateSchema<any>;\n\n  static isInstance<TFields extends StateSchemaFields>(\n    value: unknown\n  ): value is StateSchema<TFields> {\n    return (\n      typeof value === \"object\" &&\n      value !== null &&\n      STATE_SCHEMA_SYMBOL in value &&\n      value[STATE_SCHEMA_SYMBOL] === true\n    );\n  }\n}\n\nexport type AnyStateSchema = StateSchema<any>;\n", "import {\n  BaseMessage,\n  BaseMessageLike,\n  coerceMessageLikeToMessage,\n  RemoveMessage,\n} from \"@langchain/core/messages\";\nimport { v4 } from \"uuid\";\n\n/**\n * Special value that signifies the intent to remove all previous messages in the state reducer.\n * Used as the unique identifier for a `RemoveMessage` instance which, when encountered,\n * causes all prior messages to be discarded, leaving only those following this marker.\n */\nexport const REMOVE_ALL_MESSAGES = \"__remove_all__\";\n\n/**\n * Type that represents an acceptable input for the messages state reducer.\n *\n * - Can be a single `BaseMessage` or `BaseMessageLike`.\n * - Can be an array of `BaseMessage` or `BaseMessageLike`.\n */\nexport type Messages =\n  | Array<BaseMessage | BaseMessageLike>\n  | BaseMessage\n  | BaseMessageLike;\n\n/**\n * Reducer function for combining two sets of messages in LangGraph's state system.\n *\n * This reducer handles several tasks:\n * 1. Normalizes both `left` and `right` message inputs to arrays.\n * 2. Coerces any message-like objects into real `BaseMessage` instances.\n * 3. Ensures all messages have unique, stable IDs by generating missing ones.\n * 4. If a `RemoveMessage` instance is encountered in `right` with the ID `REMOVE_ALL_MESSAGES`,\n *    all previous messages are discarded and only the subsequent messages in `right` are returned.\n * 5. Otherwise, merges `left` and `right` messages together following these rules:\n *    - If a message in `right` shares an ID with a message in `left`:\n *      - If it is a `RemoveMessage`, that message (by ID) is marked for removal.\n *      - If it is a normal message, it replaces the message with the same ID from `left`.\n *    - If a message in `right` **does not exist** in `left`:\n *      - If it is a `RemoveMessage`, this is considered an error (cannot remove non-existent ID).\n *      - Otherwise, the message is appended.\n *    - Messages flagged for removal are omitted from the final output.\n *\n * @param left - The existing array (or single message) of messages from current state.\n * @param right - The new array (or single message) of messages to be applied.\n * @returns A new array of `BaseMessage` objects representing the updated state.\n *\n * @throws Error if a `RemoveMessage` is used to delete a message with an ID that does not exist in the merged list.\n *\n * @example\n * ```ts\n * const msg1 = new AIMessage(\"hello\");\n * const msg2 = new HumanMessage(\"hi\");\n * const removal = new RemoveMessage({ id: msg1.id });\n * const newState = messagesStateReducer([msg1], [msg2, removal]);\n * // newState will only contain msg2 (msg1 is removed)\n * ```\n */\nexport function messagesStateReducer(\n  left: Messages,\n  right: Messages\n): BaseMessage[] {\n  // Ensure both left and right are arrays\n  const leftArray = Array.isArray(left) ? left : [left];\n  const rightArray = Array.isArray(right) ? right : [right];\n\n  // Convert all input to BaseMessage instances\n  const leftMessages = (leftArray as BaseMessageLike[]).map(\n    coerceMessageLikeToMessage\n  );\n  const rightMessages = (rightArray as BaseMessageLike[]).map(\n    coerceMessageLikeToMessage\n  );\n\n  // Assign missing IDs to any message in the left array\n  for (const m of leftMessages) {\n    if (m.id === null || m.id === undefined) {\n      m.id = v4();\n      m.lc_kwargs.id = m.id;\n    }\n  }\n\n  // Assign missing IDs and check for \"remove all\" marker in right array\n  let removeAllIdx: number | undefined;\n  for (let i = 0; i < rightMessages.length; i += 1) {\n    const m = rightMessages[i];\n    if (m.id === null || m.id === undefined) {\n      m.id = v4();\n      m.lc_kwargs.id = m.id;\n    }\n\n    // If RemoveMessage with special REMOVE_ALL_MESSAGES id is found\n    if (RemoveMessage.isInstance(m) && m.id === REMOVE_ALL_MESSAGES) {\n      removeAllIdx = i;\n    }\n  }\n\n  // If remove-all is present, all previous messages are wiped; return only subsequent ones\n  if (removeAllIdx != null) return rightMessages.slice(removeAllIdx + 1);\n\n  // Begin normal merging logic\n  const merged = [...leftMessages];\n  const mergedById = new Map(merged.map((m, i) => [m.id, i]));\n  const idsToRemove = new Set();\n\n  for (const m of rightMessages) {\n    const existingIdx = mergedById.get(m.id);\n    if (existingIdx !== undefined) {\n      // Case: updating or removing an existing message by id\n      if (RemoveMessage.isInstance(m)) {\n        idsToRemove.add(m.id);\n      } else {\n        idsToRemove.delete(m.id);\n        merged[existingIdx] = m;\n      }\n    } else {\n      // Case: inserting a completely new message\n      if (RemoveMessage.isInstance(m)) {\n        throw new Error(\n          `Attempting to delete a message with an ID that doesn't exist ('${m.id}')`\n        );\n      }\n      mergedById.set(m.id, merged.length);\n      merged.push(m);\n    }\n  }\n\n  // Remove any messages whose IDs are marked for removal\n  return merged.filter((m) => !idsToRemove.has(m.id));\n}\n", "import type { BaseMessage } from \"@langchain/core/messages\";\nimport { z } from \"zod/v4\";\n\nimport { ReducedValue } from \"../values/reduced.js\";\nimport {\n  messagesStateReducer,\n  type Messages,\n} from \"../../graph/messages_reducer.js\";\n\nconst messagesValueSchema = z.custom<BaseMessage[]>().default(() => []);\nconst messagesInputSchema = z.custom<Messages>();\n\nexport const MessagesValue = new ReducedValue(\n  // Value schema: array of BaseMessage\n  messagesValueSchema,\n  {\n    // Input schema: accepts flexible message types\n    inputSchema: messagesInputSchema,\n    // Use the existing messagesStateReducer\n    reducer: messagesStateReducer,\n    // JSON schema extras for Studio\n    jsonSchemaExtra: {\n      langgraph_type: \"messages\",\n      description: \"A list of chat messages\",\n    },\n  }\n);\n", "import {\n  InferInteropZodOutput,\n  InteropZodObject,\n  InteropZodType,\n  getInteropZodObjectShape,\n  extendInteropZodObject,\n  getInteropZodDefaultGetter,\n  interopZodObjectPartial,\n  InteropZodObjectShape,\n  isZodSchemaV3,\n  getSchemaDescription,\n} from \"@langchain/core/utils/types\";\nimport { BaseChannel } from \"../../channels/base.js\";\nimport { BinaryOperatorAggregate } from \"../../channels/binop.js\";\nimport { LastValue } from \"../../channels/last_value.js\";\n\nexport const META_EXTRAS_DESCRIPTION_PREFIX = \"lg:\";\n\n/** @internal */\nexport type ReducedZodChannel<\n  T extends InteropZodType,\n  TReducerSchema extends InteropZodType\n> = T & {\n  lg_reducer_schema: TReducerSchema;\n};\n\n/** @internal */\nexport type InteropZodToStateDefinition<\n  T extends InteropZodObject,\n  TShape = InteropZodObjectShape<T>\n> = {\n  [key in keyof TShape]: TShape[key] extends ReducedZodChannel<\n    infer Schema,\n    infer ReducerSchema\n  >\n    ? Schema extends InteropZodType<infer V>\n      ? ReducerSchema extends InteropZodType<infer U>\n        ? BaseChannel<V, U>\n        : never\n      : never\n    : TShape[key] extends InteropZodType<infer V, infer U>\n    ? BaseChannel<V, U>\n    : never;\n};\n\nexport type UpdateType<\n  T extends InteropZodObject,\n  TShape = InteropZodObjectShape<T>\n> = {\n  [key in keyof TShape]?: TShape[key] extends ReducedZodChannel<\n    infer Schema,\n    infer ReducerSchema\n  >\n    ? Schema extends InteropZodType<unknown>\n      ? ReducerSchema extends InteropZodType<infer U>\n        ? U\n        : never\n      : never\n    : TShape[key] extends InteropZodType<unknown, infer U>\n    ? U\n    : never;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface SchemaMeta<TValue = any, TUpdate = TValue> {\n  jsonSchemaExtra?: {\n    langgraph_nodes?: string[];\n    langgraph_type?: \"prompt\" | \"messages\";\n    [key: string]: unknown;\n  };\n  reducer?: {\n    schema?: InteropZodType<TUpdate>;\n    fn: (a: TValue, b: TUpdate) => TValue;\n  };\n  default?: () => TValue;\n}\n\n/**\n * A registry for storing and managing metadata associated with schemas.\n * This class provides methods to get, extend, remove, and check metadata for a given schema.\n */\nexport class SchemaMetaRegistry {\n  /**\n   * Internal map storing schema metadata.\n   * @internal\n   */\n  _map = new WeakMap<InteropZodType, SchemaMeta>();\n\n  /**\n   * Cache for extended schfemas.\n   * @internal\n   */\n  _extensionCache = new Map<string, WeakMap<InteropZodType, InteropZodType>>();\n\n  /**\n   * Retrieves the metadata associated with a given schema.\n   * @template TValue The value type of the schema.\n   * @template TUpdate The update type of the schema (defaults to TValue).\n   * @param schema The schema to retrieve metadata for.\n   * @returns The associated SchemaMeta, or undefined if not present.\n   */\n  get<TValue, TUpdate = TValue>(\n    schema: InteropZodType<TValue>\n  ): SchemaMeta<TValue, TUpdate> | undefined {\n    return this._map.get(schema);\n  }\n\n  /**\n   * Extends or sets the metadata for a given schema.\n   * @template TValue The value type of the schema.\n   * @template TUpdate The update type of the schema (defaults to TValue).\n   * @param schema The schema to extend metadata for.\n   * @param predicate A function that receives the existing metadata (or undefined) and returns the new metadata.\n   */\n  extend<TValue, TUpdate>(\n    schema: InteropZodType<TValue>,\n    predicate: (\n      meta: SchemaMeta<TValue, TUpdate> | undefined\n    ) => SchemaMeta<TValue, TUpdate>\n  ) {\n    const existingMeta = this.get<TValue, TUpdate>(schema);\n    this._map.set(schema, predicate(existingMeta));\n  }\n\n  /**\n   * Removes the metadata associated with a given schema.\n   * @param schema The schema to remove metadata for.\n   * @returns The SchemaMetaRegistry instance (for chaining).\n   */\n  remove(schema: InteropZodType): this {\n    this._map.delete(schema);\n    return this;\n  }\n\n  /**\n   * Checks if metadata exists for a given schema.\n   * @param schema The schema to check.\n   * @returns True if metadata exists, false otherwise.\n   */\n  has(schema: InteropZodType): boolean {\n    return this._map.has(schema);\n  }\n\n  /**\n   * Returns a mapping of channel instances for each property in the schema\n   * using the associated metadata in the registry.\n   *\n   * This is used to create the `channels` object that's passed to the `Graph` constructor.\n   *\n   * @template T The shape of the schema.\n   * @param schema The schema to extract channels from.\n   * @returns A mapping from property names to channel instances.\n   */\n  getChannelsForSchema<T extends InteropZodObject>(\n    schema: T\n  ): InteropZodToStateDefinition<T> {\n    const channels = {} as Record<string, BaseChannel>;\n    const shape = getInteropZodObjectShape(schema);\n    for (const [key, channelSchema] of Object.entries(shape)) {\n      const meta = this.get(channelSchema);\n      if (meta?.reducer) {\n        channels[key] = new BinaryOperatorAggregate<\n          InferInteropZodOutput<typeof channelSchema>\n        >(meta.reducer.fn, meta.default);\n      } else {\n        channels[key] = new LastValue(meta?.default);\n      }\n    }\n    return channels as InteropZodToStateDefinition<T>;\n  }\n\n  /**\n   * Returns a modified schema that introspectively looks at all keys of the provided\n   * object schema, and applies the augmentations based on meta provided with those keys\n   * in the registry and the selectors provided in the `effects` parameter.\n   *\n   * This assumes that the passed in schema is the \"root\" schema object for a graph where\n   * the keys of the schema are the channels of the graph. Because we need to represent\n   * the input of a graph in a couple of different ways, the `effects` parameter allows\n   * us to apply those augmentations based on pre determined conditions.\n   *\n   * @param schema The root schema object to extend.\n   * @param effects The effects that are being applied.\n   * @returns The extended schema.\n   */\n  getExtendedChannelSchemas<T extends InteropZodObject>(\n    schema: T,\n    effects: {\n      /**\n       * Augments the shape by using the reducer's schema if it exists\n       */\n      withReducerSchema?: boolean;\n      /**\n       * Applies the stringified jsonSchemaExtra as a description to the schema.\n       */\n      withJsonSchemaExtrasAsDescription?: boolean;\n      /**\n       * Applies the `.partial()` modifier to the schema.\n       */\n      asPartial?: boolean;\n    }\n  ): InteropZodObject {\n    // If no effects are being applied, return the schema unchanged\n    if (Object.keys(effects).length === 0) {\n      return schema;\n    }\n\n    // Cache key is determined by looking at the effects that are being applied\n    const cacheKey = Object.entries(effects)\n      .filter(([, v]) => v === true)\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(([k, v]) => `${k}:${v}`)\n      .join(\"|\");\n\n    const cache = this._extensionCache.get(cacheKey) ?? new WeakMap();\n    if (cache.has(schema)) return cache.get(schema)! as T;\n\n    let modifiedSchema: InteropZodObject = schema;\n\n    if (\n      effects.withReducerSchema ||\n      effects.withJsonSchemaExtrasAsDescription\n    ) {\n      const newShapeEntries = Object.entries(\n        getInteropZodObjectShape(schema)\n      ).map(([key, schema]) => {\n        const meta = this.get(schema);\n        let outputSchema = effects.withReducerSchema\n          ? meta?.reducer?.schema ?? schema\n          : schema;\n        if (\n          effects.withJsonSchemaExtrasAsDescription &&\n          meta?.jsonSchemaExtra\n        ) {\n          const description =\n            getSchemaDescription(outputSchema) ?? getSchemaDescription(schema);\n          const strExtras = JSON.stringify({\n            ...meta.jsonSchemaExtra,\n            description,\n          });\n          outputSchema = outputSchema.describe(\n            `${META_EXTRAS_DESCRIPTION_PREFIX}${strExtras}`\n          );\n        }\n        return [key, outputSchema];\n      });\n      modifiedSchema = extendInteropZodObject(\n        schema,\n        Object.fromEntries(newShapeEntries)\n      );\n      if (isZodSchemaV3(modifiedSchema)) {\n        modifiedSchema._def.unknownKeys = \"strip\";\n      }\n    }\n    if (effects.asPartial) {\n      modifiedSchema = interopZodObjectPartial(modifiedSchema);\n    }\n\n    cache.set(schema, modifiedSchema);\n    this._extensionCache.set(cacheKey, cache);\n    return modifiedSchema;\n  }\n}\n\nexport const schemaMetaRegistry = new SchemaMetaRegistry();\n\nexport function withLangGraph<\n  TValue,\n  TUpdate,\n  TSchema extends InteropZodType<TValue>\n>(\n  schema: TSchema,\n  meta: SchemaMeta<TValue, TUpdate> & { reducer?: undefined }\n): TSchema;\nexport function withLangGraph<\n  TValue,\n  TUpdate,\n  TSchema extends InteropZodType<TValue>\n>(\n  schema: TSchema,\n  meta: SchemaMeta<TValue, TUpdate>\n): ReducedZodChannel<TSchema, InteropZodType<TUpdate>>;\nexport function withLangGraph<\n  TValue,\n  TUpdate,\n  TSchema extends InteropZodType<TValue>\n>(\n  schema: TSchema,\n  meta: SchemaMeta<TValue, TUpdate>\n): ReducedZodChannel<TSchema, InteropZodType<TUpdate>> | TSchema {\n  if (meta.reducer && !meta.default) {\n    const defaultValueGetter = getInteropZodDefaultGetter(schema);\n    if (defaultValueGetter != null) {\n      // eslint-disable-next-line no-param-reassign\n      meta.default = defaultValueGetter;\n    }\n  }\n  if (meta.reducer) {\n    const schemaWithReducer = Object.assign(schema, {\n      lg_reducer_schema: meta.reducer?.schema ?? schema,\n    });\n    schemaMetaRegistry.extend(schemaWithReducer, () => meta);\n    return schemaWithReducer;\n  } else {\n    schemaMetaRegistry.extend(schema, () => meta);\n    return schema;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  isInteropZodObject,\n  type InteropZodObject,\n} from \"@langchain/core/utils/types\";\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport type { LangGraphRunnableConfig } from \"../pregel/runnable_types.js\";\nimport type { CommandInstance, Send } from \"../constants.js\";\nimport { END } from \"../constants.js\";\nimport type {\n  AnnotationRoot,\n  StateDefinition,\n  StateType,\n  UpdateType as AnnotationUpdateType,\n} from \"./annotation.js\";\nimport {\n  AnyStateSchema,\n  StateSchema,\n  StateSchemaFieldsToStateDefinition,\n} from \"../state/schema.js\";\nimport type { InteropZodToStateDefinition } from \"./zod/meta.js\";\nimport { isBaseChannel } from \"../channels/base.js\";\n\n// Re-export END for use in ConditionalEdgeRouter return types\nexport { END };\n\n/**\n * Convert any supported schema type to a StateDefinition.\n *\n * @internal\n */\nexport type ToStateDefinition<T> = T extends StateSchema<infer TInit>\n  ? StateSchemaFieldsToStateDefinition<TInit>\n  : T extends AnnotationRoot<infer SD>\n  ? SD\n  : T extends InteropZodObject\n  ? InteropZodToStateDefinition<T>\n  : T extends StateDefinition\n  ? T\n  : never;\n\n/**\n * Type for schema types that can be used to initialize state.\n * Supports all valid schema types: StateDefinition, Zod objects, StateSchema, and AnnotationRoot.\n *\n * @internal\n */\nexport type StateDefinitionInit =\n  | StateDefinition\n  | InteropZodObject\n  | AnyStateSchema\n  | AnnotationRoot<any>;\n\n/**\n * Check if a value is a valid StateDefinitionInit type.\n * Supports: StateSchema, InteropZodObject (Zod), AnnotationRoot, StateDefinition\n *\n * @internal\n */\nexport function isStateDefinitionInit(\n  value: unknown\n): value is StateDefinitionInit {\n  if (value == null) return false;\n\n  // StateSchema\n  if (StateSchema.isInstance(value)) return true;\n\n  // InteropZodObject (Zod v3/v4 object schemas)\n  if (isInteropZodObject(value)) return true;\n\n  // AnnotationRoot\n  if (\n    typeof value === \"object\" &&\n    \"lc_graph_name\" in value &&\n    (value as { lc_graph_name: unknown }).lc_graph_name === \"AnnotationRoot\"\n  ) {\n    return true;\n  }\n\n  // StateDefinition (raw channel map)\n  if (\n    typeof value === \"object\" &&\n    !Array.isArray(value) &&\n    Object.keys(value).length > 0 &&\n    Object.values(value).every(\n      (v) => typeof v === \"function\" || isBaseChannel(v)\n    )\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Valid types for context schema.\n * Context doesn't have channels/reducers, so StateSchema is NOT supported.\n * Supports StandardSchemaV1 (Zod, Valibot, etc.) and AnnotationRoot (backward compat).\n *\n * @internal\n */\nexport type ContextSchemaInit =\n  | StandardSchemaV1\n  | AnnotationRoot<StateDefinition>;\n\n/**\n * Initialization options for StateGraph.\n * Accepts any combination of schema types for state/input/output.\n *\n * Supports both `state` and `stateSchema` as aliases for backward compatibility.\n * If only `input` is provided (no state/stateSchema), `input` is used as the state schema.\n *\n * @template SD - State definition type\n * @template I - Input definition type (defaults to undefined)\n * @template O - Output definition type (defaults to undefined)\n * @template C - Context schema type (defaults to undefined)\n * @template N - Node name union type (defaults to string)\n * @template InterruptType - Interrupt type (defaults to unknown)\n * @template WriterType - Writer type (defaults to unknown)\n */\nexport type StateGraphInit<\n  SD extends StateDefinitionInit = StateDefinitionInit,\n  I extends StateDefinitionInit | undefined = undefined,\n  O extends StateDefinitionInit | undefined = undefined,\n  C extends StateDefinitionInit | undefined = undefined,\n  N extends string = string,\n  InterruptType = unknown,\n  WriterType = unknown\n> = {\n  /** Primary key for state schema */\n  state?: SD;\n\n  /**\n   * @deprecated Use `state` instead. Will be removed in a future version.\n   */\n  stateSchema?: SD;\n\n  input?: I;\n  output?: O;\n\n  /** Context schema for runtime configuration validation. Does not support StateSchema. */\n  context?: C;\n\n  interrupt?: InterruptType;\n  writer?: WriterType;\n  nodes?: N[];\n};\n\n/**\n * Options for the second argument when passing a direct schema.\n * Excludes `state` and `stateSchema` since those come from the first arg.\n *\n * @internal\n */\nexport type StateGraphOptions<\n  I extends StateDefinitionInit | undefined = undefined,\n  O extends StateDefinitionInit | undefined = undefined,\n  C extends StateDefinitionInit | undefined = undefined,\n  N extends string = string,\n  InterruptType = unknown,\n  WriterType = unknown\n> = Omit<\n  StateGraphInit<StateDefinitionInit, I, O, C, N, InterruptType, WriterType>,\n  \"state\" | \"stateSchema\"\n>;\n\n/**\n * Check if a value is a StateGraphInit object (has state, stateSchema, or input with valid schema).\n *\n * @internal\n */\nexport function isStateGraphInit(\n  value: unknown\n): value is StateGraphInit<StateDefinitionInit> {\n  if (typeof value !== \"object\" || value == null) return false;\n\n  const obj = value as Record<string, unknown>;\n\n  // Must have at least one of: state, stateSchema, or input\n  const hasState = \"state\" in obj && isStateDefinitionInit(obj.state);\n  const hasStateSchema =\n    \"stateSchema\" in obj && isStateDefinitionInit(obj.stateSchema);\n  const hasInput = \"input\" in obj && isStateDefinitionInit(obj.input);\n\n  if (!hasState && !hasStateSchema && !hasInput) return false;\n\n  // Validate input/output if provided\n  if (\"input\" in obj && obj.input != null && !isStateDefinitionInit(obj.input))\n    return false;\n  if (\n    \"output\" in obj &&\n    obj.output != null &&\n    !isStateDefinitionInit(obj.output)\n  )\n    return false;\n\n  return true;\n}\n\n/**\n * Extract the State type from any supported schema type.\n *\n * Supports:\n * - StateSchema\n * - AnnotationRoot\n * - StateDefinition (internal channel definitions)\n * - InteropZodObject (Zod v3/v4 object schemas)\n *\n * @template Schema - The schema type to extract state from\n * @template Fallback - Type to return if schema doesn't match (default: never)\n */\nexport type ExtractStateType<\n  Schema,\n  Fallback = Schema\n> = Schema extends AnnotationRoot<infer SD>\n  ? StateType<SD>\n  : StateType<ToStateDefinition<Schema>> extends infer S\n  ? [S] extends [never]\n    ? Fallback\n    : S\n  : Fallback;\n\n/**\n * Extract the Update type from any supported schema type.\n *\n * The Update type represents what a node can return to update the state.\n * All fields are optional since nodes only need to return the fields they modify.\n *\n * Supports:\n * - StateSchema\n * - AnnotationRoot\n * - StateDefinition (internal channel definitions)\n * - InteropZodObject (Zod v3/v4 object schemas)\n *\n * @template Schema - The schema type to extract update type from\n * @template FallbackBase - Base type for fallback (will be partialized), defaults to Schema\n */\nexport type ExtractUpdateType<\n  Schema,\n  FallbackBase = Schema\n> = Schema extends AnnotationRoot<infer SD>\n  ? AnnotationUpdateType<SD>\n  : AnnotationUpdateType<ToStateDefinition<Schema>> extends infer U\n  ? [U] extends [never]\n    ? Partial<FallbackBase>\n    : U\n  : Partial<FallbackBase>;\n\n/**\n * Extract the input type from a type bag, using ExtractStateType on the InputSchema.\n * Falls back to Default if InputSchema is not provided.\n * @internal\n */\ntype ExtractBagInput<Bag, Default> = Bag extends {\n  InputSchema: infer I;\n}\n  ? ExtractStateType<I>\n  : Default;\n\n/**\n * Extract the output type from a type bag, using ExtractUpdateType on the OutputSchema.\n * Falls back to Default if OutputSchema is not provided.\n * @internal\n */\ntype ExtractBagOutput<Bag, Default> = Bag extends {\n  OutputSchema: infer O;\n}\n  ? ExtractUpdateType<O>\n  : Default;\n\n/**\n * Extract the context type from a type bag, using ExtractStateType on the ContextSchema.\n * Falls back to Default if ContextSchema is not provided.\n * Ensures result extends Record<string, unknown> for LangGraphRunnableConfig compatibility.\n * @internal\n */\ntype ExtractBagContext<\n  Bag,\n  Default extends Record<string, unknown>\n> = Bag extends {\n  ContextSchema: infer C;\n}\n  ? ExtractStateType<C> extends infer Ctx\n    ? Ctx extends Record<string, unknown>\n      ? Ctx\n      : Default\n    : Default\n  : Default;\n\n/**\n * Extract the Nodes type from a type bag.\n * Falls back to Default if Nodes is not provided.\n * @internal\n */\ntype ExtractBagNodes<Bag, Default extends string> = Bag extends {\n  Nodes: infer N extends string;\n}\n  ? N\n  : Default;\n\n/**\n * Type bag for GraphNode that accepts schema types.\n * All fields are optional - unspecified fields use defaults.\n *\n * This enables separate input/output schemas for nodes, which is useful when\n * a node receives a subset of state fields and returns different fields.\n *\n * @example\n * ```typescript\n * const node: GraphNode<{\n *   InputSchema: typeof NodeInputSchema;\n *   OutputSchema: typeof NodeOutputSchema;\n *   ContextSchema: typeof ContextSchema;\n *   Nodes: \"agent\" | \"tool\";\n * }> = (state, runtime) => {\n *   return { answer: `Response to: ${state.query}` };\n * };\n * ```\n */\nexport interface GraphNodeTypes<\n  InputSchema = unknown,\n  OutputSchema = unknown,\n  ContextSchema = unknown,\n  Nodes extends string = string\n> {\n  /** Schema for node input state (uses ExtractStateType) */\n  InputSchema?: InputSchema;\n  /** Schema for node output/update (uses ExtractUpdateType) */\n  OutputSchema?: OutputSchema;\n  /** Schema for runtime context (uses ExtractStateType) */\n  ContextSchema?: ContextSchema;\n  /** Union of valid node names for Command.goto */\n  Nodes?: Nodes;\n}\n\n/**\n * Detect if T is a type bag (has InputSchema or OutputSchema) or a direct schema.\n * @internal\n */\ntype IsGraphNodeTypeBag<T> = T extends { InputSchema: unknown }\n  ? true\n  : T extends { OutputSchema: unknown }\n  ? true\n  : false;\n\n/**\n * Return value type for GraphNode functions.\n * Nodes can return an update object, a Command, or a Promise of either.\n *\n * @template Update - The update type (what fields can be returned)\n * @template Nodes - Union of valid node names for Command.goto\n */\nexport type GraphNodeReturnValue<Update, Nodes extends string = string> =\n  | Update\n  | CommandInstance<unknown, Update, Nodes>\n  | Promise<Update | CommandInstance<unknown, Update, Nodes>>;\n\n/**\n * Strongly-typed utility for authoring graph nodes outside of the StateGraph builder,\n * supporting inference for both state (from Schema) and config context (from Context type).\n *\n * This type enables you to define graph node functions with full type safetyboth\n * for the evolving state and for additional context that may be passed in at runtime.\n * Typing the context parameter allows for better code organization and precise editor support.\n *\n * Works with StateSchema, AnnotationRoot, and Zod object schemas for state, and\n * with a user-defined object shape for context.\n *\n * **Supports two patterns:**\n *\n * 1. **Single schema usage** - Single schema for both input and output:\n *    `GraphNode<Schema, Context, Nodes>`\n *\n * 2. **Type bag pattern** - Separate schemas for input, output, context:\n *    `GraphNode<{ InputSchema; OutputSchema; ContextSchema; Nodes }>`\n *\n * @template Schema - The state schema type (StateSchema, AnnotationRoot, InteropZodObject) OR a type bag\n * @template Context - The type of the context passed into this node (default: Record<string, unknown>)\n * @template Nodes - An optional union of valid node names for Command.goto, used for type-safe routing (default: string)\n *\n * @example Single schema usage\n * ```typescript\n * import { StateSchema, GraphNode } from \"@langchain/langgraph\";\n * import { z } from \"zod/v4\";\n *\n * const AgentState = new StateSchema({\n *   messages: MessagesValue,\n *   step: z.number().default(0),\n * });\n *\n * // Context shape for custom node logic (optional)\n * type MyContext = { userId: string };\n *\n * // Node receiving state and config\n * const processNode: GraphNode<typeof AgentState, MyContext> = (state, config) => {\n *   const userId = config.configurable?.userId; // type-safe context access\n *   return { step: state.step + 1 };\n * };\n *\n * // Node with type-safe graph routing\n * const routerNode: GraphNode<typeof AgentState, MyContext, \"agent\" | \"tool\"> = (state, config) => {\n *   if (state.needsTool) {\n *     return new Command({ goto: \"tool\", update: { step: state.step + 1 } });\n *   }\n *   return new Command({ goto: \"agent\" });\n * };\n *\n * // Use in graph\n * const graph = new StateGraph(AgentState)\n *   .addNode(\"process\", processNode)\n *   .addNode(\"router\", routerNode)\n *   .compile();\n * ```\n *\n * @example Type bag pattern - separate input/output schemas\n * ```typescript\n * const InputSchema = new StateSchema({\n *   messages: z.array(z.string()),\n *   query: z.string(),\n * });\n *\n * const OutputSchema = new StateSchema({\n *   answer: z.string(),\n * });\n *\n * const ContextSchema = z.object({ userId: z.string() });\n *\n * const node: GraphNode<{\n *   InputSchema: typeof InputSchema;\n *   OutputSchema: typeof OutputSchema;\n *   ContextSchema: typeof ContextSchema;\n *   Nodes: \"agent\" | \"tool\";\n * }> = (state, config) => {\n *   // state is { messages: string[]; query: string }\n *   // config.configurable is { userId: string } | undefined\n *   return { answer: `Response to: ${state.query}` };\n * };\n * ```\n */\nexport type GraphNode<\n  Schema,\n  Context extends Record<string, any> = Record<string, any>,\n  Nodes extends string = string\n> = IsGraphNodeTypeBag<Schema> extends true\n  ? // Type bag pattern - extract types from schemas\n    (\n      state: ExtractBagInput<Schema, unknown>,\n      config: LangGraphRunnableConfig<\n        ExtractBagContext<Schema, Record<string, unknown>>\n      >\n    ) => GraphNodeReturnValue<\n      ExtractBagOutput<Schema, Partial<ExtractBagInput<Schema, unknown>>>,\n      ExtractBagNodes<Schema, string>\n    >\n  : // Single schema pattern (backward compatible)\n    (\n      state: ExtractStateType<Schema>,\n      config: LangGraphRunnableConfig<Context>\n    ) => GraphNodeReturnValue<ExtractUpdateType<Schema>, Nodes>;\n\n/**\n * Type bag for ConditionalEdgeRouter that accepts schema types.\n * Unlike GraphNodeTypes, conditional edges don't have separate input/output -\n * they just read state and return routing decisions.\n *\n * @example\n * ```typescript\n * const router: ConditionalEdgeRouter<{\n *   Schema: typeof StateSchema;\n *   ContextSchema: typeof ContextSchema;\n *   Nodes: \"agent\" | \"tool\";\n * }> = (state, config) => {\n *   return state.done ? END : \"agent\";\n * };\n * ```\n */\nexport interface ConditionalEdgeRouterTypes<\n  InputSchema = unknown,\n  ContextSchema = unknown,\n  Nodes extends string = string\n> {\n  /** Schema for router state (uses ExtractStateType) */\n  InputSchema?: InputSchema;\n  /** Schema for runtime context (uses ExtractStateType) */\n  ContextSchema?: ContextSchema;\n  /** Union of valid node names that can be routed to */\n  Nodes?: Nodes;\n}\n\n/**\n * Detect if T is a ConditionalEdgeRouterTypes bag.\n * @internal\n */\ntype IsConditionalEdgeRouterTypeBag<T> = T extends { InputSchema: unknown }\n  ? true\n  : T extends { ContextSchema: unknown }\n  ? true\n  : false;\n\n/**\n * Return type for conditional edge routing functions.\n */\ntype ConditionalEdgeRouterReturnValue<Nodes extends string, State> =\n  | Nodes\n  | typeof END\n  | Send<Nodes, State>\n  | Array<Nodes | Send<Nodes, State>>;\n\n/**\n * Type for conditional edge routing functions.\n *\n * Use this to type functions passed to `addConditionalEdges` for\n * full type safety on state, runtime context, and return values.\n *\n * **Supports two patterns:**\n *\n * 1. **Single schema pattern** - Single schema:\n *    `ConditionalEdgeRouter<Schema, Context, Nodes>`\n *\n * 2. **Type bag pattern** - Separate schemas for state, context:\n *    `ConditionalEdgeRouter<{ Schema; ContextSchema; Nodes }>`\n *\n * @template Schema - The state schema type OR a type bag\n * @template Context - The runtime context type available to node logic\n * @template Nodes - Union of valid node names that can be routed to\n *\n * @example Single schema pattern\n * ```typescript\n * type MyContext = { userId: string };\n * const router: ConditionalEdgeRouter<typeof AgentState, MyContext, \"agent\" | \"tool\"> =\n *   (state, config) => {\n *     const userId = config.context?.userId;\n *     if (state.done) return END;\n *     return state.needsTool ? \"tool\" : \"agent\";\n *   };\n *\n * graph.addConditionalEdges(\"router\", router, [\"agent\", \"tool\"]);\n * ```\n *\n * @example Type bag pattern\n * ```typescript\n * const router: ConditionalEdgeRouter<{\n *   Schema: typeof StateSchema;\n *   ContextSchema: typeof ContextSchema;\n *   Nodes: \"agent\" | \"tool\";\n * }> = (state, config) => {\n *   if (state.done) return END;\n *   return \"agent\";\n * };\n * ```\n */\nexport type ConditionalEdgeRouter<\n  Schema,\n  Context extends Record<string, any> = Record<string, any>,\n  Nodes extends string = string\n> = IsConditionalEdgeRouterTypeBag<Schema> extends true\n  ? // Type bag pattern - extract types from schemas\n    (\n      state: ExtractBagInput<Schema, unknown>,\n      config: LangGraphRunnableConfig<\n        ExtractBagContext<Schema, Record<string, unknown>>\n      >\n    ) =>\n      | ConditionalEdgeRouterReturnValue<\n          ExtractBagNodes<Schema, string>,\n          ExtractBagInput<Schema, unknown>\n        >\n      | Promise<\n          ConditionalEdgeRouterReturnValue<\n            ExtractBagNodes<Schema, string>,\n            ExtractBagInput<Schema, unknown>\n          >\n        >\n  : // Single schema pattern (backward compatible)\n    (\n      state: ExtractStateType<Schema>,\n      config: LangGraphRunnableConfig<Context>\n    ) =>\n      | ConditionalEdgeRouterReturnValue<Nodes, ExtractStateType<Schema>>\n      | Promise<\n          ConditionalEdgeRouterReturnValue<Nodes, ExtractStateType<Schema>>\n        >;\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { _coerceToRunnable, Runnable } from \"@langchain/core/runnables\";\nimport {\n  All,\n  type BaseCache,\n  BaseCheckpointSaver,\n  BaseStore,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  type InteropZodObject,\n  interopParse,\n  interopZodObjectPartial,\n  isInteropZodObject,\n} from \"@langchain/core/utils/types\";\nimport type {\n  RunnableLike,\n  LangGraphRunnableConfig,\n  Runtime,\n} from \"../pregel/runnable_types.js\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport {\n  CompiledGraph,\n  Graph,\n  Branch,\n  AddNodeOptions,\n  NodeSpec,\n} from \"./graph.js\";\nimport {\n  ChannelWrite,\n  ChannelWriteEntry,\n  ChannelWriteTupleEntry,\n  PASSTHROUGH,\n} from \"../pregel/write.js\";\nimport { ChannelRead, PregelNode } from \"../pregel/read.js\";\nimport {\n  NamedBarrierValue,\n  NamedBarrierValueAfterFinish,\n} from \"../channels/named_barrier_value.js\";\nimport { EphemeralValue } from \"../channels/ephemeral_value.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport {\n  isCommand,\n  _isSend,\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  SELF,\n  Send,\n  START,\n  END,\n  TAG_HIDDEN,\n  CommandInstance,\n  isInterrupted,\n  Interrupt,\n  INTERRUPT,\n} from \"../constants.js\";\nimport {\n  InvalidUpdateError,\n  ParentCommand,\n  StateGraphInputError,\n} from \"../errors.js\";\nimport {\n  AnnotationRoot,\n  getChannel,\n  SingleReducer,\n  StateDefinition,\n  StateType,\n} from \"./annotation.js\";\nimport { StateSchema } from \"../state/index.js\";\nimport type { CachePolicy, RetryPolicy } from \"../pregel/utils/index.js\";\nimport { isPregelLike } from \"../pregel/utils/subgraph.js\";\nimport { LastValueAfterFinish } from \"../channels/last_value.js\";\nimport { type SchemaMetaRegistry, schemaMetaRegistry } from \"./zod/meta.js\";\nimport type {\n  InferInterruptResumeType,\n  InferInterruptInputType,\n} from \"../interrupt.js\";\nimport type { InferWriterType } from \"../writer.js\";\nimport type { AnyStateSchema } from \"../state/schema.js\";\nimport {\n  ContextSchemaInit,\n  ExtractStateType,\n  ExtractUpdateType,\n  isStateDefinitionInit,\n  isStateGraphInit,\n  StateGraphInit,\n  StateGraphOptions,\n  ToStateDefinition,\n  type StateDefinitionInit,\n} from \"./types.js\";\n\nconst ROOT = \"__root__\";\n\nexport type ChannelReducers<Channels extends object> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [K in keyof Channels]: SingleReducer<Channels[K], any>;\n};\n\nexport interface StateGraphArgs<Channels extends object | unknown> {\n  channels: Channels extends object\n    ? Channels extends unknown[]\n      ? ChannelReducers<{ __root__: Channels }>\n      : ChannelReducers<Channels>\n    : ChannelReducers<{ __root__: Channels }>;\n}\n\nexport type StateGraphNodeSpec<RunInput, RunOutput> = NodeSpec<\n  RunInput,\n  RunOutput\n> & {\n  input?: StateDefinition;\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy;\n};\n\n/**\n * Options for StateGraph.addNode() method.\n *\n * @template Nodes - Node name constraints\n * @template InputSchema - Per-node input schema type (inferred from options.input)\n */\nexport type StateGraphAddNodeOptions<\n  Nodes extends string = string,\n  InputSchema extends StateDefinitionInit | undefined =\n    | StateDefinitionInit\n    | undefined\n> = {\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy | boolean;\n  input?: InputSchema;\n} & AddNodeOptions<Nodes>;\n\nexport type StateGraphArgsWithStateSchema<\n  SD extends StateDefinition,\n  I extends StateDefinition,\n  O extends StateDefinition\n> = {\n  stateSchema: AnnotationRoot<SD>;\n  input?: AnnotationRoot<I>;\n  output?: AnnotationRoot<O>;\n};\n\nexport type StateGraphArgsWithInputOutputSchemas<\n  SD extends StateDefinition,\n  O extends StateDefinition = SD\n> = {\n  input: AnnotationRoot<SD>;\n  output: AnnotationRoot<O>;\n};\n\ntype ExtractStateDefinition<T> = T extends AnyStateSchema\n  ? T // Keep StateSchema as-is to preserve type information\n  : T extends StateDefinitionInit\n  ? ToStateDefinition<T>\n  : StateDefinition;\n\ntype NodeAction<\n  S,\n  U,\n  C extends StateDefinitionInit,\n  InterruptType,\n  WriterType\n> = RunnableLike<\n  S,\n  U extends object ? U & Record<string, any> : U, // eslint-disable-line @typescript-eslint/no-explicit-any\n  Runtime<StateType<ToStateDefinition<C>>, InterruptType, WriterType>\n>;\n\ntype StrictNodeAction<\n  S,\n  U,\n  C extends StateDefinitionInit,\n  Nodes extends string,\n  InterruptType,\n  WriterType\n> = RunnableLike<\n  Prettify<S>,\n  | U\n  | Command<\n      InferInterruptResumeType<InterruptType>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      U & Record<string, any>,\n      Nodes\n    >,\n  Runtime<StateType<ToStateDefinition<C>>, InterruptType, WriterType>\n>;\n\nconst PartialStateSchema = Symbol.for(\"langgraph.state.partial\");\ntype PartialStateSchema = typeof PartialStateSchema;\n\ntype MergeReturnType<Prev, Curr> = Prev & Curr extends infer T\n  ? { [K in keyof T]: T[K] } & unknown\n  : never;\n\ntype Prettify<T> = {\n  [K in keyof T]: T[K];\n  // eslint-disable-next-line @typescript-eslint/ban-types\n} & {};\n\n/**\n * A graph whose nodes communicate by reading and writing to a shared state.\n * Each node takes a defined `State` as input and returns a `Partial<State>`.\n *\n * Each state key can optionally be annotated with a reducer function that\n * will be used to aggregate the values of that key received from multiple nodes.\n * The signature of a reducer function is (left: Value, right: UpdateValue) => Value.\n *\n * See {@link Annotation} for more on defining state.\n *\n * After adding nodes and edges to your graph, you must call `.compile()` on it before\n * you can use it.\n *\n * @example\n * ```ts\n * import {\n *   type BaseMessage,\n *   AIMessage,\n *   HumanMessage,\n * } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const StateAnnotation = Annotation.Root({\n *   sentiment: Annotation<string>,\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(StateAnnotation);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof StateAnnotation.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *     sentiment: \"positive\",\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   .addEdge(\"__start__\", \"myNode\")\n *   .addEdge(\"myNode\", \"__end__\")\n *   .compile();\n *\n * await graph.invoke({ messages: [new HumanMessage(\"how are you?\")] });\n *\n * // {\n * //   messages: [HumanMessage(\"how are you?\"), AIMessage(\"Some new response\")],\n * //   sentiment: \"positive\",\n * // }\n * ```\n */\nexport class StateGraph<\n  SD extends StateDefinitionInit | unknown,\n  S = ExtractStateType<SD>,\n  U = ExtractUpdateType<SD, S>,\n  N extends string = typeof START,\n  I extends StateDefinitionInit = ExtractStateDefinition<SD>,\n  O extends StateDefinitionInit = ExtractStateDefinition<SD>,\n  C extends StateDefinitionInit = StateDefinition,\n  NodeReturnType = unknown,\n  InterruptType = unknown,\n  WriterType = unknown\n> extends Graph<N, S, U, StateGraphNodeSpec<S, U>, ToStateDefinition<C>> {\n  channels: Record<string, BaseChannel> = {};\n\n  // TODO: this doesn't dedupe edges as in py, so worth fixing at some point\n  waitingEdges: Set<[N[], N]> = new Set();\n\n  /** @internal */\n  _schemaDefinition: StateDefinition;\n\n  /** @internal */\n  _schemaRuntimeDefinition: InteropZodObject | AnyStateSchema | undefined;\n\n  /** @internal */\n  _inputDefinition: I;\n\n  /** @internal */\n  _inputRuntimeDefinition:\n    | InteropZodObject\n    | AnyStateSchema\n    | PartialStateSchema\n    | undefined;\n\n  /** @internal */\n  _outputDefinition: O;\n\n  /** @internal */\n  _outputRuntimeDefinition: InteropZodObject | AnyStateSchema | undefined;\n\n  /**\n   * Map schemas to managed values\n   * @internal\n   */\n  _schemaDefinitions = new Map();\n\n  /** @internal */\n  _metaRegistry: SchemaMetaRegistry = schemaMetaRegistry;\n\n  /** @internal Used only for typing. */\n  _configSchema: ToStateDefinition<C> | undefined;\n\n  /** @internal */\n  _configRuntimeSchema: InteropZodObject | undefined;\n\n  /** @internal */\n  _interrupt: InterruptType;\n\n  /** @internal */\n  _writer: WriterType;\n\n  declare Node: StrictNodeAction<S, U, C, N, InterruptType, WriterType>;\n\n  /**\n   * Create a new StateGraph for building stateful, multi-step workflows.\n   *\n   * Accepts state definitions via `Annotation.Root`, `StateSchema`, or Zod schemas.\n   *\n   * @example Direct schema\n   * ```ts\n   * const StateAnnotation = Annotation.Root({\n   *   messages: Annotation<string[]>({ reducer: (a, b) => [...a, ...b] }),\n   * });\n   * const graph = new StateGraph(StateAnnotation);\n   * ```\n   *\n   * @example Direct schema with input/output filtering\n   * ```ts\n   * const graph = new StateGraph(StateAnnotation, {\n   *   input: InputSchema,\n   *   output: OutputSchema,\n   * });\n   * ```\n   *\n   * @example Object pattern with state, input, output\n   * ```ts\n   * const graph = new StateGraph({\n   *   state: FullStateSchema,\n   *   input: InputSchema,\n   *   output: OutputSchema,\n   * });\n   * ```\n   *\n   * @example Input/output only (state inferred from input)\n   * ```ts\n   * const graph = new StateGraph({\n   *   input: InputAnnotation,\n   *   output: OutputAnnotation,\n   * });\n   * ```\n   */\n  constructor(\n    state: SD extends StateDefinitionInit ? SD : never,\n    options?:\n      | C\n      | AnnotationRoot<ToStateDefinition<C>>\n      | StateGraphOptions<I, O, C, N, InterruptType, WriterType>\n  );\n\n  constructor(\n    fields: SD extends StateDefinition\n      ? StateGraphArgsWithInputOutputSchemas<SD, ToStateDefinition<O>>\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    fields: SD extends StateDefinition\n      ?\n          | AnnotationRoot<SD>\n          | StateGraphArgsWithStateSchema<\n              SD,\n              ToStateDefinition<I>,\n              ToStateDefinition<O>\n            >\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    init: Omit<\n      StateGraphInit<\n        SD extends StateDefinitionInit ? SD : StateDefinitionInit,\n        SD extends StateDefinitionInit ? SD : StateDefinitionInit,\n        O,\n        C extends ContextSchemaInit ? C : undefined,\n        N,\n        InterruptType,\n        WriterType\n      >,\n      \"state\" | \"stateSchema\" | \"input\"\n    > & {\n      input: SD extends StateDefinitionInit ? SD : never;\n      state?: never;\n      stateSchema?: never;\n    },\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    init: StateGraphInit<\n      SD extends StateDefinitionInit ? SD : StateDefinitionInit,\n      I,\n      O,\n      C extends ContextSchemaInit ? C : undefined,\n      N,\n      InterruptType,\n      WriterType\n    >\n  );\n\n  /** @deprecated Use `Annotation.Root`, `StateSchema`, or Zod schemas instead. */\n  constructor(\n    fields: StateGraphArgs<S>,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    stateOrInit:\n      | StateDefinitionInit\n      | StateGraphInit<StateDefinitionInit, I, O>\n      | StateGraphArgs<S>,\n    options?:\n      | C\n      | AnnotationRoot<ToStateDefinition<C>>\n      | StateGraphOptions<\n          I,\n          O,\n          C extends ContextSchemaInit ? C : undefined,\n          N,\n          InterruptType,\n          WriterType\n        >\n  ) {\n    super();\n\n    // Normalize all input patterns to StateGraphInit format\n    const init = this._normalizeToStateGraphInit(stateOrInit, options);\n\n    // Resolve state schema: state > stateSchema (deprecated) > input\n    const stateSchema = init.state ?? init.stateSchema ?? init.input;\n    if (!stateSchema) {\n      throw new StateGraphInputError();\n    }\n\n    // Get channel definitions from the schema (may contain channel factories)\n    const stateChannelDef = this._getChannelsFromSchema(stateSchema);\n\n    // Set schema definitions (these may contain channel factories)\n    this._schemaDefinition = stateChannelDef;\n\n    // Set runtime definitions for validation\n    if (StateSchema.isInstance(stateSchema)) {\n      this._schemaRuntimeDefinition = stateSchema;\n    } else if (isInteropZodObject(stateSchema)) {\n      this._schemaRuntimeDefinition = stateSchema;\n    }\n\n    // Set input runtime definition\n    if (init.input) {\n      if (StateSchema.isInstance(init.input)) {\n        this._inputRuntimeDefinition = init.input;\n      } else if (isInteropZodObject(init.input)) {\n        this._inputRuntimeDefinition = init.input;\n      } else {\n        this._inputRuntimeDefinition = PartialStateSchema;\n      }\n    } else {\n      this._inputRuntimeDefinition = PartialStateSchema;\n    }\n\n    // Set output runtime definition\n    if (init.output) {\n      if (StateSchema.isInstance(init.output)) {\n        this._outputRuntimeDefinition = init.output;\n      } else if (isInteropZodObject(init.output)) {\n        this._outputRuntimeDefinition = init.output;\n      } else {\n        this._outputRuntimeDefinition = this._schemaRuntimeDefinition;\n      }\n    } else {\n      this._outputRuntimeDefinition = this._schemaRuntimeDefinition;\n    }\n\n    // Set input/output definitions (default to state)\n    const inputChannelDef = init.input\n      ? this._getChannelsFromSchema(init.input)\n      : stateChannelDef;\n    const outputChannelDef = init.output\n      ? (this._getChannelsFromSchema(init.output) as O)\n      : stateChannelDef;\n    this._inputDefinition = inputChannelDef as I;\n    this._outputDefinition = outputChannelDef as O;\n\n    // Add all schemas (_addSchema instantiates channel factories and populates this.channels)\n    this._addSchema(this._schemaDefinition);\n    this._addSchema(this._inputDefinition);\n    this._addSchema(this._outputDefinition);\n\n    // Handle context schema\n    if (init.context) {\n      if (isInteropZodObject(init.context)) {\n        this._configRuntimeSchema = init.context;\n      }\n    }\n\n    // Handle interrupt and writer\n    this._interrupt = init.interrupt as InterruptType;\n    this._writer = init.writer as WriterType;\n  }\n\n  /**\n   * Normalize all constructor input patterns to a unified StateGraphInit object.\n   * @internal\n   */\n  private _normalizeToStateGraphInit(\n    stateOrInit: unknown,\n    options?: unknown\n  ): StateGraphInit<StateDefinitionInit, I, O, C> {\n    // Check if already StateGraphInit format\n    if (isStateGraphInit(stateOrInit)) {\n      // Second arg can be either a direct context schema or an options object\n      if (isInteropZodObject(options) || AnnotationRoot.isInstance(options)) {\n        return {\n          ...stateOrInit,\n          context: options as C,\n        };\n      }\n      // Merge any 2nd arg options\n      const opts = options as StateGraphOptions<I, O> | undefined;\n      return {\n        ...stateOrInit,\n        input: stateOrInit.input ?? opts?.input,\n        output: stateOrInit.output ?? opts?.output,\n        context: stateOrInit.context ?? opts?.context,\n        interrupt: stateOrInit.interrupt ?? opts?.interrupt,\n        writer: stateOrInit.writer ?? opts?.writer,\n        nodes: stateOrInit.nodes ?? opts?.nodes,\n      } as StateGraphInit<StateDefinitionInit, I, O, C>;\n    }\n\n    // Check if direct schema (StateSchema, Zod, Annotation, StateDefinition)\n    if (isStateDefinitionInit(stateOrInit)) {\n      // Second arg can be either a direct context schema or an options object\n      if (isInteropZodObject(options) || AnnotationRoot.isInstance(options)) {\n        return {\n          state: stateOrInit,\n          context: options as C,\n        };\n      }\n      const opts = options as StateGraphOptions<I, O> | undefined;\n      return {\n        state: stateOrInit as StateDefinitionInit,\n        input: opts?.input as I,\n        output: opts?.output as O,\n        context: opts?.context,\n        interrupt: opts?.interrupt,\n        writer: opts?.writer,\n        nodes: opts?.nodes,\n      };\n    }\n\n    // Check for legacy { channels } format\n    if (isStateGraphArgs(stateOrInit as StateGraphArgs<S>)) {\n      const legacyArgs = stateOrInit as StateGraphArgs<S>;\n      const spec = _getChannels(legacyArgs.channels);\n      return {\n        state: spec as StateDefinitionInit,\n      };\n    }\n\n    throw new StateGraphInputError();\n  }\n\n  /**\n   * Convert any supported schema type to a StateDefinition (channel map).\n   * @internal\n   */\n  private _getChannelsFromSchema(schema: StateDefinitionInit): StateDefinition {\n    if (StateSchema.isInstance(schema)) {\n      return schema.getChannels();\n    }\n\n    if (isInteropZodObject(schema)) {\n      return this._metaRegistry.getChannelsForSchema(schema);\n    }\n\n    // AnnotationRoot - has .spec property that is the StateDefinition\n    if (\n      typeof schema === \"object\" &&\n      \"lc_graph_name\" in schema &&\n      (schema as { lc_graph_name: unknown }).lc_graph_name === \"AnnotationRoot\"\n    ) {\n      return (schema as AnnotationRoot<StateDefinition>).spec;\n    }\n\n    // StateDefinition (raw channel map) - return as-is\n    if (\n      typeof schema === \"object\" &&\n      !Array.isArray(schema) &&\n      Object.keys(schema).length > 0\n    ) {\n      return schema as StateDefinition;\n    }\n\n    throw new StateGraphInputError(\n      \"Invalid schema type. Expected StateSchema, Zod object, AnnotationRoot, or StateDefinition.\"\n    );\n  }\n\n  get allEdges(): Set<[string, string]> {\n    return new Set([\n      ...this.edges,\n      ...Array.from(this.waitingEdges).flatMap(([starts, end]) =>\n        starts.map((start) => [start, end] as [string, string])\n      ),\n    ]);\n  }\n\n  _addSchema(stateDefinition: StateDefinitionInit) {\n    if (this._schemaDefinitions.has(stateDefinition)) {\n      return;\n    }\n    // TODO: Support managed values\n    this._schemaDefinitions.set(stateDefinition, stateDefinition);\n    for (const [key, val] of Object.entries(stateDefinition)) {\n      let channel;\n      if (typeof val === \"function\") {\n        channel = val();\n      } else {\n        channel = val;\n      }\n      if (this.channels[key] !== undefined) {\n        if (!this.channels[key].equals(channel)) {\n          if (channel.lc_graph_name !== \"LastValue\") {\n            throw new Error(\n              `Channel \"${key}\" already exists with a different type.`\n            );\n          }\n        }\n      } else {\n        this.channels[key] = channel;\n      }\n    }\n  }\n\n  override addNode<\n    K extends string,\n    NodeMap extends Record<K, NodeAction<S, U, C, InterruptType, WriterType>>\n  >(\n    nodes: NodeMap\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<\n      NodeReturnType,\n      {\n        [key in keyof NodeMap]: NodeMap[key] extends NodeAction<\n          S,\n          infer U,\n          C,\n          InterruptType,\n          WriterType\n        >\n          ? U\n          : never;\n      }\n    >\n  >;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ][]\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<\n    K extends string,\n    InputSchema extends StateDefinitionInit,\n    NodeOutput extends U = U\n  >(\n    key: K,\n    action: NodeAction<\n      ExtractStateType<InputSchema>,\n      NodeOutput,\n      C,\n      InterruptType,\n      WriterType\n    >,\n    options: StateGraphAddNodeOptions<N | K, InputSchema>\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<\n    K extends string,\n    InputSchema extends StateDefinitionInit,\n    NodeOutput extends U = U\n  >(\n    key: K,\n    action: NodeAction<\n      ExtractStateType<InputSchema>,\n      NodeOutput,\n      C,\n      InterruptType,\n      WriterType\n    >,\n    options: StateGraphAddNodeOptions<N | K, InputSchema>\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    key: K,\n    action: NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>,\n    options?: StateGraphAddNodeOptions\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<K extends string, NodeInput = S>(\n    key: K,\n    action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n    options?: StateGraphAddNodeOptions\n  ): StateGraph<SD, S, U, N | K, I, O, C, NodeReturnType>;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    ...args:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ]\n      | [\n          nodes:\n            | Record<K, NodeAction<NodeInput, U, C, InterruptType, WriterType>>\n            | [\n                key: K,\n                action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n                options?: StateGraphAddNodeOptions\n              ][]\n        ]\n  ): StateGraph<SD, S, U, N | K, I, O, C> {\n    function isMultipleNodes(\n      args: unknown[]\n    ): args is [\n      nodes:\n        | Record<K, NodeAction<NodeInput, U, C, InterruptType, WriterType>>\n        | [\n            key: K,\n            action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n            options?: AddNodeOptions\n          ][]\n    ] {\n      return args.length >= 1 && typeof args[0] !== \"string\";\n    }\n\n    const nodes = (\n      isMultipleNodes(args) // eslint-disable-line no-nested-ternary\n        ? Array.isArray(args[0])\n          ? args[0]\n          : Object.entries(args[0]).map(([key, action]) => [key, action])\n        : [[args[0], args[1], args[2]]]\n    ) as [\n      K,\n      NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n      StateGraphAddNodeOptions | undefined\n    ][];\n\n    if (nodes.length === 0) {\n      throw new Error(\"No nodes provided in `addNode`\");\n    }\n\n    for (const [key, action, options] of nodes) {\n      if (key in this.channels) {\n        throw new Error(\n          `${key} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`\n        );\n      }\n\n      for (const reservedChar of [\n        CHECKPOINT_NAMESPACE_SEPARATOR,\n        CHECKPOINT_NAMESPACE_END,\n      ]) {\n        if (key.includes(reservedChar)) {\n          throw new Error(\n            `\"${reservedChar}\" is a reserved character and is not allowed in node names.`\n          );\n        }\n      }\n      this.warnIfCompiled(\n        `Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n      );\n\n      if (key in this.nodes) {\n        throw new Error(`Node \\`${key}\\` already present.`);\n      }\n      if (key === END || key === START) {\n        throw new Error(`Node \\`${key}\\` is reserved.`);\n      }\n\n      let inputSpec: StateDefinition = this._schemaDefinition;\n      if (options?.input !== undefined) {\n        inputSpec = this._getChannelsFromSchema(options.input);\n      }\n      this._addSchema(inputSpec);\n\n      let runnable;\n      if (Runnable.isRunnable(action)) {\n        runnable = action;\n      } else if (typeof action === \"function\") {\n        runnable = new RunnableCallable({\n          func: action,\n          name: key,\n          trace: false,\n        });\n      } else {\n        runnable = _coerceToRunnable(action);\n      }\n\n      let cachePolicy = options?.cachePolicy;\n      if (typeof cachePolicy === \"boolean\") {\n        cachePolicy = cachePolicy ? {} : undefined;\n      }\n\n      const nodeSpec: StateGraphNodeSpec<S, U> = {\n        runnable: runnable as unknown as Runnable<S, U>,\n        retryPolicy: options?.retryPolicy,\n        cachePolicy,\n        metadata: options?.metadata,\n        input: inputSpec ?? this._schemaDefinition,\n        subgraphs: isPregelLike(runnable)\n          ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            [runnable as any]\n          : options?.subgraphs,\n        ends: options?.ends,\n        defer: options?.defer,\n      };\n\n      this.nodes[key as unknown as N] = nodeSpec;\n    }\n\n    return this as StateGraph<SD, S, U, N | K, I, O, C>;\n  }\n\n  override addEdge(\n    startKey: typeof START | N | N[],\n    endKey: N | typeof END\n  ): this {\n    if (typeof startKey === \"string\") {\n      return super.addEdge(startKey, endKey);\n    }\n\n    if (this.compiled) {\n      console.warn(\n        \"Adding an edge to a graph that has already been compiled. This will \" +\n          \"not be reflected in the compiled graph.\"\n      );\n    }\n\n    for (const start of startKey) {\n      if (start === END) {\n        throw new Error(\"END cannot be a start node\");\n      }\n      if (!Object.keys(this.nodes).some((node) => node === start)) {\n        throw new Error(`Need to add a node named \"${start}\" first`);\n      }\n    }\n    if (endKey === END) {\n      throw new Error(\"END cannot be an end node\");\n    }\n    if (!Object.keys(this.nodes).some((node) => node === endKey)) {\n      throw new Error(`Need to add a node named \"${endKey}\" first`);\n    }\n\n    this.waitingEdges.add([startKey, endKey]);\n\n    return this;\n  }\n\n  addSequence<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes: [\n      key: K,\n      action: NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>,\n      options?: StateGraphAddNodeOptions\n    ][]\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  addSequence<\n    K extends string,\n    NodeMap extends Record<K, NodeAction<S, U, C, InterruptType, WriterType>>\n  >(\n    nodes: NodeMap\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<\n      NodeReturnType,\n      {\n        [key in keyof NodeMap]: NodeMap[key] extends NodeAction<\n          S,\n          infer U,\n          C,\n          InterruptType,\n          WriterType\n        >\n          ? U\n          : never;\n      }\n    >\n  >;\n\n  addSequence<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ][]\n      | Record<\n          K,\n          NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>\n        >\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  > {\n    const parsedNodes = Array.isArray(nodes) ? nodes : Object.entries(nodes);\n\n    if (parsedNodes.length === 0) {\n      throw new Error(\"Sequence requires at least one node.\");\n    }\n\n    let previousNode: N | undefined;\n    for (const [key, action, options] of parsedNodes) {\n      if (key in this.nodes) {\n        throw new Error(\n          `Node names must be unique: node with the name \"${key}\" already exists.`\n        );\n      }\n\n      const validKey = key as unknown as N;\n      this.addNode(\n        validKey,\n        action as NodeAction<S, U, C, InterruptType, WriterType>,\n        options\n      );\n      if (previousNode != null) {\n        this.addEdge(previousNode, validKey);\n      }\n\n      previousNode = validKey;\n    }\n\n    return this as StateGraph<\n      SD,\n      S,\n      U,\n      N | K,\n      I,\n      O,\n      C,\n      MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n    >;\n  }\n\n  override compile({\n    checkpointer,\n    store,\n    cache,\n    interruptBefore,\n    interruptAfter,\n    name,\n    description,\n  }: {\n    checkpointer?: BaseCheckpointSaver | boolean;\n    store?: BaseStore;\n    cache?: BaseCache;\n    interruptBefore?: N[] | All;\n    interruptAfter?: N[] | All;\n    name?: string;\n    description?: string;\n  } = {}): CompiledStateGraph<\n    Prettify<S>,\n    Prettify<U>,\n    N,\n    I,\n    O,\n    C,\n    NodeReturnType,\n    InterruptType,\n    WriterType\n  > {\n    // validate the graph\n    this.validate([\n      ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n      ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n    ]);\n\n    // prepare output channels\n    const outputKeys = Object.keys(\n      this._schemaDefinitions.get(this._outputDefinition)\n    );\n    const outputChannels =\n      outputKeys.length === 1 && outputKeys[0] === ROOT ? ROOT : outputKeys;\n\n    const streamKeys = Object.keys(this.channels);\n    const streamChannels =\n      streamKeys.length === 1 && streamKeys[0] === ROOT ? ROOT : streamKeys;\n\n    const userInterrupt = this._interrupt;\n    // create empty compiled graph\n    const compiled = new CompiledStateGraph<\n      S,\n      U,\n      N,\n      I,\n      O,\n      C,\n      NodeReturnType,\n      InterruptType,\n      WriterType\n    >({\n      builder: this,\n      checkpointer,\n      interruptAfter,\n      interruptBefore,\n      autoValidate: false,\n      nodes: {} as Record<N | typeof START, PregelNode<S, U>>,\n      channels: {\n        ...this.channels,\n        [START]: new EphemeralValue(),\n      } as Record<N | typeof START | typeof END | string, BaseChannel>,\n      inputChannels: START,\n      outputChannels,\n      streamChannels,\n      streamMode: \"updates\",\n      store,\n      cache,\n      name,\n      description,\n      userInterrupt,\n    });\n\n    // attach nodes, edges and branches\n    compiled.attachNode(START);\n    for (const [key, node] of Object.entries<StateGraphNodeSpec<S, U>>(\n      this.nodes\n    )) {\n      compiled.attachNode(key as N, node);\n    }\n    compiled.attachBranch(START, SELF, _getControlBranch() as Branch<S, N>, {\n      withReader: false,\n    });\n    for (const [key] of Object.entries<StateGraphNodeSpec<S, U>>(this.nodes)) {\n      compiled.attachBranch(\n        key as N,\n        SELF,\n        _getControlBranch() as Branch<S, N>,\n        {\n          withReader: false,\n        }\n      );\n    }\n    for (const [start, end] of this.edges) {\n      compiled.attachEdge(start, end);\n    }\n    for (const [starts, end] of this.waitingEdges) {\n      compiled.attachEdge(starts, end);\n    }\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const [name, branch] of Object.entries(branches)) {\n        compiled.attachBranch(start as N, name, branch);\n      }\n    }\n\n    return compiled.validate();\n  }\n}\n\nfunction _getChannels<Channels extends Record<string, unknown> | unknown>(\n  schema: StateGraphArgs<Channels>[\"channels\"]\n): Record<string, BaseChannel> {\n  const channels: Record<string, BaseChannel> = {};\n  for (const [name, val] of Object.entries(schema)) {\n    if (name === ROOT) {\n      channels[name] = getChannel<Channels>(val as SingleReducer<Channels>);\n    } else {\n      const key = name as keyof Channels;\n      channels[name] = getChannel<Channels[typeof key]>(\n        val as SingleReducer<Channels[typeof key]>\n      );\n    }\n  }\n  return channels;\n}\n\n/**\n * Final result from building and compiling a {@link StateGraph}.\n * Should not be instantiated directly, only using the StateGraph `.compile()`\n * instance method.\n */\nexport class CompiledStateGraph<\n  S,\n  U,\n  N extends string = typeof START,\n  I extends StateDefinitionInit = StateDefinition,\n  O extends StateDefinitionInit = StateDefinition,\n  C extends StateDefinitionInit = StateDefinition,\n  NodeReturnType = unknown,\n  InterruptType = unknown,\n  WriterType = unknown\n> extends CompiledGraph<\n  N,\n  S,\n  U,\n  ExtractStateType<C>,\n  ExtractUpdateType<I, ExtractStateType<I>>,\n  ExtractStateType<O>,\n  NodeReturnType,\n  CommandInstance<InferInterruptResumeType<InterruptType>, Prettify<U>, N>,\n  InferWriterType<WriterType>\n> {\n  declare builder: StateGraph<unknown, S, U, N, I, O, C, NodeReturnType>;\n\n  /**\n   * The description of the compiled graph.\n   * This is used by the supervisor agent to describe the handoff to the agent.\n   */\n  description?: string;\n\n  /** @internal */\n  _metaRegistry: SchemaMetaRegistry = schemaMetaRegistry;\n\n  constructor({\n    description,\n    ...rest\n  }: { description?: string } & ConstructorParameters<\n    typeof CompiledGraph<\n      N,\n      S,\n      U,\n      ExtractStateType<C>,\n      ExtractUpdateType<I, ExtractStateType<I>>,\n      ExtractStateType<O>,\n      NodeReturnType,\n      CommandInstance<InferInterruptResumeType<InterruptType>, Prettify<U>, N>,\n      InferWriterType<WriterType>\n    >\n  >[0]) {\n    super(rest);\n    this.description = description;\n  }\n\n  attachNode(key: typeof START, node?: never): void;\n\n  attachNode(key: N, node: StateGraphNodeSpec<S, U>): void;\n\n  attachNode(key: N | typeof START, node?: StateGraphNodeSpec<S, U>): void {\n    let outputKeys: string[];\n    if (key === START) {\n      // Get input schema keys excluding managed values\n      outputKeys = Object.entries(\n        this.builder._schemaDefinitions.get(this.builder._inputDefinition)\n      ).map(([k]) => k);\n    } else {\n      outputKeys = Object.keys(this.builder.channels);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _getRoot(input: unknown): [string, any][] | null {\n      if (isCommand(input)) {\n        if (input.graph === Command.PARENT) {\n          return null;\n        }\n        return input._updateAsTuples();\n      } else if (\n        Array.isArray(input) &&\n        input.length > 0 &&\n        input.some((i) => isCommand(i))\n      ) {\n        const updates: [string, unknown][] = [];\n        for (const i of input) {\n          if (isCommand(i)) {\n            if (i.graph === Command.PARENT) {\n              continue;\n            }\n            updates.push(...i._updateAsTuples());\n          } else {\n            updates.push([ROOT, i]);\n          }\n        }\n        return updates;\n      } else if (input != null) {\n        return [[ROOT, input]];\n      }\n      return null;\n    }\n\n    // to avoid name collision below\n    const nodeKey = key;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _getUpdates(input: U): [string, any][] | null {\n      if (!input) {\n        return null;\n      } else if (isCommand(input)) {\n        if (input.graph === Command.PARENT) {\n          return null;\n        }\n        return input._updateAsTuples().filter(([k]) => outputKeys.includes(k));\n      } else if (\n        Array.isArray(input) &&\n        input.length > 0 &&\n        input.some(isCommand)\n      ) {\n        const updates: [string, unknown][] = [];\n        for (const item of input) {\n          if (isCommand(item)) {\n            if (item.graph === Command.PARENT) {\n              continue;\n            }\n            updates.push(\n              ...item._updateAsTuples().filter(([k]) => outputKeys.includes(k))\n            );\n          } else {\n            const itemUpdates = _getUpdates(item);\n            if (itemUpdates) {\n              updates.push(...(itemUpdates ?? []));\n            }\n          }\n        }\n        return updates;\n      } else if (typeof input === \"object\" && !Array.isArray(input)) {\n        return Object.entries(input).filter(([k]) => outputKeys.includes(k));\n      } else {\n        const typeofInput = Array.isArray(input) ? \"array\" : typeof input;\n        throw new InvalidUpdateError(\n          `Expected node \"${nodeKey.toString()}\" to return an object or an array containing at least one Command object, received ${typeofInput}`,\n          {\n            lc_error_code: \"INVALID_GRAPH_NODE_RETURN_VALUE\",\n          }\n        );\n      }\n    }\n\n    const stateWriteEntries: (ChannelWriteTupleEntry | ChannelWriteEntry)[] = [\n      {\n        value: PASSTHROUGH,\n        mapper: new RunnableCallable({\n          func:\n            outputKeys.length && outputKeys[0] === ROOT\n              ? _getRoot\n              : _getUpdates,\n          trace: false,\n          recurse: false,\n        }),\n      },\n    ];\n\n    // add node and output channel\n    if (key === START) {\n      this.nodes[key] = new PregelNode<S, U>({\n        tags: [TAG_HIDDEN],\n        triggers: [START],\n        channels: [START],\n        writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])],\n      });\n    } else {\n      const inputDefinition = node?.input ?? this.builder._schemaDefinition;\n      const inputValues = Object.fromEntries(\n        Object.keys(this.builder._schemaDefinitions.get(inputDefinition)).map(\n          (k) => [k, k]\n        )\n      );\n      const isSingleInput =\n        Object.keys(inputValues).length === 1 && ROOT in inputValues;\n      const branchChannel = `branch:to:${key}` as string | N;\n      this.channels[branchChannel] = node?.defer\n        ? new LastValueAfterFinish()\n        : new EphemeralValue(false);\n      this.nodes[key] = new PregelNode<S, U>({\n        triggers: [branchChannel],\n        // read state keys\n        channels: isSingleInput ? Object.keys(inputValues) : inputValues,\n        // publish to state keys\n        writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])],\n        mapper: isSingleInput\n          ? undefined\n          : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (input: Record<string, any>) => {\n              return Object.fromEntries(\n                Object.entries(input).filter(([k]) => k in inputValues)\n              );\n            },\n        bound: node?.runnable,\n        metadata: node?.metadata,\n        retryPolicy: node?.retryPolicy,\n        cachePolicy: node?.cachePolicy,\n        subgraphs: node?.subgraphs,\n        ends: node?.ends,\n      });\n    }\n  }\n\n  attachEdge(starts: N | N[] | \"__start__\", end: N | \"__end__\"): void {\n    if (end === END) return;\n    if (typeof starts === \"string\") {\n      this.nodes[starts].writers.push(\n        new ChannelWrite(\n          [{ channel: `branch:to:${end}`, value: null }],\n          [TAG_HIDDEN]\n        )\n      );\n    } else if (Array.isArray(starts)) {\n      const channelName = `join:${starts.join(\"+\")}:${end}`;\n      // register channel\n      this.channels[channelName as string | N] = this.builder.nodes[end].defer\n        ? new NamedBarrierValueAfterFinish(new Set(starts))\n        : new NamedBarrierValue(new Set(starts));\n      // subscribe to channel\n      this.nodes[end].triggers.push(channelName);\n      // publish to channel\n      for (const start of starts) {\n        this.nodes[start].writers.push(\n          new ChannelWrite(\n            [{ channel: channelName, value: start }],\n            [TAG_HIDDEN]\n          )\n        );\n      }\n    }\n  }\n\n  attachBranch(\n    start: N | typeof START,\n    _: string,\n    branch: Branch<S, N>,\n    options: { withReader?: boolean } = { withReader: true }\n  ): void {\n    const branchWriter = async (\n      packets: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => {\n      const filteredPackets = packets.filter((p) => p !== END);\n      if (!filteredPackets.length) return;\n\n      const writes: (ChannelWriteEntry | Send)[] = filteredPackets.map((p) => {\n        if (_isSend(p)) return p;\n        return { channel: p === END ? p : `branch:to:${p}`, value: start };\n      });\n      await ChannelWrite.doWrite(\n        { ...config, tags: (config.tags ?? []).concat([TAG_HIDDEN]) },\n        writes\n      );\n    };\n    // attach branch publisher\n    this.nodes[start].writers.push(\n      branch.run(\n        branchWriter,\n        // reader\n        options.withReader\n          ? (config) =>\n              ChannelRead.doRead<S>(\n                config,\n                this.streamChannels ?? this.outputChannels,\n                true\n              )\n          : undefined\n      )\n    );\n  }\n\n  protected async _validateInput(\n    input: ExtractUpdateType<I, ExtractStateType<I>>\n  ): Promise<ExtractUpdateType<I, ExtractStateType<I>>> {\n    if (input == null) return input;\n\n    const inputDef = this.builder._inputRuntimeDefinition;\n    const schemaDef = this.builder._schemaRuntimeDefinition;\n\n    // Determine which schema to use for validation\n    // Priority: inputDef (if it's a validatable schema), otherwise fall back to schemaDef\n\n    // Handle StateSchema validation for input schema\n    if (StateSchema.isInstance(inputDef)) {\n      if (isCommand(input)) {\n        const parsedInput = input;\n        if (input.update) {\n          parsedInput.update = await inputDef.validateInput(\n            Array.isArray(input.update)\n              ? Object.fromEntries(input.update)\n              : input.update\n          );\n        }\n        return parsedInput;\n      }\n      return await inputDef.validateInput(input);\n    }\n\n    // Handle StateSchema validation for state schema (when input is partial state)\n    if (inputDef === PartialStateSchema && StateSchema.isInstance(schemaDef)) {\n      if (isCommand(input)) {\n        const parsedInput = input;\n        if (input.update) {\n          parsedInput.update = await schemaDef.validateInput(\n            Array.isArray(input.update)\n              ? Object.fromEntries(input.update)\n              : input.update\n          );\n        }\n        return parsedInput;\n      }\n      return await schemaDef.validateInput(input);\n    }\n\n    // Handle InteropZodObject validation\n    const schema = (() => {\n      const apply = (schema: InteropZodObject | undefined) => {\n        if (schema == null) return undefined;\n        return this._metaRegistry.getExtendedChannelSchemas(schema, {\n          withReducerSchema: true,\n        });\n      };\n\n      if (isInteropZodObject(inputDef)) return apply(inputDef);\n      if (inputDef === PartialStateSchema) {\n        if (isInteropZodObject(schemaDef)) {\n          return interopZodObjectPartial(apply(schemaDef)!);\n        }\n        return undefined;\n      }\n      return undefined;\n    })();\n\n    if (isCommand(input)) {\n      const parsedInput = input;\n      if (input.update && schema != null)\n        parsedInput.update = interopParse(schema, input.update);\n      return parsedInput;\n    }\n    if (schema != null) return interopParse(schema, input);\n    return input;\n  }\n\n  public isInterrupted(input: unknown): input is {\n    [INTERRUPT]: Interrupt<InferInterruptInputType<InterruptType>>[];\n  } {\n    return isInterrupted(input);\n  }\n\n  protected async _validateContext(\n    config: Partial<Record<string, unknown>>\n  ): Promise<Partial<Record<string, unknown>>> {\n    const configSchema = this.builder._configRuntimeSchema;\n    if (isInteropZodObject(configSchema)) interopParse(configSchema, config);\n    return config;\n  }\n}\n\n/**\n * Check if value is a legacy StateGraphArgs with channels.\n * @internal\n * @deprecated Use StateGraphInit instead\n */\nfunction isStateGraphArgs<Channels extends object | unknown>(\n  obj: unknown | StateGraphArgs<Channels>\n): obj is StateGraphArgs<Channels> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    (obj as StateGraphArgs<Channels>).channels !== undefined\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _controlBranch(value: any): (string | Send)[] {\n  if (_isSend(value)) {\n    return [value];\n  }\n  const commands = [];\n  if (isCommand(value)) {\n    commands.push(value);\n  } else if (Array.isArray(value)) {\n    commands.push(...value.filter(isCommand));\n  }\n  const destinations: (string | Send)[] = [];\n\n  for (const command of commands) {\n    if (command.graph === Command.PARENT) {\n      throw new ParentCommand(command);\n    }\n\n    if (_isSend(command.goto)) {\n      destinations.push(command.goto);\n    } else if (typeof command.goto === \"string\") {\n      destinations.push(command.goto);\n    } else {\n      if (Array.isArray(command.goto)) {\n        destinations.push(...command.goto);\n      }\n    }\n  }\n  return destinations;\n}\n\nfunction _getControlBranch() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const CONTROL_BRANCH_PATH = new RunnableCallable<any, (string | Send)[]>({\n    func: _controlBranch,\n    tags: [TAG_HIDDEN],\n    trace: false,\n    recurse: false,\n    name: \"<control_branch>\",\n  });\n  return new Branch({\n    path: CONTROL_BRANCH_PATH,\n  });\n}\n", "import {\n  BaseCache,\n  BaseCheckpointSaver,\n  BaseStore,\n} from \"@langchain/langgraph-checkpoint\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { Pregel } from \"../pregel/index.js\";\nimport { PregelNode } from \"../pregel/read.js\";\nimport {\n  CONFIG_KEY_PREVIOUS_STATE,\n  END,\n  PREVIOUS,\n  START,\n  TAG_HIDDEN,\n} from \"../constants.js\";\nimport { EphemeralValue } from \"../channels/ephemeral_value.js\";\nimport { call, getRunnableForEntrypoint } from \"../pregel/call.js\";\nimport type { CachePolicy, RetryPolicy } from \"../pregel/utils/index.js\";\nimport { LastValue } from \"../channels/last_value.js\";\nimport {\n  EntrypointFinal,\n  EntrypointReturnT,\n  EntrypointFinalSaveT,\n  EntrypointFunc,\n  TaskFunc,\n} from \"./types.js\";\nimport { LangGraphRunnableConfig } from \"../pregel/runnable_types.js\";\nimport {\n  RunnableCallable,\n  isAsyncGeneratorFunction,\n  isGeneratorFunction,\n} from \"../utils.js\";\nimport { ChannelWrite, PASSTHROUGH } from \"../pregel/write.js\";\n\n/**\n * Options for the {@link task} function\n */\nexport interface TaskOptions {\n  /**\n   * The name of the task, analogous to the node name in {@link StateGraph}.\n   */\n  name: string;\n  /**\n   * The retry policy for the task. Configures how many times and under what conditions\n   * the task should be retried if it fails.\n   */\n  retry?: RetryPolicy;\n\n  /**\n   * The cache policy for the task. Configures how the task should be cached.\n   */\n  cachePolicy?: CachePolicy;\n}\n\n/**\n * Define a LangGraph task using the `task` function.\n *\n * Tasks can only be called from within an {@link entrypoint} or from within a StateGraph.\n * A task can be called like a regular function with the following differences:\n *\n * - When a checkpointer is enabled, the function inputs and outputs must be serializable.\n * - The wrapped function can only be called from within an entrypoint or StateGraph.\n * - Calling the function produces a promise. This makes it easy to parallelize tasks.\n *\n * @typeParam ArgsT - The type of arguments the task function accepts\n * @typeParam OutputT - The type of value the task function returns\n * @param optionsOrName - Either an {@link TaskOptions} object, or a string for the name of the task\n * @param func - The function that executes this task\n * @returns A proxy function that accepts the same arguments as the original and always returns the result as a Promise\n *\n * @example basic example\n * ```typescript\n * const addOne = task(\"add\", async (a: number) => a + 1);\n *\n * const workflow = entrypoint(\"example\", async (numbers: number[]) => {\n *   const promises = numbers.map(n => addOne(n));\n *   const results = await Promise.all(promises);\n *   return results;\n * });\n *\n * // Call the entrypoint\n * await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @example using a retry policy\n * ```typescript\n * const addOne = task({\n *     name: \"add\",\n *     retry: { maxAttempts: 3 }\n *   },\n *   async (a: number) => a + 1\n * );\n *\n * const workflow = entrypoint(\"example\", async (numbers: number[]) => {\n *   const promises = numbers.map(n => addOne(n));\n *   const results = await Promise.all(promises);\n *   return results;\n * });\n * ```\n * @category Functional API\n */\nexport function task<ArgsT extends unknown[], OutputT>(\n  optionsOrName: TaskOptions | string,\n  func: TaskFunc<ArgsT, OutputT>\n): (...args: ArgsT) => Promise<OutputT> {\n  const options =\n    typeof optionsOrName === \"string\"\n      ? { name: optionsOrName, retry: undefined, cachePolicy: undefined }\n      : optionsOrName;\n\n  const { name, retry } = options;\n  if (isAsyncGeneratorFunction(func) || isGeneratorFunction(func)) {\n    throw new Error(\n      \"Generators are disallowed as tasks. For streaming responses, use config.write.\"\n    );\n  }\n\n  const cachePolicy =\n    options.cachePolicy ??\n    // `cache` was mistakingly used as an alias for `cachePolicy` in v0.3.x,\n    // TODO: remove in 1.x\n    (\"cache\" in options ? (options.cache as CachePolicy) : undefined);\n\n  let cache: CachePolicy | undefined;\n  if (typeof cachePolicy === \"boolean\") {\n    cache = cachePolicy ? {} : undefined;\n  } else {\n    cache = cachePolicy;\n  }\n\n  return (...args: ArgsT) => {\n    return call({ func, name, retry, cache }, ...args);\n  };\n}\n\n/**\n * Options for the {@link entrypoint} function\n */\nexport type EntrypointOptions = {\n  /**\n   * The name of the {@link entrypoint}, analogous to the node name in {@link StateGraph}.\n   * This name is used for logging, debugging, and checkpoint identification.\n   */\n  name: string;\n  /**\n   * The checkpointer for the {@link entrypoint}. Used to save and restore state between\n   * invocations of the workflow.\n   */\n  checkpointer?: BaseCheckpointSaver;\n  /**\n   * The store for the {@link entrypoint}. Used to persist data across workflow runs.\n   */\n  store?: BaseStore;\n\n  /**\n   * The cache for the {@link entrypoint}. Used to cache values between workflow runs.\n   */\n  cache?: BaseCache;\n};\n\n/**\n * Type declaration for the entrypoint function with its properties\n * @category Functional API\n */\nexport interface EntrypointFunction {\n  <InputT, OutputT>(\n    optionsOrName: EntrypointOptions | string,\n    func: EntrypointFunc<InputT, OutputT>\n  ): Pregel<\n    Record<string, PregelNode<InputT, EntrypointReturnT<OutputT>>>,\n    {\n      [START]: EphemeralValue<InputT>;\n      [END]: LastValue<EntrypointReturnT<OutputT>>;\n      [PREVIOUS]: LastValue<EntrypointFinalSaveT<OutputT>>;\n    },\n    Record<string, unknown>,\n    InputT,\n    EntrypointReturnT<OutputT>,\n    // Because the update type is an return type union of tasks + entrypoint,\n    // thus we can't type it properly.\n    any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    Awaited<EntrypointReturnT<OutputT>>\n  >;\n\n  /**\n   * A helper utility for use with the functional API that returns a value to the caller,\n   * as well as a separate state value to persist to the checkpoint. This allows workflows\n   * to maintain state between runs while returning different values to the caller.\n   *\n   * @typeParam ValueT - The type of the value to return to the caller\n   * @typeParam SaveT - The type of the state to save to the checkpoint\n   * @param options.value - The value to return to the caller\n   * @param options.save - The value to save to the checkpoint\n   * @returns An object with the value and save properties\n   *\n   * @example\n   * ```typescript\n   * return entrypoint.final({\n   *   value: \"result for caller\",\n   *   save: { counter: currentCount + 1 }\n   * });\n   * ```\n   */\n  final<ValueT, SaveT>(options: {\n    value?: ValueT;\n    save?: SaveT;\n  }): EntrypointFinal<ValueT, SaveT>;\n}\n\n/**\n * Define a LangGraph workflow using the `entrypoint` function.\n *\n * ### Function signature\n *\n * The wrapped function must accept at most **two parameters**. The first parameter\n * is the input to the function. The second (optional) parameter is a\n * {@link LangGraphRunnableConfig} object. If you wish to pass multiple parameters to\n * the function, you can pass them as an object.\n *\n * ### Helper functions\n *\n * #### Streaming\n * To write data to the \"custom\" stream, use the {@link getWriter} function, or the\n * {@link LangGraphRunnableConfig.writer} property.\n *\n * #### State management\n * The {@link getPreviousState} function can be used to access the previous state\n * that was returned from the last invocation of the entrypoint on the same thread id.\n *\n * If you wish to save state other than the return value, you can use the\n * {@link entrypoint.final} function.\n *\n * @typeParam InputT - The type of input the entrypoint accepts\n * @typeParam OutputT - The type of output the entrypoint produces\n * @param optionsOrName - Either an {@link EntrypointOptions} object, or a string for the name of the entrypoint\n * @param func - The function that executes this entrypoint\n * @returns A {@link Pregel} instance that can be run to execute the workflow\n *\n * @example Using entrypoint and tasks\n * ```typescript\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n * import { interrupt, Command } from \"@langchain/langgraph\";\n *\n * const composeEssay = task(\"compose\", async (topic: string) => {\n *   await new Promise(r => setTimeout(r, 1000)); // Simulate slow operation\n *   return `An essay about ${topic}`;\n * });\n *\n * const reviewWorkflow = entrypoint({\n *   name: \"review\",\n *   checkpointer: new MemorySaver()\n * }, async (topic: string) => {\n *   const essay = await composeEssay(topic);\n *   const humanReview = await interrupt({\n *     question: \"Please provide a review\",\n *     essay\n *   });\n *   return {\n *     essay,\n *     review: humanReview\n *   };\n * });\n *\n * // Example configuration for the workflow\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n *\n * // Topic for the essay\n * const topic = \"cats\";\n *\n * // Stream the workflow to generate the essay and await human review\n * for await (const result of reviewWorkflow.stream(topic, config)) {\n *   console.log(result);\n * }\n *\n * // Example human review provided after the interrupt\n * const humanReview = \"This essay is great.\";\n *\n * // Resume the workflow with the provided human review\n * for await (const result of reviewWorkflow.stream(new Command({ resume: humanReview }), config)) {\n *   console.log(result);\n * }\n * ```\n *\n * @example Accessing the previous return value\n * ```typescript\n * import { entrypoint, getPreviousState } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * const accumulator = entrypoint({\n *   name: \"accumulator\",\n *   checkpointer: new MemorySaver()\n * }, async (input: string) => {\n *   const previous = getPreviousState<number>();\n *   return previous !== undefined ? `${previous } ${input}` : input;\n * });\n *\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n * await accumulator.invoke(\"hello\", config); // returns \"hello\"\n * await accumulator.invoke(\"world\", config); // returns \"hello world\"\n * ```\n *\n * @example Using entrypoint.final to save a value\n * ```typescript\n * import { entrypoint, getPreviousState } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * const myWorkflow = entrypoint({\n *   name: \"accumulator\",\n *   checkpointer: new MemorySaver()\n * }, async (num: number) => {\n *   const previous = getPreviousState<number>();\n *\n *   // This will return the previous value to the caller, saving\n *   // 2 * num to the checkpoint, which will be used in the next invocation\n *   // for the `previous` parameter.\n *   return entrypoint.final({\n *     value: previous ?? 0,\n *     save: 2 * num\n *   });\n * });\n *\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n *\n * await myWorkflow.invoke(3, config); // 0 (previous was undefined)\n * await myWorkflow.invoke(1, config); // 6 (previous was 3 * 2 from the previous invocation)\n * ```\n * @category Functional API\n */\nexport const entrypoint = function entrypoint<InputT, OutputT>(\n  optionsOrName: EntrypointOptions | string,\n  func: EntrypointFunc<InputT, OutputT>\n) {\n  const { name, checkpointer, store, cache } =\n    typeof optionsOrName === \"string\"\n      ? { name: optionsOrName, checkpointer: undefined, store: undefined }\n      : optionsOrName;\n  if (isAsyncGeneratorFunction(func) || isGeneratorFunction(func)) {\n    throw new Error(\n      \"Generators are disallowed as entrypoints. For streaming responses, use config.write.\"\n    );\n  }\n  const streamMode = \"updates\";\n  const bound = getRunnableForEntrypoint(name, func);\n\n  // Helper to check if a value is an EntrypointFinal\n  function isEntrypointFinal(\n    value: unknown\n  ): value is EntrypointFinal<unknown, unknown> {\n    return (\n      typeof value === \"object\" &&\n      value !== null &&\n      \"__lg_type\" in value &&\n      value.__lg_type === \"__pregel_final\"\n    );\n  }\n\n  // Helper function to pluck the return value from EntrypointFinal or passthrough\n  const pluckReturnValue = new RunnableCallable({\n    name: \"pluckReturnValue\",\n    func: (value: unknown) => {\n      return isEntrypointFinal(value) ? value.value : value;\n    },\n  });\n\n  // Helper function to pluck the save value from EntrypointFinal or passthrough\n  const pluckSaveValue = new RunnableCallable({\n    name: \"pluckSaveValue\",\n    func: (value: unknown) => {\n      return isEntrypointFinal(value) ? value.save : value;\n    },\n  });\n\n  const entrypointNode = new PregelNode<InputT, EntrypointReturnT<OutputT>>({\n    bound,\n    triggers: [START],\n    channels: [START],\n    writers: [\n      new ChannelWrite(\n        [\n          { channel: END, value: PASSTHROUGH, mapper: pluckReturnValue },\n          { channel: PREVIOUS, value: PASSTHROUGH, mapper: pluckSaveValue },\n        ],\n        [TAG_HIDDEN]\n      ),\n    ],\n  });\n\n  return new Pregel<\n    Record<string, PregelNode<InputT, EntrypointReturnT<OutputT>>>, // node types\n    {\n      [START]: EphemeralValue<InputT>;\n      [END]: LastValue<EntrypointReturnT<OutputT>>;\n      [PREVIOUS]: LastValue<EntrypointFinalSaveT<OutputT>>;\n    }, // channel types\n    Record<string, unknown>, // configurable types\n    InputT, // input type\n    EntrypointReturnT<OutputT> // output type\n  >({\n    name,\n    checkpointer,\n    nodes: {\n      [name]: entrypointNode,\n    },\n    channels: {\n      [START]: new EphemeralValue<InputT>(),\n      [END]: new LastValue<EntrypointReturnT<OutputT>>(),\n      [PREVIOUS]: new LastValue<EntrypointFinalSaveT<OutputT>>(),\n    },\n    inputChannels: START,\n    outputChannels: END,\n    streamChannels: END,\n    streamMode,\n    store,\n    cache,\n  });\n} as EntrypointFunction;\n\n// documented by the EntrypointFunction interface\nentrypoint.final = function final<ValueT, SaveT>({\n  value,\n  save,\n}: {\n  value?: ValueT;\n  save?: SaveT;\n}): EntrypointFinal<ValueT, SaveT> {\n  return { value, save, __lg_type: \"__pregel_final\" };\n};\n\n/**\n * A helper utility function for use with the functional API that returns the previous\n * state from the checkpoint from the last invocation of the current thread.\n *\n * This function allows workflows to access state that was saved in previous runs\n * using {@link entrypoint.final}.\n *\n * @typeParam StateT - The type of the state that was previously saved\n * @returns The previous saved state from the last invocation of the current thread\n *\n * @example\n * ```typescript\n * const previousState = getPreviousState<{ counter: number }>();\n * const newCount = (previousState?.counter ?? 0) + 1;\n * ```\n * @category Functional API\n */\nexport function getPreviousState<StateT>(): StateT {\n  const config: LangGraphRunnableConfig =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  return config.configurable?.[CONFIG_KEY_PREVIOUS_STATE] as StateT;\n}\n", "/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\nimport { BaseMessage } from \"@langchain/core/messages\";\nimport { z } from \"zod/v3\";\nimport { Annotation } from \"./annotation.js\";\nimport { Messages, messagesStateReducer } from \"./messages_reducer.js\";\nimport { SchemaMeta, withLangGraph } from \"./zod/meta.js\";\n\n/**\n * Prebuilt state annotation that combines returned messages.\n * Can handle standard messages and special modifiers like {@link RemoveMessage}\n * instances.\n *\n * Specifically, importing and using the prebuilt MessagesAnnotation like this:\n *\n * @example\n * ```ts\n * import { MessagesAnnotation, StateGraph } from \"@langchain/langgraph\";\n *\n * const graph = new StateGraph(MessagesAnnotation)\n *   .addNode(...)\n *   ...\n * ```\n *\n * Is equivalent to initializing your state manually like this:\n *\n * @example\n * ```ts\n * import { BaseMessage } from \"@langchain/core/messages\";\n * import { Annotation, StateGraph, messagesStateReducer } from \"@langchain/langgraph\";\n *\n * export const StateAnnotation = Annotation.Root({\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: messagesStateReducer,\n *     default: () => [],\n *   }),\n * });\n *\n * const graph = new StateGraph(StateAnnotation)\n *   .addNode(...)\n *   ...\n * ```\n */\nexport const MessagesAnnotation = Annotation.Root({\n  messages: Annotation<BaseMessage[], Messages>({\n    reducer: messagesStateReducer,\n    default: () => [],\n  }),\n});\n\n/**\n * Prebuilt schema meta for Zod state definition.\n *\n * @example\n * ```ts\n * import { z } from \"zod/v4-mini\";\n * import { MessagesZodState, StateGraph } from \"@langchain/langgraph\";\n *\n * const AgentState = z.object({\n *   messages: z.custom<BaseMessage[]>().register(registry, MessagesZodMeta),\n * });\n * ```\n */\nexport const MessagesZodMeta: SchemaMeta<BaseMessage[], Messages> = {\n  reducer: { fn: messagesStateReducer },\n  jsonSchemaExtra: { langgraph_type: \"messages\" },\n  default: () => [],\n};\n\n/**\n * Prebuilt state object that uses Zod to combine returned messages.\n * This utility is synonymous with the `MessagesAnnotation` annotation,\n * but uses Zod as the way to express messages state.\n *\n * You can use import and use this prebuilt schema like this:\n *\n * @example\n * ```ts\n * import { MessagesZodState, StateGraph } from \"@langchain/langgraph\";\n *\n * const graph = new StateGraph(MessagesZodState)\n *   .addNode(...)\n *   ...\n * ```\n *\n * Which is equivalent to initializing the schema object manually like this:\n *\n * @example\n * ```ts\n * import { z } from \"zod\";\n * import type { BaseMessage, BaseMessageLike } from \"@langchain/core/messages\";\n * import { StateGraph, messagesStateReducer } from \"@langchain/langgraph\";\n * import \"@langchain/langgraph/zod\";\n *\n * const AgentState = z.object({\n *   messages: z\n *     .custom<BaseMessage[]>()\n *     .default(() => [])\n *     .langgraph.reducer(\n *        messagesStateReducer,\n *        z.custom<BaseMessageLike | BaseMessageLike[]>()\n *     ),\n * });\n * const graph = new StateGraph(AgentState)\n *   .addNode(...)\n *   ...\n * ```\n */\nexport const MessagesZodState = z.object({\n  messages: withLangGraph(z.custom<BaseMessage[]>(), MessagesZodMeta),\n});\n", "/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\nimport { initializeAsyncLocalStorageSingleton } from \"./setup/async_local_storage.js\";\n\n// Initialize global async local storage instance for tracing\ninitializeAsyncLocalStorageSingleton();\n\nexport * from \"./web.js\";\n\nexport { interrupt } from \"./interrupt.js\";\nexport { writer } from \"./writer.js\";\nexport { pushMessage } from \"./graph/message.js\";\nexport { getStore, getWriter, getConfig } from \"./pregel/utils/config.js\";\nexport { getPreviousState } from \"./func/index.js\";\nexport { getCurrentTaskInput } from \"./pregel/utils/config.js\";\n", "/* eslint-disable no-instanceof/no-instanceof */\nimport type { ToolCall } from \"@langchain/core/messages/tool\";\nimport { isGraphBubbleUp } from \"@langchain/langgraph\";\n\nexport class MultipleToolsBoundError extends Error {\n  constructor() {\n    super(\n      \"The provided LLM already has bound tools. \" +\n        \"Please provide an LLM without bound tools to createAgent. \" +\n        \"The agent will bind the tools provided in the 'tools' parameter.\"\n    );\n  }\n}\n\n/**\n * Raised when model returns multiple structured output tool calls when only one is expected.\n */\nexport class MultipleStructuredOutputsError extends Error {\n  public readonly toolNames: string[];\n\n  constructor(toolNames: string[]) {\n    super(\n      `The model has called multiple tools: ${toolNames.join(\n        \", \"\n      )} to return a structured output. ` +\n        \"This is not supported. Please provide a single structured output.\"\n    );\n    this.toolNames = toolNames;\n  }\n}\n\n/**\n * Raised when structured output tool call arguments fail to parse according to the schema.\n */\nexport class StructuredOutputParsingError extends Error {\n  public readonly toolName: string;\n\n  public readonly errors: string[];\n\n  constructor(toolName: string, errors: string[]) {\n    super(\n      `Failed to parse structured output for tool '${toolName}':${errors\n        .map((e) => `\\n  - ${e}`)\n        .join(\"\")}.`\n    );\n    this.toolName = toolName;\n    this.errors = errors;\n  }\n}\n\n/**\n * Raised when a tool call is throwing an error.\n */\nexport class ToolInvocationError extends Error {\n  public readonly toolCall: ToolCall;\n\n  public readonly toolError: Error;\n\n  constructor(toolError: unknown, toolCall: ToolCall) {\n    const error =\n      toolError instanceof Error ? toolError : new Error(String(toolError));\n    const toolArgs = JSON.stringify(toolCall.args);\n    super(\n      `Error invoking tool '${toolCall.name}' with kwargs ${toolArgs} with error: ${error.stack}\\n Please fix the error and try again.`\n    );\n\n    this.toolCall = toolCall;\n    this.toolError = error;\n  }\n}\n\n/**\n * Error thrown when a middleware fails.\n *\n * Use `MiddlewareError.wrap()` to create instances. The constructor is private\n * to ensure that GraphBubbleUp errors (like GraphInterrupt) are never wrapped.\n */\nexport class MiddlewareError extends Error {\n  static readonly \"~brand\" = \"MiddlewareError\";\n\n  private constructor(error: unknown, middlewareName: string) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    super(errorMessage);\n    this.name =\n      error instanceof Error\n        ? error.name\n        : `${middlewareName[0].toUpperCase() + middlewareName.slice(1)}Error`;\n\n    if (error instanceof Error) {\n      this.cause = error;\n    }\n  }\n\n  /**\n   * Wrap an error in a MiddlewareError, unless it's a GraphBubbleUp error\n   * (like GraphInterrupt) which should propagate unchanged.\n   *\n   * @param error - The error to wrap\n   * @param middlewareName - The name of the middleware that threw the error\n   * @returns The original error if it's a GraphBubbleUp, otherwise a new MiddlewareError\n   */\n  static wrap(error: unknown, middlewareName: string): Error {\n    // Don't wrap GraphBubbleUp errors (GraphInterrupt, NodeInterrupt, etc.)\n    // These are control flow mechanisms that need to bubble up unchanged\n    if (isGraphBubbleUp(error)) {\n      return error;\n    }\n    return new MiddlewareError(error, middlewareName);\n  }\n\n  /**\n   * Check if the error is a MiddlewareError.\n   * @param error - The error to check\n   * @returns Whether the error is a MiddlewareError\n   */\n  static isInstance(error: unknown): error is MiddlewareError {\n    return (\n      error instanceof Error &&\n      \"~brand\" in error &&\n      error[\"~brand\"] === \"MiddlewareError\"\n    );\n  }\n}\n", "import type { LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport type { BaseChatModel } from \"@langchain/core/language_models/chat_models\";\n\nexport interface ConfigurableModelInterface {\n  _queuedMethodOperations: Record<string, unknown>;\n  _getModelInstance: () => Promise<BaseChatModel>;\n}\n\nexport function isBaseChatModel(\n  model: LanguageModelLike\n): model is BaseChatModel {\n  return (\n    \"invoke\" in model &&\n    typeof model.invoke === \"function\" &&\n    \"_streamResponseChunks\" in model\n  );\n}\n\nexport function isConfigurableModel(\n  model: unknown\n): model is ConfigurableModelInterface {\n  return (\n    typeof model === \"object\" &&\n    model != null &&\n    \"_queuedMethodOperations\" in model &&\n    \"_getModelInstance\" in model &&\n    typeof (model as { _getModelInstance: unknown })._getModelInstance ===\n      \"function\"\n  );\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-instanceof/no-instanceof */\nimport {\n  InteropZodObject,\n  isInteropZodSchema,\n  InteropZodType,\n  isInteropZodObject,\n} from \"@langchain/core/utils/types\";\nimport { type AIMessage } from \"@langchain/core/messages\";\nimport { type LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport { toJsonSchema, Validator } from \"@langchain/core/utils/json_schema\";\nimport { type FunctionDefinition } from \"@langchain/core/language_models/base\";\n\nimport {\n  StructuredOutputParsingError,\n  MultipleStructuredOutputsError,\n} from \"./errors.js\";\nimport { isConfigurableModel, isBaseChatModel } from \"./model.js\";\n\n/**\n * Special type to indicate that no response format is provided.\n * When this type is used, the structuredResponse property should not be present in the result.\n */\nexport type ResponseFormatUndefined = {\n  __responseFormatUndefined: true;\n};\n\n/**\n * Default value for strict mode in providerStrategy.\n *\n * When using providerStrategy with json_schema response format, OpenAI's parse() method\n * requires all function tools to have strict: true. This ensures the model's output\n * exactly matches the provided JSON schema.\n *\n * @see https://platform.openai.com/docs/guides/structured-outputs\n */\nconst PROVIDER_STRATEGY_DEFAULT_STRICT = true;\n\n/**\n * This is a global counter for generating unique names for tools.\n */\nlet bindingIdentifier = 0;\n\n/**\n * Information for tracking structured output tool metadata.\n * This contains all necessary information to handle structured responses generated\n * via tool calls, including the original schema, its type classification, and the\n * corresponding tool implementation used by the tools strategy.\n */\nexport class ToolStrategy<_T = unknown> {\n  private constructor(\n    /**\n     * The original JSON Schema provided for structured output\n     */\n    public readonly schema: Record<string, unknown>,\n\n    /**\n     * The tool that will be used to parse the tool call arguments.\n     */\n    public readonly tool: {\n      type: \"function\";\n      function: FunctionDefinition;\n    },\n\n    /**\n     * The options to use for the tool output.\n     */\n    public readonly options?: ToolStrategyOptions\n  ) {}\n\n  get name() {\n    return this.tool.function.name;\n  }\n\n  static fromSchema<S extends InteropZodObject>(\n    schema: S,\n    outputOptions?: ToolStrategyOptions\n  ): ToolStrategy<S extends InteropZodType<infer U> ? U : unknown>;\n\n  static fromSchema(\n    schema: Record<string, unknown>,\n    outputOptions?: ToolStrategyOptions\n  ): ToolStrategy<Record<string, unknown>>;\n\n  static fromSchema(\n    schema: InteropZodObject | Record<string, unknown>,\n    outputOptions?: ToolStrategyOptions\n  ): ToolStrategy<any> {\n    /**\n     * It is required for tools to have a name so we can map the tool call to the correct tool\n     * when parsing the response.\n     */\n    function getFunctionName(name?: string) {\n      return name ?? `extract-${++bindingIdentifier}`;\n    }\n\n    if (isInteropZodSchema(schema)) {\n      const asJsonSchema = toJsonSchema(schema);\n      const tool = {\n        type: \"function\" as const,\n        function: {\n          name: getFunctionName(asJsonSchema.title),\n          strict: false,\n          description:\n            asJsonSchema.description ??\n            \"Tool for extracting structured output from the model's response.\",\n          parameters: asJsonSchema,\n        },\n      };\n      return new ToolStrategy(asJsonSchema, tool, outputOptions);\n    }\n\n    let functionDefinition: FunctionDefinition;\n    if (\n      typeof schema.name === \"string\" &&\n      typeof schema.parameters === \"object\" &&\n      schema.parameters != null\n    ) {\n      functionDefinition = schema as unknown as FunctionDefinition;\n    } else {\n      functionDefinition = {\n        name: getFunctionName(schema.title as string),\n        description: (schema.description as string) ?? \"\",\n        parameters: schema.schema || (schema as Record<string, unknown>),\n      };\n    }\n    const asJsonSchema = toJsonSchema(schema);\n    const tool = {\n      type: \"function\" as const,\n      function: functionDefinition,\n    };\n    return new ToolStrategy(asJsonSchema, tool, outputOptions);\n  }\n\n  /**\n   * Parse tool arguments according to the schema.\n   *\n   * @throws {StructuredOutputParsingError} if the response is not valid\n   * @param toolArgs - The arguments from the tool call\n   * @returns The parsed response according to the schema type\n   */\n  parse(toolArgs: Record<string, unknown>): Record<string, unknown> {\n    const validator = new Validator(this.schema);\n    const result = validator.validate(toolArgs);\n    if (!result.valid) {\n      throw new StructuredOutputParsingError(\n        this.name,\n        result.errors.map((e) => e.error)\n      );\n    }\n    return toolArgs;\n  }\n}\n\nexport class ProviderStrategy<T = unknown> {\n  // @ts-expect-error - _schemaType is used only for type inference\n  private _schemaType?: T;\n\n  /**\n   * The schema to use for the provider strategy\n   */\n  public readonly schema: Record<string, unknown>;\n\n  /**\n   * Whether to use strict mode for the provider strategy\n   */\n  public readonly strict: boolean;\n\n  private constructor(options: {\n    schema: Record<string, unknown>;\n    strict?: boolean;\n  });\n  private constructor(schema: Record<string, unknown>, strict?: boolean);\n  private constructor(\n    schemaOrOptions:\n      | Record<string, unknown>\n      | { schema: Record<string, unknown>; strict?: boolean },\n    strict?: boolean\n  ) {\n    if (\n      \"schema\" in schemaOrOptions &&\n      typeof schemaOrOptions.schema === \"object\" &&\n      schemaOrOptions.schema !== null &&\n      !(\"type\" in schemaOrOptions)\n    ) {\n      const options = schemaOrOptions as {\n        schema: Record<string, unknown>;\n        strict?: boolean;\n      };\n      this.schema = options.schema;\n      this.strict = options.strict ?? PROVIDER_STRATEGY_DEFAULT_STRICT;\n    } else {\n      this.schema = schemaOrOptions as Record<string, unknown>;\n      this.strict = strict ?? PROVIDER_STRATEGY_DEFAULT_STRICT;\n    }\n  }\n\n  static fromSchema<T>(\n    schema: InteropZodType<T>,\n    strict?: boolean\n  ): ProviderStrategy<T>;\n\n  static fromSchema(\n    schema: Record<string, unknown>,\n    strict?: boolean\n  ): ProviderStrategy<Record<string, unknown>>;\n\n  static fromSchema<T = unknown>(\n    schema: InteropZodType<T> | Record<string, unknown>,\n    strict?: boolean\n  ): ProviderStrategy<T> | ProviderStrategy<Record<string, unknown>> {\n    const asJsonSchema = toJsonSchema(schema);\n    return new ProviderStrategy(asJsonSchema, strict) as\n      | ProviderStrategy<T>\n      | ProviderStrategy<Record<string, unknown>>;\n  }\n\n  /**\n   * Parse tool arguments according to the schema. If the response is not valid, return undefined.\n   *\n   * @param response - The AI message response to parse\n   * @returns The parsed response according to the schema type\n   */\n  parse(response: AIMessage) {\n    /**\n     * Extract text content from the response.\n     * Handles both string content and array content (e.g., from thinking models).\n     */\n    let textContent: string | undefined;\n\n    if (typeof response.content === \"string\") {\n      textContent = response.content;\n    } else if (Array.isArray(response.content)) {\n      /**\n       * For thinking models, content is an array with thinking blocks and text blocks.\n       * Extract the text from text blocks.\n       */\n      for (const block of response.content) {\n        if (\n          typeof block === \"object\" &&\n          block !== null &&\n          \"type\" in block &&\n          block.type === \"text\" &&\n          \"text\" in block &&\n          typeof block.text === \"string\"\n        ) {\n          textContent = block.text;\n          break; // Use the first text block found\n        }\n      }\n    }\n\n    // Return if no valid text content found\n    if (!textContent || textContent === \"\") {\n      return;\n    }\n\n    try {\n      const content = JSON.parse(textContent);\n      const validator = new Validator(this.schema);\n      const result = validator.validate(content);\n      if (!result.valid) {\n        return;\n      }\n\n      return content;\n    } catch {\n      // no-op\n    }\n  }\n}\n\nexport type ResponseFormat = ToolStrategy<any> | ProviderStrategy<any>;\n\n/**\n * Handle user input for `responseFormat` parameter of `CreateAgentParams`.\n * This function defines the default behavior for the `responseFormat` parameter, which is:\n *\n * - if value is a Zod schema, default to structured output via tool calling\n * - if value is a JSON schema, default to structured output via tool calling\n * - if value is a custom response format, return it as is\n * - if value is an array, ensure all array elements are instance of `ToolStrategy`\n * @param responseFormat - The response format to transform, provided by the user\n * @param options - The response format options for tool strategy\n * @param model - The model to check if it supports JSON schema output\n * @returns\n */\nexport function transformResponseFormat(\n  responseFormat?:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[]\n    | ResponseFormat\n    | ToolStrategy<any>[]\n    | ResponseFormatUndefined,\n  options?: ToolStrategyOptions,\n  model?: LanguageModelLike | string\n): ResponseFormat[] {\n  if (!responseFormat) {\n    return [];\n  }\n\n  // Handle ResponseFormatUndefined case\n  if (\n    typeof responseFormat === \"object\" &&\n    responseFormat !== null &&\n    \"__responseFormatUndefined\" in responseFormat\n  ) {\n    return [];\n  }\n\n  /**\n   * If users provide an array, it should only contain raw schemas (Zod or JSON schema),\n   * not ToolStrategy or ProviderStrategy instances.\n   */\n  if (Array.isArray(responseFormat)) {\n    /**\n     * if every entry is a ToolStrategy or ProviderStrategy instance, return the array as is\n     */\n    if (\n      responseFormat.every(\n        (item) =>\n          item instanceof ToolStrategy || item instanceof ProviderStrategy\n      )\n    ) {\n      return responseFormat as unknown as ResponseFormat[];\n    }\n\n    /**\n     * Check if all items are Zod schemas\n     */\n    if (responseFormat.every((item) => isInteropZodObject(item))) {\n      return responseFormat.map((item) =>\n        ToolStrategy.fromSchema(item as InteropZodObject, options)\n      );\n    }\n\n    /**\n     * Check if all items are plain objects (JSON schema)\n     */\n    if (\n      responseFormat.every(\n        (item) =>\n          typeof item === \"object\" && item !== null && !isInteropZodObject(item)\n      )\n    ) {\n      return responseFormat.map((item) =>\n        ToolStrategy.fromSchema(item as JsonSchemaFormat, options)\n      );\n    }\n\n    throw new Error(\n      `Invalid response format: list contains mixed types.\\n` +\n        `All items must be either InteropZodObject or plain JSON schema objects.`\n    );\n  }\n\n  if (\n    responseFormat instanceof ToolStrategy ||\n    responseFormat instanceof ProviderStrategy\n  ) {\n    return [responseFormat];\n  }\n\n  const useProviderStrategy = hasSupportForJsonSchemaOutput(model);\n\n  /**\n   * `responseFormat` is a Zod schema\n   */\n  if (isInteropZodObject(responseFormat)) {\n    return useProviderStrategy\n      ? [ProviderStrategy.fromSchema(responseFormat)]\n      : [ToolStrategy.fromSchema(responseFormat, options)];\n  }\n\n  /**\n   * Handle plain object (JSON schema)\n   */\n  if (\n    typeof responseFormat === \"object\" &&\n    responseFormat !== null &&\n    \"properties\" in responseFormat\n  ) {\n    return useProviderStrategy\n      ? [ProviderStrategy.fromSchema(responseFormat as JsonSchemaFormat)]\n      : [ToolStrategy.fromSchema(responseFormat as JsonSchemaFormat, options)];\n  }\n\n  throw new Error(`Invalid response format: ${String(responseFormat)}`);\n}\n\n/**\n * Branded type for ToolStrategy arrays that preserves type information\n */\nexport interface TypedToolStrategy<T = unknown>\n  extends Array<ToolStrategy<any>> {\n  _schemaType?: T;\n}\nexport type ToolStrategyError =\n  | StructuredOutputParsingError\n  | MultipleStructuredOutputsError;\nexport interface ToolStrategyOptions {\n  /**\n   * Allows you to customize the message that appears in the conversation history when structured\n   * output is generated.\n   */\n  toolMessageContent?: string;\n  /**\n   * Handle errors from the structured output tool call. Using tools to generate structured output\n   * can cause errors, e.g. if:\n   * - you provide multiple structured output schemas and the model calls multiple structured output tools\n   * - if the structured output generated by the tool call doesn't match provided schema\n   *\n   * This property allows to handle these errors in different ways:\n   * - `true` - retry the tool call\n   * - `false` - throw an error\n   * - `string` - retry the tool call with the provided message\n   * - `(error: ToolStrategyError) => Promise<string> | string` - retry with the provided message or throw the error\n   *\n   * @default true\n   */\n  handleError?:\n    | boolean\n    | string\n    | ((error: ToolStrategyError) => Promise<string> | string);\n}\n\nexport function toolStrategy<T extends InteropZodType<any>>(\n  responseFormat: T,\n  options?: ToolStrategyOptions\n): TypedToolStrategy<T extends InteropZodType<infer U> ? U : never>;\nexport function toolStrategy<T extends readonly InteropZodType<any>[]>(\n  responseFormat: T,\n  options?: ToolStrategyOptions\n): TypedToolStrategy<\n  { [K in keyof T]: T[K] extends InteropZodType<infer U> ? U : never }[number]\n>;\nexport function toolStrategy(\n  responseFormat: JsonSchemaFormat,\n  options?: ToolStrategyOptions\n): TypedToolStrategy<Record<string, unknown>>;\nexport function toolStrategy(\n  responseFormat: JsonSchemaFormat[],\n  options?: ToolStrategyOptions\n): TypedToolStrategy<Record<string, unknown>>;\n\n/**\n * Creates a tool strategy for structured output using function calling.\n *\n * This function configures structured output by converting schemas into function tools that\n * the model calls. Unlike `providerStrategy`, which uses native JSON schema support,\n * `toolStrategy` works with any model that supports function calling, making it more\n * widely compatible across providers and model versions.\n *\n * The model will call a function with arguments matching your schema, and the agent will\n * extract and validate the structured output from the tool call. This approach is automatically\n * used when your model doesn't support native JSON schema output.\n *\n * @param responseFormat - The schema(s) to enforce. Can be a single Zod schema, an array of Zod schemas,\n *   a JSON schema object, or an array of JSON schema objects.\n * @param options - Optional configuration for the tool strategy\n * @param options.handleError - How to handle errors when the model calls multiple structured output tools\n *   or when the output doesn't match the schema. Defaults to `true` (auto-retry). Can be `false` (throw),\n *   a `string` (retry with message), or a `function` (custom handler).\n * @param options.toolMessageContent - Custom message content to include in conversation history\n *   when structured output is generated via tool call\n * @returns A `TypedToolStrategy` instance that can be used as the `responseFormat` in `createAgent`\n *\n * @example\n * ```ts\n * import { toolStrategy, createAgent } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: toolStrategy(\n *     z.object({\n *       answer: z.string(),\n *       confidence: z.number().min(0).max(1),\n *     })\n *   ),\n * });\n * ```\n *\n * @example\n * ```ts\n * // Multiple schemas - model can choose which one to use\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: toolStrategy([\n *     z.object({ name: z.string(), age: z.number() }),\n *     z.object({ email: z.string(), phone: z.string() }),\n *   ]),\n * });\n * ```\n */\nexport function toolStrategy(\n  responseFormat:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[],\n  options?: ToolStrategyOptions\n): TypedToolStrategy {\n  return transformResponseFormat(responseFormat, options) as TypedToolStrategy;\n}\n\n/**\n * Creates a provider strategy for structured output using native JSON schema support.\n *\n * This function is used to configure structured output for agents when the underlying model\n * supports native JSON schema output (e.g., OpenAI's `gpt-4o`, `gpt-4o-mini`, and newer models).\n * Unlike `toolStrategy`, which uses function calling to extract structured output, `providerStrategy`\n * leverages the provider's native structured output capabilities, resulting in more efficient\n * and reliable schema enforcement.\n *\n * When used with a model that supports JSON schema output, the model will return responses\n * that directly conform to the provided schema without requiring tool calls. This is the\n * recommended approach for structured output when your model supports it.\n *\n * @param responseFormat - The schema to enforce, either a Zod schema, a JSON schema object, or an options object with `schema` and optional `strict` flag\n * @returns A `ProviderStrategy` instance that can be used as the `responseFormat` in `createAgent`\n *\n * @example\n * ```ts\n * import { providerStrategy, createAgent } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: providerStrategy(\n *     z.object({\n *       answer: z.string().describe(\"The answer to the question\"),\n *       confidence: z.number().min(0).max(1),\n *     })\n *   ),\n * });\n * ```\n *\n * @example\n * ```ts\n * // Using strict mode for stricter schema enforcement\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: providerStrategy({\n *     schema: z.object({\n *       name: z.string(),\n *       age: z.number(),\n *     }),\n *     strict: true\n *   }),\n * });\n * ```\n */\nexport function providerStrategy<T extends InteropZodType<unknown>>(\n  responseFormat: T | { schema: T; strict?: boolean }\n): ProviderStrategy<T extends InteropZodType<infer U> ? U : never>;\nexport function providerStrategy(\n  responseFormat:\n    | JsonSchemaFormat\n    | { schema: JsonSchemaFormat; strict?: boolean }\n): ProviderStrategy<Record<string, unknown>>;\nexport function providerStrategy(\n  responseFormat:\n    | InteropZodType<unknown>\n    | JsonSchemaFormat\n    | { schema: InteropZodType<unknown> | JsonSchemaFormat; strict?: boolean }\n): ProviderStrategy<unknown> {\n  /**\n   * Handle options object format\n   */\n  if (\n    typeof responseFormat === \"object\" &&\n    responseFormat !== null &&\n    \"schema\" in responseFormat &&\n    !isInteropZodSchema(responseFormat) &&\n    !(\"type\" in responseFormat)\n  ) {\n    const { schema, strict: strictFlag } = responseFormat as {\n      schema: InteropZodType<unknown> | JsonSchemaFormat;\n      strict?: boolean;\n    };\n    return ProviderStrategy.fromSchema(\n      schema as InteropZodType<unknown>,\n      strictFlag\n    ) as ProviderStrategy<unknown>;\n  }\n\n  /**\n   * Handle direct schema format\n   */\n  return ProviderStrategy.fromSchema(\n    responseFormat as InteropZodType<unknown>\n  ) as ProviderStrategy<unknown>;\n}\n\n/**\n * Type representing a JSON Schema object format.\n * This is a strict type that excludes ToolStrategy and ProviderStrategy instances.\n */\nexport type JsonSchemaFormat = {\n  type:\n    | \"null\"\n    | \"boolean\"\n    | \"object\"\n    | \"array\"\n    | \"number\"\n    | \"string\"\n    | \"integer\";\n  properties?: Record<string, unknown>;\n  required?: string[];\n  additionalProperties?: boolean;\n  [key: string]: unknown;\n} & {\n  // Brand to ensure this is not a ToolStrategy or ProviderStrategy\n  __brand?: never;\n};\n\nconst CHAT_MODELS_THAT_SUPPORT_JSON_SCHEMA_OUTPUT = [\"ChatOpenAI\", \"ChatXAI\"];\nconst MODEL_NAMES_THAT_SUPPORT_JSON_SCHEMA_OUTPUT = [\n  \"grok\",\n  \"gpt-5\",\n  \"gpt-4.1\",\n  \"gpt-4o\",\n  \"gpt-oss\",\n  \"o3-pro\",\n  \"o3-mini\",\n];\n\n/**\n * Identifies the models that support JSON schema output\n * @param model - The model to check\n * @returns True if the model supports JSON schema output, false otherwise\n */\nexport function hasSupportForJsonSchemaOutput(\n  model?: LanguageModelLike | string\n): boolean {\n  if (!model) {\n    return false;\n  }\n\n  if (typeof model === \"string\") {\n    const modelName = model.split(\":\").pop() as string;\n    return MODEL_NAMES_THAT_SUPPORT_JSON_SCHEMA_OUTPUT.some(\n      (modelNameSnippet) => modelName.includes(modelNameSnippet)\n    );\n  }\n\n  if (isConfigurableModel(model)) {\n    const configurableModel = model as unknown as {\n      _defaultConfig: { model: string };\n    };\n    return hasSupportForJsonSchemaOutput(\n      configurableModel._defaultConfig.model\n    );\n  }\n\n  if (!isBaseChatModel(model)) {\n    return false;\n  }\n\n  const chatModelClass = model.getName();\n\n  /**\n   * for testing purposes only\n   */\n  if (chatModelClass === \"FakeToolCallingChatModel\") {\n    return true;\n  }\n\n  if (\n    CHAT_MODELS_THAT_SUPPORT_JSON_SCHEMA_OUTPUT.includes(chatModelClass) &&\n    /**\n     * OpenAI models\n     */ ((\"model\" in model &&\n      MODEL_NAMES_THAT_SUPPORT_JSON_SCHEMA_OUTPUT.some(\n        (modelNameSnippet) =>\n          typeof model.model === \"string\" &&\n          model.model.includes(modelNameSnippet)\n      )) ||\n      /**\n       * for testing purposes only\n       */\n      (chatModelClass === \"FakeToolCallingModel\" &&\n        \"structuredResponse\" in model))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n", "import {\n  AIMessage,\n  ToolMessage,\n  type BaseMessage,\n} from \"@langchain/core/messages\";\nimport {\n  AfterModelHook,\n  AfterAgentHook,\n  BeforeAgentHook,\n  BeforeModelHook,\n} from \"./types.js\";\nimport { JumpToTarget } from \"../constants.js\";\n\n/**\n * Default token counter that approximates based on character count\n * @param messages Messages to count tokens for\n * @returns Approximate token count\n */\nexport function countTokensApproximately(messages: BaseMessage[]): number {\n  let totalChars = 0;\n  for (const msg of messages) {\n    let textContent: string;\n    if (typeof msg.content === \"string\") {\n      textContent = msg.content;\n    } else if (Array.isArray(msg.content)) {\n      textContent = msg.content\n        .map((item) => {\n          if (typeof item === \"string\") return item;\n          if (item.type === \"text\" && \"text\" in item) return item.text;\n          return \"\";\n        })\n        .join(\"\");\n    } else {\n      textContent = \"\";\n    }\n\n    if (\n      AIMessage.isInstance(msg) &&\n      Array.isArray(msg.tool_calls) &&\n      msg.tool_calls.length > 0\n    ) {\n      textContent += JSON.stringify(msg.tool_calls);\n    }\n\n    if (ToolMessage.isInstance(msg)) {\n      textContent += msg.tool_call_id ?? \"\";\n    }\n\n    totalChars += textContent.length;\n  }\n  // Approximate 1 token = 4 characters\n  return Math.ceil(totalChars / 4);\n}\n\nexport function getHookConstraint(\n  hook:\n    | BeforeAgentHook\n    | BeforeModelHook\n    | AfterAgentHook\n    | AfterModelHook\n    | undefined\n): JumpToTarget[] | undefined {\n  if (!hook || typeof hook === \"function\") {\n    return undefined;\n  }\n  return hook.canJumpTo;\n}\n\nexport function getHookFunction(\n  arg: BeforeAgentHook | BeforeModelHook | AfterAgentHook | AfterModelHook\n) {\n  if (typeof arg === \"function\") {\n    return arg;\n  }\n  return arg.hook;\n}\n\n/**\n * Sleep for the specified number of milliseconds.\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Calculate delay for a retry attempt with exponential backoff and jitter.\n *\n * @param retryNumber - The retry attempt number (0-indexed)\n * @param config - Configuration for backoff calculation\n * @returns Delay in milliseconds before next retry\n *\n * @internal Exported for testing purposes\n */\nexport function calculateRetryDelay(\n  config: {\n    backoffFactor: number;\n    initialDelayMs: number;\n    maxDelayMs: number;\n    jitter: boolean;\n  },\n  retryNumber: number\n): number {\n  const { backoffFactor, initialDelayMs, maxDelayMs, jitter } = config;\n\n  let delay: number;\n  if (backoffFactor === 0.0) {\n    delay = initialDelayMs;\n  } else {\n    delay = initialDelayMs * backoffFactor ** retryNumber;\n  }\n\n  // Cap at maxDelayMs\n  delay = Math.min(delay, maxDelayMs);\n\n  if (jitter && delay > 0) {\n    const jitterAmount = delay * 0.25;\n    delay = delay + (Math.random() * 2 - 1) * jitterAmount;\n    // Ensure delay is not negative after jitter\n    delay = Math.max(0, delay);\n  }\n\n  return delay;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  InteropZodObject,\n  InteropZodDefault,\n  InteropZodOptional,\n  InferInteropZodInput,\n  InferInteropZodOutput,\n} from \"@langchain/core/utils/types\";\nimport type { InteropZodToStateDefinition } from \"@langchain/langgraph/zod\";\nimport type {\n  AnnotationRoot,\n  StateSchema,\n  InferStateSchemaUpdate,\n  StateDefinitionInit,\n} from \"@langchain/langgraph\";\nimport type {\n  AIMessage,\n  SystemMessage,\n  ToolMessage,\n} from \"@langchain/core/messages\";\nimport type { ToolCall } from \"@langchain/core/messages/tool\";\nimport type { Command } from \"@langchain/langgraph\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\n\nimport type { JumpToTarget } from \"../constants.js\";\nimport type { Runtime, AgentBuiltInState } from \"../runtime.js\";\nimport type { ModelRequest } from \"../nodes/types.js\";\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\nexport type AnyAnnotationRoot = AnnotationRoot<any>;\n\n/**\n * Type bag that encapsulates all middleware type parameters.\n *\n * This interface bundles all the generic type parameters used throughout the middleware system\n * into a single configuration object. This pattern simplifies type signatures and makes\n * it easier to add new type parameters without changing multiple function signatures.\n *\n * @typeParam TSchema - The middleware state schema type. Can be a `StateDefinitionInit`\n *   (including `InteropZodObject`, `StateSchema`, or `AnnotationRoot`) or `undefined`.\n *\n * @typeParam TContextSchema - The middleware context schema type. Can be an `InteropZodObject`,\n *   `InteropZodDefault`, `InteropZodOptional`, or `undefined`.\n *\n * @typeParam TFullContext - The full context type available to middleware hooks.\n *\n * @typeParam TTools - The tools array type registered by the middleware.\n *\n * @example\n * ```typescript\n * // Define a type configuration\n * type MyMiddlewareTypes = MiddlewareTypeConfig<\n *   typeof myStateSchema,\n *   typeof myContextSchema,\n *   MyContextType,\n *   typeof myTools\n * >;\n * ```\n */\nexport interface MiddlewareTypeConfig<\n  TSchema extends StateDefinitionInit | undefined =\n    | StateDefinitionInit\n    | undefined,\n  TContextSchema extends\n    | InteropZodObject\n    | InteropZodDefault<InteropZodObject>\n    | InteropZodOptional<InteropZodObject>\n    | undefined =\n    | InteropZodObject\n    | InteropZodDefault<InteropZodObject>\n    | InteropZodOptional<InteropZodObject>\n    | undefined,\n  TFullContext = any,\n  TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n> {\n  /** The middleware state schema type */\n  Schema: TSchema;\n  /** The middleware context schema type */\n  ContextSchema: TContextSchema;\n  /** The full context type */\n  FullContext: TFullContext;\n  /** The tools array type */\n  Tools: TTools;\n}\n\n/**\n * Default type configuration for middleware.\n * Used when no explicit type parameters are provided.\n */\nexport type DefaultMiddlewareTypeConfig = MiddlewareTypeConfig;\n\nexport type NormalizedSchemaInput<\n  TSchema extends StateDefinitionInit | undefined | never = any,\n> = [TSchema] extends [never]\n  ? AgentBuiltInState\n  : TSchema extends InteropZodObject\n    ? InferInteropZodOutput<TSchema> & AgentBuiltInState\n    : TSchema extends StateDefinitionInit\n      ? InferSchemaInput<TSchema> & AgentBuiltInState\n      : AgentBuiltInState;\n\n/**\n * Result type for middleware functions.\n */\nexport type MiddlewareResult<TState> =\n  | (TState & {\n      jumpTo?: JumpToTarget;\n    })\n  | void;\n\n/**\n * Represents a tool call request for the wrapToolCall hook.\n * Contains the tool call information along with the agent's current state and runtime.\n */\nexport interface ToolCallRequest<\n  TState extends Record<string, unknown> = Record<string, unknown>,\n  TContext = unknown,\n> {\n  /**\n   * The tool call to be executed\n   */\n  toolCall: ToolCall;\n  /**\n   * The BaseTool instance being invoked.\n   * Provides access to tool metadata like name, description, schema, etc.\n   *\n   * This will be `undefined` for dynamically registered tools that aren't\n   * declared upfront when creating the agent. In such cases, middleware\n   * should provide the tool implementation by spreading the request with\n   * the tool property.\n   *\n   * @example Dynamic tool handling\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   if (request.toolCall.name === \"dynamic_tool\" && !request.tool) {\n   *     // Provide the tool implementation for dynamically registered tools\n   *     return handler({ ...request, tool: myDynamicTool });\n   *   }\n   *   return handler(request);\n   * }\n   * ```\n   */\n  tool: ClientTool | ServerTool | undefined;\n  /**\n   * The current agent state (includes both middleware state and built-in state).\n   */\n  state: TState & AgentBuiltInState;\n  /**\n   * The runtime context containing metadata, signal, writer, interrupt, etc.\n   */\n  runtime: Runtime<TContext>;\n}\n\n/**\n * Handler function type for wrapping tool calls.\n * Takes a tool call request and returns the tool result or a command.\n */\nexport type ToolCallHandler<\n  TSchema extends Record<string, unknown> = AgentBuiltInState,\n  TContext = unknown,\n> = (\n  request: ToolCallRequest<TSchema, TContext>\n) => PromiseOrValue<ToolMessage | Command>;\n\n/**\n * Wrapper function type for the wrapToolCall hook.\n * Allows middleware to intercept and modify tool execution.\n */\nexport type WrapToolCallHook<\n  TSchema extends StateDefinitionInit | undefined = undefined,\n  TContext = unknown,\n> = (\n  request: ToolCallRequest<NormalizedSchemaInput<TSchema>, TContext>,\n  handler: ToolCallHandler<NormalizedSchemaInput<TSchema>, TContext>\n) => PromiseOrValue<ToolMessage | Command>;\n\n/**\n * Handler function type for wrapping model calls.\n * Takes a model request and returns the AI message response.\n *\n * @param request - The model request containing model, messages, systemPrompt, tools, state, and runtime\n * @returns The AI message response from the model\n */\nexport type WrapModelCallHandler<\n  TSchema extends StateDefinitionInit | undefined = undefined,\n  TContext = unknown,\n> = (\n  request: Omit<\n    ModelRequest<NormalizedSchemaInput<TSchema>, TContext>,\n    /**\n     * allow to reset the system prompt or system message\n     */\n    \"systemPrompt\" | \"systemMessage\"\n  > & { systemPrompt?: string; systemMessage?: SystemMessage }\n) => PromiseOrValue<AIMessage>;\n\n/**\n * Wrapper function type for the wrapModelCall hook.\n * Allows middleware to intercept and modify model execution.\n * This enables you to:\n * - Modify the request before calling the model (e.g., change system prompt, add/remove tools)\n * - Handle errors and retry with different parameters\n * - Post-process the response\n * - Implement custom caching, logging, or other cross-cutting concerns\n *\n * @param request - The model request containing all parameters needed for the model call\n * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response\n * @returns The AI message response from the model (or a modified version)\n */\nexport type WrapModelCallHook<\n  TSchema extends StateDefinitionInit | undefined = undefined,\n  TContext = unknown,\n> = (\n  request: ModelRequest<NormalizedSchemaInput<TSchema>, TContext>,\n  handler: WrapModelCallHandler<TSchema, TContext>\n) => PromiseOrValue<AIMessage>;\n\n/**\n * Handler function type for the beforeAgent hook.\n * Called once at the start of agent invocation before any model calls or tool executions.\n *\n * @param state - The current agent state (includes both middleware state and built-in state)\n * @param runtime - The runtime context containing metadata, signal, writer, interrupt, etc.\n * @returns A middleware result containing partial state updates or undefined to pass through\n */\ntype BeforeAgentHandler<TSchema, TContext> = (\n  state: TSchema,\n  runtime: Runtime<TContext>\n) => PromiseOrValue<MiddlewareResult<Partial<TSchema>>>;\n\n/**\n * Hook type for the beforeAgent lifecycle event.\n * Can be either a handler function or an object with a handler and optional jump targets.\n * This hook is called once at the start of the agent invocation.\n */\nexport type BeforeAgentHook<\n  TSchema extends StateDefinitionInit | undefined = undefined,\n  TContext = unknown,\n> =\n  | BeforeAgentHandler<NormalizedSchemaInput<TSchema>, TContext>\n  | {\n      hook: BeforeAgentHandler<NormalizedSchemaInput<TSchema>, TContext>;\n      canJumpTo?: JumpToTarget[];\n    };\n\n/**\n * Handler function type for the beforeModel hook.\n * Called before the model is invoked and before the wrapModelCall hook.\n *\n * @param state - The current agent state (includes both middleware state and built-in state)\n * @param runtime - The runtime context containing metadata, signal, writer, interrupt, etc.\n * @returns A middleware result containing partial state updates or undefined to pass through\n */\ntype BeforeModelHandler<TSchema, TContext> = (\n  state: TSchema,\n  runtime: Runtime<TContext>\n) => PromiseOrValue<MiddlewareResult<Partial<TSchema>>>;\n\n/**\n * Hook type for the beforeModel lifecycle event.\n * Can be either a handler function or an object with a handler and optional jump targets.\n * This hook is called before each model invocation.\n */\nexport type BeforeModelHook<\n  TSchema extends StateDefinitionInit | undefined = undefined,\n  TContext = unknown,\n> =\n  | BeforeModelHandler<NormalizedSchemaInput<TSchema>, TContext>\n  | {\n      hook: BeforeModelHandler<NormalizedSchemaInput<TSchema>, TContext>;\n      canJumpTo?: JumpToTarget[];\n    };\n\n/**\n * Handler function type for the afterModel hook.\n * Called after the model is invoked and before any tools are called.\n * Allows modifying the agent state after model invocation, e.g., to update tool call parameters.\n *\n * @param state - The current agent state (includes both middleware state and built-in state)\n * @param runtime - The runtime context containing metadata, signal, writer, interrupt, etc.\n * @returns A middleware result containing partial state updates or undefined to pass through\n */\ntype AfterModelHandler<TSchema, TContext> = (\n  state: TSchema,\n  runtime: Runtime<TContext>\n) => PromiseOrValue<MiddlewareResult<Partial<TSchema>>>;\n\n/**\n * Hook type for the afterModel lifecycle event.\n * Can be either a handler function or an object with a handler and optional jump targets.\n * This hook is called after each model invocation.\n */\nexport type AfterModelHook<\n  TSchema extends StateDefinitionInit | undefined = undefined,\n  TContext = unknown,\n> =\n  | AfterModelHandler<NormalizedSchemaInput<TSchema>, TContext>\n  | {\n      hook: AfterModelHandler<NormalizedSchemaInput<TSchema>, TContext>;\n      canJumpTo?: JumpToTarget[];\n    };\n\n/**\n * Handler function type for the afterAgent hook.\n * Called once at the end of agent invocation after all model calls and tool executions are complete.\n *\n * @param state - The current agent state (includes both middleware state and built-in state)\n * @param runtime - The runtime context containing metadata, signal, writer, interrupt, etc.\n * @returns A middleware result containing partial state updates or undefined to pass through\n */\ntype AfterAgentHandler<TSchema, TContext> = (\n  state: TSchema,\n  runtime: Runtime<TContext>\n) => PromiseOrValue<MiddlewareResult<Partial<TSchema>>>;\n\n/**\n * Hook type for the afterAgent lifecycle event.\n * Can be either a handler function or an object with a handler and optional jump targets.\n * This hook is called once at the end of the agent invocation.\n */\nexport type AfterAgentHook<\n  TSchema extends StateDefinitionInit | undefined = undefined,\n  TContext = unknown,\n> =\n  | AfterAgentHandler<NormalizedSchemaInput<TSchema>, TContext>\n  | {\n      hook: AfterAgentHandler<NormalizedSchemaInput<TSchema>, TContext>;\n      canJumpTo?: JumpToTarget[];\n    };\n\n/**\n * Unique symbol used to brand middleware instances.\n * This prevents functions from being accidentally assignable to AgentMiddleware\n * since functions have a 'name' property that would otherwise make them structurally compatible.\n */\nexport const MIDDLEWARE_BRAND: unique symbol = Symbol(\"AgentMiddleware\");\n\n/**\n * Base middleware interface.\n *\n * @typeParam TSchema - The middleware state schema type\n * @typeParam TContextSchema - The middleware context schema type\n * @typeParam TFullContext - The full context type available to hooks\n * @typeParam TTools - The tools array type registered by the middleware\n *\n * @example\n * ```typescript\n * const middleware = createMiddleware({\n *   name: \"myMiddleware\",\n *   stateSchema: z.object({ count: z.number() }),\n *   tools: [myTool],\n * });\n * ```\n */\nexport interface AgentMiddleware<\n  TSchema extends StateDefinitionInit | undefined = any,\n  TContextSchema extends\n    | InteropZodObject\n    | InteropZodDefault<InteropZodObject>\n    | InteropZodOptional<InteropZodObject>\n    | undefined = any,\n  TFullContext = any,\n  TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n> {\n  /**\n   * Brand property to distinguish middleware instances from plain objects or functions.\n   * This is required and prevents accidental assignment of functions to middleware arrays.\n   */\n  readonly [MIDDLEWARE_BRAND]: true;\n\n  /**\n   * Type marker for extracting the MiddlewareTypeConfig from a middleware instance.\n   * This is a phantom property used only for type inference.\n   * @internal\n   */\n  readonly \"~middlewareTypes\"?: MiddlewareTypeConfig<\n    TSchema,\n    TContextSchema,\n    TFullContext,\n    TTools\n  >;\n\n  /**\n   * The name of the middleware.\n   */\n  name: string;\n\n  /**\n   * The schema of the middleware state. Middleware state is persisted between multiple invocations. It can be either:\n   * - A Zod object (InteropZodObject)\n   * - A StateSchema from LangGraph (supports ReducedValue, UntrackedValue)\n   * - An AnnotationRoot\n   * - Undefined\n   */\n  stateSchema?: TSchema;\n\n  /**\n   * The schema of the middleware context. Middleware context is read-only and not persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  contextSchema?: TContextSchema;\n\n  /**\n   * Additional tools registered by the middleware.\n   */\n  tools?: TTools;\n  /**\n   * Wraps tool execution with custom logic. This allows you to:\n   * - Modify tool call parameters before execution\n   * - Handle errors and retry with different parameters\n   * - Post-process tool results\n   * - Implement caching, logging, authentication, or other cross-cutting concerns\n   * - Return Command objects for advanced control flow\n   *\n   * The handler receives a ToolCallRequest containing the tool call, state, and runtime,\n   * along with a handler function to execute the actual tool.\n   *\n   * @param request - The tool call request containing toolCall, state, and runtime.\n   * @param handler - The function that executes the tool. Call this with a ToolCallRequest to get the result.\n   * @returns The tool result as a ToolMessage or a Command for advanced control flow.\n   *\n   * @example\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   console.log(`Calling tool: ${request.tool.name}`);\n   *   console.log(`Tool description: ${request.tool.description}`);\n   *\n   *   try {\n   *     // Execute the tool\n   *     const result = await handler(request);\n   *     console.log(`Tool ${request.tool.name} succeeded`);\n   *     return result;\n   *   } catch (error) {\n   *     console.error(`Tool ${request.tool.name} failed:`, error);\n   *     // Could return a custom error message or retry\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @example Authentication\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   // Check if user is authorized for this tool\n   *   if (!request.runtime.context.isAuthorized(request.tool.name)) {\n   *     return new ToolMessage({\n   *       content: \"Unauthorized to call this tool\",\n   *       tool_call_id: request.toolCall.id,\n   *     });\n   *   }\n   *   return handler(request);\n   * }\n   * ```\n   *\n   * @example Caching\n   * ```ts\n   * const cache = new Map();\n   * wrapToolCall: async (request, handler) => {\n   *   const cacheKey = `${request.tool.name}:${JSON.stringify(request.toolCall.args)}`;\n   *   if (cache.has(cacheKey)) {\n   *     return cache.get(cacheKey);\n   *   }\n   *   const result = await handler(request);\n   *   cache.set(cacheKey, result);\n   *   return result;\n   * }\n   * ```\n   */\n  wrapToolCall?: WrapToolCallHook<TSchema, TFullContext>;\n\n  /**\n   * Wraps the model invocation with custom logic. This allows you to:\n   * - Modify the request before calling the model\n   * - Handle errors and retry with different parameters\n   * - Post-process the response\n   * - Implement custom caching, logging, or other cross-cutting concerns\n   *\n   * @param request - The model request containing model, messages, systemPrompt, tools, state, and runtime.\n   * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response.\n   * @returns The response from the model (or a modified version).\n   *\n   * @example\n   * ```ts\n   * wrapModelCall: async (request, handler) => {\n   *   // Modify request before calling\n   *   const modifiedRequest = { ...request, systemPrompt: \"You are helpful\" };\n   *\n   *   try {\n   *     // Call the model\n   *     return await handler(modifiedRequest);\n   *   } catch (error) {\n   *     // Handle errors and retry with fallback\n   *     const fallbackRequest = { ...request, model: fallbackModel };\n   *     return await handler(fallbackRequest);\n   *   }\n   * }\n   * ```\n   */\n  wrapModelCall?: WrapModelCallHook<TSchema, TFullContext>;\n\n  /**\n   * The function to run before the agent execution starts. This function is called once at the start of the agent invocation.\n   * It allows to modify the state of the agent before any model calls or tool executions.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeAgent?: BeforeAgentHook<TSchema, TFullContext>;\n\n  /**\n   * The function to run before the model call. This function is called before the model is invoked and before the `wrapModelCall` hook.\n   * It allows to modify the state of the agent.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeModel?: BeforeModelHook<TSchema, TFullContext>;\n\n  /**\n   * The function to run after the model call. This function is called after the model is invoked and before any tools are called.\n   * It allows to modify the state of the agent after the model is invoked, e.g. to update tool call parameters.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterModel?: AfterModelHook<TSchema, TFullContext>;\n\n  /**\n   * The function to run after the agent execution completes. This function is called once at the end of the agent invocation.\n   * It allows to modify the final state of the agent after all model calls and tool executions are complete.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterAgent?: AfterAgentHook<TSchema, TFullContext>;\n}\n\n/**\n * Helper type to filter out properties that start with underscore (private properties)\n */\ntype FilterPrivateProps<T> = {\n  [K in keyof T as K extends `_${string}` ? never : K]: T[K];\n};\n\n/**\n * Helper type to resolve a MiddlewareTypeConfig from either:\n * - A MiddlewareTypeConfig directly\n * - An AgentMiddleware instance (using `typeof middleware`)\n */\nexport type ResolveMiddlewareTypeConfig<T> = T extends {\n  \"~middlewareTypes\"?: infer Types;\n}\n  ? Types extends MiddlewareTypeConfig\n    ? Types\n    : never\n  : T extends MiddlewareTypeConfig\n    ? T\n    : never;\n\n/**\n * Helper type to extract any property from a MiddlewareTypeConfig or AgentMiddleware.\n *\n * @typeParam T - The MiddlewareTypeConfig or AgentMiddleware to extract from\n * @typeParam K - The property key to extract (\"Schema\" | \"ContextSchema\" | \"FullContext\" | \"Tools\")\n */\nexport type InferMiddlewareType<\n  T,\n  K extends keyof MiddlewareTypeConfig,\n> = ResolveMiddlewareTypeConfig<T>[K];\n\n/**\n * Shorthand helper to extract the Schema type from a MiddlewareTypeConfig or AgentMiddleware.\n */\nexport type InferMiddlewareSchema<T> = InferMiddlewareType<T, \"Schema\">;\n\n/**\n * Shorthand helper to extract the ContextSchema type from a MiddlewareTypeConfig or AgentMiddleware.\n */\nexport type InferMiddlewareContextSchema<T> = InferMiddlewareType<\n  T,\n  \"ContextSchema\"\n>;\n\n/**\n * Shorthand helper to extract the FullContext type from a MiddlewareTypeConfig or AgentMiddleware.\n */\nexport type InferMiddlewareFullContext<T> = InferMiddlewareType<\n  T,\n  \"FullContext\"\n>;\n\n/**\n * Shorthand helper to extract the Tools type from a MiddlewareTypeConfig or AgentMiddleware.\n */\nexport type InferMiddlewareToolsFromConfig<T> = InferMiddlewareType<T, \"Tools\">;\n\nexport type InferChannelType<T extends AnyAnnotationRoot | InteropZodObject> =\n  T extends AnyAnnotationRoot\n    ? ToAnnotationRoot<T>[\"State\"]\n    : T extends InteropZodObject\n      ? InferInteropZodInput<T>\n      : {};\n\n/**\n * Helper type to infer the state schema type from a middleware\n * This filters out private properties (those starting with underscore)\n * Supports both Zod schemas (InteropZodObject) and StateSchema from LangGraph\n */\nexport type InferMiddlewareState<T extends AgentMiddleware> =\n  T extends AgentMiddleware<infer TSchema, any, any, any>\n    ? TSchema extends InteropZodObject\n      ? FilterPrivateProps<InferInteropZodOutput<TSchema>>\n      : TSchema extends StateDefinitionInit\n        ? FilterPrivateProps<InferSchemaInput<TSchema>>\n        : {}\n    : {};\n\n/**\n * Helper type to infer the input state schema type from a middleware (all properties optional)\n * This filters out private properties (those starting with underscore)\n * Supports both Zod schemas (InteropZodObject) and StateSchema from LangGraph\n */\nexport type InferMiddlewareInputState<T extends AgentMiddleware> =\n  T extends AgentMiddleware<infer TSchema, any, any, any>\n    ? TSchema extends InteropZodObject\n      ? FilterPrivateProps<InferInteropZodInput<TSchema>>\n      : TSchema extends StateDefinitionInit\n        ? FilterPrivateProps<InferSchemaInput<TSchema>>\n        : {}\n    : {};\n\n/**\n * Helper type to infer merged state from an array of middleware (just the middleware states)\n */\nexport type InferMiddlewareStates<T extends readonly AgentMiddleware[]> =\n  T extends readonly []\n    ? {}\n    : T extends readonly [infer First, ...infer Rest]\n      ? First extends AgentMiddleware\n        ? Rest extends readonly AgentMiddleware[]\n          ? InferMiddlewareState<First> & InferMiddlewareStates<Rest>\n          : InferMiddlewareState<First>\n        : {}\n      : {};\n\n/**\n * Helper type to infer merged input state from an array of middleware (with optional defaults)\n */\nexport type InferMiddlewareInputStates<T extends readonly AgentMiddleware[]> =\n  T extends readonly []\n    ? {}\n    : T extends readonly [infer First, ...infer Rest]\n      ? First extends AgentMiddleware\n        ? Rest extends readonly AgentMiddleware[]\n          ? InferMiddlewareInputState<First> & InferMiddlewareInputStates<Rest>\n          : InferMiddlewareInputState<First>\n        : {}\n      : {};\n\n/**\n * Helper type to infer merged state from an array of middleware (includes built-in state)\n */\nexport type InferMergedState<T extends readonly AgentMiddleware[]> =\n  InferMiddlewareStates<T> & AgentBuiltInState;\n\n/**\n * Helper type to infer merged input state from an array of middleware (includes built-in state)\n */\nexport type InferMergedInputState<T extends readonly AgentMiddleware[]> =\n  InferMiddlewareInputStates<T> & AgentBuiltInState;\n\n/**\n * Helper type to infer the context schema type from a middleware\n */\nexport type InferMiddlewareContext<T extends AgentMiddleware> =\n  T extends AgentMiddleware<any, infer TContextSchema, any, any>\n    ? TContextSchema extends InteropZodObject\n      ? InferInteropZodInput<TContextSchema>\n      : {}\n    : {};\n\n/**\n * Helper type to infer the input context schema type from a middleware (with optional defaults)\n */\nexport type InferMiddlewareContextInput<T extends AgentMiddleware> =\n  T extends AgentMiddleware<any, infer TContextSchema, any, any>\n    ? TContextSchema extends InteropZodOptional<infer Inner>\n      ? InferInteropZodInput<Inner> | undefined\n      : TContextSchema extends InteropZodObject\n        ? InferInteropZodInput<TContextSchema>\n        : {}\n    : {};\n\n/**\n * Helper type to infer merged context from an array of middleware\n */\nexport type InferMiddlewareContexts<T extends readonly AgentMiddleware[]> =\n  T extends readonly []\n    ? {}\n    : T extends readonly [infer First, ...infer Rest]\n      ? First extends AgentMiddleware\n        ? Rest extends readonly AgentMiddleware[]\n          ? InferMiddlewareContext<First> & InferMiddlewareContexts<Rest>\n          : InferMiddlewareContext<First>\n        : {}\n      : {};\n\n/**\n * Helper to merge two context types, preserving undefined unions\n */\ntype MergeContextTypes<A, B> = [A] extends [undefined]\n  ? [B] extends [undefined]\n    ? undefined\n    : B | undefined\n  : [B] extends [undefined]\n    ? A | undefined\n    : [A] extends [B]\n      ? A\n      : [B] extends [A]\n        ? B\n        : A & B;\n\n/**\n * Helper type to infer merged input context from an array of middleware (with optional defaults)\n */\nexport type InferMiddlewareContextInputs<T extends readonly AgentMiddleware[]> =\n  T extends readonly []\n    ? {}\n    : T extends readonly [infer First, ...infer Rest]\n      ? First extends AgentMiddleware\n        ? Rest extends readonly AgentMiddleware[]\n          ? MergeContextTypes<\n              InferMiddlewareContextInput<First>,\n              InferMiddlewareContextInputs<Rest>\n            >\n          : InferMiddlewareContextInput<First>\n        : {}\n      : {};\n\n/**\n * Helper type to extract input type from context schema (with optional defaults)\n */\nexport type InferContextInput<\n  ContextSchema extends AnyAnnotationRoot | InteropZodObject,\n> = ContextSchema extends InteropZodObject\n  ? InferInteropZodInput<ContextSchema>\n  : ContextSchema extends AnyAnnotationRoot\n    ? ToAnnotationRoot<ContextSchema>[\"State\"]\n    : {};\n\nexport type ToAnnotationRoot<A extends StateDefinitionInit> =\n  A extends AnyAnnotationRoot\n    ? A\n    : A extends InteropZodObject\n      ? InteropZodToStateDefinition<A>\n      : never;\n\nexport type InferSchemaInput<A extends StateDefinitionInit | undefined> =\n  A extends StateSchema<infer TFields>\n    ? InferStateSchemaUpdate<TFields>\n    : A extends InteropZodObject\n      ? InferInteropZodOutput<A>\n      : A extends AnyAnnotationRoot\n        ? A[\"State\"]\n        : {};\n", "import type {\n  InteropZodObject,\n  InferInteropZodOutput,\n} from \"@langchain/core/utils/types\";\nimport type { StateDefinitionInit } from \"@langchain/langgraph\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\n\nimport {\n  MIDDLEWARE_BRAND,\n  type AgentMiddleware,\n  type WrapToolCallHook,\n  type WrapModelCallHook,\n  type BeforeAgentHook,\n  type BeforeModelHook,\n  type AfterModelHook,\n  type AfterAgentHook,\n} from \"./middleware/types.js\";\n\n/**\n * Creates a middleware instance with automatic schema inference.\n *\n * @param config - Middleware configuration\n * @param config.name - The name of the middleware\n * @param config.stateSchema - The schema of the middleware state\n * @param config.contextSchema - The schema of the middleware context\n * @param config.wrapModelCall - The function to wrap model invocation\n * @param config.wrapToolCall - The function to wrap tool invocation\n * @param config.beforeModel - The function to run before the model call\n * @param config.afterModel - The function to run after the model call\n * @param config.beforeAgent - The function to run before the agent execution starts\n * @param config.afterAgent - The function to run after the agent execution completes\n * @returns A middleware instance\n *\n * @example Using Zod schema\n * ```ts\n * const authMiddleware = createMiddleware({\n *   name: \"AuthMiddleware\",\n *   stateSchema: z.object({\n *     isAuthenticated: z.boolean().default(false),\n *   }),\n *   contextSchema: z.object({\n *     userId: z.string(),\n *   }),\n *   beforeModel: async (state, runtime, controls) => {\n *     if (!state.isAuthenticated) {\n *       return controls.terminate(new Error(\"Not authenticated\"));\n *     }\n *   },\n * });\n * ```\n *\n * @example Using StateSchema\n * ```ts\n * import { StateSchema, ReducedValue } from \"@langchain/langgraph\";\n *\n * const historyMiddleware = createMiddleware({\n *   name: \"HistoryMiddleware\",\n *   stateSchema: new StateSchema({\n *     count: z.number().default(0),\n *     history: new ReducedValue(\n *       z.array(z.string()).default(() => []),\n *       { inputSchema: z.string(), reducer: (current, next) => [...current, next] }\n *     ),\n *   }),\n *   beforeModel: async (state, runtime) => {\n *     return { count: state.count + 1 };\n *   },\n * });\n * ```\n */\nexport function createMiddleware<\n  TSchema extends StateDefinitionInit | undefined = undefined,\n  TContextSchema extends InteropZodObject | undefined = undefined,\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(config: {\n  /**\n   * The name of the middleware\n   */\n  name: string;\n  /**\n   * The schema of the middleware state. Middleware state is persisted between multiple invocations. It can be either:\n   * - A Zod object (InteropZodObject)\n   * - A StateSchema from LangGraph (supports ReducedValue, UntrackedValue)\n   * - An AnnotationRoot\n   * - Undefined\n   */\n  stateSchema?: TSchema;\n  /**\n   * The schema of the middleware context. Middleware context is read-only and not persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  contextSchema?: TContextSchema;\n  /**\n   * Additional tools registered by the middleware.\n   */\n  tools?: TTools;\n  /**\n   * Wraps tool execution with custom logic. This allows you to:\n   * - Modify tool call parameters before execution\n   * - Handle errors and retry with different parameters\n   * - Post-process tool results\n   * - Implement caching, logging, authentication, or other cross-cutting concerns\n   * - Return Command objects for advanced control flow\n   *\n   * The handler receives a ToolCallRequest containing the tool call, state, and runtime,\n   * along with a handler function to execute the actual tool.\n   *\n   * @param request - The tool call request containing toolCall, state, and runtime.\n   * @param handler - The function that executes the tool. Call this with a ToolCallRequest to get the result.\n   * @returns The tool result as a ToolMessage or a Command for advanced control flow.\n   *\n   * @example\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   console.log(`Calling tool: ${request.tool.name}`);\n   *   console.log(`Tool description: ${request.tool.description}`);\n   *\n   *   try {\n   *     // Execute the tool\n   *     const result = await handler(request);\n   *     console.log(`Tool ${request.tool.name} succeeded`);\n   *     return result;\n   *   } catch (error) {\n   *     console.error(`Tool ${request.tool.name} failed:`, error);\n   *     // Could return a custom error message or retry\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @example Authentication\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   // Check if user is authorized for this tool\n   *   if (!request.runtime.context.isAuthorized(request.tool.name)) {\n   *     return new ToolMessage({\n   *       content: \"Unauthorized to call this tool\",\n   *       tool_call_id: request.toolCall.id,\n   *     });\n   *   }\n   *   return handler(request);\n   * }\n   * ```\n   */\n  wrapToolCall?: WrapToolCallHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * Wraps the model invocation with custom logic. This allows you to:\n   * - Modify the request before calling the model\n   * - Handle errors and retry with different parameters\n   * - Post-process the response\n   * - Implement custom caching, logging, or other cross-cutting concerns\n   *\n   * The request parameter contains: model, messages, systemPrompt, tools, state, and runtime.\n   *\n   * @param request - The model request containing all the parameters needed.\n   * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response.\n   * @returns The response from the model (or a modified version).\n   *\n   * @example\n   * ```ts\n   * wrapModelCall: async (request, handler) => {\n   *   // Modify request before calling\n   *   const modifiedRequest = { ...request, systemPrompt: \"You are helpful\" };\n   *\n   *   try {\n   *     // Call the model\n   *     return await handler(modifiedRequest);\n   *   } catch (error) {\n   *     // Handle errors and retry with fallback\n   *     const fallbackRequest = { ...request, model: fallbackModel };\n   *     return await handler(fallbackRequest);\n   *   }\n   * }\n   * ```\n   */\n  wrapModelCall?: WrapModelCallHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n  /**\n   * The function to run before the agent execution starts. This function is called once at the start of the agent invocation.\n   * It allows to modify the state of the agent before any model calls or tool executions.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeAgent?: BeforeAgentHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * The function to run before the model call. This function is called before the model is invoked and before the `wrapModelCall` hook.\n   * It allows to modify the state of the agent.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeModel?: BeforeModelHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * The function to run after the model call. This function is called after the model is invoked and before any tools are called.\n   * It allows to modify the state of the agent after the model is invoked, e.g. to update tool call parameters.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterModel?: AfterModelHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n\n  /**\n   * The function to run after the agent execution completes. This function is called once at the end of the agent invocation.\n   * It allows to modify the final state of the agent after all model calls and tool executions are complete.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterAgent?: AfterAgentHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n}): AgentMiddleware<\n  TSchema,\n  TContextSchema,\n  NormalizeContextSchema<TContextSchema>,\n  TTools\n> {\n  const middleware: AgentMiddleware<\n    TSchema,\n    TContextSchema,\n    NormalizeContextSchema<TContextSchema>,\n    TTools\n  > = {\n    [MIDDLEWARE_BRAND]: true as const,\n    name: config.name,\n    stateSchema: config.stateSchema,\n    contextSchema: config.contextSchema,\n    wrapToolCall: config.wrapToolCall,\n    wrapModelCall: config.wrapModelCall,\n    beforeAgent: config.beforeAgent,\n    beforeModel: config.beforeModel,\n    afterModel: config.afterModel,\n    afterAgent: config.afterAgent,\n    tools: config.tools,\n  };\n\n  return middleware;\n}\n\ntype NormalizeContextSchema<\n  TContextSchema extends InteropZodObject | undefined = undefined,\n> = TContextSchema extends InteropZodObject\n  ? InferInteropZodOutput<TContextSchema>\n  : unknown;\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { CallbackManagerForLLMRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  BaseChatModel,\n  BaseChatModelParams,\n  BaseChatModelCallOptions,\n  BindToolsInput,\n  ToolChoice,\n} from \"@langchain/core/language_models/chat_models\";\nimport { StructuredTool } from \"@langchain/core/tools\";\nimport {\n  BaseMessage,\n  AIMessage,\n  HumanMessage,\n  BaseMessageFields,\n  AIMessageFields,\n  ToolMessage,\n  ToolMessageFields,\n} from \"@langchain/core/messages\";\nimport { ChatResult } from \"@langchain/core/outputs\";\nimport {\n  Runnable,\n  RunnableConfig,\n  RunnableLambda,\n  RunnableBinding,\n} from \"@langchain/core/runnables\";\nimport {\n  MemorySaver,\n  Checkpoint,\n  CheckpointMetadata,\n  type BaseCheckpointSaver,\n} from \"@langchain/langgraph-checkpoint\";\nimport { LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport { z } from \"zod/v3\";\n\n/**\n * Custom asymmetric matcher that matches any string value.\n * Works with both Jest and Vitest's toEqual() assertions.\n */\nclass AnyString {\n  asymmetricMatch(other: unknown): boolean {\n    return typeof other === \"string\";\n  }\n\n  toString(): string {\n    return \"Any<String>\";\n  }\n\n  toAsymmetricMatcher(): string {\n    return \"Any<String>\";\n  }\n}\n\nexport class _AnyIdAIMessage extends AIMessage {\n  get lc_id() {\n    return [\"langchain_core\", \"messages\", \"AIMessage\"];\n  }\n\n  constructor(fields: AIMessageFields | string) {\n    let fieldsWithJestMatcher: Partial<AIMessageFields> = {\n      id: new AnyString() as unknown as string,\n    };\n    if (typeof fields === \"string\") {\n      fieldsWithJestMatcher = {\n        content: fields,\n        ...fieldsWithJestMatcher,\n      };\n    } else {\n      fieldsWithJestMatcher = {\n        ...fields,\n        ...fieldsWithJestMatcher,\n      };\n    }\n    super(fieldsWithJestMatcher as AIMessageFields);\n  }\n}\n\nexport class _AnyIdHumanMessage extends HumanMessage {\n  get lc_id() {\n    return [\"langchain_core\", \"messages\", \"HumanMessage\"];\n  }\n\n  constructor(fields: BaseMessageFields | string) {\n    let fieldsWithJestMatcher: Partial<BaseMessageFields> = {\n      id: new AnyString() as unknown as string,\n    };\n    if (typeof fields === \"string\") {\n      fieldsWithJestMatcher = {\n        content: fields,\n        ...fieldsWithJestMatcher,\n      };\n    } else {\n      fieldsWithJestMatcher = {\n        ...fields,\n        ...fieldsWithJestMatcher,\n      };\n    }\n    super(fieldsWithJestMatcher as BaseMessageFields);\n  }\n}\n\nexport class _AnyIdToolMessage extends ToolMessage {\n  get lc_id() {\n    return [\"langchain_core\", \"messages\", \"ToolMessage\"];\n  }\n\n  constructor(fields: ToolMessageFields) {\n    const fieldsWithJestMatcher: Partial<ToolMessageFields> = {\n      id: new AnyString() as unknown as string,\n      ...fields,\n    };\n    super(fieldsWithJestMatcher as ToolMessageFields);\n  }\n}\n\nexport class FakeConfigurableModel extends BaseChatModel {\n  _queuedMethodOperations: Record<string, any> = {};\n\n  _chatModel: LanguageModelLike;\n\n  constructor(\n    fields: {\n      model: LanguageModelLike;\n    } & BaseChatModelParams\n  ) {\n    super(fields);\n    this._chatModel = fields.model;\n  }\n\n  _llmType() {\n    return \"fake_configurable\";\n  }\n\n  async _generate(\n    _messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    throw new Error(\"Not implemented\");\n  }\n\n  async _model() {\n    return this._chatModel;\n  }\n\n  bindTools(tools: BindToolsInput[]) {\n    const modelWithTools = new FakeConfigurableModel({\n      model: (this._chatModel as FakeToolCallingChatModel).bindTools(tools),\n    });\n    modelWithTools._queuedMethodOperations.bindTools = tools;\n    return modelWithTools;\n  }\n}\n\nexport class FakeToolCallingChatModel extends BaseChatModel {\n  sleep?: number = 50;\n\n  responses?: BaseMessage[];\n\n  thrownErrorString?: string;\n\n  idx: number;\n\n  toolStyle: \"openai\" | \"anthropic\" | \"bedrock\" | \"google\" = \"openai\";\n\n  structuredResponse?: Record<string, unknown>;\n\n  // Track messages passed to structured output calls\n  structuredOutputMessages: BaseMessage[][] = [];\n\n  constructor(\n    fields: {\n      sleep?: number;\n      responses?: BaseMessage[];\n      thrownErrorString?: string;\n      toolStyle?: \"openai\" | \"anthropic\" | \"bedrock\" | \"google\";\n      structuredResponse?: Record<string, unknown>;\n    } & BaseChatModelParams\n  ) {\n    super(fields);\n    this.sleep = fields.sleep ?? this.sleep;\n    this.responses = fields.responses;\n    this.thrownErrorString = fields.thrownErrorString;\n    this.idx = 0;\n    this.toolStyle = fields.toolStyle ?? this.toolStyle;\n    this.structuredResponse = fields.structuredResponse;\n    this.structuredOutputMessages = [];\n  }\n\n  _llmType() {\n    return \"fake\";\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n    if (this.sleep !== undefined) {\n      await new Promise((resolve) => setTimeout(resolve, this.sleep));\n    }\n    const responses = this.responses?.length ? this.responses : messages;\n    const msg = responses[this.idx % responses.length];\n    const generation: ChatResult = {\n      generations: [\n        {\n          text: \"\",\n          message: msg,\n        },\n      ],\n    };\n    this.idx += 1;\n\n    if (typeof msg.content === \"string\") {\n      await runManager?.handleLLMNewToken(msg.content);\n    }\n    return generation;\n  }\n\n  bindTools(tools: BindToolsInput[]): Runnable<any> {\n    const toolDicts = [];\n    const serverTools = [];\n    for (const tool of tools) {\n      if (!(\"name\" in tool)) {\n        serverTools.push(tool);\n        continue;\n      }\n\n      // NOTE: this is a simplified tool spec for testing purposes only\n      if (this.toolStyle === \"openai\") {\n        toolDicts.push({\n          type: \"function\",\n          function: {\n            name: tool.name,\n          },\n        });\n      } else if ([\"anthropic\", \"google\"].includes(this.toolStyle)) {\n        toolDicts.push({\n          name: tool.name,\n        });\n      } else if (this.toolStyle === \"bedrock\") {\n        toolDicts.push({\n          toolSpec: {\n            name: tool.name,\n          },\n        });\n      }\n    }\n    let toolsToBind: BindToolsInput[] = toolDicts;\n    if (this.toolStyle === \"google\") {\n      toolsToBind = [{ functionDeclarations: toolDicts }];\n    }\n    return this.withConfig({\n      tools: [...toolsToBind, ...serverTools],\n    } as BaseChatModelCallOptions);\n  }\n\n  withStructuredOutput<\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(_: unknown): Runnable<any> {\n    if (!this.structuredResponse) {\n      throw new Error(\"No structured response provided\");\n    }\n    // Create a runnable that returns the proper structured format\n    return RunnableLambda.from(async (messages: BaseMessage[]) => {\n      if (this.sleep) {\n        await new Promise((resolve) => setTimeout(resolve, this.sleep));\n      }\n\n      // Store the messages that were sent to generate structured output\n      this.structuredOutputMessages.push([...messages]);\n\n      // Return in the format expected: { raw: BaseMessage, parsed: RunOutput }\n      return this.structuredResponse as RunOutput;\n    });\n  }\n}\n\nexport class MemorySaverAssertImmutable extends MemorySaver {\n  storageForCopies: Record<string, Record<string, Uint8Array>> = {};\n\n  constructor() {\n    super();\n    this.storageForCopies = {};\n  }\n\n  async put(\n    config: RunnableConfig,\n    checkpoint: Checkpoint,\n    metadata: CheckpointMetadata\n  ): Promise<RunnableConfig> {\n    const thread_id = config.configurable?.thread_id;\n    this.storageForCopies[thread_id] ??= {};\n\n    // assert checkpoint hasn't been modified since last written\n    const saved = await this.get(config);\n    if (saved) {\n      const savedId = saved.id;\n      if (this.storageForCopies[thread_id][savedId]) {\n        const [, serializedSaved] = await this.serde.dumpsTyped(saved);\n        const serializedCopy = this.storageForCopies[thread_id][savedId];\n\n        // Compare Uint8Array contents by converting to string\n        const savedStr = new TextDecoder().decode(serializedSaved);\n        const copyStr = new TextDecoder().decode(serializedCopy);\n        if (savedStr !== copyStr) {\n          throw new Error(\n            `Checkpoint [${savedId}] has been modified since last written`\n          );\n        }\n      }\n    }\n    const [, serializedCheckpoint] = await this.serde.dumpsTyped(checkpoint);\n    // save a copy of the checkpoint\n    this.storageForCopies[thread_id][checkpoint.id] = serializedCheckpoint;\n\n    return super.put(config, checkpoint, metadata);\n  }\n}\n\ninterface ToolCall {\n  name: string;\n  args: Record<string, any>;\n  id: string;\n  type?: \"tool_call\";\n}\n\ninterface FakeToolCallingModelFields {\n  toolCalls?: ToolCall[][];\n  toolStyle?: \"openai\" | \"anthropic\";\n  index?: number;\n  structuredResponse?: any;\n}\n\n// Helper function to create checkpointer\nexport function createCheckpointer(): BaseCheckpointSaver {\n  return new MemorySaver();\n}\n\n/**\n * Fake chat model for testing tool calling functionality\n */\nexport class FakeToolCallingModel extends BaseChatModel {\n  toolCalls: ToolCall[][];\n\n  toolStyle: \"openai\" | \"anthropic\";\n\n  // Use a shared reference object so the index persists across bindTools calls\n  private indexRef: { current: number };\n\n  structuredResponse?: any;\n\n  private tools: StructuredTool[] = [];\n\n  constructor({\n    toolCalls = [],\n    toolStyle = \"openai\",\n    index = 0,\n    structuredResponse,\n    indexRef,\n    ...rest\n  }: FakeToolCallingModelFields & { indexRef?: { current: number } } = {}) {\n    super(rest);\n    this.toolCalls = toolCalls;\n    this.toolStyle = toolStyle;\n    // Share the same index reference across instances\n    this.indexRef = indexRef ?? { current: index };\n    this.structuredResponse = structuredResponse;\n  }\n\n  // Getter/setter for backwards compatibility\n  get index(): number {\n    return this.indexRef.current;\n  }\n\n  set index(value: number) {\n    this.indexRef.current = value;\n  }\n\n  _llmType(): string {\n    return \"fake-tool-calling\";\n  }\n\n  _combineLLMOutput() {\n    return [];\n  }\n\n  bindTools(\n    tools: StructuredTool[]\n  ):\n    | FakeToolCallingModel\n    | RunnableBinding<\n        any,\n        any,\n        any & { tool_choice?: ToolChoice | undefined }\n      > {\n    const newInstance = new FakeToolCallingModel({\n      toolCalls: this.toolCalls,\n      toolStyle: this.toolStyle,\n      structuredResponse: this.structuredResponse,\n      // Pass the same indexRef so all instances share the same index state\n      indexRef: this.indexRef,\n    });\n    newInstance.tools = [...this.tools, ...tools];\n    return newInstance;\n  }\n\n  withStructuredOutput(_schema: any) {\n    return new RunnableLambda({\n      func: async () => {\n        return this.structuredResponse;\n      },\n    });\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    _options?: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const lastMessage = messages[messages.length - 1];\n    let content = lastMessage.content as string;\n\n    // Handle prompt concatenation\n    if (messages.length > 1) {\n      const parts = messages.map((m) => m.content).filter(Boolean);\n      content = parts\n        .map((part) => {\n          if (typeof part === \"string\") {\n            return part;\n          } else if (typeof part === \"object\" && \"text\" in part) {\n            return part.text;\n          } else if (Array.isArray(part)) {\n            return part\n              .map((p) => {\n                if (typeof p === \"string\") {\n                  return p;\n                } else if (typeof p === \"object\" && \"text\" in p) {\n                  return p.text;\n                }\n                return \"\";\n              })\n              .join(\"-\");\n          } else {\n            return JSON.stringify(part);\n          }\n        })\n        .join(\"-\");\n    }\n\n    // Reset index at the start of a new conversation (only human message)\n    // This allows the model to be reused across multiple agent.invoke() calls\n    const isStartOfConversation =\n      messages.length === 1 ||\n      (messages.length === 2 && messages.every(HumanMessage.isInstance));\n    if (isStartOfConversation && this.index !== 0) {\n      this.index = 0;\n    }\n\n    const currentToolCalls = this.toolCalls[this.index] || [];\n    const messageId = this.index.toString();\n\n    // Move to next set of tool calls for subsequent invocations\n    this.index = (this.index + 1) % Math.max(1, this.toolCalls.length);\n\n    const message = new AIMessage({\n      content,\n      id: messageId,\n      tool_calls:\n        currentToolCalls.length > 0\n          ? currentToolCalls.map((tc) => ({\n              ...tc,\n              type: \"tool_call\" as const,\n            }))\n          : undefined,\n    });\n\n    return {\n      generations: [\n        {\n          text: content,\n          message,\n        },\n      ],\n      llmOutput: {},\n    };\n  }\n}\n\nexport class SearchAPI extends StructuredTool {\n  name = \"search_api\";\n\n  description = \"A simple API that returns the input string.\";\n\n  schema = z.object({\n    query: z.string().describe(\"The query to search for.\"),\n  });\n\n  async _call(input: z.infer<typeof this.schema>) {\n    if (input?.query === \"error\") {\n      throw new Error(\"Error\");\n    }\n    return `result for ${input?.query}`;\n  }\n}\n", "import { z as z4 } from \"zod/v4\";\nimport { z as z3 } from \"zod/v3\";\nimport {\n  getInteropZodDefaultGetter,\n  InteropZodType,\n} from \"@langchain/core/utils/types\";\nimport { SchemaMeta, withLangGraph } from \"./meta.js\";\n\nconst metaSymbol = Symbol.for(\"langgraph-zod\");\n\ninterface ZodLangGraphTypesV3<T extends z3.ZodTypeAny, Output> {\n  reducer<Input = z3.output<T>>(\n    transform: (a: Output, arg: Input) => Output,\n    options?: z3.ZodType<Input>\n  ): z3.ZodType<Output, z3.ZodEffectsDef<T>, Input>;\n\n  metadata(payload: {\n    langgraph_nodes?: string[];\n    langgraph_type?: \"prompt\";\n\n    [key: string]: unknown;\n  }): T;\n}\n\ndeclare module \"zod\" {\n  interface ZodType<Output> {\n    /**\n     * @deprecated Using the langgraph zod plugin is deprecated and will be removed in future versions\n     * Consider upgrading to zod 4 and using the exported langgraph meta registry. {@link langgraphRegistry}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    langgraph: ZodLangGraphTypesV3<any, Output>;\n  }\n}\ndeclare module \"zod/v3\" {\n  interface ZodType<Output> {\n    /**\n     * @deprecated Using the langgraph zod plugin is deprecated and will be removed in future versions\n     * Consider upgrading to zod 4 and using the exported langgraph meta registry. {@link langgraphRegistry}\n     */\n    langgraph: ZodLangGraphTypesV3<this, Output>;\n  }\n}\n\ninterface PluginGlobalType {\n  [metaSymbol]?: WeakSet<object>;\n}\n\nif (!(metaSymbol in globalThis)) {\n  (globalThis as PluginGlobalType)[metaSymbol] = new WeakSet();\n}\n\nfunction applyPluginPrototype(prototype: object) {\n  const cache = (globalThis as PluginGlobalType)[metaSymbol]!;\n  if (cache.has(prototype)) {\n    return; // Already applied\n  }\n\n  Object.defineProperty(prototype, \"langgraph\", {\n    get(this: InteropZodType) {\n      // Actual return type is provided by module augmentation\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const zodThis = this;\n\n      return {\n        metadata(jsonSchemaExtra: SchemaMeta[\"jsonSchemaExtra\"]) {\n          return withLangGraph(zodThis, { jsonSchemaExtra });\n        },\n        reducer(\n          fn: (a: unknown, arg: unknown) => unknown,\n          schema?: InteropZodType\n        ) {\n          const defaultFn = getInteropZodDefaultGetter(zodThis);\n          return withLangGraph(zodThis, {\n            default: defaultFn,\n            reducer: { schema, fn },\n          });\n        },\n      };\n    },\n  });\n  cache.add(prototype);\n}\n\ntry {\n  applyPluginPrototype(z3.ZodType.prototype);\n  applyPluginPrototype(z4.ZodType.prototype);\n} catch (error) {\n  throw new Error(\n    \"Failed to extend Zod with LangGraph-related methods. This is most likely a bug, consider opening an issue and/or using `withLangGraph` to augment your Zod schema.\",\n    { cause: error }\n  );\n}\n", "// @ts-expect-error If zod/v4 is not imported, the module augmentation will fail in build\nimport type { ZodType } from \"zod/v4\"; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n// @ts-expect-error If zod/v4-mini is not imported, the module augmentation will fail in build\nimport type { ZodMiniType } from \"zod/v4-mini\"; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nimport type * as core from \"zod/v4/core\";\nimport { getInteropZodDefaultGetter } from \"@langchain/core/utils/types\";\nimport { $ZodType, $ZodRegistry, $replace } from \"zod/v4/core\";\nimport {\n  type ReducedZodChannel,\n  type SchemaMeta,\n  type SchemaMetaRegistry,\n  schemaMetaRegistry,\n} from \"./meta.js\";\n\n/**\n * A Zod v4-compatible meta registry that extends the base registry.\n *\n * This registry allows you to associate and retrieve metadata for Zod schemas,\n * leveraging the base registry for storage. It is compatible with Zod v4 and\n * interoperates with the base registry to ensure consistent metadata management\n * across different Zod versions.\n *\n * @template Meta - The type of metadata associated with each schema.\n * @template Schema - The Zod schema type.\n */\nexport class LanggraphZodMetaRegistry<\n  Meta extends SchemaMeta = SchemaMeta,\n  Schema extends $ZodType = $ZodType\n> extends $ZodRegistry<Meta & { [key: string]: unknown }, Schema> {\n  /**\n   * Creates a new LanggraphZodMetaRegistry instance.\n   *\n   * @param parent - The base SchemaMetaRegistry to use for metadata storage.\n   */\n  constructor(protected parent: SchemaMetaRegistry) {\n    super();\n    // Use the parent's map for metadata storage\n    this._map = this.parent._map as Map<\n      Schema,\n      $replace<Meta & { [key: string]: unknown }, Schema>\n    >;\n  }\n\n  add<S extends Schema>(\n    schema: S,\n    ..._meta: undefined extends Meta & { [key: string]: unknown }\n      ? [$replace<Meta & { [key: string]: unknown }, S>?]\n      : [$replace<Meta & { [key: string]: unknown }, S>]\n  ): this {\n    const firstMeta = _meta[0];\n    if (firstMeta && !firstMeta?.default) {\n      const defaultValueGetter = getInteropZodDefaultGetter(schema);\n      if (defaultValueGetter != null) {\n        // eslint-disable-next-line no-param-reassign\n        firstMeta.default = defaultValueGetter;\n      }\n    }\n    return super.add(schema, ..._meta);\n  }\n}\n\n// Augment the zod/v4 module nudging the `register` method\n// to use the user provided input schema if specified.\ndeclare module \"zod/v4\" {\n  export interface ZodType<\n    out Output = unknown,\n    out Input = unknown,\n    out Internals extends core.$ZodTypeInternals<\n      Output,\n      Input\n    > = core.$ZodTypeInternals<Output, Input>\n  > extends core.$ZodType<Output, Input, Internals> {\n    register<\n      R extends LanggraphZodMetaRegistry,\n      TOutput = core.output<this>,\n      TInput = core.input<this>,\n      TInternals extends core.$ZodTypeInternals<\n        TOutput,\n        TInput\n      > = core.$ZodTypeInternals<TOutput, TInput>\n    >(\n      registry: R,\n      meta: SchemaMeta<TOutput, TInput>\n    ): ReducedZodChannel<this, ZodType<TOutput, TInput, TInternals>>;\n  }\n}\n\ndeclare module \"zod/v4-mini\" {\n  export interface ZodMiniType<\n    out Output = unknown,\n    out Input = unknown,\n    out Internals extends core.$ZodTypeInternals<\n      Output,\n      Input\n    > = core.$ZodTypeInternals<Output, Input>\n  > extends core.$ZodType<Output, Input, Internals> {\n    register<\n      R extends LanggraphZodMetaRegistry,\n      TOutput = core.output<this>,\n      TInput = core.input<this>,\n      TInternals extends core.$ZodTypeInternals<\n        TOutput,\n        TInput\n      > = core.$ZodTypeInternals<TOutput, TInput>\n    >(\n      registry: R,\n      meta: SchemaMeta<TOutput, TInput>\n    ): ReducedZodChannel<this, ZodMiniType<TOutput, TInput, TInternals>>;\n  }\n}\n\nexport const registry = new LanggraphZodMetaRegistry(schemaMetaRegistry);\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  StateSchema,\n  MessagesValue,\n  UntrackedValue,\n  ReducedValue,\n  type StateDefinitionInit,\n} from \"@langchain/langgraph\";\nimport { schemaMetaRegistry } from \"@langchain/langgraph/zod\";\n\nimport type { AgentMiddleware } from \"./middleware/types.js\";\nimport {\n  type InteropZodObject,\n  isZodSchemaV4,\n  getInteropZodObjectShape,\n  isInteropZodObject,\n} from \"@langchain/core/utils/types\";\n\n/**\n * Type for jumpTo navigation targets\n */\ntype JumpToTarget = \"model_request\" | \"tools\" | \"end\" | undefined;\n\nexport function createAgentState<\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  TMiddleware extends readonly AgentMiddleware<any, any, any>[] = [],\n>(\n  hasStructuredResponse = true,\n  stateSchema: TStateSchema,\n  middlewareList: TMiddleware = [] as unknown as TMiddleware\n) {\n  /**\n   * Collect fields from state schemas\n   */\n  const stateFields: Record<string, any> = {\n    // jumpTo is used for internal navigation control\n    jumpTo: new UntrackedValue<JumpToTarget>(),\n  };\n\n  // Separate shapes for input/output without reducer metadata (to avoid channel conflicts)\n  const inputFields: Record<string, any> = {};\n  const outputFields: Record<string, any> = {};\n\n  const applySchema = (schema: InteropZodObject | StateSchema<any>) => {\n    // Handle StateSchema: extract from .fields\n    if (StateSchema.isInstance(schema)) {\n      for (const [key, field] of Object.entries(schema.fields)) {\n        if (key.startsWith(\"_\")) {\n          continue;\n        }\n        if (!(key in stateFields)) {\n          // Add to stateFields to preserve ReducedValue/UntrackedValue behavior\n          stateFields[key] = field;\n\n          // For ioFields, extract the appropriate schema from ReducedValue\n          if (ReducedValue.isInstance(field)) {\n            // For input, use inputSchema if available, otherwise use the value schema\n            inputFields[key] = field.inputSchema || field.valueSchema;\n            outputFields[key] = field.valueSchema;\n          } else {\n            // For non-ReducedValue fields, use the field as-is\n            inputFields[key] = field;\n            outputFields[key] = field;\n          }\n        }\n      }\n      return;\n    }\n\n    // Handle Zod v3/v4: extract shape using interop utilities\n    const shape = getInteropZodObjectShape(schema);\n    for (const [key, fieldSchema] of Object.entries(shape)) {\n      // Skip private state properties (prefixed with underscore)\n      if (key.startsWith(\"_\")) {\n        continue;\n      }\n      if (!(key in stateFields)) {\n        // Check for reducer metadata (Zod v4 only supports schemaMetaRegistry)\n        if (isZodSchemaV4(fieldSchema)) {\n          const meta = schemaMetaRegistry.get(fieldSchema);\n          if (meta?.reducer) {\n            // Wrap with ReducedValue to preserve reducer behavior\n            if (meta.reducer.schema) {\n              stateFields[key] = new ReducedValue(fieldSchema as any, {\n                inputSchema: meta.reducer.schema as any,\n                reducer: meta.reducer.fn,\n              });\n              // For input, use the inputSchema\n              inputFields[key] = meta.reducer.schema;\n              outputFields[key] = fieldSchema;\n            } else {\n              stateFields[key] = new ReducedValue(fieldSchema as any, {\n                reducer: meta.reducer.fn,\n              });\n              // No inputSchema, use the value schema\n              inputFields[key] = fieldSchema;\n              outputFields[key] = fieldSchema;\n            }\n            continue;\n          }\n        }\n\n        // No reducer - use schema directly\n        stateFields[key] = fieldSchema;\n        inputFields[key] = fieldSchema;\n        outputFields[key] = fieldSchema;\n      }\n    }\n  };\n\n  /**\n   * Add state schema properties from user-provided schema.\n   * Supports both StateSchema and Zod v3/v4 objects.\n   */\n  if (\n    stateSchema &&\n    (StateSchema.isInstance(stateSchema) || isInteropZodObject(stateSchema))\n  ) {\n    applySchema(stateSchema);\n  }\n\n  /**\n   * Add state schema properties from middleware.\n   * Supports both StateSchema and Zod v3/v4 objects.\n   */\n  for (const middleware of middlewareList) {\n    if (\n      middleware.stateSchema &&\n      (StateSchema.isInstance(middleware.stateSchema) ||\n        isInteropZodObject(middleware.stateSchema))\n    ) {\n      applySchema(middleware.stateSchema);\n    }\n  }\n\n  // Only include structuredResponse when responseFormat is defined\n  if (hasStructuredResponse) {\n    outputFields.structuredResponse = new UntrackedValue<any>();\n  }\n\n  /**\n   * Create StateSchema instances for state, input, and output.\n   * Using MessagesValue provides the proper message reducer behavior.\n   */\n  return {\n    state: new StateSchema({\n      messages: MessagesValue,\n      ...stateFields,\n    }),\n    input: new StateSchema({\n      messages: MessagesValue,\n      ...inputFields,\n    }),\n    output: new StateSchema({\n      messages: MessagesValue,\n      ...outputFields,\n    }),\n  };\n}\n", "import {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  BaseMessageLike,\n  SystemMessage,\n  MessageContent,\n  ToolMessage,\n} from \"@langchain/core/messages\";\nimport { isCommand, StateSchema } from \"@langchain/langgraph\";\nimport {\n  type InteropZodObject,\n  interopParse,\n  isInteropZodSchema,\n} from \"@langchain/core/utils/types\";\nimport {\n  BaseChatModel,\n  type BaseChatModelCallOptions,\n} from \"@langchain/core/language_models/chat_models\";\nimport {\n  LanguageModelLike,\n  BaseLanguageModelInput,\n} from \"@langchain/core/language_models/base\";\nimport {\n  Runnable,\n  RunnableLike,\n  RunnableConfig,\n  RunnableSequence,\n  RunnableBinding,\n} from \"@langchain/core/runnables\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\n\nimport { isBaseChatModel, isConfigurableModel } from \"./model.js\";\nimport { MultipleToolsBoundError, MiddlewareError } from \"./errors.js\";\nimport type { AgentBuiltInState } from \"./runtime.js\";\nimport type {\n  ToolCallHandler,\n  AgentMiddleware,\n  ToolCallRequest,\n  WrapToolCallHook,\n} from \"./middleware/types.js\";\n\nconst NAME_PATTERN = /<name>(.*?)<\\/name>/s;\nconst CONTENT_PATTERN = /<content>(.*?)<\\/content>/s;\n\n/**\n * Parse middleware state from the full agent state based on the middleware's stateSchema.\n *\n * Handles two types of state schemas:\n * 1. Zod schemas (v3 or v4) - parsed using interopParse\n * 2. LangGraph StateSchema - extracts only the keys defined in `fields`\n *\n * @param stateSchema - The middleware's state schema (Zod or LangGraph StateSchema)\n * @param state - The full agent state to parse from\n * @returns Parsed state containing only the keys defined in the schema\n */\nfunction parseMiddlewareState(\n  stateSchema: unknown,\n  state: Record<string, unknown>\n): Record<string, unknown> {\n  // Handle LangGraph StateSchema (has `fields` property)\n  if (StateSchema.isInstance(stateSchema)) {\n    const result: Record<string, unknown> = {};\n    for (const key of Object.keys(stateSchema.fields)) {\n      if (key in state) {\n        result[key] = state[key];\n      }\n    }\n    return result;\n  }\n\n  // Handle Zod schemas using interopParse\n  if (isInteropZodSchema(stateSchema)) {\n    return interopParse(stateSchema as InteropZodObject, state);\n  }\n\n  throw new Error(`Invalid state schema type: ${typeof stateSchema}`);\n}\n\nexport type AgentNameMode = \"inline\";\n\n/**\n * Attach formatted agent names to the messages passed to and from a language model.\n *\n * This is useful for making a message history with multiple agents more coherent.\n *\n * NOTE: agent name is consumed from the message.name field.\n * If you're using an agent built with createAgent, name is automatically set.\n * If you're building a custom agent, make sure to set the name on the AI message returned by the LLM.\n *\n * @param message - Message to add agent name formatting to\n * @returns Message with agent name formatting\n *\n * @internal\n */\nexport function _addInlineAgentName<T extends BaseMessageLike>(\n  message: T\n): T | AIMessage {\n  if (!AIMessage.isInstance(message) || AIMessageChunk.isInstance(message)) {\n    return message;\n  }\n\n  if (!message.name) {\n    return message;\n  }\n\n  const { name } = message;\n\n  if (typeof message.content === \"string\") {\n    return new AIMessage({\n      ...message.lc_kwargs,\n      content: `<name>${name}</name><content>${message.content}</content>`,\n      name: undefined,\n    });\n  }\n\n  const updatedContent = [];\n  let textBlockCount = 0;\n\n  for (const contentBlock of message.content) {\n    if (typeof contentBlock === \"string\") {\n      textBlockCount += 1;\n      updatedContent.push(\n        `<name>${name}</name><content>${contentBlock}</content>`\n      );\n    } else if (\n      typeof contentBlock === \"object\" &&\n      \"type\" in contentBlock &&\n      contentBlock.type === \"text\"\n    ) {\n      textBlockCount += 1;\n      updatedContent.push({\n        ...contentBlock,\n        text: `<name>${name}</name><content>${contentBlock.text}</content>`,\n      });\n    } else {\n      updatedContent.push(contentBlock);\n    }\n  }\n\n  if (!textBlockCount) {\n    updatedContent.unshift({\n      type: \"text\",\n      text: `<name>${name}</name><content></content>`,\n    });\n  }\n  return new AIMessage({\n    ...message.lc_kwargs,\n    content: updatedContent as MessageContent,\n    name: undefined,\n  });\n}\n\n/**\n * Remove explicit name and content XML tags from the AI message content.\n *\n * Examples:\n *\n * @example\n * ```typescript\n * removeInlineAgentName(new AIMessage({ content: \"<name>assistant</name><content>Hello</content>\", name: \"assistant\" }))\n * // AIMessage with content: \"Hello\"\n *\n * removeInlineAgentName(new AIMessage({ content: [{type: \"text\", text: \"<name>assistant</name><content>Hello</content>\"}], name: \"assistant\" }))\n * // AIMessage with content: [{type: \"text\", text: \"Hello\"}]\n * ```\n *\n * @internal\n */\nexport function _removeInlineAgentName<T extends BaseMessage>(message: T): T {\n  if (!AIMessage.isInstance(message) || !message.content) {\n    return message;\n  }\n\n  let updatedContent: MessageContent = [];\n  let updatedName: string | undefined;\n\n  if (Array.isArray(message.content)) {\n    updatedContent = message.content\n      .filter((block) => {\n        if (block.type === \"text\" && typeof block.text === \"string\") {\n          const nameMatch = block.text.match(NAME_PATTERN);\n          const contentMatch = block.text.match(CONTENT_PATTERN);\n          // don't include empty content blocks that were added because there was no text block to modify\n          if (nameMatch && (!contentMatch || contentMatch[1] === \"\")) {\n            // capture name from text block\n            updatedName = nameMatch[1];\n            return false;\n          }\n          return true;\n        }\n        return true;\n      })\n      .map((block) => {\n        if (block.type === \"text\" && typeof block.text === \"string\") {\n          const nameMatch = block.text.match(NAME_PATTERN);\n          const contentMatch = block.text.match(CONTENT_PATTERN);\n\n          if (!nameMatch || !contentMatch) {\n            return block;\n          }\n\n          // capture name from text block\n          updatedName = nameMatch[1];\n\n          return {\n            ...block,\n            text: contentMatch[1],\n          };\n        }\n        return block;\n      });\n  } else {\n    const content = message.content as string;\n    const nameMatch = content.match(NAME_PATTERN);\n    const contentMatch = content.match(CONTENT_PATTERN);\n\n    if (!nameMatch || !contentMatch) {\n      return message;\n    }\n\n    updatedName = nameMatch[1];\n    updatedContent = contentMatch[1];\n  }\n\n  return new AIMessage({\n    ...(Object.keys(message.lc_kwargs ?? {}).length > 0\n      ? message.lc_kwargs\n      : message),\n    content: updatedContent,\n    name: updatedName,\n  }) as T;\n}\n\nexport function isClientTool(\n  tool: ClientTool | ServerTool\n): tool is ClientTool {\n  return Runnable.isRunnable(tool);\n}\n\n/**\n * Helper function to check if a language model has a bindTools method.\n * @param llm - The language model to check if it has a bindTools method.\n * @returns True if the language model has a bindTools method, false otherwise.\n */\nfunction _isChatModelWithBindTools(\n  llm: LanguageModelLike\n): llm is BaseChatModel & Required<Pick<BaseChatModel, \"bindTools\">> {\n  if (!isBaseChatModel(llm)) return false;\n  return \"bindTools\" in llm && typeof llm.bindTools === \"function\";\n}\n\n/**\n * Helper function to bind tools to a language model.\n * @param llm - The language model to bind tools to.\n * @param toolClasses - The tools to bind to the language model.\n * @param options - The options to pass to the language model.\n * @returns The language model with the tools bound to it.\n */\nconst _simpleBindTools = (\n  llm: LanguageModelLike,\n  toolClasses: (ClientTool | ServerTool)[],\n  options: Partial<BaseChatModelCallOptions> = {}\n) => {\n  if (_isChatModelWithBindTools(llm)) {\n    return llm.bindTools(toolClasses, options);\n  }\n\n  if (\n    RunnableBinding.isRunnableBinding(llm) &&\n    _isChatModelWithBindTools(llm.bound)\n  ) {\n    const newBound = llm.bound.bindTools(toolClasses, options);\n\n    if (RunnableBinding.isRunnableBinding(newBound)) {\n      return new RunnableBinding({\n        bound: newBound.bound,\n        config: { ...llm.config, ...newBound.config },\n        kwargs: { ...llm.kwargs, ...newBound.kwargs },\n        configFactories: newBound.configFactories ?? llm.configFactories,\n      });\n    }\n\n    return new RunnableBinding({\n      bound: newBound,\n      config: llm.config,\n      kwargs: llm.kwargs,\n      configFactories: llm.configFactories,\n    });\n  }\n\n  return null;\n};\n\n/**\n * Check if the LLM already has bound tools and throw if it does.\n *\n * @param llm - The LLM to check.\n * @returns void\n */\nexport function validateLLMHasNoBoundTools(llm: LanguageModelLike): void {\n  /**\n   * If llm is a function, we can't validate until runtime, so skip\n   */\n  if (typeof llm === \"function\") {\n    return;\n  }\n\n  let model = llm;\n\n  /**\n   * If model is a RunnableSequence, find a RunnableBinding in its steps\n   */\n  if (RunnableSequence.isRunnableSequence(model)) {\n    model =\n      model.steps.find((step: RunnableLike) =>\n        RunnableBinding.isRunnableBinding(step)\n      ) || model;\n  }\n\n  /**\n   * If model is configurable, get the underlying model\n   */\n  if (isConfigurableModel(model)) {\n    /**\n     * Can't validate async model retrieval in constructor\n     */\n    return;\n  }\n\n  /**\n   * Check if model is a RunnableBinding with bound tools\n   */\n  if (RunnableBinding.isRunnableBinding(model)) {\n    const hasToolsInKwargs =\n      model.kwargs != null &&\n      typeof model.kwargs === \"object\" &&\n      \"tools\" in model.kwargs &&\n      Array.isArray(model.kwargs.tools) &&\n      model.kwargs.tools.length > 0;\n\n    const hasToolsInConfig =\n      model.config != null &&\n      typeof model.config === \"object\" &&\n      \"tools\" in model.config &&\n      Array.isArray(model.config.tools) &&\n      model.config.tools.length > 0;\n\n    if (hasToolsInKwargs || hasToolsInConfig) {\n      throw new MultipleToolsBoundError();\n    }\n  }\n\n  /**\n   * Also check if model has tools property directly (e.g., FakeToolCallingModel)\n   */\n  if (\n    \"tools\" in model &&\n    model.tools !== undefined &&\n    Array.isArray(model.tools) &&\n    model.tools.length > 0\n  ) {\n    throw new MultipleToolsBoundError();\n  }\n}\n\n/**\n * Check if the last message in the messages array has tool calls.\n *\n * @param messages - The messages to check.\n * @returns True if the last message has tool calls, false otherwise.\n */\nexport function hasToolCalls(message?: BaseMessage): boolean {\n  return Boolean(\n    AIMessage.isInstance(message) &&\n      message.tool_calls &&\n      message.tool_calls.length > 0\n  );\n}\n\n/**\n * Normalizes a system prompt to a SystemMessage object.\n * If it's already a SystemMessage, returns it as-is.\n * If it's a string, converts it to a SystemMessage.\n * If it's undefined, creates an empty system message so it is easier to append to it later.\n */\nexport function normalizeSystemPrompt(\n  systemPrompt?: string | SystemMessage\n): SystemMessage {\n  if (systemPrompt == null) {\n    return new SystemMessage(\"\");\n  }\n  if (SystemMessage.isInstance(systemPrompt)) {\n    return systemPrompt;\n  }\n  if (typeof systemPrompt === \"string\") {\n    return new SystemMessage({\n      content: [{ type: \"text\", text: systemPrompt }],\n    });\n  }\n  throw new Error(\n    `Invalid systemPrompt type: expected string or SystemMessage, got ${typeof systemPrompt}`\n  );\n}\n\n/**\n * Helper function to bind tools to a language model.\n * @param llm - The language model to bind tools to.\n * @param toolClasses - The tools to bind to the language model.\n * @param options - The options to pass to the language model.\n * @returns The language model with the tools bound to it.\n */\nexport async function bindTools(\n  llm: LanguageModelLike,\n  toolClasses: (ClientTool | ServerTool)[],\n  options: Partial<BaseChatModelCallOptions> = {}\n): Promise<\n  | RunnableSequence<unknown, unknown>\n  | RunnableBinding<unknown, unknown, RunnableConfig<Record<string, unknown>>>\n  | Runnable<BaseLanguageModelInput, AIMessageChunk, BaseChatModelCallOptions>\n> {\n  const model = _simpleBindTools(llm, toolClasses, options);\n  if (model) return model;\n\n  if (isConfigurableModel(llm)) {\n    const model = _simpleBindTools(\n      await llm._getModelInstance(),\n      toolClasses,\n      options\n    );\n    if (model) return model;\n  }\n\n  if (RunnableSequence.isRunnableSequence(llm)) {\n    const modelStep = llm.steps.findIndex(\n      (step) =>\n        RunnableBinding.isRunnableBinding(step) ||\n        isBaseChatModel(step) ||\n        isConfigurableModel(step)\n    );\n\n    if (modelStep >= 0) {\n      const model = _simpleBindTools(\n        llm.steps[modelStep],\n        toolClasses,\n        options\n      );\n      if (model) {\n        const nextSteps: unknown[] = llm.steps.slice();\n        nextSteps.splice(modelStep, 1, model);\n\n        return RunnableSequence.from(\n          nextSteps as [RunnableLike, ...RunnableLike[], RunnableLike]\n        );\n      }\n    }\n  }\n\n  throw new Error(`llm ${llm} must define bindTools method.`);\n}\n\n/**\n * Compose multiple wrapToolCall handlers into a single middleware stack.\n *\n * Composes handlers so the first in the list becomes the outermost layer.\n * Each handler receives a handler callback to execute inner layers.\n *\n * @param handlers - List of handlers. First handler wraps all others.\n * @returns Composed handler, or undefined if handlers array is empty.\n *\n * @example\n * ```typescript\n * // handlers=[auth, retry] means: auth wraps retry\n * // Flow: auth calls retry, retry calls base handler\n * const auth: ToolCallWrapper = async (request, handler) => {\n *   try {\n *     return await handler(request);\n *   } catch (error) {\n *     if (error.message === \"Unauthorized\") {\n *       await refreshToken();\n *       return await handler(request);\n *     }\n *     throw error;\n *   }\n * };\n *\n * const retry: ToolCallWrapper = async (request, handler) => {\n *   for (let attempt = 0; attempt < 3; attempt++) {\n *     try {\n *       return await handler(request);\n *     } catch (error) {\n *       if (attempt === 2) throw error;\n *     }\n *   }\n *   throw new Error(\"Unreachable\");\n * };\n *\n * const composedHandler = chainToolCallHandlers([auth, retry]);\n * ```\n */\nfunction chainToolCallHandlers(\n  handlers: WrapToolCallHook[]\n): WrapToolCallHook | undefined {\n  if (handlers.length === 0) {\n    return undefined;\n  }\n\n  if (handlers.length === 1) {\n    return handlers[0];\n  }\n\n  // Compose two handlers where outer wraps inner\n  // The key is to properly propagate request modifications through the chain\n  function composeTwo(\n    outer: WrapToolCallHook,\n    inner: WrapToolCallHook\n  ): WrapToolCallHook {\n    return async (request, handler) => {\n      // Create a wrapper that calls inner with the base handler\n      // The innerHandler receives the (possibly modified) request from outer\n      // and passes it to inner, which then calls the base handler\n      const innerHandler: ToolCallHandler = async (passedRequest) => {\n        // inner receives the request passed by outer (which may be modified)\n        return inner(passedRequest, handler);\n      };\n\n      // Call outer with the wrapped inner as its handler\n      return outer(request, innerHandler);\n    };\n  }\n\n  // Compose right-to-left: outer(inner(innermost(handler)))\n  let result = handlers[handlers.length - 1];\n  for (let i = handlers.length - 2; i >= 0; i--) {\n    result = composeTwo(handlers[i], result);\n  }\n\n  return result;\n}\n\n/**\n * Wrapping `wrapToolCall` invocation so we can inject middleware name into\n * the error message.\n *\n * @param middleware list of middleware passed to the agent\n * @param state state of the agent\n * @returns single wrap function\n */\nexport function wrapToolCall(\n  middleware: readonly AgentMiddleware<InteropZodObject | undefined>[]\n) {\n  const middlewareWithWrapToolCall = middleware.filter((m) => m.wrapToolCall);\n\n  if (middlewareWithWrapToolCall.length === 0) {\n    return;\n  }\n\n  return chainToolCallHandlers(\n    middlewareWithWrapToolCall.map((m) => {\n      const originalHandler = m.wrapToolCall!;\n      /**\n       * Wrap with error handling and validation\n       */\n      const wrappedHandler: WrapToolCallHook = async (request, handler) => {\n        /**\n         * Capture the original state for this middleware's schema parsing.\n         * This is important because the request may be modified (via override)\n         * as it passes through the middleware chain, but each middleware\n         * should always see the full original state for its schema parsing.\n         */\n        const originalState = request.state;\n\n        /**\n         * Create a handler that preserves state parsing for this middleware\n         * while allowing tool/toolCall/state modifications from inner middleware\n         */\n        const wrappedInnerHandler: ToolCallHandler = async (passedRequest) => {\n          /**\n           * Merge the passed request with the original state for parsing.\n           * This ensures middleware can override tool/toolCall while\n           * maintaining proper state parsing for each middleware in the chain.\n           */\n          const mergedState = {\n            ...originalState,\n            ...passedRequest.state,\n          };\n          return handler({\n            ...passedRequest,\n            state: mergedState,\n          });\n        };\n\n        try {\n          const result = await originalHandler(\n            {\n              ...request,\n              /**\n               * override state with the state from the specific middleware\n               */\n              state: {\n                messages: originalState.messages,\n                ...(m.stateSchema\n                  ? parseMiddlewareState(m.stateSchema, { ...originalState })\n                  : {}),\n              },\n            } as ToolCallRequest<AgentBuiltInState, unknown>,\n            wrappedInnerHandler\n          );\n\n          /**\n           * Validate return type\n           */\n          if (!ToolMessage.isInstance(result) && !isCommand(result)) {\n            throw new Error(\n              `Invalid response from \"wrapToolCall\" in middleware \"${m.name}\": ` +\n                `expected ToolMessage or Command, got ${typeof result}`\n            );\n          }\n\n          return result;\n        } catch (error) {\n          throw MiddlewareError.wrap(error, m.name);\n        }\n      };\n      return wrappedHandler;\n    })\n  );\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z } from \"zod/v4\";\nimport { type BaseMessage } from \"@langchain/core/messages\";\nimport {\n  interopSafeParseAsync,\n  interopZodObjectMakeFieldsOptional,\n  interopZodObjectPartial,\n  isInteropZodObject,\n  isZodSchemaV4,\n  type InteropZodObject,\n} from \"@langchain/core/utils/types\";\nimport type { StateDefinitionInit } from \"@langchain/langgraph\";\nimport { END, StateSchema, ReducedValue } from \"@langchain/langgraph\";\n\nimport type { JumpTo } from \"../types.js\";\nimport type { AgentMiddleware } from \"../middleware/types.js\";\n\n/**\n * Helper function to initialize middleware state defaults.\n * This is used to ensure all middleware state properties are initialized.\n *\n * Private properties (starting with _) are automatically made optional since\n * users cannot provide them when invoking the agent.\n */\nexport async function initializeMiddlewareStates(\n  middlewareList: readonly AgentMiddleware[],\n  state: unknown\n): Promise<Record<string, any>> {\n  const middlewareStates: Record<string, any> = {};\n\n  for (const middleware of middlewareList) {\n    /**\n     * skip middleware if it doesn't have a state schema\n     */\n    if (!middleware.stateSchema) {\n      continue;\n    }\n\n    // Convert StateSchema to Zod object if needed\n    let zodSchema = middleware.stateSchema;\n    if (StateSchema.isInstance(middleware.stateSchema)) {\n      const zodShape: Record<string, any> = {};\n      for (const [key, field] of Object.entries(\n        middleware.stateSchema.fields\n      )) {\n        if (ReducedValue.isInstance(field)) {\n          // For ReducedValue, use inputSchema if available, otherwise valueSchema\n          zodShape[key] = field.inputSchema || field.valueSchema;\n        } else {\n          zodShape[key] = field;\n        }\n      }\n      zodSchema = z.object(zodShape);\n    }\n\n    // Create a modified schema where private properties are optional\n    const modifiedSchema = interopZodObjectMakeFieldsOptional(\n      zodSchema,\n      (key) => key.startsWith(\"_\")\n    );\n\n    // Use safeParse with the modified schema\n    const parseResult = await interopSafeParseAsync(modifiedSchema, state);\n    if (parseResult.success) {\n      Object.assign(middlewareStates, parseResult.data);\n      continue;\n    }\n\n    /**\n     * If safeParse fails, there are required public fields missing.\n     * Note: Zod v3 uses message \"Required\", Zod v4 uses \"Invalid input: expected X, received undefined\"\n     */\n    const requiredFields = parseResult.error.issues\n      .filter((issue) => issue.code === \"invalid_type\")\n      .map((issue) => `  - ${issue.path.join(\".\")}: Required`)\n      .join(\"\\n\");\n\n    throw new Error(\n      `Middleware \"${middleware.name}\" has required state fields that must be initialized:\\n` +\n        `${requiredFields}\\n\\n` +\n        `To fix this, either:\\n` +\n        `1. Provide default values in your middleware's state schema using .default():\\n` +\n        `   stateSchema: z.object({\\n` +\n        `     myField: z.string().default(\"default value\")\\n` +\n        `   })\\n\\n` +\n        `2. Or make the fields optional using .optional():\\n` +\n        `   stateSchema: z.object({\\n` +\n        `     myField: z.string().optional()\\n` +\n        `   })\\n\\n` +\n        `3. Or ensure you pass these values when invoking the agent:\\n` +\n        `   agent.invoke({\\n` +\n        `     messages: [...],\\n` +\n        `     ${parseResult.error.issues[0]?.path.join(\".\")}: \"value\"\\n` +\n        `   })`\n    );\n  }\n\n  return middlewareStates;\n}\n\n/**\n * Users can define private and public state for a middleware. Private state properties start with an underscore.\n * This function will return the private state properties from the state schema, making all of them optional.\n * @param stateSchema - The middleware state schema\n * @returns A new schema containing only the private properties (underscore-prefixed), all made optional\n */\nexport function derivePrivateState(\n  stateSchema?: z.ZodObject<z.ZodRawShape> | StateSchema<any>\n): z.ZodObject<z.ZodRawShape> {\n  const builtInStateSchema = {\n    messages: z.custom<BaseMessage[]>(() => []),\n    // Include optional structuredResponse so after_agent hooks can access/modify it\n    structuredResponse: z.any().optional(),\n  };\n\n  if (!stateSchema) {\n    return z.object(builtInStateSchema);\n  }\n\n  // Extract shape from either StateSchema or Zod object\n  let shape: Record<string, any>;\n  if (StateSchema.isInstance(stateSchema)) {\n    // For StateSchema, extract Zod schemas from fields\n    shape = {};\n    for (const [key, field] of Object.entries(stateSchema.fields)) {\n      if (ReducedValue.isInstance(field)) {\n        // For ReducedValue, use inputSchema if available, otherwise valueSchema\n        shape[key] = field.inputSchema || field.valueSchema;\n      } else {\n        shape[key] = field;\n      }\n    }\n  } else {\n    shape = stateSchema.shape;\n  }\n\n  const privateShape: Record<string, any> = { ...builtInStateSchema };\n\n  // Filter properties that start with underscore and make them optional\n  for (const [key, value] of Object.entries(shape)) {\n    if (key.startsWith(\"_\")) {\n      // Make the private property optional\n      privateShape[key] = value.optional();\n    } else {\n      privateShape[key] = value;\n    }\n  }\n\n  // Return a new schema with only private properties (all optional)\n  return z.object(privateShape);\n}\n\n/**\n * Converts any supported schema type (ZodObject, StateSchema, AnnotationRoot) to a partial Zod object.\n * This is useful for parsing state loosely where all fields are optional.\n *\n * @param schema - The schema to convert (InteropZodObject, StateSchema, or AnnotationRoot)\n * @returns A partial Zod object schema where all fields are optional\n */\nexport function toPartialZodObject(\n  schema: StateDefinitionInit\n): InteropZodObject {\n  // Handle ZodObject directly\n  if (isInteropZodObject(schema)) {\n    return interopZodObjectPartial(schema);\n  }\n\n  // Handle StateSchema: convert fields to Zod shape, then make partial\n  if (StateSchema.isInstance(schema)) {\n    const partialShape: Record<string, any> = {};\n    for (const [key, field] of Object.entries(schema.fields)) {\n      let fieldSchema: unknown;\n      if (ReducedValue.isInstance(field)) {\n        // For ReducedValue, use inputSchema if available, otherwise valueSchema\n        fieldSchema = field.inputSchema || field.valueSchema;\n      } else {\n        fieldSchema = field;\n      }\n      // Only call .optional() on Zod v4 schemas, otherwise use z.any()\n      partialShape[key] = isZodSchemaV4(fieldSchema)\n        ? (fieldSchema as any).optional()\n        : z.any().optional();\n    }\n    return z.object(partialShape);\n  }\n\n  // Fallback: return empty object schema\n  return z.object({});\n}\n\n/**\n * Parse `jumpTo` target from user facing labels to a LangGraph node names\n */\nexport function parseJumpToTarget(target: string): JumpTo;\nexport function parseJumpToTarget(target?: string): JumpTo | undefined {\n  if (!target) {\n    return undefined;\n  }\n\n  /**\n   * if target is already a valid jump target, return it\n   */\n  if ([\"model_request\", \"tools\", END].includes(target)) {\n    return target as JumpTo;\n  }\n\n  if (target === \"model\") {\n    return \"model_request\";\n  }\n  if (target === \"tools\") {\n    return \"tools\";\n  }\n  if (target === \"end\") {\n    return END;\n  }\n\n  throw new Error(\n    `Invalid jump target: ${target}, must be \"model\", \"tools\" or \"end\".`\n  );\n}\n\n/**\n * TypeScript currently doesn't support types for `AbortSignal.any`\n * @see https://github.com/microsoft/TypeScript/issues/60695\n */\ndeclare const AbortSignal: {\n  any(signals: AbortSignal[]): AbortSignal;\n};\n\n/**\n * `config` always contains a signal from LangGraphs Pregel class.\n * To ensure we acknowledge the abort signal from the user, we merge it\n * with the signal from the ToolNode.\n *\n * @param signals - The signals to merge.\n * @returns The merged signal.\n */\nexport function mergeAbortSignals(\n  ...signals: (AbortSignal | undefined)[]\n): AbortSignal {\n  return AbortSignal.any(\n    signals.filter(\n      (maybeSignal): maybeSignal is AbortSignal =>\n        maybeSignal !== null &&\n        maybeSignal !== undefined &&\n        typeof maybeSignal === \"object\" &&\n        \"aborted\" in maybeSignal &&\n        typeof maybeSignal.aborted === \"boolean\"\n    )\n  );\n}\n", "import {\n  mergeConfigs,\n  Runnable,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\n\nexport interface RunnableCallableArgs<I, O> {\n  /**\n   * The name of the runnable.\n   */\n  name?: string;\n  /**\n   * The function to call.\n   */\n  func: (...args: I[]) => O | Promise<O>;\n  /**\n   * The tags to add to the runnable.\n   */\n  tags?: string[];\n  /**\n   * Whether to recurse the runnable.\n   */\n  recurse?: boolean;\n}\n\nexport class RunnableCallable<I = unknown, O = unknown> extends Runnable<I, O> {\n  lc_namespace: string[] = [\"langgraph\"];\n\n  func: RunnableCallableArgs<I, O>[\"func\"];\n\n  tags?: RunnableCallableArgs<I, O>[\"tags\"];\n\n  config?: RunnableConfig;\n\n  trace = true;\n\n  recurse = true;\n\n  #state: Awaited<O>;\n\n  constructor(fields: RunnableCallableArgs<I, O>) {\n    super();\n    this.name = fields.name ?? fields.func.name;\n    this.func = fields.func;\n    this.config = fields.tags ? { tags: fields.tags } : undefined;\n    this.recurse = fields.recurse ?? this.recurse;\n  }\n\n  getState(): Awaited<O> {\n    return this.#state;\n  }\n\n  /**\n   * This allows us to set the state of the runnable, e.g. for model and middleware nodes.\n   * @internal\n   */\n  setState(state: Awaited<O>) {\n    this.#state = {\n      ...this.#state,\n      ...state,\n    };\n  }\n\n  async invoke(\n    input: I,\n    options?: Partial<RunnableConfig> | undefined\n  ): Promise<O> {\n    const mergedConfig = mergeConfigs(this.config, options);\n\n    const returnValue = await AsyncLocalStorageProviderSingleton.runWithConfig(\n      mergedConfig,\n      async () => this.func(input, mergedConfig as I)\n    );\n\n    if (Runnable.isRunnable(returnValue) && this.recurse) {\n      return await AsyncLocalStorageProviderSingleton.runWithConfig(\n        mergedConfig,\n        async () => (returnValue as Runnable<I, O>).invoke(input, mergedConfig)\n      );\n    }\n\n    this.#state = returnValue;\n    return returnValue;\n  }\n}\n", "import { BaseMessage, BaseMessageLike } from \"@langchain/core/messages\";\nimport { LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport {\n  Runnable,\n  RunnableLambda,\n  RunnableSequence,\n  type RunnableConfig,\n} from \"@langchain/core/runnables\";\n\nimport {\n  AgentNameMode,\n  _addInlineAgentName,\n  _removeInlineAgentName,\n} from \"./utils.js\";\n\n/**\n * Attach formatted agent names to the messages passed to and from a language model.\n *\n * This is useful for making a message history with multiple agents more coherent.\n *\n * NOTE: agent name is consumed from the message.name field.\n * If you're using an agent built with createAgent, name is automatically set.\n * If you're building a custom agent, make sure to set the name on the AI message returned by the LLM.\n *\n * @param model - Language model to add agent name formatting to\n * @param agentNameMode - How to expose the agent name to the LLM\n *   - \"inline\": Add the agent name directly into the content field of the AI message using XML-style tags.\n *     Example: \"How can I help you\" -> \"<name>agent_name</name><content>How can I help you?</content>\".\n */\nexport function withAgentName(\n  model:\n    | LanguageModelLike\n    | Runnable<unknown, unknown, RunnableConfig<Record<string, unknown>>>,\n  agentNameMode: AgentNameMode\n): LanguageModelLike {\n  let processInputMessage: (message: BaseMessageLike) => BaseMessageLike;\n  let processOutputMessage: (message: BaseMessage) => BaseMessage;\n\n  if (agentNameMode === \"inline\") {\n    processInputMessage = _addInlineAgentName;\n    processOutputMessage = _removeInlineAgentName;\n  } else {\n    throw new Error(\n      `Invalid agent name mode: ${agentNameMode}. Needs to be one of: \"inline\"`\n    );\n  }\n\n  function processInputMessages(\n    messages: BaseMessageLike[]\n  ): BaseMessageLike[] {\n    return messages.map(processInputMessage);\n  }\n\n  return RunnableSequence.from([\n    RunnableLambda.from(processInputMessages),\n    model,\n    RunnableLambda.from(processOutputMessage),\n  ]);\n}\n", "/* eslint-disable no-instanceof/no-instanceof */\nimport { Runnable, RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  BaseMessage,\n  AIMessage,\n  ToolMessage,\n  SystemMessage,\n} from \"@langchain/core/messages\";\nimport { Command, type LangGraphRunnableConfig } from \"@langchain/langgraph\";\nimport { type LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport { type BaseChatModelCallOptions } from \"@langchain/core/language_models/chat_models\";\nimport {\n  InteropZodObject,\n  getSchemaDescription,\n  interopParse,\n} from \"@langchain/core/utils/types\";\nimport { raceWithSignal } from \"@langchain/core/runnables\";\nimport type { ToolCall } from \"@langchain/core/messages/tool\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\n\nimport { initChatModel } from \"../../chat_models/universal.js\";\nimport { MultipleStructuredOutputsError, MiddlewareError } from \"../errors.js\";\nimport { RunnableCallable } from \"../RunnableCallable.js\";\nimport {\n  bindTools,\n  validateLLMHasNoBoundTools,\n  hasToolCalls,\n  isClientTool,\n} from \"../utils.js\";\nimport { mergeAbortSignals, toPartialZodObject } from \"../nodes/utils.js\";\nimport { CreateAgentParams } from \"../types.js\";\nimport type { InternalAgentState, Runtime } from \"../runtime.js\";\nimport type {\n  AgentMiddleware,\n  AnyAnnotationRoot,\n  WrapModelCallHandler,\n} from \"../middleware/types.js\";\nimport type { ModelRequest } from \"./types.js\";\nimport { withAgentName } from \"../withAgentName.js\";\nimport {\n  ToolStrategy,\n  ProviderStrategy,\n  transformResponseFormat,\n  ToolStrategyError,\n} from \"../responses.js\";\n\ntype ResponseHandlerResult<StructuredResponseFormat> =\n  | {\n      structuredResponse: StructuredResponseFormat;\n      messages: BaseMessage[];\n    }\n  | Promise<Command>;\n\n/**\n * Wrap the base handler with middleware wrapModelCall hooks\n * Middleware are composed so the first middleware is the outermost wrapper\n * Example: [auth, retry, cache] means auth wraps retry wraps cache wraps baseHandler\n */\ntype InternalModelResponse<StructuredResponseFormat> =\n  | AIMessage\n  | ResponseHandlerResult<StructuredResponseFormat>;\n\n/**\n * Check if the response is an internal model response.\n * @param response - The response to check.\n * @returns True if the response is an internal model response, false otherwise.\n */\nfunction isInternalModelResponse<StructuredResponseFormat>(\n  response: unknown\n): response is InternalModelResponse<StructuredResponseFormat> {\n  return (\n    AIMessage.isInstance(response) ||\n    (typeof response === \"object\" &&\n      response !== null &&\n      \"structuredResponse\" in response &&\n      \"messages\" in response)\n  );\n}\n\n/**\n * The name of the agent node in the state graph.\n */\nexport const AGENT_NODE_NAME = \"model_request\";\n\nexport interface AgentNodeOptions<\n  StructuredResponseFormat extends Record<string, unknown> = Record<\n    string,\n    unknown\n  >,\n  StateSchema extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n> extends Pick<\n    CreateAgentParams<StructuredResponseFormat, StateSchema, ContextSchema>,\n    \"model\" | \"includeAgentName\" | \"name\" | \"responseFormat\" | \"middleware\"\n  > {\n  toolClasses: (ClientTool | ServerTool)[];\n  shouldReturnDirect: Set<string>;\n  signal?: AbortSignal;\n  systemMessage: SystemMessage;\n  wrapModelCallHookMiddleware?: [\n    AgentMiddleware,\n    () => Record<string, unknown>,\n  ][];\n}\n\ninterface NativeResponseFormat {\n  type: \"native\";\n  strategy: ProviderStrategy;\n}\n\ninterface ToolResponseFormat {\n  type: \"tool\";\n  tools: Record<string, ToolStrategy>;\n}\n\ntype ResponseFormat = NativeResponseFormat | ToolResponseFormat;\n\nexport class AgentNode<\n  StructuredResponseFormat extends Record<string, unknown> = Record<\n    string,\n    unknown\n  >,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n> extends RunnableCallable<\n  InternalAgentState<StructuredResponseFormat>,\n  | (\n      | { messages: BaseMessage[] }\n      | { structuredResponse: StructuredResponseFormat }\n    )\n  | Command\n> {\n  #options: AgentNodeOptions<StructuredResponseFormat, ContextSchema>;\n  #systemMessage: SystemMessage;\n  #currentSystemMessage: SystemMessage;\n\n  constructor(\n    options: AgentNodeOptions<StructuredResponseFormat, ContextSchema>\n  ) {\n    super({\n      name: options.name ?? \"model\",\n      func: (input, config) => this.#run(input, config as RunnableConfig),\n    });\n\n    this.#options = options;\n    this.#systemMessage = options.systemMessage;\n  }\n\n  /**\n   * Returns response format primtivies based on given model and response format provided by the user.\n   *\n   * If the user selects a tool output:\n   * - return a record of tools to extract structured output from the model's response\n   *\n   * if the the user selects a native schema output or if the model supports JSON schema output:\n   * - return a provider strategy to extract structured output from the model's response\n   *\n   * @param model - The model to get the response format for.\n   * @returns The response format.\n   */\n  #getResponseFormat(\n    model: string | LanguageModelLike\n  ): ResponseFormat | undefined {\n    if (!this.#options.responseFormat) {\n      return undefined;\n    }\n\n    const strategies = transformResponseFormat(\n      this.#options.responseFormat,\n      undefined,\n      model\n    );\n\n    /**\n     * we either define a list of provider strategies or a list of tool strategies\n     */\n    const isProviderStrategy = strategies.every(\n      (format) => format instanceof ProviderStrategy\n    );\n\n    /**\n     * Populate a list of structured tool info.\n     */\n    if (!isProviderStrategy) {\n      return {\n        type: \"tool\",\n        tools: (\n          strategies.filter(\n            (format) => format instanceof ToolStrategy\n          ) as ToolStrategy[]\n        ).reduce(\n          (acc, format) => {\n            acc[format.name] = format;\n            return acc;\n          },\n          {} as Record<string, ToolStrategy>\n        ),\n      };\n    }\n\n    return {\n      type: \"native\",\n      /**\n       * there can only be one provider strategy\n       */\n      strategy: strategies[0] as ProviderStrategy,\n    };\n  }\n\n  async #run(\n    state: InternalAgentState<StructuredResponseFormat>,\n    config: RunnableConfig\n  ) {\n    /**\n     * Check if we just executed a returnDirect tool\n     * If so, we should generate structured response (if needed) and stop\n     */\n    const lastMessage = state.messages.at(-1);\n    if (\n      lastMessage &&\n      ToolMessage.isInstance(lastMessage) &&\n      lastMessage.name &&\n      this.#options.shouldReturnDirect.has(lastMessage.name)\n    ) {\n      /**\n       * return directly without invoking the model again\n       */\n      return { messages: [] };\n    }\n\n    const response = await this.#invokeModel(state, config);\n\n    /**\n     * if we were able to generate a structured response, return it\n     */\n    if (\"structuredResponse\" in response) {\n      return {\n        messages: [...state.messages, ...(response.messages || [])],\n        structuredResponse: response.structuredResponse,\n      };\n    }\n\n    /**\n     * if we need to direct the agent to the model, return the update\n     */\n    if (response instanceof Command) {\n      return response;\n    }\n\n    response.name = this.name;\n    response.lc_kwargs.name = this.name;\n\n    if (this.#areMoreStepsNeeded(state, response)) {\n      return {\n        messages: [\n          new AIMessage({\n            content: \"Sorry, need more steps to process this request.\",\n            name: this.name,\n            id: response.id,\n          }),\n        ],\n      };\n    }\n\n    return { messages: [response] };\n  }\n\n  /**\n   * Derive the model from the options.\n   * @param state - The state of the agent.\n   * @param config - The config of the agent.\n   * @returns The model.\n   */\n  #deriveModel() {\n    if (typeof this.#options.model === \"string\") {\n      return initChatModel(this.#options.model);\n    }\n\n    if (this.#options.model) {\n      return this.#options.model;\n    }\n\n    throw new Error(\"No model option was provided, either via `model` option.\");\n  }\n\n  async #invokeModel(\n    state: InternalAgentState<StructuredResponseFormat>,\n    config: RunnableConfig,\n    options: {\n      lastMessage?: string;\n    } = {}\n  ): Promise<AIMessage | ResponseHandlerResult<StructuredResponseFormat>> {\n    const model = await this.#deriveModel();\n    const lgConfig = config as LangGraphRunnableConfig;\n\n    /**\n     * Create the base handler that performs the actual model invocation\n     */\n    const baseHandler = async (\n      request: ModelRequest\n    ): Promise<AIMessage | ResponseHandlerResult<StructuredResponseFormat>> => {\n      /**\n       * Check if the LLM already has bound tools and throw if it does.\n       */\n      validateLLMHasNoBoundTools(request.model);\n\n      const structuredResponseFormat = this.#getResponseFormat(request.model);\n      const modelWithTools = await this.#bindTools(\n        request.model,\n        request,\n        structuredResponseFormat\n      );\n\n      /**\n       * prepend the system message to the messages if it is not empty\n       */\n      const messages = [\n        ...(this.#currentSystemMessage.text === \"\"\n          ? []\n          : [this.#currentSystemMessage]),\n        ...request.messages,\n      ];\n\n      const signal = mergeAbortSignals(this.#options.signal, config.signal);\n      const response = (await raceWithSignal(\n        modelWithTools.invoke(messages, {\n          ...config,\n          signal,\n        }),\n        signal\n      )) as AIMessage;\n\n      /**\n       * if the user requests a native schema output, try to parse the response\n       * and return the structured response if it is valid\n       */\n      if (structuredResponseFormat?.type === \"native\") {\n        const structuredResponse =\n          structuredResponseFormat.strategy.parse(response);\n        if (structuredResponse) {\n          return { structuredResponse, messages: [response] };\n        }\n\n        return response;\n      }\n\n      if (!structuredResponseFormat || !response.tool_calls) {\n        return response;\n      }\n\n      const toolCalls = response.tool_calls.filter(\n        (call) => call.name in structuredResponseFormat.tools\n      );\n\n      /**\n       * if there were not structured tool calls, we can return the response\n       */\n      if (toolCalls.length === 0) {\n        return response;\n      }\n\n      /**\n       * if there were multiple structured tool calls, we should throw an error as this\n       * scenario is not defined/supported.\n       */\n      if (toolCalls.length > 1) {\n        return this.#handleMultipleStructuredOutputs(\n          response,\n          toolCalls,\n          structuredResponseFormat\n        );\n      }\n\n      const toolStrategy = structuredResponseFormat.tools[toolCalls[0].name];\n      const toolMessageContent = toolStrategy?.options?.toolMessageContent;\n      return this.#handleSingleStructuredOutput(\n        response,\n        toolCalls[0],\n        structuredResponseFormat,\n        toolMessageContent ?? options.lastMessage\n      );\n    };\n\n    const wrapperMiddleware = this.#options.wrapModelCallHookMiddleware ?? [];\n    let wrappedHandler: (\n      request: ModelRequest<\n        InternalAgentState<StructuredResponseFormat>,\n        unknown\n      >\n    ) => Promise<InternalModelResponse<StructuredResponseFormat>> = baseHandler;\n\n    /**\n     * Build composed handler from last to first so first middleware becomes outermost\n     */\n    for (let i = wrapperMiddleware.length - 1; i >= 0; i--) {\n      const [middleware, getMiddlewareState] = wrapperMiddleware[i];\n      if (middleware.wrapModelCall) {\n        const innerHandler = wrappedHandler;\n        const currentMiddleware = middleware;\n        const currentGetState = getMiddlewareState;\n\n        wrappedHandler = async (\n          request: ModelRequest<\n            InternalAgentState<StructuredResponseFormat>,\n            unknown\n          >\n        ): Promise<InternalModelResponse<StructuredResponseFormat>> => {\n          /**\n           * Merge context with default context of middleware\n           */\n          const context = currentMiddleware.contextSchema\n            ? interopParse(\n                currentMiddleware.contextSchema,\n                lgConfig?.context || {}\n              )\n            : lgConfig?.context;\n\n          /**\n           * Create runtime\n           */\n          const runtime: Runtime<unknown> = Object.freeze({\n            context,\n            writer: lgConfig.writer,\n            interrupt: lgConfig.interrupt,\n            signal: lgConfig.signal,\n          });\n\n          /**\n           * Create the request with state and runtime\n           */\n          const requestWithStateAndRuntime: ModelRequest<\n            InternalAgentState<StructuredResponseFormat>,\n            unknown\n          > = {\n            ...request,\n            state: {\n              ...(middleware.stateSchema\n                ? interopParse(\n                    toPartialZodObject(middleware.stateSchema),\n                    state\n                  )\n                : {}),\n              ...currentGetState(),\n              messages: state.messages,\n            } as InternalAgentState<StructuredResponseFormat>,\n            runtime,\n          };\n\n          /**\n           * Create handler that validates tools and calls the inner handler\n           */\n          const handlerWithValidation = async (\n            req: ModelRequest<\n              InternalAgentState<StructuredResponseFormat>,\n              unknown\n            >\n          ): Promise<InternalModelResponse<StructuredResponseFormat>> => {\n            /**\n             * Verify that the user didn't add any new tools.\n             * We can't allow this as the ToolNode is already initiated with given tools.\n             */\n            const modifiedTools = req.tools ?? [];\n            const newTools = modifiedTools.filter(\n              (tool) =>\n                isClientTool(tool) &&\n                !this.#options.toolClasses.some((t) => t.name === tool.name)\n            );\n            if (newTools.length > 0) {\n              throw new Error(\n                `You have added a new tool in \"wrapModelCall\" hook of middleware \"${\n                  currentMiddleware.name\n                }\": ${newTools\n                  .map((tool) => tool.name)\n                  .join(\", \")}. This is not supported.`\n              );\n            }\n\n            /**\n             * Verify that user has not added or modified a tool with the same name.\n             * We can't allow this as the ToolNode is already initiated with given tools.\n             */\n            const invalidTools = modifiedTools.filter(\n              (tool) =>\n                isClientTool(tool) &&\n                this.#options.toolClasses.every((t) => t !== tool)\n            );\n            if (invalidTools.length > 0) {\n              throw new Error(\n                `You have modified a tool in \"wrapModelCall\" hook of middleware \"${\n                  currentMiddleware.name\n                }\": ${invalidTools\n                  .map((tool) => tool.name)\n                  .join(\", \")}. This is not supported.`\n              );\n            }\n\n            let normalizedReq = req;\n            const hasSystemPromptChanged =\n              req.systemPrompt !== this.#currentSystemMessage.text;\n            const hasSystemMessageChanged =\n              req.systemMessage !== this.#currentSystemMessage;\n            if (hasSystemPromptChanged && hasSystemMessageChanged) {\n              throw new Error(\n                \"Cannot change both systemPrompt and systemMessage in the same request.\"\n              );\n            }\n\n            /**\n             * Check if systemPrompt is a string was changed, if so create a new SystemMessage\n             */\n            if (hasSystemPromptChanged) {\n              this.#currentSystemMessage = new SystemMessage({\n                content: [{ type: \"text\", text: req.systemPrompt }],\n              });\n              normalizedReq = {\n                ...req,\n                systemPrompt: this.#currentSystemMessage.text,\n                systemMessage: this.#currentSystemMessage,\n              };\n            }\n            /**\n             * If the systemMessage was changed, update the current system message\n             */\n            if (hasSystemMessageChanged) {\n              this.#currentSystemMessage = new SystemMessage({\n                ...req.systemMessage,\n              });\n              normalizedReq = {\n                ...req,\n                systemPrompt: this.#currentSystemMessage.text,\n                systemMessage: this.#currentSystemMessage,\n              };\n            }\n\n            return innerHandler(normalizedReq);\n          };\n\n          // Call middleware's wrapModelCall with the validation handler\n          if (!currentMiddleware.wrapModelCall) {\n            return handlerWithValidation(requestWithStateAndRuntime);\n          }\n\n          try {\n            const middlewareResponse = await currentMiddleware.wrapModelCall(\n              requestWithStateAndRuntime,\n              handlerWithValidation as WrapModelCallHandler\n            );\n\n            /**\n             * Validate that this specific middleware returned a valid AIMessage\n             */\n            if (!isInternalModelResponse(middlewareResponse)) {\n              throw new Error(\n                `Invalid response from \"wrapModelCall\" in middleware \"${\n                  currentMiddleware.name\n                }\": expected AIMessage, got ${typeof middlewareResponse}`\n              );\n            }\n\n            return middlewareResponse;\n          } catch (error) {\n            throw MiddlewareError.wrap(error, currentMiddleware.name);\n          }\n        };\n      }\n    }\n\n    /**\n     * Execute the wrapped handler with the initial request\n     * Reset current system prompt to initial state and convert to string using .text getter\n     * for backwards compatibility with ModelRequest\n     */\n    this.#currentSystemMessage = this.#systemMessage;\n    const initialRequest: ModelRequest<\n      InternalAgentState<StructuredResponseFormat>,\n      unknown\n    > = {\n      model,\n      systemPrompt: this.#currentSystemMessage?.text,\n      systemMessage: this.#currentSystemMessage,\n      messages: state.messages,\n      tools: this.#options.toolClasses,\n      state,\n      runtime: Object.freeze({\n        context: lgConfig?.context,\n        writer: lgConfig.writer,\n        interrupt: lgConfig.interrupt,\n        signal: lgConfig.signal,\n      }) as Runtime<unknown>,\n    };\n\n    return wrappedHandler(initialRequest);\n  }\n\n  /**\n   * If the model returns multiple structured outputs, we need to handle it.\n   * @param response - The response from the model\n   * @param toolCalls - The tool calls that were made\n   * @returns The response from the model\n   */\n  #handleMultipleStructuredOutputs(\n    response: AIMessage,\n    toolCalls: ToolCall[],\n    responseFormat: ToolResponseFormat\n  ): Promise<Command> {\n    const multipleStructuredOutputsError = new MultipleStructuredOutputsError(\n      toolCalls.map((call) => call.name)\n    );\n\n    return this.#handleToolStrategyError(\n      multipleStructuredOutputsError,\n      response,\n      toolCalls[0],\n      responseFormat\n    );\n  }\n\n  /**\n   * If the model returns a single structured output, we need to handle it.\n   * @param toolCall - The tool call that was made\n   * @returns The structured response and a message to the LLM if needed\n   */\n  #handleSingleStructuredOutput(\n    response: AIMessage,\n    toolCall: ToolCall,\n    responseFormat: ToolResponseFormat,\n    lastMessage?: string\n  ): ResponseHandlerResult<StructuredResponseFormat> {\n    const tool = responseFormat.tools[toolCall.name];\n\n    try {\n      const structuredResponse = tool.parse(\n        toolCall.args\n      ) as StructuredResponseFormat;\n\n      return {\n        structuredResponse,\n        messages: [\n          response,\n          new ToolMessage({\n            tool_call_id: toolCall.id ?? \"\",\n            content: JSON.stringify(structuredResponse),\n            name: toolCall.name,\n          }),\n          new AIMessage(\n            lastMessage ??\n              `Returning structured response: ${JSON.stringify(\n                structuredResponse\n              )}`\n          ),\n        ],\n      };\n    } catch (error) {\n      return this.#handleToolStrategyError(\n        error as ToolStrategyError,\n        response,\n        toolCall,\n        responseFormat\n      );\n    }\n  }\n\n  async #handleToolStrategyError(\n    error: ToolStrategyError,\n    response: AIMessage,\n    toolCall: ToolCall,\n    responseFormat: ToolResponseFormat\n  ): Promise<Command> {\n    /**\n     * Using the `errorHandler` option of the first `ToolStrategy` entry is sufficient here.\n     * There is technically only one `ToolStrategy` entry in `structuredToolInfo` if the user\n     * uses `toolStrategy` to define the response format. If the user applies a list of json\n     * schema objects, these will be transformed into multiple `ToolStrategy` entries but all\n     * with the same `handleError` option.\n     */\n    const errorHandler = Object.values(responseFormat.tools).at(0)?.options\n      ?.handleError;\n\n    const toolCallId = toolCall.id;\n    if (!toolCallId) {\n      throw new Error(\n        \"Tool call ID is required to handle tool output errors. Please provide a tool call ID.\"\n      );\n    }\n\n    /**\n     * Default behavior: retry if `errorHandler` is undefined or truthy.\n     * Only throw if explicitly set to `false`.\n     */\n    if (errorHandler === false) {\n      throw error;\n    }\n\n    /**\n     * retry if:\n     */\n    if (\n      /**\n       * if the user has provided truthy value as the `errorHandler`, return a new AIMessage\n       * with the error message and retry the tool call.\n       */\n      errorHandler === undefined ||\n      (typeof errorHandler === \"boolean\" && errorHandler) ||\n      /**\n       * if `errorHandler` is an array and contains MultipleStructuredOutputsError\n       */\n      (Array.isArray(errorHandler) &&\n        errorHandler.some((h) => h instanceof MultipleStructuredOutputsError))\n    ) {\n      return new Command({\n        update: {\n          messages: [\n            response,\n            new ToolMessage({\n              content: error.message,\n              tool_call_id: toolCallId,\n            }),\n          ],\n        },\n        goto: AGENT_NODE_NAME,\n      });\n    }\n\n    /**\n     * if `errorHandler` is a string, retry the tool call with given string\n     */\n    if (typeof errorHandler === \"string\") {\n      return new Command({\n        update: {\n          messages: [\n            response,\n            new ToolMessage({\n              content: errorHandler,\n              tool_call_id: toolCallId,\n            }),\n          ],\n        },\n        goto: AGENT_NODE_NAME,\n      });\n    }\n\n    /**\n     * if `errorHandler` is a function, retry the tool call with the function\n     */\n    if (typeof errorHandler === \"function\") {\n      const content = await errorHandler(error);\n      if (typeof content !== \"string\") {\n        throw new Error(\"Error handler must return a string.\");\n      }\n\n      return new Command({\n        update: {\n          messages: [\n            response,\n            new ToolMessage({\n              content,\n              tool_call_id: toolCallId,\n            }),\n          ],\n        },\n        goto: AGENT_NODE_NAME,\n      });\n    }\n\n    /**\n     * Default: retry if we reach here\n     */\n    return new Command({\n      update: {\n        messages: [\n          response,\n          new ToolMessage({\n            content: error.message,\n            tool_call_id: toolCallId,\n          }),\n        ],\n      },\n      goto: AGENT_NODE_NAME,\n    });\n  }\n\n  #areMoreStepsNeeded(\n    state: InternalAgentState<StructuredResponseFormat>,\n    response: BaseMessage\n  ): boolean {\n    const allToolsReturnDirect =\n      AIMessage.isInstance(response) &&\n      response.tool_calls?.every((call) =>\n        this.#options.shouldReturnDirect.has(call.name)\n      );\n    const remainingSteps =\n      \"remainingSteps\" in state ? (state.remainingSteps as number) : undefined;\n    return Boolean(\n      remainingSteps &&\n        ((remainingSteps < 1 && allToolsReturnDirect) ||\n          (remainingSteps < 2 && hasToolCalls(state.messages.at(-1))))\n    );\n  }\n\n  async #bindTools(\n    model: LanguageModelLike,\n    preparedOptions: ModelRequest | undefined,\n    structuredResponseFormat: ResponseFormat | undefined\n  ): Promise<Runnable> {\n    const options: Partial<BaseChatModelCallOptions> = {};\n    const structuredTools = Object.values(\n      structuredResponseFormat && \"tools\" in structuredResponseFormat\n        ? structuredResponseFormat.tools\n        : {}\n    );\n\n    /**\n     * Use tools from preparedOptions if provided, otherwise use default tools\n     */\n    const allTools = [\n      ...(preparedOptions?.tools ?? this.#options.toolClasses),\n      ...structuredTools.map((toolStrategy) => toolStrategy.tool),\n    ];\n\n    /**\n     * If there are structured tools, we need to set the tool choice to \"any\"\n     * so that the model can choose to use a structured tool or not.\n     */\n    const toolChoice =\n      preparedOptions?.toolChoice ||\n      (structuredTools.length > 0 ? \"any\" : undefined);\n\n    /**\n     * check if the user requests a native schema output\n     */\n    if (structuredResponseFormat?.type === \"native\") {\n      const resolvedStrict =\n        preparedOptions?.modelSettings?.strict ??\n        structuredResponseFormat?.strategy?.strict ??\n        true;\n\n      const jsonSchemaParams = {\n        name: structuredResponseFormat.strategy.schema?.name ?? \"extract\",\n        description: getSchemaDescription(\n          structuredResponseFormat.strategy.schema\n        ),\n        schema: structuredResponseFormat.strategy.schema,\n        strict: resolvedStrict,\n      };\n\n      Object.assign(options, {\n        response_format: {\n          type: \"json_schema\",\n          json_schema: jsonSchemaParams,\n        },\n        output_format: {\n          type: \"json_schema\",\n          schema: structuredResponseFormat.strategy.schema,\n        },\n        headers: {\n          \"anthropic-beta\": \"structured-outputs-2025-11-13\",\n        },\n        ls_structured_output_format: {\n          kwargs: { method: \"json_schema\" },\n          schema: structuredResponseFormat.strategy.schema,\n        },\n        strict: resolvedStrict,\n      });\n    }\n\n    /**\n     * Bind tools to the model if they are not already bound.\n     */\n    const modelWithTools = await bindTools(model, allTools, {\n      ...options,\n      ...preparedOptions?.modelSettings,\n      tool_choice: toolChoice,\n    });\n\n    /**\n     * Create a model runnable with the prompt and agent name\n     * Use current SystemMessage state (which may have been modified by middleware)\n     */\n    const modelRunnable =\n      this.#options.includeAgentName === \"inline\"\n        ? withAgentName(modelWithTools, this.#options.includeAgentName)\n        : modelWithTools;\n\n    return modelRunnable;\n  }\n\n  getState(): {\n    messages: BaseMessage[];\n  } {\n    const state = super.getState();\n    const origState = state && !(state instanceof Command) ? state : {};\n\n    return {\n      messages: [],\n      ...origState,\n    };\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-instanceof/no-instanceof */\nimport { BaseMessage, ToolMessage, AIMessage } from \"@langchain/core/messages\";\nimport { RunnableConfig, RunnableToolLike } from \"@langchain/core/runnables\";\nimport {\n  DynamicTool,\n  StructuredToolInterface,\n  ToolInputParsingException,\n} from \"@langchain/core/tools\";\nimport type { ToolCall } from \"@langchain/core/messages/tool\";\nimport type { InteropZodObject } from \"@langchain/core/utils/types\";\nimport {\n  isCommand,\n  Command,\n  Send,\n  isGraphInterrupt,\n  type LangGraphRunnableConfig,\n  StateDefinitionInit,\n} from \"@langchain/langgraph\";\n\nimport { RunnableCallable } from \"../RunnableCallable.js\";\nimport { mergeAbortSignals } from \"./utils.js\";\nimport { ToolInvocationError } from \"../errors.js\";\nimport type {\n  WrapToolCallHook,\n  ToolCallRequest,\n  ToAnnotationRoot,\n} from \"../middleware/types.js\";\nimport type { AgentBuiltInState } from \"../runtime.js\";\n\n/**\n * Error message template for when middleware adds tools that can't be executed.\n * This happens when middleware modifies tools in wrapModelCall but doesn't provide\n * a wrapToolCall handler to execute them.\n */\nconst getInvalidToolError = (\n  toolName: string,\n  availableTools: string[]\n): string =>\n  `Error: ${toolName} is not a valid tool, try one of [${availableTools.join(\", \")}].`;\n\n/**\n * The name of the tool node in the state graph.\n */\nexport const TOOLS_NODE_NAME = \"tools\";\n\nexport interface ToolNodeOptions {\n  /**\n   * The name of the tool node.\n   */\n  name?: string;\n  /**\n   * The tags to add to the tool call.\n   */\n  tags?: string[];\n  /**\n   * The abort signal to cancel the tool call.\n   */\n  signal?: AbortSignal;\n  /**\n   * Whether to throw the error immediately if the tool fails or handle it by the `onToolError` function or via ToolMessage.\n   *\n   * **Default behavior** (matches Python):\n   *   - Catches only `ToolInvocationError` (invalid arguments from model) and converts to ToolMessage\n   *   - Re-raises all other errors including errors from `wrapToolCall` middleware\n   *\n   * If `true`:\n   *   - Catches all errors and returns a ToolMessage with the error\n   *\n   * If `false`:\n   *   - All errors are thrown immediately\n   *\n   * If a function is provided:\n   *   - If function returns a `ToolMessage`, use it as the result\n   *   - If function returns `undefined`, re-raise the error\n   *\n   * @default A function that only catches ToolInvocationError\n   */\n  handleToolErrors?:\n    | boolean\n    | ((error: unknown, toolCall: ToolCall) => ToolMessage | undefined);\n  /**\n   * Optional wrapper function for tool execution.\n   * Allows middleware to intercept and modify tool calls before execution.\n   * The wrapper receives the tool call request and a handler function to execute the tool.\n   */\n  wrapToolCall?: WrapToolCallHook;\n}\n\nconst isBaseMessageArray = (input: unknown): input is BaseMessage[] =>\n  Array.isArray(input) && input.every(BaseMessage.isInstance);\n\nconst isMessagesState = (\n  input: unknown\n): input is { messages: BaseMessage[] } =>\n  typeof input === \"object\" &&\n  input != null &&\n  \"messages\" in input &&\n  isBaseMessageArray(input.messages);\n\nconst isSendInput = (\n  input: unknown\n): input is { lg_tool_call: ToolCall; jumpTo?: string } =>\n  typeof input === \"object\" && input != null && \"lg_tool_call\" in input;\n\n/**\n * Default error handler for tool errors.\n *\n * This is applied to errors from baseHandler (tool execution).\n * For errors from wrapToolCall middleware, those are handled separately\n * and will bubble up by default.\n *\n * Catches all tool execution errors and converts them to ToolMessage.\n * This allows the LLM to see the error and potentially retry with different arguments.\n */\nfunction defaultHandleToolErrors(\n  error: unknown,\n  toolCall: ToolCall\n): ToolMessage | undefined {\n  if (error instanceof ToolInvocationError) {\n    return new ToolMessage({\n      content: error.message,\n      tool_call_id: toolCall.id!,\n      name: toolCall.name,\n    });\n  }\n  /**\n   * Catch all other tool errors and convert to ToolMessage\n   */\n  return new ToolMessage({\n    content: `${error}\\n Please fix your mistakes.`,\n    tool_call_id: toolCall.id!,\n    name: toolCall.name,\n  });\n}\n\n/**\n * `ToolNode` is a built-in LangGraph component that handles tool calls within an agent's workflow.\n * It works seamlessly with `createAgent`, offering advanced tool execution control, built\n * in parallelism, and error handling.\n *\n * @example\n * ```ts\n * import { ToolNode, tool, AIMessage } from \"langchain\";\n * import { z } from \"zod/v3\";\n *\n * const getWeather = tool((input) => {\n *   if ([\"sf\", \"san francisco\"].includes(input.location.toLowerCase())) {\n *     return \"It's 60 degrees and foggy.\";\n *   } else {\n *     return \"It's 90 degrees and sunny.\";\n *   }\n * }, {\n *   name: \"get_weather\",\n *   description: \"Call to get the current weather.\",\n *   schema: z.object({\n *     location: z.string().describe(\"Location to get the weather for.\"),\n *   }),\n * });\n *\n * const tools = [getWeather];\n * const toolNode = new ToolNode(tools);\n *\n * const messageWithSingleToolCall = new AIMessage({\n *   content: \"\",\n *   tool_calls: [\n *     {\n *       name: \"get_weather\",\n *       args: { location: \"sf\" },\n *       id: \"tool_call_id\",\n *       type: \"tool_call\",\n *     }\n *   ]\n * })\n *\n * await toolNode.invoke({ messages: [messageWithSingleToolCall] });\n * // Returns tool invocation responses as:\n * // { messages: ToolMessage[] }\n * ```\n */\nexport class ToolNode<\n  StateSchema extends StateDefinitionInit = any,\n  ContextSchema extends InteropZodObject = any,\n> extends RunnableCallable<StateSchema, ContextSchema> {\n  tools: (StructuredToolInterface | DynamicTool | RunnableToolLike)[];\n\n  trace = false;\n\n  signal?: AbortSignal;\n\n  handleToolErrors:\n    | boolean\n    | ((error: unknown, toolCall: ToolCall) => ToolMessage | undefined) =\n    defaultHandleToolErrors;\n\n  wrapToolCall: WrapToolCallHook | undefined;\n\n  constructor(\n    tools: (StructuredToolInterface | DynamicTool | RunnableToolLike)[],\n    public options?: ToolNodeOptions\n  ) {\n    const { name, tags, handleToolErrors, signal, wrapToolCall } =\n      options ?? {};\n    super({\n      name,\n      tags,\n      func: (state, config) =>\n        this.run(\n          state as ToAnnotationRoot<StateDefinitionInit>[\"State\"] &\n            AgentBuiltInState,\n          config as RunnableConfig\n        ),\n    });\n    this.tools = tools;\n    this.handleToolErrors = handleToolErrors ?? this.handleToolErrors;\n    this.signal = signal;\n    this.wrapToolCall = wrapToolCall;\n  }\n\n  /**\n   * Handle errors from tool execution or middleware.\n   * @param error - The error to handle\n   * @param call - The tool call that caused the error\n   * @param isMiddlewareError - Whether the error came from wrapToolCall middleware\n   * @returns ToolMessage if error is handled, otherwise re-throws\n   */\n  #handleError(\n    error: unknown,\n    call: ToolCall,\n    isMiddlewareError: boolean\n  ): ToolMessage {\n    /**\n     * {@link NodeInterrupt} errors are a breakpoint to bring a human into the loop.\n     * As such, they are not recoverable by the agent and shouldn't be fed\n     * back. Instead, re-throw these errors even when `handleToolErrors = true`.\n     */\n    if (isGraphInterrupt(error)) {\n      throw error;\n    }\n\n    /**\n     * If the signal is aborted, we want to bubble up the error to the invoke caller.\n     */\n    if (this.signal?.aborted) {\n      throw error;\n    }\n\n    /**\n     * If error is from middleware and handleToolErrors is not true, bubble up\n     * (default handler and false both re-raise middleware errors)\n     */\n    if (isMiddlewareError && this.handleToolErrors !== true) {\n      throw error;\n    }\n\n    /**\n     * If handleToolErrors is false, throw all errors\n     */\n    if (!this.handleToolErrors) {\n      throw error;\n    }\n\n    /**\n     * Apply handleToolErrors to the error\n     */\n    if (typeof this.handleToolErrors === \"function\") {\n      const result = this.handleToolErrors(error, call);\n      if (result && ToolMessage.isInstance(result)) {\n        return result;\n      }\n\n      /**\n       * `handleToolErrors` returned undefined - re-raise\n       */\n      throw error;\n    } else if (this.handleToolErrors) {\n      return new ToolMessage({\n        name: call.name,\n        content: `${error}\\n Please fix your mistakes.`,\n        tool_call_id: call.id!,\n      });\n    }\n\n    /**\n     * Shouldn't reach here, but throw as fallback\n     */\n    throw error;\n  }\n\n  protected async runTool(\n    call: ToolCall,\n    config: RunnableConfig,\n    state: AgentBuiltInState\n  ): Promise<ToolMessage | Command> {\n    /**\n     * Build runtime from LangGraph config\n     */\n    const lgConfig = config as LangGraphRunnableConfig;\n    const runtime = {\n      context: lgConfig?.context,\n      writer: lgConfig?.writer,\n      interrupt: lgConfig?.interrupt,\n      signal: lgConfig?.signal,\n    };\n\n    /**\n     * Find the tool instance to include in the request.\n     * For dynamically registered tools, this may be undefined.\n     */\n    const registeredTool = this.tools.find((t) => t.name === call.name);\n\n    /**\n     * Define the base handler that executes the tool.\n     * When wrapToolCall middleware is present, this handler does NOT catch errors\n     * so the middleware can handle them.\n     * When no middleware, errors are caught and handled here.\n     *\n     * The handler now accepts an overridden tool from the request, allowing\n     * middleware to provide tool implementations for dynamically registered tools.\n     */\n    const baseHandler = async (\n      request: ToolCallRequest\n    ): Promise<ToolMessage | Command> => {\n      const { toolCall, tool: requestTool } = request;\n\n      /**\n       * Use the tool from the request (which may be overridden via spread syntax)\n       * or fall back to finding it in registered tools.\n       * This allows middleware to provide dynamic tool implementations.\n       */\n      const tool =\n        requestTool ?? this.tools.find((t) => t.name === toolCall.name);\n\n      if (tool === undefined) {\n        /**\n         * Tool not found - return a graceful error message rather than throwing.\n         * This allows the LLM to see the error and potentially retry.\n         */\n        const availableTools = this.tools.map((t) => t.name);\n        return new ToolMessage({\n          content: getInvalidToolError(toolCall.name, availableTools),\n          tool_call_id: toolCall.id!,\n          name: toolCall.name,\n          status: \"error\",\n        });\n      }\n\n      /**\n       * Cast tool to a common invokable type.\n       * The tool can be from registered tools (StructuredToolInterface | DynamicTool | RunnableToolLike)\n       * or from middleware override (ClientTool | ServerTool).\n       */\n      const invokableTool = tool as\n        | StructuredToolInterface\n        | DynamicTool\n        | RunnableToolLike;\n\n      try {\n        const output = await invokableTool.invoke(\n          { ...toolCall, type: \"tool_call\" },\n          {\n            ...config,\n            /**\n             * extend to match ToolRuntime\n             */\n            config,\n            toolCallId: toolCall.id!,\n            state: config.configurable?.__pregel_scratchpad?.currentTaskInput,\n            signal: mergeAbortSignals(this.signal, config.signal),\n          }\n        );\n\n        if (ToolMessage.isInstance(output) || isCommand(output)) {\n          return output as ToolMessage | Command;\n        }\n\n        return new ToolMessage({\n          name: invokableTool.name,\n          content: typeof output === \"string\" ? output : JSON.stringify(output),\n          tool_call_id: toolCall.id!,\n        });\n      } catch (e: unknown) {\n        /**\n         * Handle errors from tool execution (not from wrapToolCall)\n         * If tool invocation fails due to input parsing error, throw a {@link ToolInvocationError}\n         */\n        if (e instanceof ToolInputParsingException) {\n          throw new ToolInvocationError(e, toolCall);\n        }\n        /**\n         * Re-throw to be handled by caller\n         */\n        throw e;\n      }\n    };\n\n    /**\n     * Create request object for middleware\n     * Cast to ToolCallRequest<AgentBuiltInState> to satisfy type constraints\n     * of wrapToolCall which expects AgentBuiltInState\n     */\n    const request: ToolCallRequest<AgentBuiltInState> = {\n      toolCall: call,\n      tool: registeredTool,\n      state,\n      runtime,\n    };\n\n    /**\n     * If wrapToolCall is provided, use it to wrap the tool execution\n     */\n    if (this.wrapToolCall) {\n      try {\n        return await this.wrapToolCall(request, baseHandler);\n      } catch (e: unknown) {\n        /**\n         * Handle middleware errors\n         */\n        return this.#handleError(e, call, true);\n      }\n    }\n\n    /**\n     * No wrapToolCall - if tool wasn't found, return graceful error\n     */\n    if (!registeredTool) {\n      const availableTools = this.tools.map((t) => t.name);\n      return new ToolMessage({\n        content: getInvalidToolError(call.name, availableTools),\n        tool_call_id: call.id!,\n        name: call.name,\n        status: \"error\",\n      });\n    }\n\n    /**\n     * No wrapToolCall - execute tool directly and handle errors here\n     */\n    try {\n      return await baseHandler(request);\n    } catch (e: unknown) {\n      /**\n       * Handle tool errors when no middleware provided\n       */\n      return this.#handleError(e, call, false);\n    }\n  }\n\n  protected async run(\n    state: ToAnnotationRoot<StateSchema>[\"State\"] & AgentBuiltInState,\n    config: RunnableConfig\n  ): Promise<ContextSchema> {\n    let outputs: (ToolMessage | Command)[];\n\n    if (isSendInput(state)) {\n      const { lg_tool_call: _, jumpTo: __, ...newState } = state;\n      outputs = [await this.runTool(state.lg_tool_call, config, newState)];\n    } else {\n      let messages: BaseMessage[];\n      if (isBaseMessageArray(state)) {\n        messages = state;\n      } else if (isMessagesState(state)) {\n        messages = state.messages;\n      } else {\n        throw new Error(\n          \"ToolNode only accepts BaseMessage[] or { messages: BaseMessage[] } as input.\"\n        );\n      }\n\n      const toolMessageIds: Set<string> = new Set(\n        messages\n          .filter((msg) => msg.getType() === \"tool\")\n          .map((msg) => (msg as ToolMessage).tool_call_id)\n      );\n\n      let aiMessage: AIMessage | undefined;\n      for (let i = messages.length - 1; i >= 0; i -= 1) {\n        const message = messages[i];\n        if (AIMessage.isInstance(message)) {\n          aiMessage = message;\n          break;\n        }\n      }\n\n      if (!AIMessage.isInstance(aiMessage)) {\n        throw new Error(\"ToolNode only accepts AIMessages as input.\");\n      }\n\n      outputs = await Promise.all(\n        aiMessage.tool_calls\n          ?.filter((call) => call.id == null || !toolMessageIds.has(call.id))\n          .map((call) => this.runTool(call, config, state)) ?? []\n      );\n    }\n\n    // Preserve existing behavior for non-command tool outputs for backwards compatibility\n    if (!outputs.some(isCommand)) {\n      return (Array.isArray(state)\n        ? outputs\n        : { messages: outputs }) as unknown as ContextSchema;\n    }\n\n    // Handle mixed Command and non-Command outputs\n    const combinedOutputs: (\n      | { messages: BaseMessage[] }\n      | BaseMessage[]\n      | Command\n    )[] = [];\n    let parentCommand: Command | null = null;\n\n    for (const output of outputs) {\n      if (isCommand(output)) {\n        if (\n          output.graph === Command.PARENT &&\n          Array.isArray(output.goto) &&\n          output.goto.every((send) => isSend(send))\n        ) {\n          if (parentCommand) {\n            (parentCommand.goto as Send[]).push(...(output.goto as Send[]));\n          } else {\n            parentCommand = new Command({\n              graph: Command.PARENT,\n              goto: output.goto,\n            });\n          }\n        } else {\n          combinedOutputs.push(output);\n        }\n      } else {\n        combinedOutputs.push(\n          Array.isArray(state) ? [output] : { messages: [output] }\n        );\n      }\n    }\n\n    if (parentCommand) {\n      combinedOutputs.push(parentCommand);\n    }\n\n    return combinedOutputs as unknown as ContextSchema;\n  }\n}\n\nexport function isSend(x: unknown): x is Send {\n  return x instanceof Send;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z } from \"zod/v4\";\nimport { LangGraphRunnableConfig, Command } from \"@langchain/langgraph\";\nimport { interopParse } from \"@langchain/core/utils/types\";\n\nimport { RunnableCallable, RunnableCallableArgs } from \"../RunnableCallable.js\";\nimport type { JumpToTarget } from \"../constants.js\";\nimport type { Runtime } from \"../runtime.js\";\nimport type { AgentMiddleware, MiddlewareResult } from \"../middleware/types.js\";\nimport { derivePrivateState } from \"./utils.js\";\nimport { getHookConstraint } from \"../middleware/utils.js\";\n\n/**\n * Named class for context objects to provide better error messages\n */\nclass AgentContext {}\nclass AgentRuntime {}\n\ntype NodeOutput<TStateSchema extends Record<string, any>> =\n  | TStateSchema\n  | Command<any, TStateSchema, string>;\n\nexport interface MiddlewareNodeOptions {\n  getState: () => Record<string, unknown>;\n}\n\nexport abstract class MiddlewareNode<\n  TStateSchema extends Record<string, any>,\n  TContextSchema extends Record<string, any>,\n> extends RunnableCallable<TStateSchema, NodeOutput<TStateSchema>> {\n  #options: MiddlewareNodeOptions;\n\n  abstract middleware: AgentMiddleware<\n    z.ZodObject<z.ZodRawShape>,\n    z.ZodObject<z.ZodRawShape>\n  >;\n\n  constructor(\n    fields: RunnableCallableArgs<TStateSchema, NodeOutput<TStateSchema>>,\n    options: MiddlewareNodeOptions\n  ) {\n    super(fields);\n    this.#options = options;\n  }\n\n  abstract runHook(\n    state: TStateSchema,\n    config?: Runtime<TContextSchema>\n  ): Promise<MiddlewareResult<TStateSchema>> | MiddlewareResult<TStateSchema>;\n\n  async invokeMiddleware(\n    invokeState: TStateSchema,\n    config?: LangGraphRunnableConfig\n  ): Promise<NodeOutput<TStateSchema>> {\n    /**\n     * Filter context based on middleware's contextSchema\n     */\n    let filteredContext = {} as TContextSchema;\n    /**\n     * Parse context using middleware's contextSchema to apply defaults and validation\n     */\n    if (this.middleware.contextSchema) {\n      /**\n       * Extract only the fields relevant to this middleware's schema\n       */\n      const schemaShape = this.middleware.contextSchema?.shape;\n      if (schemaShape) {\n        const relevantContext: Record<string, unknown> = {};\n        const invokeContext = config?.context || {};\n        for (const key of Object.keys(schemaShape)) {\n          if (key in invokeContext) {\n            relevantContext[key] = invokeContext[key];\n          }\n        }\n        /**\n         * Parse to apply defaults and validation, even if relevantContext is empty\n         * This will throw if required fields are missing and no defaults exist\n         */\n        filteredContext = interopParse(\n          this.middleware.contextSchema,\n          relevantContext\n        ) as TContextSchema;\n      }\n    }\n\n    const state: TStateSchema = {\n      ...this.#options.getState(),\n      ...invokeState,\n      /**\n       * don't overwrite possible outdated messages from other middleware nodes\n       */\n      messages: invokeState.messages,\n    };\n\n    /**\n     * ToDo: implement later\n     */\n    const runtime: Runtime<TContextSchema> = {\n      context: filteredContext,\n      writer: config?.writer,\n      interrupt: config?.interrupt,\n      signal: config?.signal,\n    };\n\n    const result = await this.runHook(\n      state,\n      /**\n       * assign runtime and context values into empty named class\n       * instances to create a better error message.\n       */\n      Object.freeze(\n        Object.assign(new AgentRuntime(), {\n          ...runtime,\n          context: Object.freeze(\n            Object.assign(new AgentContext(), filteredContext)\n          ),\n        })\n      )\n    );\n\n    /**\n     * If result is undefined, return current state\n     */\n    if (!result) {\n      return { ...state, jumpTo: undefined };\n    }\n\n    /**\n     * Verify that the jump target is allowed for the middleware\n     */\n    let jumpToConstraint: JumpToTarget[] | undefined;\n    let constraint: string | undefined;\n\n    if (this.name?.startsWith(\"BeforeAgentNode_\")) {\n      jumpToConstraint = getHookConstraint(this.middleware.beforeAgent);\n      constraint = \"beforeAgent.canJumpTo\";\n    } else if (this.name?.startsWith(\"BeforeModelNode_\")) {\n      jumpToConstraint = getHookConstraint(this.middleware.beforeModel);\n      constraint = \"beforeModel.canJumpTo\";\n    } else if (this.name?.startsWith(\"AfterAgentNode_\")) {\n      jumpToConstraint = getHookConstraint(this.middleware.afterAgent);\n      constraint = \"afterAgent.canJumpTo\";\n    } else if (this.name?.startsWith(\"AfterModelNode_\")) {\n      jumpToConstraint = getHookConstraint(this.middleware.afterModel);\n      constraint = \"afterModel.canJumpTo\";\n    }\n\n    if (\n      typeof result.jumpTo === \"string\" &&\n      !jumpToConstraint?.includes(result.jumpTo as JumpToTarget)\n    ) {\n      const suggestion =\n        jumpToConstraint && jumpToConstraint.length > 0\n          ? `must be one of: ${jumpToConstraint?.join(\", \")}.`\n          : constraint\n            ? `no ${constraint} defined in middleware ${this.middleware.name}`\n            : \"\";\n      throw new Error(`Invalid jump target: ${result.jumpTo}, ${suggestion}.`);\n    }\n\n    /**\n     * If result is a control action, handle it\n     */\n    if (typeof result === \"object\" && \"type\" in result) {\n      // Handle control actions\n      if (result.type === \"terminate\") {\n        if (result.error) {\n          throw result.error;\n        }\n        return {\n          ...state,\n          ...(result.result || {}),\n          jumpTo: result.jumpTo,\n        };\n      }\n\n      throw new Error(`Invalid control action: ${JSON.stringify(result)}`);\n    }\n\n    /**\n     * If result is a state update, merge it with current state\n     */\n    return { ...state, ...result, jumpTo: result.jumpTo };\n  }\n\n  get nodeOptions() {\n    return {\n      input: derivePrivateState(this.middleware.stateSchema),\n    };\n  }\n}\n", "import { z } from \"zod/v4\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport { MiddlewareNode, type MiddlewareNodeOptions } from \"./middleware.js\";\nimport type { AgentMiddleware, MiddlewareResult } from \"../middleware/types.js\";\nimport type { AgentBuiltInState, Runtime } from \"../runtime.js\";\nimport { getHookFunction } from \"../middleware/utils.js\";\n\n/**\n * Node for executing a single middleware's beforeAgent hook.\n */\nexport class BeforeAgentNode<\n  TStateSchema extends Record<string, unknown> = Record<string, unknown>,\n  TContextSchema extends Record<string, unknown> = Record<string, unknown>,\n> extends MiddlewareNode<TStateSchema, TContextSchema> {\n  lc_namespace = [\"langchain\", \"agents\", \"beforeAgentNodes\"];\n\n  constructor(\n    public middleware: AgentMiddleware<\n      z.ZodObject<z.ZodRawShape>,\n      z.ZodObject<z.ZodRawShape>\n    >,\n    options: MiddlewareNodeOptions\n  ) {\n    super(\n      {\n        name: `BeforeAgentNode_${middleware.name}`,\n        func: async (\n          state: TStateSchema,\n          config?: RunnableConfig<TContextSchema>\n        ) => this.invokeMiddleware(state, config),\n      },\n      options\n    );\n  }\n\n  runHook(state: TStateSchema, runtime: Runtime<TContextSchema>) {\n    const fn = getHookFunction(this.middleware.beforeAgent!);\n    return fn(\n      state as Record<string, unknown> & AgentBuiltInState,\n      runtime as Runtime<unknown>\n    ) as Promise<MiddlewareResult<TStateSchema>>;\n  }\n}\n", "import { z } from \"zod/v4\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport { MiddlewareNode, type MiddlewareNodeOptions } from \"./middleware.js\";\nimport type { AgentMiddleware, MiddlewareResult } from \"../middleware/types.js\";\nimport type { AgentBuiltInState, Runtime } from \"../runtime.js\";\nimport { getHookFunction } from \"../middleware/utils.js\";\n\n/**\n * Node for executing a single middleware's beforeModel hook.\n */\nexport class BeforeModelNode<\n  TStateSchema extends Record<string, unknown> = Record<string, unknown>,\n  TContextSchema extends Record<string, unknown> = Record<string, unknown>,\n> extends MiddlewareNode<TStateSchema, TContextSchema> {\n  lc_namespace = [\"langchain\", \"agents\", \"beforeModelNodes\"];\n\n  constructor(\n    public middleware: AgentMiddleware<\n      z.ZodObject<z.ZodRawShape>,\n      z.ZodObject<z.ZodRawShape>\n    >,\n    options: MiddlewareNodeOptions\n  ) {\n    super(\n      {\n        name: `BeforeModelNode_${middleware.name}`,\n        func: async (\n          state: TStateSchema,\n          config?: RunnableConfig<TContextSchema>\n        ) => this.invokeMiddleware(state, config),\n      },\n      options\n    );\n  }\n\n  runHook(state: TStateSchema, runtime: Runtime<TContextSchema>) {\n    const fn = getHookFunction(this.middleware.beforeModel!);\n    return fn(\n      state as Record<string, unknown> & AgentBuiltInState,\n      runtime as Runtime<unknown>\n    ) as Promise<MiddlewareResult<TStateSchema>>;\n  }\n}\n", "import { z } from \"zod/v4\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport { MiddlewareNode, MiddlewareNodeOptions } from \"./middleware.js\";\nimport type { AgentMiddleware, MiddlewareResult } from \"../middleware/types.js\";\nimport type { AgentBuiltInState, Runtime } from \"../runtime.js\";\nimport { getHookFunction } from \"../middleware/utils.js\";\n\n/**\n * Node for executing a single middleware's afterModel hook.\n */\nexport class AfterModelNode<\n  TStateSchema extends Record<string, unknown> = Record<string, unknown>,\n  TContextSchema extends Record<string, unknown> = Record<string, unknown>,\n> extends MiddlewareNode<TStateSchema, TContextSchema> {\n  lc_namespace = [\"langchain\", \"agents\", \"afterModelNodes\"];\n\n  constructor(\n    public middleware: AgentMiddleware<\n      z.ZodObject<z.ZodRawShape>,\n      z.ZodObject<z.ZodRawShape>\n    >,\n    options: MiddlewareNodeOptions\n  ) {\n    super(\n      {\n        name: `AfterModelNode_${middleware.name}`,\n        func: async (\n          state: TStateSchema,\n          config?: RunnableConfig<TContextSchema>\n        ) => this.invokeMiddleware(state, config),\n      },\n      options\n    );\n  }\n\n  runHook(state: TStateSchema, runtime: Runtime<TContextSchema>) {\n    const fn = getHookFunction(this.middleware.afterModel!);\n    return fn(\n      state as Record<string, unknown> & AgentBuiltInState,\n      runtime as Runtime<unknown>\n    ) as Promise<MiddlewareResult<TStateSchema>>;\n  }\n}\n", "import { z } from \"zod/v4\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport { MiddlewareNode, MiddlewareNodeOptions } from \"./middleware.js\";\nimport type { AgentMiddleware, MiddlewareResult } from \"../middleware/types.js\";\nimport type { AgentBuiltInState, Runtime } from \"../runtime.js\";\nimport { getHookFunction } from \"../middleware/utils.js\";\n\n/**\n * Node for executing a single middleware's afterAgent hook.\n */\nexport class AfterAgentNode<\n  TStateSchema extends Record<string, unknown> = Record<string, unknown>,\n  TContextSchema extends Record<string, unknown> = Record<string, unknown>,\n> extends MiddlewareNode<TStateSchema, TContextSchema> {\n  lc_namespace = [\"langchain\", \"agents\", \"afterAgentNodes\"];\n\n  constructor(\n    public middleware: AgentMiddleware<\n      z.ZodObject<z.ZodRawShape>,\n      z.ZodObject<z.ZodRawShape>\n    >,\n    options: MiddlewareNodeOptions\n  ) {\n    super(\n      {\n        name: `AfterAgentNode_${middleware.name}`,\n        func: async (\n          state: TStateSchema,\n          config?: RunnableConfig<TContextSchema>\n        ) => this.invokeMiddleware(state, config),\n      },\n      options\n    );\n  }\n\n  runHook(state: TStateSchema, runtime: Runtime<TContextSchema>) {\n    const fn = getHookFunction(this.middleware.afterAgent!);\n    return fn(\n      state as Record<string, unknown> & AgentBuiltInState,\n      runtime as Runtime<unknown>\n    ) as Promise<MiddlewareResult<TStateSchema>>;\n  }\n}\n", "import type { InteropZodObject } from \"@langchain/core/utils/types\";\nimport type { RunnableCallable } from \"./RunnableCallable.js\";\nimport type { AgentMiddleware } from \"./middleware/types.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AgentNode = RunnableCallable<any, any>;\n\n/**\n * The StateManager is responsible for managing the state of the agent.\n * The `createAgent` maintains different nodes with their own state. For the user\n * however, they only see the combined state of all nodes. This class is helps\n * to share the state between different nodes.\n *\n * @internal\n */\nexport class StateManager {\n  #nodes = new Map<string, AgentNode[]>();\n\n  /**\n   * Add node to middleware group.\n   * @param name - The name of the middleware group.\n   * @param node - The node to add.\n   */\n  addNode(\n    middleware: AgentMiddleware<InteropZodObject | undefined>,\n    node: AgentNode\n  ) {\n    this.#nodes.set(middleware.name, [\n      ...(this.#nodes.get(middleware.name) ?? []),\n      node,\n    ]);\n  }\n\n  /**\n   * Get the state of a middleware group.\n   * @param name - The name of the middleware group.\n   * @returns The state of the middleware group.\n   */\n  getState(name: string) {\n    const middlewareNodes = this.#nodes.get(name) ?? [];\n    const state = middlewareNodes.reduce(\n      (prev, node) => {\n        return {\n          ...prev,\n          ...((node.getState() as Record<string, unknown>) ?? {}),\n        };\n      },\n      {} as Record<string, unknown>\n    );\n\n    /**\n     * we internally reset the jumpTo property and shouldn't propagate this value\n     * to the middleware hooks.\n     */\n    delete state.jumpTo;\n\n    return state;\n  }\n}\n", "/* eslint-disable no-instanceof/no-instanceof */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { InteropZodObject } from \"@langchain/core/utils/types\";\n\nimport {\n  StateGraph,\n  END,\n  START,\n  Send,\n  Command,\n  CompiledStateGraph,\n  type GetStateOptions,\n  type LangGraphRunnableConfig,\n  type StreamMode,\n  type StreamOutputMap,\n  type PregelOptions,\n} from \"@langchain/langgraph\";\nimport type { CheckpointListOptions } from \"@langchain/langgraph-checkpoint\";\nimport {\n  ToolMessage,\n  AIMessage,\n  MessageStructure,\n} from \"@langchain/core/messages\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport type { Runnable, RunnableConfig } from \"@langchain/core/runnables\";\nimport type { StreamEvent } from \"@langchain/core/tracers/log_stream\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\nimport { createAgentState } from \"./annotation.js\";\nimport {\n  isClientTool,\n  validateLLMHasNoBoundTools,\n  wrapToolCall,\n  normalizeSystemPrompt,\n} from \"./utils.js\";\n\nimport { AgentNode, AGENT_NODE_NAME } from \"./nodes/AgentNode.js\";\nimport { ToolNode, TOOLS_NODE_NAME } from \"./nodes/ToolNode.js\";\nimport { BeforeAgentNode } from \"./nodes/BeforeAgentNode.js\";\nimport { BeforeModelNode } from \"./nodes/BeforeModelNode.js\";\nimport { AfterModelNode } from \"./nodes/AfterModelNode.js\";\nimport { AfterAgentNode } from \"./nodes/AfterAgentNode.js\";\nimport {\n  initializeMiddlewareStates,\n  parseJumpToTarget,\n} from \"./nodes/utils.js\";\nimport { StateManager } from \"./state.js\";\n\nimport type {\n  WithStateGraphNodes,\n  AgentTypeConfig,\n  CreateAgentParams,\n  ToolsToMessageToolSet,\n} from \"./types.js\";\n\nimport type { BuiltInState, JumpTo, UserInput } from \"./types.js\";\nimport type { InvokeConfiguration, StreamConfiguration } from \"./runtime.js\";\nimport type {\n  AgentMiddleware,\n  InferMiddlewareContextInputs,\n  InferMiddlewareStates,\n  InferMiddlewareInputStates,\n  InferContextInput,\n  AnyAnnotationRoot,\n  InferSchemaInput,\n  ToAnnotationRoot,\n} from \"./middleware/types.js\";\nimport { type ResponseFormatUndefined } from \"./responses.js\";\nimport { getHookConstraint } from \"./middleware/utils.js\";\n\n/**\n * In the ReAct pattern we have three main nodes:\n * - model_request: The node that makes the model call.\n * - tools: The node that calls the tools.\n * - END: The end of the graph.\n *\n * These are the only nodes that can be jumped to from other nodes.\n */\ntype BaseGraphDestination =\n  | typeof TOOLS_NODE_NAME\n  | typeof AGENT_NODE_NAME\n  | typeof END;\n\n// Helper type to get the state definition with middleware states\ntype MergedAgentState<Types extends AgentTypeConfig> = InferSchemaInput<\n  Types[\"State\"]\n> &\n  (Types[\"Response\"] extends ResponseFormatUndefined\n    ? Omit<\n        BuiltInState<MessageStructure<ToolsToMessageToolSet<Types[\"Tools\"]>>>,\n        \"jumpTo\"\n      >\n    : Omit<\n        BuiltInState<MessageStructure<ToolsToMessageToolSet<Types[\"Tools\"]>>>,\n        \"jumpTo\"\n      > & {\n        structuredResponse: Types[\"Response\"];\n      }) &\n  InferMiddlewareStates<Types[\"Middleware\"]>;\n\ntype InvokeStateParameter<Types extends AgentTypeConfig> =\n  | (UserInput<Types[\"State\"]> &\n      InferMiddlewareInputStates<Types[\"Middleware\"]>)\n  | Command<any, any, any>\n  | null;\n\ntype AgentGraph<Types extends AgentTypeConfig> = CompiledStateGraph<\n  any,\n  any,\n  any,\n  any,\n  MergedAgentState<Types>,\n  ToAnnotationRoot<\n    Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n      ? Types[\"Context\"]\n      : AnyAnnotationRoot\n  >[\"spec\"],\n  unknown\n>;\n\n/**\n * ReactAgent is a production-ready ReAct (Reasoning + Acting) agent that combines\n * language models with tools and middleware.\n *\n * The agent is parameterized by a single type bag `Types` that encapsulates all\n * type information:\n *\n * @typeParam Types - An {@link AgentTypeConfig} that bundles:\n *   - `Response`: The structured response type\n *   - `State`: The custom state schema type\n *   - `Context`: The context schema type\n *   - `Middleware`: The middleware array type\n *   - `Tools`: The combined tools type from agent and middleware\n *\n * @example\n * ```typescript\n * // Using the type bag pattern\n * type MyTypes = AgentTypeConfig<\n *   { name: string },  // Response\n *   typeof myState,    // State\n *   typeof myContext,  // Context\n *   typeof middleware, // Middleware\n *   typeof tools       // Tools\n * >;\n *\n * const agent: ReactAgent<MyTypes> = createAgent({ ... });\n * ```\n */\nexport class ReactAgent<\n  Types extends AgentTypeConfig = AgentTypeConfig<\n    Record<string, any>,\n    undefined,\n    AnyAnnotationRoot,\n    readonly AgentMiddleware[],\n    readonly (ClientTool | ServerTool)[]\n  >,\n> {\n  /**\n   * Type marker for extracting the AgentTypeConfig from a ReactAgent instance.\n   * This is a phantom property used only for type inference.\n   * @internal\n   */\n  declare readonly \"~agentTypes\": Types;\n\n  #graph: AgentGraph<Types>;\n\n  #toolBehaviorVersion: \"v1\" | \"v2\" = \"v2\";\n\n  #agentNode: AgentNode<any, AnyAnnotationRoot>;\n\n  #stateManager = new StateManager();\n\n  constructor(\n    public options: CreateAgentParams<\n      Types[\"Response\"],\n      Types[\"State\"],\n      Types[\"Context\"]\n    >\n  ) {\n    this.#toolBehaviorVersion = options.version ?? this.#toolBehaviorVersion;\n\n    /**\n     * validate that model option is provided\n     */\n    if (!options.model) {\n      throw new Error(\"`model` option is required to create an agent.\");\n    }\n\n    /**\n     * Check if the LLM already has bound tools and throw if it does.\n     */\n    if (typeof options.model !== \"string\") {\n      validateLLMHasNoBoundTools(options.model);\n    }\n\n    /**\n     * define complete list of tools based on options and middleware\n     */\n    const middlewareTools = (this.options.middleware\n      ?.filter((m) => m.tools)\n      .flatMap((m) => m.tools) ?? []) as (ClientTool | ServerTool)[];\n    const toolClasses = [...(options.tools ?? []), ...middlewareTools];\n\n    /**\n     * If any of the tools are configured to return_directly after running,\n     * our graph needs to check if these were called\n     */\n    const shouldReturnDirect = new Set(\n      toolClasses\n        .filter(isClientTool)\n        .filter((tool) => \"returnDirect\" in tool && tool.returnDirect)\n        .map((tool) => tool.name)\n    );\n\n    /**\n     * Create a schema that merges agent base schema with middleware state schemas\n     * Using Zod with withLangGraph ensures LangGraph Studio gets proper metadata\n     */\n    const { state, input, output } = createAgentState<\n      Types[\"State\"],\n      Types[\"Middleware\"]\n    >(\n      this.options.responseFormat !== undefined,\n      this.options.stateSchema as Types[\"State\"],\n      this.options.middleware as Types[\"Middleware\"]\n    );\n\n    const workflow = new StateGraph(state, {\n      input,\n      output,\n      context: this.options.contextSchema,\n    });\n\n    const allNodeWorkflows = workflow as WithStateGraphNodes<\n      typeof TOOLS_NODE_NAME | typeof AGENT_NODE_NAME | string,\n      typeof workflow\n    >;\n\n    // Generate node names for middleware nodes that have hooks\n    const beforeAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const beforeModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const afterModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const afterAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const wrapModelCallHookMiddleware: [\n      AgentMiddleware,\n      /**\n       * ToDo: better type to get the state of middleware\n       */\n      () => any,\n    ][] = [];\n\n    this.#agentNode = new AgentNode({\n      model: this.options.model,\n      systemMessage: normalizeSystemPrompt(this.options.systemPrompt),\n      includeAgentName: this.options.includeAgentName,\n      name: this.options.name,\n      responseFormat: this.options.responseFormat,\n      middleware: this.options.middleware,\n      toolClasses,\n      shouldReturnDirect,\n      signal: this.options.signal,\n      wrapModelCallHookMiddleware,\n    });\n\n    const middlewareNames = new Set<string>();\n    const middleware = this.options.middleware ?? [];\n    for (let i = 0; i < middleware.length; i++) {\n      let beforeAgentNode: BeforeAgentNode | undefined;\n      let beforeModelNode: BeforeModelNode | undefined;\n      let afterModelNode: AfterModelNode | undefined;\n      let afterAgentNode: AfterAgentNode | undefined;\n      const m = middleware[i];\n      if (middlewareNames.has(m.name)) {\n        throw new Error(`Middleware ${m.name} is defined multiple times`);\n      }\n\n      middlewareNames.add(m.name);\n      if (m.beforeAgent) {\n        beforeAgentNode = new BeforeAgentNode(m, {\n          getState: () => this.#stateManager.getState(m.name),\n        });\n        this.#stateManager.addNode(m, beforeAgentNode);\n        const name = `${m.name}.before_agent`;\n        beforeAgentNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.beforeAgent),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          beforeAgentNode,\n          beforeAgentNode.nodeOptions\n        );\n      }\n      if (m.beforeModel) {\n        beforeModelNode = new BeforeModelNode(m, {\n          getState: () => this.#stateManager.getState(m.name),\n        });\n        this.#stateManager.addNode(m, beforeModelNode);\n        const name = `${m.name}.before_model`;\n        beforeModelNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.beforeModel),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          beforeModelNode,\n          beforeModelNode.nodeOptions\n        );\n      }\n      if (m.afterModel) {\n        afterModelNode = new AfterModelNode(m, {\n          getState: () => this.#stateManager.getState(m.name),\n        });\n        this.#stateManager.addNode(m, afterModelNode);\n        const name = `${m.name}.after_model`;\n        afterModelNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.afterModel),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          afterModelNode,\n          afterModelNode.nodeOptions\n        );\n      }\n      if (m.afterAgent) {\n        afterAgentNode = new AfterAgentNode(m, {\n          getState: () => this.#stateManager.getState(m.name),\n        });\n        this.#stateManager.addNode(m, afterAgentNode);\n        const name = `${m.name}.after_agent`;\n        afterAgentNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.afterAgent),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          afterAgentNode,\n          afterAgentNode.nodeOptions\n        );\n      }\n\n      if (m.wrapModelCall) {\n        wrapModelCallHookMiddleware.push([\n          m,\n          () => this.#stateManager.getState(m.name),\n        ]);\n      }\n    }\n\n    /**\n     * Add Nodes\n     */\n    allNodeWorkflows.addNode(AGENT_NODE_NAME, this.#agentNode);\n\n    /**\n     * Check if any middleware has wrapToolCall defined.\n     * If so, we need to create a ToolNode even without pre-registered tools\n     * to allow middleware to handle dynamically registered tools.\n     */\n    const hasWrapToolCallMiddleware = middleware.some((m) => m.wrapToolCall);\n    const clientTools = toolClasses.filter(isClientTool);\n\n    /**\n     * Create ToolNode if we have client-side tools OR if middleware defines wrapToolCall\n     * (which may handle dynamically registered tools)\n     */\n    if (clientTools.length > 0 || hasWrapToolCallMiddleware) {\n      const toolNode = new ToolNode(clientTools, {\n        signal: this.options.signal,\n        wrapToolCall: wrapToolCall(middleware),\n      });\n      allNodeWorkflows.addNode(TOOLS_NODE_NAME, toolNode);\n    }\n\n    /**\n     * Add Edges\n     */\n    // Determine the entry node (runs once at start): before_agent -> before_model -> model_request\n    let entryNode: string;\n    if (beforeAgentNodes.length > 0) {\n      entryNode = beforeAgentNodes[0].name;\n    } else if (beforeModelNodes.length > 0) {\n      entryNode = beforeModelNodes[0].name;\n    } else {\n      entryNode = AGENT_NODE_NAME;\n    }\n\n    // Determine the loop entry node (beginning of agent loop, excludes before_agent)\n    // This is where tools will loop back to for the next iteration\n    const loopEntryNode =\n      beforeModelNodes.length > 0 ? beforeModelNodes[0].name : AGENT_NODE_NAME;\n\n    // Determine the exit node (runs once at end): after_agent or END\n    const exitNode =\n      afterAgentNodes.length > 0\n        ? afterAgentNodes[afterAgentNodes.length - 1].name\n        : END;\n\n    allNodeWorkflows.addEdge(START, entryNode);\n\n    /**\n     * Determine if we have tools available for routing.\n     * This includes both registered client tools AND dynamic tools via middleware.\n     */\n    const hasToolsAvailable =\n      clientTools.length > 0 || hasWrapToolCallMiddleware;\n\n    // Connect beforeAgent nodes (run once at start)\n    for (let i = 0; i < beforeAgentNodes.length; i++) {\n      const node = beforeAgentNodes[i];\n      const current = node.name;\n      const isLast = i === beforeAgentNodes.length - 1;\n      const nextDefault = isLast ? loopEntryNode : beforeAgentNodes[i + 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasToolsAvailable);\n        // Replace END with exitNode (which could be an afterAgent node)\n        const destinations = Array.from(\n          new Set([\n            nextDefault,\n            ...allowedMapped.map((dest) => (dest === END ? exitNode : dest)),\n          ])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createBeforeAgentRouter(\n            clientTools,\n            nextDefault,\n            exitNode,\n            hasToolsAvailable\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect beforeModel nodes; add conditional routing ONLY if allowed jumps are specified\n    for (let i = 0; i < beforeModelNodes.length; i++) {\n      const node = beforeModelNodes[i];\n      const current = node.name;\n      const isLast = i === beforeModelNodes.length - 1;\n      const nextDefault = isLast\n        ? AGENT_NODE_NAME\n        : beforeModelNodes[i + 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasToolsAvailable);\n        const destinations = Array.from(\n          new Set([nextDefault, ...allowedMapped])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createBeforeModelRouter(\n            clientTools,\n            nextDefault,\n            hasToolsAvailable\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect agent to last afterModel node (for reverse order execution)\n    const lastAfterModelNode = afterModelNodes.at(-1);\n    if (afterModelNodes.length > 0 && lastAfterModelNode) {\n      allNodeWorkflows.addEdge(AGENT_NODE_NAME, lastAfterModelNode.name);\n    } else {\n      // If no afterModel nodes, connect model_request directly to model paths\n      const modelPaths = this.#getModelPaths(\n        clientTools,\n        false,\n        hasToolsAvailable\n      );\n      // Replace END with exitNode in destinations, since exitNode might be an afterAgent node\n      const destinations = modelPaths.map((p) =>\n        p === END ? exitNode : p\n      ) as BaseGraphDestination[];\n      if (destinations.length === 1) {\n        allNodeWorkflows.addEdge(AGENT_NODE_NAME, destinations[0]);\n      } else {\n        allNodeWorkflows.addConditionalEdges(\n          AGENT_NODE_NAME,\n          this.#createModelRouter(exitNode),\n          destinations\n        );\n      }\n    }\n\n    // Connect afterModel nodes in reverse sequence; add conditional routing ONLY if allowed jumps are specified per node\n    for (let i = afterModelNodes.length - 1; i > 0; i--) {\n      const node = afterModelNodes[i];\n      const current = node.name;\n      const nextDefault = afterModelNodes[i - 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasToolsAvailable);\n        const destinations = Array.from(\n          new Set([nextDefault, ...allowedMapped])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createAfterModelSequenceRouter(\n            clientTools,\n            node.allowed,\n            nextDefault,\n            hasToolsAvailable\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect first afterModel node (last to execute) to model paths with jumpTo support\n    if (afterModelNodes.length > 0) {\n      const firstAfterModel = afterModelNodes[0];\n      const firstAfterModelNode = firstAfterModel.name;\n\n      // Include exitNode in the paths since afterModel should be able to route to after_agent or END\n      const modelPaths = this.#getModelPaths(\n        clientTools,\n        true,\n        hasToolsAvailable\n      ).filter((p) => p !== TOOLS_NODE_NAME || hasToolsAvailable);\n\n      const allowJump = Boolean(\n        firstAfterModel.allowed && firstAfterModel.allowed.length > 0\n      );\n\n      // Replace END with exitNode in destinations, since exitNode might be an afterAgent node\n      const destinations = modelPaths.map((p) =>\n        p === END ? exitNode : p\n      ) as BaseGraphDestination[];\n\n      allNodeWorkflows.addConditionalEdges(\n        firstAfterModelNode,\n        this.#createAfterModelRouter(\n          clientTools,\n          allowJump,\n          exitNode,\n          hasToolsAvailable\n        ),\n        destinations\n      );\n    }\n\n    // Connect afterAgent nodes (run once at end, in reverse order like afterModel)\n    for (let i = afterAgentNodes.length - 1; i > 0; i--) {\n      const node = afterAgentNodes[i];\n      const current = node.name;\n      const nextDefault = afterAgentNodes[i - 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasToolsAvailable);\n        const destinations = Array.from(\n          new Set([nextDefault, ...allowedMapped])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createAfterModelSequenceRouter(\n            clientTools,\n            node.allowed,\n            nextDefault,\n            hasToolsAvailable\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect the first afterAgent node (last to execute) to END\n    if (afterAgentNodes.length > 0) {\n      const firstAfterAgent = afterAgentNodes[0];\n      const firstAfterAgentNode = firstAfterAgent.name;\n\n      if (firstAfterAgent.allowed && firstAfterAgent.allowed.length > 0) {\n        const allowedMapped = firstAfterAgent.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasToolsAvailable);\n\n        /**\n         * For after_agent, only use explicitly allowed destinations (don't add loopEntryNode)\n         * The default destination (when no jump occurs) should be END\n         */\n        const destinations = Array.from(\n          new Set([END, ...allowedMapped])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          firstAfterAgentNode,\n          this.#createAfterModelSequenceRouter(\n            clientTools,\n            firstAfterAgent.allowed,\n            END as string,\n            hasToolsAvailable\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(firstAfterAgentNode, END);\n      }\n    }\n\n    /**\n     * add edges for tools node (includes both registered tools and dynamic tools via middleware)\n     */\n    if (hasToolsAvailable) {\n      // Tools should return to loop entry node (not including before_agent)\n      const toolReturnTarget = loopEntryNode;\n\n      if (shouldReturnDirect.size > 0) {\n        allNodeWorkflows.addConditionalEdges(\n          TOOLS_NODE_NAME,\n          this.#createToolsRouter(shouldReturnDirect, exitNode),\n          [toolReturnTarget, exitNode as string]\n        );\n      } else {\n        allNodeWorkflows.addEdge(TOOLS_NODE_NAME, toolReturnTarget);\n      }\n    }\n\n    /**\n     * compile the graph\n     */\n    this.#graph = allNodeWorkflows.compile({\n      checkpointer: this.options.checkpointer,\n      store: this.options.store,\n      name: this.options.name,\n      description: this.options.description,\n    }) as unknown as AgentGraph<Types>;\n  }\n\n  /**\n   * Get the compiled {@link https://docs.langchain.com/oss/javascript/langgraph/use-graph-api | StateGraph}.\n   */\n  get graph(): AgentGraph<Types> {\n    return this.#graph;\n  }\n\n  /**\n   * Get possible edge destinations from model node.\n   * @param toolClasses names of tools to call\n   * @param includeModelRequest whether to include \"model_request\" as a valid path (for jumpTo routing)\n   * @param hasToolsAvailable whether tools are available (includes dynamic tools via middleware)\n   * @returns list of possible edge destinations\n   */\n  #getModelPaths(\n    toolClasses: (ClientTool | ServerTool)[],\n    includeModelRequest: boolean = false,\n    hasToolsAvailable: boolean = toolClasses.length > 0\n  ): BaseGraphDestination[] {\n    const paths: BaseGraphDestination[] = [];\n    if (hasToolsAvailable) {\n      paths.push(TOOLS_NODE_NAME);\n    }\n\n    if (includeModelRequest) {\n      paths.push(AGENT_NODE_NAME);\n    }\n\n    paths.push(END);\n\n    return paths;\n  }\n\n  /**\n   * Create routing function for tools node conditional edges.\n   */\n  #createToolsRouter(\n    shouldReturnDirect: Set<string>,\n    exitNode: string | typeof END\n  ) {\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      const messages = builtInState.messages;\n      const lastMessage = messages[messages.length - 1];\n\n      // Check if we just executed a returnDirect tool\n      if (\n        ToolMessage.isInstance(lastMessage) &&\n        lastMessage.name &&\n        shouldReturnDirect.has(lastMessage.name)\n      ) {\n        // If we have a response format, route to agent to generate structured response\n        // Otherwise, return directly to exit node (could be after_agent or END)\n        return this.options.responseFormat ? AGENT_NODE_NAME : exitNode;\n      }\n\n      // For non-returnDirect tools, always route back to agent\n      return AGENT_NODE_NAME;\n    };\n  }\n\n  /**\n   * Create routing function for model node conditional edges.\n   * @param exitNode - The exit node to route to (could be after_agent or END)\n   */\n  #createModelRouter(exitNode: string | typeof END = END) {\n    /**\n     * determine if the agent should continue or not\n     */\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      const messages = builtInState.messages;\n      const lastMessage = messages.at(-1);\n\n      if (\n        !AIMessage.isInstance(lastMessage) ||\n        !lastMessage.tool_calls ||\n        lastMessage.tool_calls.length === 0\n      ) {\n        return exitNode;\n      }\n\n      // Check if all tool calls are for structured response extraction\n      const hasOnlyStructuredResponseCalls = lastMessage.tool_calls.every(\n        (toolCall) => toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (hasOnlyStructuredResponseCalls) {\n        // If all tool calls are for structured response extraction, go to exit node\n        // The AgentNode will handle these internally and return the structured response\n        return exitNode;\n      }\n\n      /**\n       * The tool node processes a single message.\n       */\n      if (this.#toolBehaviorVersion === \"v1\") {\n        return TOOLS_NODE_NAME;\n      }\n\n      /**\n       * Route to tools node (filter out any structured response tool calls)\n       */\n      const regularToolCalls = lastMessage.tool_calls.filter(\n        (toolCall) => !toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (regularToolCalls.length === 0) {\n        return exitNode;\n      }\n\n      return regularToolCalls.map(\n        (toolCall) =>\n          new Send(TOOLS_NODE_NAME, { ...state, lg_tool_call: toolCall })\n      );\n    };\n  }\n\n  /**\n   * Create routing function for jumpTo functionality after afterModel hooks.\n   *\n   * This router checks if the `jumpTo` property is set in the state after afterModel middleware\n   * execution. If set, it routes to the specified target (\"model_request\" or \"tools\").\n   * If not set, it falls back to the normal model routing logic for afterModel context.\n   *\n   * The jumpTo property is automatically cleared after use to prevent infinite loops.\n   *\n   * @param toolClasses - Available tool classes for validation\n   * @param allowJump - Whether jumping is allowed\n   * @param exitNode - The exit node to route to (could be after_agent or END)\n   * @param hasToolsAvailable - Whether tools are available (includes dynamic tools via middleware)\n   * @returns Router function that handles jumpTo logic and normal routing\n   */\n  #createAfterModelRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    allowJump: boolean,\n    exitNode: string | typeof END,\n    hasToolsAvailable: boolean = toolClasses.length > 0\n  ) {\n    const hasStructuredResponse = Boolean(this.options.responseFormat);\n\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as Omit<BuiltInState, \"jumpTo\"> & {\n        jumpTo?: JumpTo;\n      };\n      // First, check if we just processed a structured response\n      // If so, ignore any existing jumpTo and go to exitNode\n      const messages = builtInState.messages;\n      const lastMessage = messages.at(-1);\n      if (\n        AIMessage.isInstance(lastMessage) &&\n        (!lastMessage.tool_calls || lastMessage.tool_calls.length === 0)\n      ) {\n        return exitNode;\n      }\n\n      // Check if jumpTo is set in the state and allowed\n      if (allowJump && builtInState.jumpTo) {\n        const destination = parseJumpToTarget(builtInState.jumpTo);\n        if (destination === END) {\n          return exitNode;\n        }\n        if (destination === TOOLS_NODE_NAME) {\n          // If trying to jump to tools but no tools are available, go to exitNode\n          if (!hasToolsAvailable) {\n            return exitNode;\n          }\n          return new Send(TOOLS_NODE_NAME, { ...state, jumpTo: undefined });\n        }\n        // destination === \"model_request\"\n        return new Send(AGENT_NODE_NAME, { ...state, jumpTo: undefined });\n      }\n\n      // check if there are pending tool calls\n      const toolMessages = messages.filter(ToolMessage.isInstance);\n      const lastAiMessage = messages.filter(AIMessage.isInstance).at(-1);\n      const pendingToolCalls = lastAiMessage?.tool_calls?.filter(\n        (call) => !toolMessages.some((m) => m.tool_call_id === call.id)\n      );\n      if (pendingToolCalls && pendingToolCalls.length > 0) {\n        return pendingToolCalls.map(\n          (toolCall) =>\n            new Send(TOOLS_NODE_NAME, { ...state, lg_tool_call: toolCall })\n        );\n      }\n\n      // if we exhausted all tool calls, but still have no structured response tool calls,\n      // go back to model_request\n      const hasStructuredResponseCalls = lastAiMessage?.tool_calls?.some(\n        (toolCall) => toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (\n        pendingToolCalls &&\n        pendingToolCalls.length === 0 &&\n        !hasStructuredResponseCalls &&\n        hasStructuredResponse\n      ) {\n        return AGENT_NODE_NAME;\n      }\n\n      if (\n        !AIMessage.isInstance(lastMessage) ||\n        !lastMessage.tool_calls ||\n        lastMessage.tool_calls.length === 0\n      ) {\n        return exitNode;\n      }\n\n      // Check if all tool calls are for structured response extraction\n      const hasOnlyStructuredResponseCalls = lastMessage.tool_calls.every(\n        (toolCall) => toolCall.name.startsWith(\"extract-\")\n      );\n\n      // Check if there are any regular tool calls (non-structured response)\n      const hasRegularToolCalls = lastMessage.tool_calls.some(\n        (toolCall) => !toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (hasOnlyStructuredResponseCalls || !hasRegularToolCalls) {\n        return exitNode;\n      }\n\n      /**\n       * For routing from afterModel nodes, always use simple string paths\n       * The Send API is handled at the model_request node level\n       */\n      return TOOLS_NODE_NAME;\n    };\n  }\n\n  /**\n   * Router for afterModel sequence nodes (connecting later middlewares to earlier ones),\n   * honoring allowed jump targets and defaulting to the next node.\n   * @param toolClasses - Available tool classes for validation\n   * @param allowed - List of allowed jump targets\n   * @param nextDefault - Default node to route to\n   * @param hasToolsAvailable - Whether tools are available (includes dynamic tools via middleware)\n   */\n  #createAfterModelSequenceRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    allowed: string[],\n    nextDefault: string,\n    hasToolsAvailable: boolean = toolClasses.length > 0\n  ) {\n    const allowedSet = new Set(allowed.map((t) => parseJumpToTarget(t)));\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      if (builtInState.jumpTo) {\n        const dest = parseJumpToTarget(builtInState.jumpTo);\n        if (dest === END && allowedSet.has(END)) {\n          return END;\n        }\n        if (dest === TOOLS_NODE_NAME && allowedSet.has(TOOLS_NODE_NAME)) {\n          if (!hasToolsAvailable) return END;\n          return new Send(TOOLS_NODE_NAME, { ...state, jumpTo: undefined });\n        }\n        if (dest === AGENT_NODE_NAME && allowedSet.has(AGENT_NODE_NAME)) {\n          return new Send(AGENT_NODE_NAME, { ...state, jumpTo: undefined });\n        }\n      }\n      return nextDefault;\n    };\n  }\n\n  /**\n   * Create routing function for jumpTo functionality after beforeAgent hooks.\n   * Falls back to the default next node if no jumpTo is present.\n   * When jumping to END, routes to exitNode (which could be an afterAgent node).\n   * @param toolClasses - Available tool classes for validation\n   * @param nextDefault - Default node to route to\n   * @param exitNode - Exit node to route to (could be after_agent or END)\n   * @param hasToolsAvailable - Whether tools are available (includes dynamic tools via middleware)\n   */\n  #createBeforeAgentRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    nextDefault: string,\n    exitNode: string | typeof END,\n    hasToolsAvailable: boolean = toolClasses.length > 0\n  ) {\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      if (!builtInState.jumpTo) {\n        return nextDefault;\n      }\n      const destination = parseJumpToTarget(builtInState.jumpTo);\n      if (destination === END) {\n        /**\n         * When beforeAgent jumps to END, route to exitNode (first afterAgent node)\n         */\n        return exitNode;\n      }\n      if (destination === TOOLS_NODE_NAME) {\n        if (!hasToolsAvailable) {\n          return exitNode;\n        }\n        return new Send(TOOLS_NODE_NAME, { ...state, jumpTo: undefined });\n      }\n      return new Send(AGENT_NODE_NAME, { ...state, jumpTo: undefined });\n    };\n  }\n\n  /**\n   * Create routing function for jumpTo functionality after beforeModel hooks.\n   * Falls back to the default next node if no jumpTo is present.\n   * @param toolClasses - Available tool classes for validation\n   * @param nextDefault - Default node to route to\n   * @param hasToolsAvailable - Whether tools are available (includes dynamic tools via middleware)\n   */\n  #createBeforeModelRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    nextDefault: string,\n    hasToolsAvailable: boolean = toolClasses.length > 0\n  ) {\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      if (!builtInState.jumpTo) {\n        return nextDefault;\n      }\n      const destination = parseJumpToTarget(builtInState.jumpTo);\n      if (destination === END) {\n        return END;\n      }\n      if (destination === TOOLS_NODE_NAME) {\n        if (!hasToolsAvailable) {\n          return END;\n        }\n        return new Send(TOOLS_NODE_NAME, { ...state, jumpTo: undefined });\n      }\n      return new Send(AGENT_NODE_NAME, { ...state, jumpTo: undefined });\n    };\n  }\n\n  /**\n   * Initialize middleware states if not already present in the input state.\n   */\n  async #initializeMiddlewareStates(\n    state: InvokeStateParameter<Types>,\n    config: RunnableConfig\n  ): Promise<InvokeStateParameter<Types>> {\n    if (\n      !this.options.middleware ||\n      this.options.middleware.length === 0 ||\n      state instanceof Command ||\n      !state\n    ) {\n      return state;\n    }\n\n    const defaultStates = await initializeMiddlewareStates(\n      this.options.middleware,\n      state\n    );\n    const threadState = await this.#graph\n      .getState(config)\n      .catch(() => ({ values: {} }));\n    const updatedState = {\n      ...threadState.values,\n      ...state,\n    } as InvokeStateParameter<Types>;\n    if (!updatedState) {\n      return updatedState;\n    }\n\n    // Only add defaults for keys that don't exist in current state\n    for (const [key, value] of Object.entries(defaultStates)) {\n      if (!(key in updatedState)) {\n        updatedState[key as keyof typeof updatedState] = value;\n      }\n    }\n\n    return updatedState;\n  }\n\n  /**\n   * Executes the agent with the given state and returns the final state after all processing.\n   *\n   * This method runs the agent's entire workflow synchronously, including:\n   * - Processing the input messages through any configured middleware\n   * - Calling the language model to generate responses\n   * - Executing any tool calls made by the model\n   * - Running all middleware hooks (beforeModel, afterModel, etc.)\n   *\n   * @param state - The initial state for the agent execution. Can be:\n   *   - An object containing `messages` array and any middleware-specific state properties\n   *   - A Command object for more advanced control flow\n   *\n   * @param config - Optional runtime configuration including:\n   * @param config.context - The context for the agent execution.\n   * @param config.configurable - LangGraph configuration options like `thread_id`, `run_id`, etc.\n   * @param config.store - The store for the agent execution for persisting state, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Memory storage}.\n   * @param config.signal - An optional {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal | `AbortSignal`} for the agent execution.\n   * @param config.recursionLimit - The recursion limit for the agent execution.\n   *\n   * @returns A Promise that resolves to the final agent state after execution completes.\n   *          The returned state includes:\n   *          - a `messages` property containing an array with all messages (input, AI responses, tool calls/results)\n   *          - a `structuredResponse` property containing the structured response (if configured)\n   *          - all state values defined in the middleware\n   *\n   * @example\n   * ```typescript\n   * const agent = new ReactAgent({\n   *   llm: myModel,\n   *   tools: [calculator, webSearch],\n   *   responseFormat: z.object({\n   *     weather: z.string(),\n   *   }),\n   * });\n   *\n   * const result = await agent.invoke({\n   *   messages: [{ role: \"human\", content: \"What's the weather in Paris?\" }]\n   * });\n   *\n   * console.log(result.structuredResponse.weather); // outputs: \"It's sunny and 75F.\"\n   * ```\n   */\n  async invoke(\n    state: InvokeStateParameter<Types>,\n    config?: InvokeConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>\n    >\n  ) {\n    type FullState = MergedAgentState<Types>;\n    const initializedState = await this.#initializeMiddlewareStates(\n      state,\n      config as RunnableConfig\n    );\n\n    return this.#graph.invoke(\n      initializedState,\n      config as unknown as InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>\n    ) as Promise<FullState>;\n  }\n\n  /**\n   * Executes the agent with streaming, returning an async iterable of state updates as they occur.\n   *\n   * This method runs the agent's workflow similar to `invoke`, but instead of waiting for\n   * completion, it streams high-level state updates in real-time. This allows you to:\n   * - Display intermediate results to users as they're generated\n   * - Monitor the agent's progress through each step\n   * - React to state changes as nodes complete\n   *\n   * For more granular event-level streaming (like individual LLM tokens), use `streamEvents` instead.\n   *\n   * @param state - The initial state for the agent execution. Can be:\n   *   - An object containing `messages` array and any middleware-specific state properties\n   *   - A Command object for more advanced control flow\n   *\n   * @param config - Optional runtime configuration including:\n   * @param config.context - The context for the agent execution.\n   * @param config.configurable - LangGraph configuration options like `thread_id`, `run_id`, etc.\n   * @param config.store - The store for the agent execution for persisting state, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Memory storage}.\n   * @param config.signal - An optional {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal | `AbortSignal`} for the agent execution.\n   * @param config.streamMode - The streaming mode for the agent execution, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/streaming#supported-stream-modes | Supported stream modes}.\n   * @param config.recursionLimit - The recursion limit for the agent execution.\n   *\n   * @returns A Promise that resolves to an IterableReadableStream of state updates.\n   *          Each update contains the current state after a node completes.\n   *\n   * @example\n   * ```typescript\n   * const agent = new ReactAgent({\n   *   llm: myModel,\n   *   tools: [calculator, webSearch]\n   * });\n   *\n   * const stream = await agent.stream({\n   *   messages: [{ role: \"human\", content: \"What's 2+2 and the weather in NYC?\" }]\n   * });\n   *\n   * for await (const chunk of stream) {\n   *   console.log(chunk); // State update from each node\n   * }\n   * ```\n   */\n  async stream<\n    TStreamMode extends StreamMode | StreamMode[] | undefined,\n    TEncoding extends \"text/event-stream\" | undefined,\n  >(\n    state: InvokeStateParameter<Types>,\n    config?: StreamConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>,\n      TStreamMode,\n      TEncoding\n    >\n  ) {\n    const initializedState = await this.#initializeMiddlewareStates(\n      state,\n      config as RunnableConfig\n    );\n    return this.#graph.stream(\n      initializedState,\n      config as Record<string, any>\n    ) as Promise<\n      IterableReadableStream<\n        StreamOutputMap<\n          TStreamMode,\n          false,\n          MergedAgentState<Types>,\n          MergedAgentState<Types>,\n          string,\n          unknown,\n          unknown,\n          TEncoding\n        >\n      >\n    >;\n  }\n\n  /**\n   * Visualize the graph as a PNG image.\n   * @param params - Parameters for the drawMermaidPng method.\n   * @param params.withStyles - Whether to include styles in the graph.\n   * @param params.curveStyle - The style of the graph's curves.\n   * @param params.nodeColors - The colors of the graph's nodes.\n   * @param params.wrapLabelNWords - The maximum number of words to wrap in a node's label.\n   * @param params.backgroundColor - The background color of the graph.\n   * @returns PNG image as a buffer\n   */\n  async drawMermaidPng(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }) {\n    const representation = await this.#graph.getGraphAsync();\n    const image = await representation.drawMermaidPng(params);\n    const arrayBuffer = await image.arrayBuffer();\n    const buffer = new Uint8Array(arrayBuffer);\n    return buffer;\n  }\n\n  /**\n   * Draw the graph as a Mermaid string.\n   * @param params - Parameters for the drawMermaid method.\n   * @param params.withStyles - Whether to include styles in the graph.\n   * @param params.curveStyle - The style of the graph's curves.\n   * @param params.nodeColors - The colors of the graph's nodes.\n   * @param params.wrapLabelNWords - The maximum number of words to wrap in a node's label.\n   * @param params.backgroundColor - The background color of the graph.\n   * @returns Mermaid string\n   */\n  async drawMermaid(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }) {\n    const representation = await this.#graph.getGraphAsync();\n    return representation.drawMermaid(params);\n  }\n\n  /**\n   * The following are internal methods to enable support for LangGraph Platform.\n   * They are not part of the createAgent public API.\n   *\n   * Note: we intentionally return as `never` to avoid type errors due to type inference.\n   */\n\n  /**\n   * @internal\n   */\n  streamEvents(\n    state: InvokeStateParameter<Types>,\n    config?: StreamConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>,\n      StreamMode | StreamMode[] | undefined,\n      \"text/event-stream\" | undefined\n    > & { version?: \"v1\" | \"v2\" },\n    streamOptions?: Parameters<Runnable[\"streamEvents\"]>[2]\n  ): IterableReadableStream<StreamEvent> {\n    return this.#graph.streamEvents(\n      state,\n      {\n        ...(config as Partial<\n          PregelOptions<\n            any,\n            any,\n            any,\n            StreamMode | StreamMode[] | undefined,\n            boolean,\n            \"text/event-stream\"\n          >\n        >),\n        version: config?.version ?? \"v2\",\n      },\n      streamOptions\n    );\n  }\n  /**\n   * @internal\n   */\n  getGraphAsync(config?: RunnableConfig) {\n    return this.#graph.getGraphAsync(config) as never;\n  }\n  /**\n   * @internal\n   */\n  getState(config: RunnableConfig, options?: GetStateOptions) {\n    return this.#graph.getState(config, options) as never;\n  }\n  /**\n   * @internal\n   */\n  getStateHistory(config: RunnableConfig, options?: CheckpointListOptions) {\n    return this.#graph.getStateHistory(config, options) as never;\n  }\n  /**\n   * @internal\n   */\n  getSubgraphs(namespace?: string, recurse?: boolean) {\n    return this.#graph.getSubgraphs(namespace, recurse) as never;\n  }\n  /**\n   * @internal\n   */\n  getSubgraphAsync(namespace?: string, recurse?: boolean) {\n    return this.#graph.getSubgraphsAsync(namespace, recurse) as never;\n  }\n  /**\n   * @internal\n   */\n  updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: string\n  ) {\n    return this.#graph.updateState(inputConfig, values, asNode) as never;\n  }\n\n  /**\n   * @internal\n   */\n  get builder() {\n    return this.#graph.builder;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {\n  InteropZodObject,\n  InteropZodType,\n} from \"@langchain/core/utils/types\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\nimport type { StateDefinitionInit } from \"@langchain/langgraph\";\n\nimport type { ResponseFormatUndefined } from \"./responses.js\";\nimport type {\n  CreateAgentParams,\n  AgentTypeConfig,\n  CombineTools,\n} from \"./types.js\";\nimport type { AgentMiddleware, AnyAnnotationRoot } from \"./middleware/types.js\";\nimport type { ExtractZodArrayTypes } from \"./types.js\";\nimport type {\n  ToolStrategy,\n  TypedToolStrategy,\n  ProviderStrategy,\n  ResponseFormat,\n  JsonSchemaFormat,\n} from \"./responses.js\";\nimport { ReactAgent } from \"./ReactAgent.js\";\n\n/**\n * Creates a production-ready ReAct (Reasoning + Acting) agent that combines language models with tools\n * and middleware to create systems that can reason about tasks, decide which tools to use, and iteratively\n * work towards solutions.\n *\n * The agent follows the ReAct pattern, interleaving reasoning steps with tool calls to iteratively\n * work towards solutions. It can handle multiple tool calls in sequence or parallel, maintain state\n * across interactions, and provide auditable decision processes.\n *\n * ## Core Components\n *\n * ### Model\n * The reasoning engine can be specified as:\n * - **String identifier**: `\"openai:gpt-4o\"` for simple setup\n * - **Model instance**: Configured model object for full control\n * - **Dynamic function**: Select models at runtime based on state\n *\n * ### Tools\n * Tools give agents the ability to take actions:\n * - Pass an array of tools created with the `tool` function\n * - Or provide a configured `ToolNode` for custom error handling\n *\n * ### Prompt\n * Shape how your agent approaches tasks:\n * - String for simple instructions\n * - SystemMessage for structured prompts\n * - Function for dynamic prompts based on state\n *\n * ### Middleware\n * Middleware allows you to extend the agent's behavior:\n * - Add pre/post-model processing for context injection or validation\n * - Add dynamic control flows, e.g. terminate invocation or retries\n * - Add human-in-the-loop capabilities\n * - Add tool calls to the agent\n * - Add tool results to the agent\n *\n * ## Advanced Features\n *\n * - **Structured Output**: Use `responseFormat` with a Zod schema to get typed responses\n * - **Memory**: Extend the state schema to remember information across interactions\n * - **Streaming**: Get real-time updates as the agent processes\n *\n * @param options - Configuration options for the agent\n * @param options.llm - The language model as an instance of a chat model\n * @param options.model - The language model as a string identifier, see more in {@link https://docs.langchain.com/oss/javascript/langchain/models#basic-usage | Models}.\n * @param options.tools - Array of tools or configured ToolNode\n * @param options.prompt - System instructions (string, SystemMessage, or function)\n * @param options.responseFormat - Zod schema for structured output\n * @param options.stateSchema - Custom state schema for memory\n * @param options.middleware - Array of middleware for extending agent behavior, see more in {@link https://docs.langchain.com/oss/javascript/langchain/middleware | Middleware}.\n *\n * @returns A ReactAgent instance with `invoke` and `stream` methods\n *\n * @example Basic agent with tools\n * ```ts\n * import { createAgent, tool } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const search = tool(\n *   ({ query }) => `Results for: ${query}`,\n *   {\n *     name: \"search\",\n *     description: \"Search for information\",\n *     schema: z.object({\n *       query: z.string().describe(\"The search query\"),\n *     })\n *   }\n * );\n *\n * const agent = createAgent({\n *   llm: \"openai:gpt-4o\",\n *   tools: [search],\n * });\n *\n * const result = await agent.invoke({\n *   messages: [{ role: \"user\", content: \"Search for ReAct agents\" }],\n * });\n * ```\n *\n * @example Structured output\n * ```ts\n * import { createAgent } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const ContactInfo = z.object({\n *   name: z.string(),\n *   email: z.string(),\n *   phone: z.string(),\n * });\n *\n * const agent = createAgent({\n *   llm: \"openai:gpt-4o\",\n *   tools: [],\n *   responseFormat: ContactInfo,\n * });\n *\n * const result = await agent.invoke({\n *   messages: [{\n *     role: \"user\",\n *     content: \"Extract: John Doe, john@example.com, (555) 123-4567\"\n *   }],\n * });\n *\n * console.log(result.structuredResponse);\n * // { name: 'John Doe', email: 'john@example.com', phone: '(555) 123-4567' }\n * ```\n *\n * @example Streaming responses\n * ```ts\n * const stream = await agent.stream(\n *   { messages: [{ role: \"user\", content: \"What's the weather?\" }] },\n *   { streamMode: \"values\" }\n * );\n *\n * for await (const chunk of stream) {\n *   // ...\n * }\n * ```\n *\n * @example With StateSchema\n * ```ts\n * import { createAgent } from \"langchain\";\n * import { StateSchema, ReducedValue } from \"@langchain/langgraph\";\n * import { z } from \"zod\";\n *\n * const AgentState = new StateSchema({\n *   userId: z.string(),\n *   count: z.number().default(0),\n *   history: new ReducedValue(\n *     z.array(z.string()).default(() => []),\n *     { inputSchema: z.string(), reducer: (c, n) => [...c, n] }\n *   ),\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [searchTool],\n *   stateSchema: AgentState,\n * });\n * ```\n */\n// Overload 1: With responseFormat as single InteropZodType\nexport function createAgent<\n  StructuredResponseFormat extends Record<string, any> = Record<string, any>,\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    InteropZodType<StructuredResponseFormat>\n  > & {\n    responseFormat: InteropZodType<StructuredResponseFormat>;\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 2: With responseFormat as array of InteropZodTypes (infers union type)\nexport function createAgent<\n  StructuredResponseFormat extends readonly InteropZodType<any>[],\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    ExtractZodArrayTypes<StructuredResponseFormat> extends Record<string, any>\n      ? ExtractZodArrayTypes<StructuredResponseFormat>\n      : Record<string, any>,\n    TStateSchema,\n    ContextSchema,\n    StructuredResponseFormat\n  > & {\n    responseFormat: StructuredResponseFormat;\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    ExtractZodArrayTypes<StructuredResponseFormat> extends Record<string, any>\n      ? ExtractZodArrayTypes<StructuredResponseFormat>\n      : Record<string, any>,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 3: With responseFormat as JsonSchemaFormat (JSON schema object)\nexport function createAgent<\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    Record<string, unknown>,\n    TStateSchema,\n    ContextSchema,\n    JsonSchemaFormat\n  > & {\n    responseFormat: JsonSchemaFormat;\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    Record<string, unknown>,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 4: With responseFormat as array of JsonSchemaFormat (JSON schema objects)\nexport function createAgent<\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    Record<string, unknown>,\n    TStateSchema,\n    ContextSchema,\n    JsonSchemaFormat[]\n  > & {\n    responseFormat: JsonSchemaFormat[];\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    Record<string, unknown>,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 4.5: With responseFormat as union of JsonSchemaFormat | JsonSchemaFormat[]\nexport function createAgent<\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    Record<string, unknown>,\n    TStateSchema,\n    ContextSchema,\n    JsonSchemaFormat | JsonSchemaFormat[]\n  > & {\n    responseFormat: JsonSchemaFormat | JsonSchemaFormat[];\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    Record<string, unknown>,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 5: With responseFormat as TypedToolStrategy (for union types from toolStrategy)\nexport function createAgent<\n  StructuredResponseFormat extends Record<string, any> = Record<string, any>,\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    TypedToolStrategy<StructuredResponseFormat>\n  > & {\n    responseFormat: TypedToolStrategy<StructuredResponseFormat>;\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 6: With responseFormat as single ToolStrategy instance\nexport function createAgent<\n  StructuredResponseFormat extends Record<string, any> = Record<string, any>,\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    ToolStrategy<StructuredResponseFormat>\n  > & {\n    responseFormat: ToolStrategy<StructuredResponseFormat>;\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 7: With responseFormat as ProviderStrategy\nexport function createAgent<\n  StructuredResponseFormat extends Record<string, any> = Record<string, any>,\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    ProviderStrategy<StructuredResponseFormat>\n  > & {\n    responseFormat: ProviderStrategy<StructuredResponseFormat>;\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 8: Without responseFormat property at all - with proper middleware state typing\nexport function createAgent<\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: Omit<\n    CreateAgentParams<\n      ResponseFormatUndefined,\n      TStateSchema,\n      ContextSchema,\n      never\n    >,\n    \"responseFormat\"\n  > & { middleware?: TMiddleware; tools?: TTools }\n): ReactAgent<\n  AgentTypeConfig<\n    ResponseFormatUndefined,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 9: With responseFormat explicitly undefined\nexport function createAgent<\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: Omit<\n    CreateAgentParams<\n      ResponseFormatUndefined,\n      TStateSchema,\n      ContextSchema,\n      never\n    >,\n    \"responseFormat\"\n  > & {\n    responseFormat?: undefined;\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    ResponseFormatUndefined,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Overload 10: For other ResponseFormat values (failsafe)\nexport function createAgent<\n  StructuredResponseFormat extends Record<string, any> = Record<string, any>,\n  TStateSchema extends StateDefinitionInit | undefined = undefined,\n  ContextSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject = AnyAnnotationRoot,\n  const TMiddleware extends\n    readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  const TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    ResponseFormat\n  > & {\n    responseFormat: ResponseFormat;\n    middleware?: TMiddleware;\n    tools?: TTools;\n  }\n): ReactAgent<\n  AgentTypeConfig<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n>;\n\n// Implementation\nexport function createAgent<\n  StructuredResponseFormat extends Record<string, any>,\n  TStateSchema extends StateDefinitionInit,\n  ContextSchema extends AnyAnnotationRoot | InteropZodObject,\n  TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[],\n  TTools extends readonly (ClientTool | ServerTool)[] = readonly (\n    | ClientTool\n    | ServerTool\n  )[],\n>(\n  params: CreateAgentParams<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    any\n  >\n): ReactAgent<\n  AgentTypeConfig<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    TMiddleware,\n    CombineTools<TTools, TMiddleware>\n  >\n> {\n  return new ReactAgent(params);\n}\n\n// Re-export types and utilities\nexport * from \"./types.js\";\nexport * from \"./errors.js\";\nexport type { JumpToTarget } from \"./constants.js\";\nexport type { Runtime } from \"./runtime.js\";\nexport {\n  toolStrategy,\n  providerStrategy,\n  ToolStrategy,\n  ProviderStrategy,\n  type ResponseFormat,\n  type ResponseFormatUndefined,\n} from \"./responses.js\";\nexport { createMiddleware } from \"./middleware.js\";\nexport { MIDDLEWARE_BRAND } from \"./middleware/types.js\";\nexport type * from \"./middleware/types.js\";\nexport { FakeToolCallingModel } from \"./tests/utils.js\";\nexport type { ReactAgent } from \"./ReactAgent.js\";\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z } from \"zod/v3\";\nimport { AIMessage, ToolMessage, ToolCall } from \"@langchain/core/messages\";\nimport {\n  InferInteropZodInput,\n  interopParse,\n} from \"@langchain/core/utils/types\";\nimport { interrupt } from \"@langchain/langgraph\";\n\nimport { createMiddleware } from \"../middleware.js\";\nimport type { AgentBuiltInState, Runtime } from \"../runtime.js\";\nimport type { JumpToTarget } from \"../constants.js\";\n\nconst DescriptionFunctionSchema = z\n  .function()\n  .args(\n    z.custom<ToolCall>(), // toolCall\n    z.custom<AgentBuiltInState>(), // state\n    z.custom<Runtime<unknown>>() // runtime\n  )\n  .returns(z.union([z.string(), z.promise(z.string())]));\n\n/**\n * Function type that dynamically generates a description for a tool call approval request.\n *\n * @param toolCall - The tool call being reviewed\n * @param state - The current agent state\n * @param runtime - The agent runtime context\n * @returns A string description or Promise that resolves to a string description\n *\n * @example\n * ```typescript\n * import { type DescriptionFactory, type ToolCall } from \"langchain\";\n *\n * const descriptionFactory: DescriptionFactory = (toolCall, state, runtime) => {\n *   return `Please review: ${toolCall.name}(${JSON.stringify(toolCall.args)})`;\n * };\n * ```\n */\nexport type DescriptionFactory = z.infer<typeof DescriptionFunctionSchema>;\n\n/**\n * The type of decision a human can make.\n */\nconst ALLOWED_DECISIONS = [\"approve\", \"edit\", \"reject\"] as const;\nconst DecisionType = z.enum(ALLOWED_DECISIONS);\nexport type DecisionType = z.infer<typeof DecisionType>;\n\nconst InterruptOnConfigSchema = z.object({\n  /**\n   * The decisions that are allowed for this action.\n   */\n  allowedDecisions: z.array(DecisionType),\n  /**\n   * The description attached to the request for human input.\n   * Can be either:\n   * - A static string describing the approval request\n   * - A callable that dynamically generates the description based on agent state,\n   *   runtime, and tool call information\n   *\n   * @example\n   * Static string description\n   * ```typescript\n   * import type { InterruptOnConfig } from \"langchain\";\n   *\n   * const config: InterruptOnConfig = {\n   *   allowedDecisions: [\"approve\", \"reject\"],\n   *   description: \"Please review this tool execution\"\n   * };\n   * ```\n   *\n   * @example\n   * Dynamic callable description\n   * ```typescript\n   * import type {\n   *   AgentBuiltInState,\n   *   Runtime,\n   *   DescriptionFactory,\n   *   ToolCall,\n   *   InterruptOnConfig\n   * } from \"langchain\";\n   *\n   * const formatToolDescription: DescriptionFactory = (\n   *   toolCall: ToolCall,\n   *   state: AgentBuiltInState,\n   *   runtime: Runtime<unknown>\n   * ) => {\n   *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n   * };\n   *\n   * const config: InterruptOnConfig = {\n   *   allowedDecisions: [\"approve\", \"edit\"],\n   *   description: formatToolDescription\n   * };\n   * ```\n   */\n  description: z.union([z.string(), DescriptionFunctionSchema]).optional(),\n  /**\n   * JSON schema for the arguments associated with the action, if edits are allowed.\n   */\n  argsSchema: z.record(z.any()).optional(),\n});\nexport type InterruptOnConfig = z.input<typeof InterruptOnConfigSchema>;\n\n/**\n * Represents an action with a name and arguments.\n */\nexport interface Action {\n  /**\n   * The type or name of action being requested (e.g., \"add_numbers\").\n   */\n  name: string;\n  /**\n   * Key-value pairs of arguments needed for the action (e.g., {\"a\": 1, \"b\": 2}).\n   */\n  args: Record<string, any>;\n}\n\n/**\n * Represents an action request with a name, arguments, and description.\n */\nexport interface ActionRequest {\n  /**\n   * The name of the action being requested.\n   */\n  name: string;\n  /**\n   * Key-value pairs of arguments needed for the action (e.g., {\"a\": 1, \"b\": 2}).\n   */\n  args: Record<string, any>;\n  /**\n   * The description of the action to be reviewed.\n   */\n  description?: string;\n}\n\n/**\n * Policy for reviewing a HITL request.\n */\nexport interface ReviewConfig {\n  /**\n   * Name of the action associated with this review configuration.\n   */\n  actionName: string;\n  /**\n   * The decisions that are allowed for this request.\n   */\n  allowedDecisions: DecisionType[];\n  /**\n   * JSON schema for the arguments associated with the action, if edits are allowed.\n   */\n  argsSchema?: Record<string, any>;\n}\n\n/**\n * Request for human feedback on a sequence of actions requested by a model.\n *\n * @example\n * ```ts\n * const hitlRequest: HITLRequest = {\n *   actionRequests: [\n *     { name: \"send_email\", args: { to: \"user@example.com\", subject: \"Hello\" } }\n *   ],\n *   reviewConfigs: [\n *     {\n *       actionName: \"send_email\",\n *       allowedDecisions: [\"approve\", \"edit\", \"reject\"],\n *       description: \"Please review the email before sending\"\n *     }\n *   ]\n * };\n * const response = interrupt(hitlRequest);\n * ```\n */\nexport interface HITLRequest {\n  /**\n   * A list of agent actions for human review.\n   */\n  actionRequests: ActionRequest[];\n  /**\n   * Review configuration for all possible actions.\n   */\n  reviewConfigs: ReviewConfig[];\n}\n\n/**\n * Response when a human approves the action.\n */\nexport interface ApproveDecision {\n  type: \"approve\";\n}\n\n/**\n * Response when a human edits the action.\n */\nexport interface EditDecision {\n  type: \"edit\";\n  /**\n   * Edited action for the agent to perform.\n   * Ex: for a tool call, a human reviewer can edit the tool name and args.\n   */\n  editedAction: Action;\n}\n\n/**\n * Response when a human rejects the action.\n */\nexport interface RejectDecision {\n  type: \"reject\";\n  /**\n   * The message sent to the model explaining why the action was rejected.\n   */\n  message?: string;\n}\n\n/**\n * Union of all possible decision types.\n */\nexport type Decision = ApproveDecision | EditDecision | RejectDecision;\n\n/**\n * Response payload for a HITLRequest.\n */\nexport interface HITLResponse {\n  /**\n   * The decisions made by the human.\n   */\n  decisions: Decision[];\n}\n\nconst contextSchema = z.object({\n  /**\n   * Mapping of tool name to allowed reviewer responses.\n   * If a tool doesn't have an entry, it's auto-approved by default.\n   *\n   * - `true` -> pause for approval and allow approve/edit/reject decisions\n   * - `false` -> auto-approve (no human review)\n   * - `InterruptOnConfig` -> explicitly specify which decisions are allowed for this tool\n   */\n  interruptOn: z\n    .record(z.union([z.boolean(), InterruptOnConfigSchema]))\n    .optional(),\n  /**\n   * Prefix used when constructing human-facing approval messages.\n   * Provides context about the tool call being reviewed; does not change the underlying action.\n   *\n   * Note: This prefix is only applied for tools that do not provide a custom\n   * `description` via their {@link InterruptOnConfig}. If a tool specifies a custom\n   * `description`, that per-tool text is used and this prefix is ignored.\n   */\n  descriptionPrefix: z.string().default(\"Tool execution requires approval\"),\n});\nexport type HumanInTheLoopMiddlewareConfig = InferInteropZodInput<\n  typeof contextSchema\n>;\n\n/**\n * Creates a Human-in-the-Loop (HITL) middleware for tool approval and oversight.\n *\n * This middleware intercepts tool calls made by an AI agent and provides human oversight\n * capabilities before execution. It enables selective approval workflows where certain tools\n * require human intervention while others can execute automatically.\n *\n * A invocation result that has been interrupted by the middleware will have a `__interrupt__`\n * property that contains the interrupt request.\n *\n * ```ts\n * import { type HITLRequest, type HITLResponse } from \"langchain\";\n * import { type Interrupt } from \"langchain\";\n *\n * const result = await agent.invoke(request);\n * const interruptRequest = result.__interrupt__?.[0] as Interrupt<HITLRequest>;\n *\n * // Examine the action requests and review configs\n * const actionRequests = interruptRequest.value.actionRequests;\n * const reviewConfigs = interruptRequest.value.reviewConfigs;\n *\n * // Create decisions for each action\n * const resume: HITLResponse = {\n *   decisions: actionRequests.map((action, i) => {\n *     if (action.name === \"calculator\") {\n *       return { type: \"approve\" };\n *     } else if (action.name === \"write_file\") {\n *       return {\n *         type: \"edit\",\n *         editedAction: { name: \"write_file\", args: { filename: \"safe.txt\", content: \"Safe content\" } }\n *       };\n *     }\n *     return { type: \"reject\", message: \"Action not allowed\" };\n *   })\n * };\n *\n * // Resume with decisions\n * await agent.invoke(new Command({ resume }), config);\n * ```\n *\n * ## Features\n *\n * - **Selective Tool Approval**: Configure which tools require human approval\n * - **Multiple Decision Types**: Approve, edit, or reject tool calls\n * - **Asynchronous Workflow**: Uses LangGraph's interrupt mechanism for non-blocking approval\n * - **Custom Approval Messages**: Provide context-specific descriptions for approval requests\n *\n * ## Decision Types\n *\n * When a tool requires approval, the human operator can respond with:\n * - `approve`: Execute the tool with original arguments\n * - `edit`: Modify the tool name and/or arguments before execution\n * - `reject`: Provide a manual response instead of executing the tool\n *\n * @param options - Configuration options for the middleware\n * @param options.interruptOn - Per-tool configuration mapping tool names to their settings\n * @param options.interruptOn[toolName].allowedDecisions - Array of decision types allowed for this tool (e.g., [\"approve\", \"edit\", \"reject\"])\n * @param options.interruptOn[toolName].description - Custom approval message for the tool. Can be either a static string or a callable that dynamically generates the description based on agent state, runtime, and tool call information\n * @param options.interruptOn[toolName].argsSchema - JSON schema for the arguments associated with the action, if edits are allowed\n * @param options.descriptionPrefix - Default prefix for approval messages (default: \"Tool execution requires approval\"). Only used for tools that do not define a custom `description` in their InterruptOnConfig.\n *\n * @returns A middleware instance that can be passed to `createAgent`\n *\n * @example\n * Basic usage with selective tool approval\n * ```typescript\n * import { humanInTheLoopMiddleware } from \"langchain\";\n * import { createAgent } from \"langchain\";\n *\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     // Interrupt write_file tool and allow edits or approvals\n *     \"write_file\": {\n *       allowedDecisions: [\"approve\", \"edit\"],\n *       description: \" File write operation requires approval\"\n *     },\n *     // Auto-approve read_file tool\n *     \"read_file\": false\n *   }\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4\",\n *   tools: [writeFileTool, readFileTool],\n *   middleware: [hitlMiddleware]\n * });\n * ```\n *\n * @example\n * Handling approval requests\n * ```typescript\n * import { type HITLRequest, type HITLResponse, type Interrupt } from \"langchain\";\n * import { Command } from \"@langchain/langgraph\";\n *\n * // Initial agent invocation\n * const result = await agent.invoke({\n *   messages: [new HumanMessage(\"Write 'Hello' to output.txt\")]\n * }, config);\n *\n * // Check if agent is paused for approval\n * if (result.__interrupt__) {\n *   const interruptRequest = result.__interrupt__?.[0] as Interrupt<HITLRequest>;\n *\n *   // Show tool call details to user\n *   console.log(\"Actions:\", interruptRequest.value.actionRequests);\n *   console.log(\"Review configs:\", interruptRequest.value.reviewConfigs);\n *\n *   // Resume with approval\n *   const resume: HITLResponse = {\n *     decisions: [{ type: \"approve\" }]\n *   };\n *   await agent.invoke(\n *     new Command({ resume }),\n *     config\n *   );\n * }\n * ```\n *\n * @example\n * Different decision types\n * ```typescript\n * import { type HITLResponse } from \"langchain\";\n *\n * // Approve the tool call as-is\n * const resume: HITLResponse = {\n *   decisions: [{ type: \"approve\" }]\n * };\n *\n * // Edit the tool arguments\n * const resume: HITLResponse = {\n *   decisions: [{\n *     type: \"edit\",\n *     editedAction: { name: \"write_file\", args: { filename: \"safe.txt\", content: \"Modified\" } }\n *   }]\n * };\n *\n * // Reject with feedback\n * const resume: HITLResponse = {\n *   decisions: [{\n *     type: \"reject\",\n *     message: \"File operation not allowed in demo mode\"\n *   }]\n * };\n * ```\n *\n * @example\n * Production use case with database operations\n * ```typescript\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     \"execute_sql\": {\n *       allowedDecisions: [\"approve\", \"edit\", \"reject\"],\n *       description: \" SQL query requires DBA approval\\nPlease review for safety and performance\"\n *     },\n *     \"read_schema\": false,  // Reading metadata is safe\n *     \"delete_records\": {\n *       allowedDecisions: [\"approve\", \"reject\"],\n *       description: \" DESTRUCTIVE OPERATION - Requires manager approval\"\n *     }\n *   },\n *   descriptionPrefix: \"Database operation pending approval\"\n * });\n * ```\n *\n * @example\n * Using dynamic callable descriptions\n * ```typescript\n * import { type DescriptionFactory, type ToolCall } from \"langchain\";\n * import type { AgentBuiltInState, Runtime } from \"langchain/agents\";\n *\n * // Define a dynamic description factory\n * const formatToolDescription: DescriptionFactory = (\n *   toolCall: ToolCall,\n *   state: AgentBuiltInState,\n *   runtime: Runtime<unknown>\n * ) => {\n *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n * };\n *\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     \"write_file\": {\n *       allowedDecisions: [\"approve\", \"edit\"],\n *       // Use dynamic description that can access tool call, state, and runtime\n *       description: formatToolDescription\n *     },\n *     // Or use an inline function\n *     \"send_email\": {\n *       allowedDecisions: [\"approve\", \"reject\"],\n *       description: (toolCall, state, runtime) => {\n *         const { to, subject } = toolCall.args;\n *         return `Email to ${to}\\nSubject: ${subject}\\n\\nRequires approval before sending`;\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @remarks\n * - Tool calls are processed in the order they appear in the AI message\n * - Auto-approved tools execute immediately without interruption\n * - Multiple tools requiring approval are bundled into a single interrupt request\n * - The middleware operates in the `afterModel` phase, intercepting before tool execution\n * - Requires a checkpointer to maintain state across interruptions\n *\n * @see {@link createAgent} for agent creation\n * @see {@link Command} for resuming interrupted execution\n * @public\n */\nexport function humanInTheLoopMiddleware(\n  options: NonNullable<HumanInTheLoopMiddlewareConfig>\n) {\n  const createActionAndConfig = async (\n    toolCall: ToolCall,\n    config: InterruptOnConfig,\n    state: AgentBuiltInState,\n    runtime: Runtime<unknown>\n  ): Promise<{\n    actionRequest: ActionRequest;\n    reviewConfig: ReviewConfig;\n  }> => {\n    const toolName = toolCall.name;\n    const toolArgs = toolCall.args;\n\n    // Generate description using the description field (str or callable)\n    const descriptionValue = config.description;\n    let description: string;\n    if (typeof descriptionValue === \"function\") {\n      description = await descriptionValue(toolCall, state, runtime);\n    } else if (descriptionValue !== undefined) {\n      description = descriptionValue;\n    } else {\n      description = `${\n        options.descriptionPrefix ?? \"Tool execution requires approval\"\n      }\\n\\nTool: ${toolName}\\nArgs: ${JSON.stringify(toolArgs, null, 2)}`;\n    }\n\n    /**\n     * Create ActionRequest with description\n     */\n    const actionRequest: ActionRequest = {\n      name: toolName,\n      args: toolArgs,\n      description,\n    };\n\n    /**\n     * Create ReviewConfig\n     */\n    const reviewConfig: ReviewConfig = {\n      actionName: toolName,\n      allowedDecisions: config.allowedDecisions,\n    };\n\n    if (config.argsSchema) {\n      reviewConfig.argsSchema = config.argsSchema;\n    }\n\n    return { actionRequest, reviewConfig };\n  };\n\n  const processDecision = (\n    decision: Decision,\n    toolCall: ToolCall,\n    config: InterruptOnConfig\n  ): { revisedToolCall: ToolCall | null; toolMessage: ToolMessage | null } => {\n    const allowedDecisions = config.allowedDecisions;\n    if (decision.type === \"approve\" && allowedDecisions.includes(\"approve\")) {\n      return { revisedToolCall: toolCall, toolMessage: null };\n    }\n\n    if (decision.type === \"edit\" && allowedDecisions.includes(\"edit\")) {\n      const editedAction = decision.editedAction;\n\n      /**\n       * Validate edited action structure\n       */\n      if (!editedAction || typeof editedAction.name !== \"string\") {\n        throw new Error(\n          `Invalid edited action for tool \"${toolCall.name}\": name must be a string`\n        );\n      }\n      if (!editedAction.args || typeof editedAction.args !== \"object\") {\n        throw new Error(\n          `Invalid edited action for tool \"${toolCall.name}\": args must be an object`\n        );\n      }\n\n      return {\n        revisedToolCall: {\n          type: \"tool_call\",\n          name: editedAction.name,\n          args: editedAction.args,\n          id: toolCall.id,\n        },\n        toolMessage: null,\n      };\n    }\n\n    if (decision.type === \"reject\" && allowedDecisions.includes(\"reject\")) {\n      /**\n       * Validate that message is a string if provided\n       */\n      if (\n        decision.message !== undefined &&\n        typeof decision.message !== \"string\"\n      ) {\n        throw new Error(\n          `Tool call response for \"${\n            toolCall.name\n          }\" must be a string, got ${typeof decision.message}`\n        );\n      }\n\n      // Create a tool message with the human's text response\n      const content =\n        decision.message ??\n        `User rejected the tool call for \\`${toolCall.name}\\` with id ${toolCall.id}`;\n\n      const toolMessage = new ToolMessage({\n        content,\n        name: toolCall.name,\n        tool_call_id: toolCall.id!,\n        status: \"error\",\n      });\n\n      return { revisedToolCall: toolCall, toolMessage };\n    }\n\n    const msg = `Unexpected human decision: ${JSON.stringify(\n      decision\n    )}. Decision type '${decision.type}' is not allowed for tool '${\n      toolCall.name\n    }'. Expected one of ${JSON.stringify(\n      allowedDecisions\n    )} based on the tool's configuration.`;\n    throw new Error(msg);\n  };\n\n  return createMiddleware({\n    name: \"HumanInTheLoopMiddleware\",\n    contextSchema,\n    afterModel: {\n      canJumpTo: [\"model\"],\n      hook: async (state, runtime) => {\n        const config = interopParse(contextSchema, {\n          ...options,\n          ...(runtime.context || {}),\n        });\n        if (!config) {\n          return;\n        }\n\n        const { messages } = state;\n        if (!messages.length) {\n          return;\n        }\n\n        /**\n         * Don't do anything if the last message isn't an AI message with tool calls.\n         */\n        const lastMessage = [...messages]\n          .reverse()\n          .find((msg) => AIMessage.isInstance(msg)) as AIMessage;\n        if (!lastMessage || !lastMessage.tool_calls?.length) {\n          return;\n        }\n\n        /**\n         * If the user omits the interruptOn config, we don't do anything.\n         */\n        if (!config.interruptOn) {\n          return;\n        }\n\n        /**\n         * Resolve per-tool configs (boolean true -> all decisions allowed; false -> auto-approve)\n         */\n        const resolvedConfigs: Record<string, InterruptOnConfig> = {};\n        for (const [toolName, toolConfig] of Object.entries(\n          config.interruptOn\n        )) {\n          if (typeof toolConfig === \"boolean\") {\n            if (toolConfig === true) {\n              resolvedConfigs[toolName] = {\n                allowedDecisions: [...ALLOWED_DECISIONS],\n              };\n            }\n          } else if (toolConfig.allowedDecisions) {\n            resolvedConfigs[toolName] = toolConfig as InterruptOnConfig;\n          }\n        }\n\n        const interruptToolCalls: ToolCall[] = [];\n        const autoApprovedToolCalls: ToolCall[] = [];\n\n        for (const toolCall of lastMessage.tool_calls) {\n          if (toolCall.name in resolvedConfigs) {\n            interruptToolCalls.push(toolCall);\n          } else {\n            autoApprovedToolCalls.push(toolCall);\n          }\n        }\n\n        /**\n         * No interrupt tool calls, so we can just return.\n         */\n        if (!interruptToolCalls.length) {\n          return;\n        }\n\n        /**\n         * Create action requests and review configs for all tools that need approval\n         */\n        const actionRequests: ActionRequest[] = [];\n        const reviewConfigs: ReviewConfig[] = [];\n\n        for (const toolCall of interruptToolCalls) {\n          const interruptConfig = resolvedConfigs[toolCall.name]!;\n\n          /**\n           * Create ActionRequest and ReviewConfig using helper method\n           */\n          const { actionRequest, reviewConfig } = await createActionAndConfig(\n            toolCall,\n            interruptConfig,\n            state,\n            runtime\n          );\n          actionRequests.push(actionRequest);\n          reviewConfigs.push(reviewConfig);\n        }\n\n        /**\n         * Create single HITLRequest with all actions and configs\n         */\n        const hitlRequest: HITLRequest = {\n          actionRequests,\n          reviewConfigs,\n        };\n\n        /**\n         * Send interrupt and get response\n         */\n        const hitlResponse = (await interrupt(hitlRequest)) as HITLResponse;\n        const decisions = hitlResponse.decisions;\n\n        /**\n         * Validate that decisions is a valid array before checking length\n         */\n        if (!decisions || !Array.isArray(decisions)) {\n          throw new Error(\n            \"Invalid HITLResponse: decisions must be a non-empty array\"\n          );\n        }\n\n        /**\n         * Validate that the number of decisions matches the number of interrupt tool calls\n         */\n        if (decisions.length !== interruptToolCalls.length) {\n          throw new Error(\n            `Number of human decisions (${decisions.length}) does not match number of hanging tool calls (${interruptToolCalls.length}).`\n          );\n        }\n\n        const revisedToolCalls: ToolCall[] = [...autoApprovedToolCalls];\n        const artificialToolMessages: ToolMessage[] = [];\n        const hasRejectedToolCalls = decisions.some(\n          (decision) => decision.type === \"reject\"\n        );\n\n        /**\n         * Process each decision using helper method\n         */\n        for (let i = 0; i < decisions.length; i++) {\n          const decision = decisions[i]!;\n          const toolCall = interruptToolCalls[i]!;\n          const interruptConfig = resolvedConfigs[toolCall.name]!;\n\n          const { revisedToolCall, toolMessage } = processDecision(\n            decision,\n            toolCall,\n            interruptConfig\n          );\n\n          if (\n            revisedToolCall &&\n            /**\n             * If any decision is a rejected, we are going back to the model\n             * with only the tool calls that were rejected as we don't know\n             * the results of the approved/updated tool calls at this point.\n             */\n            (!hasRejectedToolCalls || decision.type === \"reject\")\n          ) {\n            revisedToolCalls.push(revisedToolCall);\n          }\n          if (toolMessage) {\n            artificialToolMessages.push(toolMessage);\n          }\n        }\n\n        /**\n         * Update the AI message to only include approved tool calls\n         */\n        if (AIMessage.isInstance(lastMessage)) {\n          lastMessage.tool_calls = revisedToolCalls;\n        }\n\n        const jumpTo: JumpToTarget | undefined = hasRejectedToolCalls\n          ? \"model\"\n          : undefined;\n        return {\n          messages: [lastMessage, ...artificialToolMessages],\n          jumpTo,\n        };\n      },\n    },\n  });\n}\n", "import { z } from \"zod/v3\";\nimport { z as z4 } from \"zod/v4\";\nimport { v4 as uuid } from \"uuid\";\nimport {\n  BaseMessage,\n  AIMessage,\n  SystemMessage,\n  ToolMessage,\n  RemoveMessage,\n  trimMessages,\n  HumanMessage,\n  getBufferString,\n} from \"@langchain/core/messages\";\nimport {\n  BaseLanguageModel,\n  getModelContextSize,\n} from \"@langchain/core/language_models/base\";\nimport {\n  interopSafeParse,\n  InferInteropZodInput,\n  InferInteropZodOutput,\n} from \"@langchain/core/utils/types\";\nimport {\n  mergeConfigs,\n  pickRunnableConfigKeys,\n  type RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport { REMOVE_ALL_MESSAGES } from \"@langchain/langgraph\";\nimport { createMiddleware } from \"../middleware.js\";\nimport { countTokensApproximately } from \"./utils.js\";\nimport { hasToolCalls } from \"../utils.js\";\nimport { initChatModel } from \"../../chat_models/universal.js\";\nimport type { Runtime } from \"../runtime.js\";\n\nexport const DEFAULT_SUMMARY_PROMPT = `<role>\nContext Extraction Assistant\n</role>\n\n<primary_objective>\nYour sole objective in this task is to extract the highest quality/most relevant context from the conversation history below.\n</primary_objective>\n\n<objective_information>\nYou're nearing the total number of input tokens you can accept, so you must extract the highest quality/most relevant pieces of information from your conversation history.\nThis context will then overwrite the conversation history presented below. Because of this, ensure the context you extract is only the most important information to your overall goal.\n</objective_information>\n\n<instructions>\nThe conversation history below will be replaced with the context you extract in this step. Because of this, you must do your very best to extract and record all of the most important context from the conversation history.\nYou want to ensure that you don't repeat any actions you've already completed, so the context you extract from the conversation history should be focused on the most important information to your overall goal.\n</instructions>\n\nThe user will message you with the full message history you'll be extracting context from, to then replace. Carefully read over it all, and think deeply about what information is most important to your overall goal that should be saved:\n\nWith all of this in mind, please carefully read over the entire conversation history, and extract the most important and relevant context to replace it so that you can free up space in the conversation history.\nRespond ONLY with the extracted context. Do not include any additional information, or text before or after the extracted context.\n\n<messages>\nMessages to summarize:\n{messages}\n</messages>`;\n\nconst DEFAULT_SUMMARY_PREFIX = \"Here is a summary of the conversation to date:\";\nconst DEFAULT_MESSAGES_TO_KEEP = 20;\nconst DEFAULT_TRIM_TOKEN_LIMIT = 4000;\nconst DEFAULT_FALLBACK_MESSAGE_COUNT = 15;\nconst SEARCH_RANGE_FOR_TOOL_PAIRS = 5;\n\nconst tokenCounterSchema = z\n  .function()\n  .args(z.array(z.custom<BaseMessage>()))\n  .returns(z.union([z.number(), z.promise(z.number())]));\nexport type TokenCounter = (\n  messages: BaseMessage[]\n) => number | Promise<number>;\n\nexport const contextSizeSchema = z\n  .object({\n    /**\n     * Fraction of the model's context size to use as the trigger\n     */\n    fraction: z\n      .number()\n      .gt(0, \"Fraction must be greater than 0\")\n      .max(1, \"Fraction must be less than or equal to 1\")\n      .optional(),\n    /**\n     * Number of tokens to use as the trigger\n     */\n    tokens: z.number().positive(\"Tokens must be greater than 0\").optional(),\n    /**\n     * Number of messages to use as the trigger\n     */\n    messages: z\n      .number()\n      .int(\"Messages must be an integer\")\n      .positive(\"Messages must be greater than 0\")\n      .optional(),\n  })\n  .refine(\n    (data) => {\n      const count = [data.fraction, data.tokens, data.messages].filter(\n        (v) => v !== undefined\n      ).length;\n      return count >= 1;\n    },\n    {\n      message: \"At least one of fraction, tokens, or messages must be provided\",\n    }\n  );\nexport type ContextSize = z.infer<typeof contextSizeSchema>;\n\nexport const keepSchema = z\n  .object({\n    /**\n     * Fraction of the model's context size to keep\n     */\n    fraction: z\n      .number()\n      .min(0, \"Messages must be non-negative\")\n      .max(1, \"Fraction must be less than or equal to 1\")\n      .optional(),\n    /**\n     * Number of tokens to keep\n     */\n    tokens: z\n      .number()\n      .min(0, \"Tokens must be greater than or equal to 0\")\n      .optional(),\n    messages: z\n      .number()\n      .int(\"Messages must be an integer\")\n      .min(0, \"Messages must be non-negative\")\n      .optional(),\n  })\n  .refine(\n    (data) => {\n      const count = [data.fraction, data.tokens, data.messages].filter(\n        (v) => v !== undefined\n      ).length;\n      return count === 1;\n    },\n    {\n      message: \"Exactly one of fraction, tokens, or messages must be provided\",\n    }\n  );\nexport type KeepSize = z.infer<typeof keepSchema>;\n\nconst contextSchema = z.object({\n  /**\n   * Model to use for summarization\n   */\n  model: z.custom<string | BaseLanguageModel>(),\n  /**\n   * Trigger conditions for summarization.\n   * Can be a single condition object (all properties must be met) or an array of conditions (any condition must be met).\n   *\n   * @example\n   * ```ts\n   * // Single condition: trigger if tokens >= 5000 AND messages >= 3\n   * trigger: { tokens: 5000, messages: 3 }\n   *\n   * // Multiple conditions: trigger if (tokens >= 5000 AND messages >= 3) OR (tokens >= 3000 AND messages >= 6)\n   * trigger: [\n   *   { tokens: 5000, messages: 3 },\n   *   { tokens: 3000, messages: 6 }\n   * ]\n   * ```\n   */\n  trigger: z.union([contextSizeSchema, z.array(contextSizeSchema)]).optional(),\n  /**\n   * Keep conditions for summarization\n   */\n  keep: keepSchema.optional(),\n  /**\n   * Token counter function to use for summarization\n   */\n  tokenCounter: tokenCounterSchema.optional(),\n  /**\n   * Summary prompt to use for summarization\n   * @default {@link DEFAULT_SUMMARY_PROMPT}\n   */\n  summaryPrompt: z.string().default(DEFAULT_SUMMARY_PROMPT),\n  /**\n   * Number of tokens to trim to before summarizing\n   */\n  trimTokensToSummarize: z.number().optional(),\n  /**\n   * Prefix to add to the summary\n   */\n  summaryPrefix: z.string().optional(),\n  /**\n   * @deprecated Use `trigger: { tokens: value }` instead.\n   */\n  maxTokensBeforeSummary: z.number().optional(),\n  /**\n   * @deprecated Use `keep: { messages: value }` instead.\n   */\n  messagesToKeep: z.number().optional(),\n});\n\nexport type SummarizationMiddlewareConfig = InferInteropZodInput<\n  typeof contextSchema\n>;\n\n/**\n * Get max input tokens from model profile or fallback to model name lookup\n */\nexport function getProfileLimits(input: BaseLanguageModel): number | undefined {\n  // Access maxInputTokens on the model profile directly if available\n  if (\n    \"profile\" in input &&\n    typeof input.profile === \"object\" &&\n    input.profile &&\n    \"maxInputTokens\" in input.profile &&\n    (typeof input.profile.maxInputTokens === \"number\" ||\n      input.profile.maxInputTokens == null)\n  ) {\n    return input.profile.maxInputTokens ?? undefined;\n  }\n\n  // Fallback to using model name if available\n  if (\"model\" in input && typeof input.model === \"string\") {\n    return getModelContextSize(input.model);\n  }\n  if (\"modelName\" in input && typeof input.modelName === \"string\") {\n    return getModelContextSize(input.modelName);\n  }\n\n  return undefined;\n}\n\n/**\n * Summarization middleware that automatically summarizes conversation history when token limits are approached.\n *\n * This middleware monitors message token counts and automatically summarizes older\n * messages when a threshold is reached, preserving recent messages and maintaining\n * context continuity by ensuring AI/Tool message pairs remain together.\n *\n * @param options Configuration options for the summarization middleware\n * @returns A middleware instance\n *\n * @example\n * ```ts\n * import { summarizationMiddleware } from \"langchain\";\n * import { createAgent } from \"langchain\";\n *\n * // Single condition: trigger if tokens >= 4000 AND messages >= 10\n * const agent1 = createAgent({\n *   llm: model,\n *   tools: [getWeather],\n *   middleware: [\n *     summarizationMiddleware({\n *       model: new ChatOpenAI({ model: \"gpt-4o\" }),\n *       trigger: { tokens: 4000, messages: 10 },\n *       keep: { messages: 20 },\n *     })\n *   ],\n * });\n *\n * // Multiple conditions: trigger if (tokens >= 5000 AND messages >= 3) OR (tokens >= 3000 AND messages >= 6)\n * const agent2 = createAgent({\n *   llm: model,\n *   tools: [getWeather],\n *   middleware: [\n *     summarizationMiddleware({\n *       model: new ChatOpenAI({ model: \"gpt-4o\" }),\n *       trigger: [\n *         { tokens: 5000, messages: 3 },\n *         { tokens: 3000, messages: 6 },\n *       ],\n *       keep: { messages: 20 },\n *     })\n *   ],\n * });\n *\n * ```\n */\nexport function summarizationMiddleware(\n  options: SummarizationMiddlewareConfig\n) {\n  /**\n   * Parse user options to get their explicit values\n   */\n  const { data: userOptions, error } = interopSafeParse(contextSchema, options);\n  if (error) {\n    throw new Error(\n      `Invalid summarization middleware options: ${z4.prettifyError(error)}`\n    );\n  }\n\n  return createMiddleware({\n    name: \"SummarizationMiddleware\",\n    contextSchema: contextSchema.extend({\n      /**\n       * `model` should be required when initializing the middleware,\n       * but can be omitted within context when invoking the middleware.\n       */\n      model: z.custom<BaseLanguageModel>().optional(),\n    }),\n    beforeModel: async (state, runtime) => {\n      let trigger: ContextSize | ContextSize[] | undefined =\n        userOptions.trigger;\n      let keep: ContextSize = userOptions.keep as InferInteropZodOutput<\n        typeof keepSchema\n      >;\n\n      /**\n       * Handle deprecated parameters\n       */\n      if (userOptions.maxTokensBeforeSummary !== undefined) {\n        console.warn(\n          \"maxTokensBeforeSummary is deprecated. Use `trigger: { tokens: value }` instead.\"\n        );\n        if (trigger === undefined) {\n          trigger = { tokens: userOptions.maxTokensBeforeSummary };\n        }\n      }\n\n      /**\n       * Handle deprecated parameters\n       */\n      if (userOptions.messagesToKeep !== undefined) {\n        console.warn(\n          \"messagesToKeep is deprecated. Use `keep: { messages: value }` instead.\"\n        );\n        if (\n          !keep ||\n          (keep &&\n            \"messages\" in keep &&\n            keep.messages === DEFAULT_MESSAGES_TO_KEEP)\n        ) {\n          keep = { messages: userOptions.messagesToKeep };\n        }\n      }\n\n      /**\n       * Merge context with user options\n       */\n      const resolvedTrigger =\n        runtime.context?.trigger !== undefined\n          ? runtime.context.trigger\n          : trigger;\n      const resolvedKeep =\n        runtime.context?.keep !== undefined\n          ? runtime.context.keep\n          : (keep ?? { messages: DEFAULT_MESSAGES_TO_KEEP });\n\n      const validatedKeep = keepSchema.parse(resolvedKeep);\n\n      /**\n       * Validate trigger conditions\n       */\n      let triggerConditions: ContextSize[] = [];\n      if (resolvedTrigger === undefined) {\n        triggerConditions = [];\n      } else if (Array.isArray(resolvedTrigger)) {\n        /**\n         * It's an array of ContextSize objects\n         */\n        triggerConditions = (resolvedTrigger as ContextSize[]).map((t) =>\n          contextSizeSchema.parse(t)\n        );\n      } else {\n        /**\n         * Single ContextSize object - all properties must be satisfied (AND logic)\n         */\n        triggerConditions = [contextSizeSchema.parse(resolvedTrigger)];\n      }\n\n      /**\n       * Check if profile is required\n       */\n      const requiresProfile =\n        triggerConditions.some((c) => \"fraction\" in c) ||\n        \"fraction\" in validatedKeep;\n\n      const model =\n        typeof userOptions.model === \"string\"\n          ? await initChatModel(userOptions.model)\n          : userOptions.model;\n\n      if (requiresProfile && !getProfileLimits(model)) {\n        throw new Error(\n          \"Model profile information is required to use fractional token limits. \" +\n            \"Use absolute token counts instead.\"\n        );\n      }\n\n      const summaryPrompt =\n        runtime.context?.summaryPrompt === DEFAULT_SUMMARY_PROMPT\n          ? (userOptions.summaryPrompt ?? DEFAULT_SUMMARY_PROMPT)\n          : (runtime.context?.summaryPrompt ??\n            userOptions.summaryPrompt ??\n            DEFAULT_SUMMARY_PROMPT);\n      const summaryPrefix =\n        runtime.context.summaryPrefix ??\n        userOptions.summaryPrefix ??\n        DEFAULT_SUMMARY_PREFIX;\n      const trimTokensToSummarize =\n        runtime.context?.trimTokensToSummarize !== undefined\n          ? runtime.context.trimTokensToSummarize\n          : (userOptions.trimTokensToSummarize ?? DEFAULT_TRIM_TOKEN_LIMIT);\n\n      /**\n       * Ensure all messages have IDs\n       */\n      ensureMessageIds(state.messages);\n\n      const tokenCounter =\n        runtime.context?.tokenCounter !== undefined\n          ? runtime.context.tokenCounter\n          : (userOptions.tokenCounter ?? countTokensApproximately);\n      const totalTokens = await tokenCounter(state.messages);\n      const doSummarize = await shouldSummarize(\n        state.messages,\n        totalTokens,\n        triggerConditions,\n        model\n      );\n\n      if (!doSummarize) {\n        return;\n      }\n\n      const { systemPrompt, conversationMessages } = splitSystemMessage(\n        state.messages\n      );\n      const cutoffIndex = await determineCutoffIndex(\n        conversationMessages,\n        validatedKeep,\n        tokenCounter,\n        model\n      );\n\n      if (cutoffIndex <= 0) {\n        return;\n      }\n\n      const { messagesToSummarize, preservedMessages } = partitionMessages(\n        systemPrompt,\n        conversationMessages,\n        cutoffIndex\n      );\n\n      const summary = await createSummary(\n        messagesToSummarize,\n        model,\n        summaryPrompt,\n        tokenCounter,\n        trimTokensToSummarize,\n        runtime\n      );\n\n      const summaryMessage = new HumanMessage({\n        content: `${summaryPrefix}\\n\\n${summary}`,\n        id: uuid(),\n        additional_kwargs: { lc_source: \"summarization\" },\n      });\n\n      return {\n        messages: [\n          new RemoveMessage({ id: REMOVE_ALL_MESSAGES }),\n          summaryMessage,\n          ...preservedMessages,\n        ],\n      };\n    },\n  });\n}\n\n/**\n * Ensure all messages have unique IDs\n */\nfunction ensureMessageIds(messages: BaseMessage[]): void {\n  for (const msg of messages) {\n    if (!msg.id) {\n      msg.id = uuid();\n    }\n  }\n}\n\n/**\n * Separate system message from conversation messages\n */\nfunction splitSystemMessage(messages: BaseMessage[]): {\n  systemPrompt?: SystemMessage;\n  conversationMessages: BaseMessage[];\n} {\n  if (messages.length > 0 && SystemMessage.isInstance(messages[0])) {\n    return {\n      systemPrompt: messages[0] as SystemMessage,\n      conversationMessages: messages.slice(1),\n    };\n  }\n  return {\n    conversationMessages: messages,\n  };\n}\n\n/**\n * Partition messages into those to summarize and those to preserve\n */\nfunction partitionMessages(\n  systemPrompt: SystemMessage | undefined,\n  conversationMessages: BaseMessage[],\n  cutoffIndex: number\n): { messagesToSummarize: BaseMessage[]; preservedMessages: BaseMessage[] } {\n  const messagesToSummarize = conversationMessages.slice(0, cutoffIndex);\n  const preservedMessages = conversationMessages.slice(cutoffIndex);\n\n  // Include system message in messages to summarize to capture previous summaries\n  if (systemPrompt) {\n    messagesToSummarize.unshift(systemPrompt);\n  }\n\n  return { messagesToSummarize, preservedMessages };\n}\n\n/**\n * Determine whether summarization should run for the current token usage\n *\n * @param messages - Current messages in the conversation\n * @param totalTokens - Total token count for all messages\n * @param triggerConditions - Array of trigger conditions. Returns true if ANY condition is satisfied (OR logic).\n *                           Within each condition, ALL specified properties must be satisfied (AND logic).\n * @param model - The language model being used\n * @returns true if summarization should be triggered\n */\nasync function shouldSummarize(\n  messages: BaseMessage[],\n  totalTokens: number,\n  triggerConditions: ContextSize[],\n  model: BaseLanguageModel\n): Promise<boolean> {\n  if (triggerConditions.length === 0) {\n    return false;\n  }\n\n  /**\n   * Check each condition (OR logic between conditions)\n   */\n  for (const trigger of triggerConditions) {\n    /**\n     * Within a single condition, all specified properties must be satisfied (AND logic)\n     */\n    let conditionMet = true;\n    let hasAnyProperty = false;\n\n    if (trigger.messages !== undefined) {\n      hasAnyProperty = true;\n      if (messages.length < trigger.messages) {\n        conditionMet = false;\n      }\n    }\n\n    if (trigger.tokens !== undefined) {\n      hasAnyProperty = true;\n      if (totalTokens < trigger.tokens) {\n        conditionMet = false;\n      }\n    }\n\n    if (trigger.fraction !== undefined) {\n      hasAnyProperty = true;\n      const maxInputTokens = getProfileLimits(model);\n      if (typeof maxInputTokens === \"number\") {\n        const threshold = Math.floor(maxInputTokens * trigger.fraction);\n        if (totalTokens < threshold) {\n          conditionMet = false;\n        }\n      } else {\n        /**\n         * If fraction is specified but we can't get model limits, skip this condition\n         */\n        conditionMet = false;\n      }\n    }\n\n    /**\n     * If condition has at least one property and all properties are satisfied, trigger summarization\n     */\n    if (hasAnyProperty && conditionMet) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Determine cutoff index respecting retention configuration\n */\nasync function determineCutoffIndex(\n  messages: BaseMessage[],\n  keep: ContextSize,\n  tokenCounter: TokenCounter,\n  model: BaseLanguageModel\n): Promise<number> {\n  if (\"tokens\" in keep || \"fraction\" in keep) {\n    const tokenBasedCutoff = await findTokenBasedCutoff(\n      messages,\n      keep,\n      tokenCounter,\n      model\n    );\n    if (typeof tokenBasedCutoff === \"number\") {\n      return tokenBasedCutoff;\n    }\n    /**\n     * Fallback to message count if token-based fails\n     */\n    return findSafeCutoff(messages, DEFAULT_MESSAGES_TO_KEEP);\n  }\n  /**\n   * find cutoff index based on message count\n   */\n  return findSafeCutoff(messages, keep.messages ?? DEFAULT_MESSAGES_TO_KEEP);\n}\n\n/**\n * Find cutoff index based on target token retention\n */\nasync function findTokenBasedCutoff(\n  messages: BaseMessage[],\n  keep: ContextSize,\n  tokenCounter: TokenCounter,\n  model: BaseLanguageModel\n): Promise<number | undefined> {\n  if (messages.length === 0) {\n    return 0;\n  }\n\n  let targetTokenCount: number;\n\n  if (\"fraction\" in keep && keep.fraction !== undefined) {\n    const maxInputTokens = getProfileLimits(model);\n    if (typeof maxInputTokens !== \"number\") {\n      return;\n    }\n    targetTokenCount = Math.floor(maxInputTokens * keep.fraction);\n  } else if (\"tokens\" in keep && keep.tokens !== undefined) {\n    targetTokenCount = Math.floor(keep.tokens);\n  } else {\n    return;\n  }\n\n  if (targetTokenCount <= 0) {\n    targetTokenCount = 1;\n  }\n\n  const totalTokens = await tokenCounter(messages);\n  if (totalTokens <= targetTokenCount) {\n    return 0;\n  }\n\n  /**\n   * Use binary search to identify the earliest message index that keeps the\n   * suffix within the token budget.\n   */\n  let left = 0;\n  let right = messages.length;\n  let cutoffCandidate = messages.length;\n  const maxIterations = Math.floor(Math.log2(messages.length)) + 1;\n\n  for (let i = 0; i < maxIterations; i++) {\n    if (left >= right) {\n      break;\n    }\n\n    const mid = Math.floor((left + right) / 2);\n    const suffixTokens = await tokenCounter(messages.slice(mid));\n    if (suffixTokens <= targetTokenCount) {\n      cutoffCandidate = mid;\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n\n  if (cutoffCandidate === messages.length) {\n    cutoffCandidate = left;\n  }\n\n  if (cutoffCandidate >= messages.length) {\n    if (messages.length === 1) {\n      return 0;\n    }\n    cutoffCandidate = messages.length - 1;\n  }\n\n  /**\n   * Find safe cutoff point that preserves AI/Tool pairs.\n   * If cutoff lands on ToolMessage, move backward to include the AIMessage.\n   */\n  const safeCutoff = findSafeCutoffPoint(messages, cutoffCandidate);\n\n  /**\n   * If findSafeCutoffPoint moved forward (fallback case), verify it's safe.\n   * If it moved backward, we already have a safe point.\n   */\n  if (safeCutoff <= cutoffCandidate) {\n    return safeCutoff;\n  }\n\n  /**\n   * Fallback: iterate backward to find a safe cutoff\n   */\n  for (let i = cutoffCandidate; i >= 0; i--) {\n    if (isSafeCutoffPoint(messages, i)) {\n      return i;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Find safe cutoff point that preserves AI/Tool message pairs\n */\nfunction findSafeCutoff(\n  messages: BaseMessage[],\n  messagesToKeep: number\n): number {\n  if (messages.length <= messagesToKeep) {\n    return 0;\n  }\n\n  const targetCutoff = messages.length - messagesToKeep;\n\n  /**\n   * First, try to find a safe cutoff point using findSafeCutoffPoint.\n   * This handles the case where cutoff lands on a ToolMessage by moving\n   * backward to include the corresponding AIMessage.\n   */\n  const safeCutoff = findSafeCutoffPoint(messages, targetCutoff);\n\n  /**\n   * If findSafeCutoffPoint moved backward (found matching AIMessage), use it.\n   */\n  if (safeCutoff <= targetCutoff) {\n    return safeCutoff;\n  }\n\n  /**\n   * Fallback: iterate backward to find a safe cutoff\n   */\n  for (let i = targetCutoff; i >= 0; i--) {\n    if (isSafeCutoffPoint(messages, i)) {\n      return i;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Check if cutting at index would separate AI/Tool message pairs\n */\nfunction isSafeCutoffPoint(\n  messages: BaseMessage[],\n  cutoffIndex: number\n): boolean {\n  if (cutoffIndex >= messages.length) {\n    return true;\n  }\n\n  /**\n   * Prevent preserved messages from starting with AI message containing tool calls\n   */\n  if (\n    cutoffIndex < messages.length &&\n    AIMessage.isInstance(messages[cutoffIndex]) &&\n    hasToolCalls(messages[cutoffIndex])\n  ) {\n    return false;\n  }\n\n  const searchStart = Math.max(0, cutoffIndex - SEARCH_RANGE_FOR_TOOL_PAIRS);\n  const searchEnd = Math.min(\n    messages.length,\n    cutoffIndex + SEARCH_RANGE_FOR_TOOL_PAIRS\n  );\n\n  for (let i = searchStart; i < searchEnd; i++) {\n    if (!hasToolCalls(messages[i])) {\n      continue;\n    }\n\n    const toolCallIds = extractToolCallIds(messages[i] as AIMessage);\n    if (cutoffSeparatesToolPair(messages, i, cutoffIndex, toolCallIds)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Extract tool call IDs from an AI message\n */\nfunction extractToolCallIds(aiMessage: AIMessage): Set<string> {\n  const toolCallIds = new Set<string>();\n  if (aiMessage.tool_calls) {\n    for (const toolCall of aiMessage.tool_calls) {\n      const id =\n        typeof toolCall === \"object\" && \"id\" in toolCall ? toolCall.id : null;\n      if (id) {\n        toolCallIds.add(id);\n      }\n    }\n  }\n  return toolCallIds;\n}\n\n/**\n * Find a safe cutoff point that doesn't split AI/Tool message pairs.\n *\n * If the message at `cutoffIndex` is a `ToolMessage`, search backward for the\n * `AIMessage` containing the corresponding `tool_calls` and adjust the cutoff to\n * include it. This ensures tool call requests and responses stay together.\n *\n * Falls back to advancing forward past `ToolMessage` objects only if no matching\n * `AIMessage` is found (edge case).\n */\nfunction findSafeCutoffPoint(\n  messages: BaseMessage[],\n  cutoffIndex: number\n): number {\n  if (\n    cutoffIndex >= messages.length ||\n    !ToolMessage.isInstance(messages[cutoffIndex])\n  ) {\n    return cutoffIndex;\n  }\n\n  // Collect tool_call_ids from consecutive ToolMessages at/after cutoff\n  const toolCallIds = new Set<string>();\n  let idx = cutoffIndex;\n  while (idx < messages.length && ToolMessage.isInstance(messages[idx])) {\n    const toolMsg = messages[idx] as ToolMessage;\n    if (toolMsg.tool_call_id) {\n      toolCallIds.add(toolMsg.tool_call_id);\n    }\n    idx++;\n  }\n\n  // Search backward for AIMessage with matching tool_calls\n  for (let i = cutoffIndex - 1; i >= 0; i--) {\n    const msg = messages[i];\n    if (AIMessage.isInstance(msg) && hasToolCalls(msg)) {\n      const aiToolCallIds = extractToolCallIds(msg as AIMessage);\n      // Check if there's any overlap between the tool_call_ids\n      for (const id of toolCallIds) {\n        if (aiToolCallIds.has(id)) {\n          // Found the AIMessage - move cutoff to include it\n          return i;\n        }\n      }\n    }\n  }\n\n  // Fallback: no matching AIMessage found, advance past ToolMessages to avoid\n  // orphaned tool responses\n  return idx;\n}\n\n/**\n * Check if cutoff separates an AI message from its corresponding tool messages\n */\nfunction cutoffSeparatesToolPair(\n  messages: BaseMessage[],\n  aiMessageIndex: number,\n  cutoffIndex: number,\n  toolCallIds: Set<string>\n): boolean {\n  for (let j = aiMessageIndex + 1; j < messages.length; j++) {\n    const message = messages[j];\n    if (\n      ToolMessage.isInstance(message) &&\n      toolCallIds.has(message.tool_call_id)\n    ) {\n      const aiBeforeCutoff = aiMessageIndex < cutoffIndex;\n      const toolBeforeCutoff = j < cutoffIndex;\n      if (aiBeforeCutoff !== toolBeforeCutoff) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Generate summary for the given messages.\n *\n * @param messagesToSummarize - Messages to summarize.\n * @param model - The language model to use for summarization.\n * @param summaryPrompt - The prompt template for summarization.\n * @param tokenCounter - Function to count tokens.\n * @param trimTokensToSummarize - Optional token limit for trimming messages.\n * @param runtime - The runtime environment, used to inherit config so that\n *   LangGraph's handlers can properly track and tag the summarization model call.\n */\nasync function createSummary(\n  messagesToSummarize: BaseMessage[],\n  model: BaseLanguageModel,\n  summaryPrompt: string,\n  tokenCounter: TokenCounter,\n  trimTokensToSummarize: number | undefined,\n  runtime: Runtime<unknown>\n): Promise<string> {\n  if (!messagesToSummarize.length) {\n    return \"No previous conversation history.\";\n  }\n\n  const trimmedMessages = await trimMessagesForSummary(\n    messagesToSummarize,\n    tokenCounter,\n    trimTokensToSummarize\n  );\n\n  if (!trimmedMessages.length) {\n    return \"Previous conversation was too long to summarize.\";\n  }\n\n  /**\n   * Format messages using getBufferString to avoid token inflation from metadata\n   * when str() / JSON.stringify is called on message objects.\n   * This produces compact output like:\n   * ```\n   * Human: What's the weather?\n   * AI: Let me check...[tool_calls]\n   * Tool: 72F and sunny\n   * ```\n   */\n  const formattedMessages = getBufferString(trimmedMessages);\n\n  try {\n    const formattedPrompt = summaryPrompt.replace(\n      \"{messages}\",\n      formattedMessages\n    );\n    /**\n     * Merge parent runnable config with summarization metadata so LangGraph's\n     * stream handlers (and other callback-based consumers) can properly track\n     * and tag the summarization model call.\n     */\n    const baseConfig: RunnableConfig = pickRunnableConfigKeys(runtime) ?? {};\n    const config = mergeConfigs(baseConfig, {\n      metadata: { lc_source: \"summarization\" },\n    });\n    const response = await model.invoke(formattedPrompt, config);\n    const content = response.content;\n    /**\n     * Handle both string content and MessageContent array\n     */\n    if (typeof content === \"string\") {\n      return content.trim();\n    } else if (Array.isArray(content)) {\n      /**\n       * Extract text from MessageContent array\n       */\n      const textContent = content\n        .map((item) => {\n          if (typeof item === \"string\") return item;\n          if (typeof item === \"object\" && item !== null && \"text\" in item) {\n            return (item as { text: string }).text;\n          }\n          return \"\";\n        })\n        .join(\"\");\n      return textContent.trim();\n    }\n    return \"Error generating summary: Invalid response format\";\n  } catch (e) {\n    return `Error generating summary: ${e}`;\n  }\n}\n\n/**\n * Trim messages to fit within summary generation limits\n */\nasync function trimMessagesForSummary(\n  messages: BaseMessage[],\n  tokenCounter: TokenCounter,\n  trimTokensToSummarize: number | undefined\n): Promise<BaseMessage[]> {\n  if (trimTokensToSummarize === undefined) {\n    return messages;\n  }\n\n  try {\n    return await trimMessages(messages, {\n      maxTokens: trimTokensToSummarize,\n      tokenCounter: async (msgs) => tokenCounter(msgs),\n      strategy: \"last\",\n      allowPartial: true,\n      includeSystem: true,\n    });\n  } catch {\n    /**\n     * Fallback to last N messages if trimming fails\n     */\n    return messages.slice(-DEFAULT_FALLBACK_MESSAGE_COUNT);\n  }\n}\n", "import { SystemMessage } from \"@langchain/core/messages\";\nimport { createMiddleware } from \"../middleware.js\";\nimport type { Runtime, AgentBuiltInState } from \"../runtime.js\";\n\nexport type DynamicSystemPromptMiddlewareConfig<TContextSchema> = (\n  state: AgentBuiltInState,\n  runtime: Runtime<TContextSchema>\n) => string | SystemMessage | Promise<string | SystemMessage>;\n\n/**\n * Dynamic System Prompt Middleware\n *\n * Allows setting the system prompt dynamically right before each model invocation.\n * Useful when the prompt depends on the current agent state or per-invocation context.\n *\n * @typeParam TContextSchema - The shape of the runtime context available at invocation time.\n * If your agent defines a `contextSchema`, pass the inferred type here to get full type-safety\n * for `runtime.context`.\n *\n * @param fn - Function that receives the current agent `state` and `runtime`, and\n * returns the system prompt for the next model call as a string.\n *\n * @returns A middleware instance that sets `systemPrompt` for the next model call.\n *\n * @example Basic usage with typed context\n * ```ts\n * import { z } from \"zod\";\n * import { dynamicSystemPrompt } from \"langchain\";\n * import { createAgent, SystemMessage } from \"langchain\";\n *\n * const contextSchema = z.object({ region: z.string().optional() });\n *\n * const middleware = dynamicSystemPrompt<z.infer<typeof contextSchema>>(\n *   (_state, runtime) => `You are a helpful assistant. Region: ${runtime.context.region ?? \"n/a\"}`\n * );\n *\n * const agent = createAgent({\n *   model: \"anthropic:claude-3-5-sonnet\",\n *   contextSchema,\n *   middleware: [middleware],\n * });\n *\n * await agent.invoke({ messages }, { context: { region: \"EU\" } });\n * ```\n *\n * @public\n */\nexport function dynamicSystemPromptMiddleware<TContextSchema = unknown>(\n  fn: DynamicSystemPromptMiddlewareConfig<TContextSchema>\n) {\n  return createMiddleware({\n    name: \"DynamicSystemPromptMiddleware\",\n    wrapModelCall: async (request, handler) => {\n      const systemPrompt = await fn(\n        request.state as AgentBuiltInState,\n        request.runtime as Runtime<TContextSchema>\n      );\n\n      const isExpectedType =\n        typeof systemPrompt === \"string\" ||\n        SystemMessage.isInstance(systemPrompt);\n      if (!isExpectedType) {\n        throw new Error(\n          \"dynamicSystemPromptMiddleware function must return a string or SystemMessage\"\n        );\n      }\n\n      return handler({\n        ...request,\n        systemMessage: request.systemMessage.concat(systemPrompt),\n      });\n    },\n  });\n}\n", "import { z } from \"zod/v3\";\nimport { BaseLanguageModel } from \"@langchain/core/language_models/base\";\nimport type { InferInteropZodInput } from \"@langchain/core/utils/types\";\nimport { HumanMessage } from \"@langchain/core/messages\";\nimport type { StructuredToolInterface } from \"@langchain/core/tools\";\n\nimport { createMiddleware } from \"../middleware.js\";\nimport { initChatModel } from \"../../chat_models/universal.js\";\nimport type { Runtime } from \"../runtime.js\";\nimport type { ModelRequest } from \"../nodes/types.js\";\n\nconst DEFAULT_SYSTEM_PROMPT =\n  \"Your goal is to select the most relevant tools for answering the user's query.\";\n\n/**\n * Prepared inputs for tool selection.\n */\ninterface SelectionRequest {\n  availableTools: StructuredToolInterface[];\n  systemMessage: string;\n  lastUserMessage: HumanMessage;\n  model: BaseLanguageModel;\n  validToolNames: string[];\n}\n\n/**\n * Create a structured output schema for tool selection.\n *\n * @param tools - Available tools to include in the schema.\n * @returns Zod schema where each tool name is a literal with its description.\n */\nfunction createToolSelectionResponse(tools: StructuredToolInterface[]) {\n  if (!tools || tools.length === 0) {\n    throw new Error(\"Invalid usage: tools must be non-empty\");\n  }\n\n  // Create a union of literals for each tool name\n  const toolLiterals = tools.map((tool) => z.literal(tool.name));\n  const toolEnum = z.union(\n    toolLiterals as [\n      z.ZodLiteral<string>,\n      z.ZodLiteral<string>,\n      ...z.ZodLiteral<string>[],\n    ]\n  );\n\n  return z.object({\n    tools: z\n      .array(toolEnum)\n      .describe(\"Tools to use. Place the most relevant tools first.\"),\n  });\n}\n\n/**\n * Options for configuring the LLM Tool Selector middleware.\n */\nexport const LLMToolSelectorOptionsSchema = z.object({\n  /**\n   * The language model to use for tool selection (default: the provided model from the agent options).\n   */\n  model: z.string().or(z.instanceof(BaseLanguageModel)).optional(),\n  /**\n   * System prompt for the tool selection model.\n   */\n  systemPrompt: z.string().optional(),\n  /**\n   * Maximum number of tools to select. If the model selects more,\n   * only the first maxTools will be used. No limit if not specified.\n   */\n  maxTools: z.number().optional(),\n  /**\n   * Tool names to always include regardless of selection.\n   * These do not count against the maxTools limit.\n   */\n  alwaysInclude: z.array(z.string()).optional(),\n});\nexport type LLMToolSelectorConfig = InferInteropZodInput<\n  typeof LLMToolSelectorOptionsSchema\n>;\n\n/**\n * Middleware for selecting tools using an LLM-based strategy.\n *\n * When an agent has many tools available, this middleware filters them down\n * to only the most relevant ones for the user's query. This reduces token usage\n * and helps the main model focus on the right tools.\n *\n * @param options - Configuration options for the middleware\n * @param options.model - The language model to use for tool selection (default: the provided model from the agent options).\n * @param options.systemPrompt - Instructions for the selection model.\n * @param options.maxTools - Maximum number of tools to select. If the model selects more,\n *   only the first maxTools will be used. No limit if not specified.\n * @param options.alwaysInclude - Tool names to always include regardless of selection.\n *   These do not count against the maxTools limit.\n *\n * @example\n * Limit to 3 tools:\n * ```ts\n * import { llmToolSelectorMiddleware } from \"langchain/agents/middleware\";\n *\n * const middleware = llmToolSelectorMiddleware({ maxTools: 3 });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [tool1, tool2, tool3, tool4, tool5],\n *   middleware: [middleware],\n * });\n * ```\n *\n * @example\n * Use a smaller model for selection:\n * ```ts\n * const middleware = llmToolSelectorMiddleware({\n *   model: \"openai:gpt-4o-mini\",\n *   maxTools: 2\n * });\n * ```\n */\nexport function llmToolSelectorMiddleware(\n  options: LLMToolSelectorConfig\n): ReturnType<typeof createMiddleware> {\n  return createMiddleware({\n    name: \"LLMToolSelector\",\n    contextSchema: LLMToolSelectorOptionsSchema,\n    async wrapModelCall(request, handler) {\n      const selectionRequest = await prepareSelectionRequest(\n        request,\n        options,\n        request.runtime\n      );\n      if (!selectionRequest) {\n        return handler(request);\n      }\n\n      // Create dynamic response model with union of literal tool names\n      const toolSelectionSchema = createToolSelectionResponse(\n        selectionRequest.availableTools\n      );\n      const structuredModel =\n        await selectionRequest.model.withStructuredOutput?.(\n          toolSelectionSchema\n        );\n\n      const response = await structuredModel?.invoke([\n        { role: \"system\", content: selectionRequest.systemMessage },\n        selectionRequest.lastUserMessage,\n      ]);\n\n      // Response should be an object with a tools array\n      if (!response || typeof response !== \"object\" || !(\"tools\" in response)) {\n        throw new Error(\n          `Expected object response with tools array, got ${typeof response}`\n        );\n      }\n\n      return handler(\n        processSelectionResponse(\n          response as { tools: string[] },\n          selectionRequest.availableTools,\n          selectionRequest.validToolNames,\n          request,\n          options\n        )\n      );\n    },\n  });\n}\n\n/**\n * Prepare inputs for tool selection.\n *\n * @param request - The model request to process.\n * @param options - Configuration options.\n * @param runtime - Runtime context.\n * @returns SelectionRequest with prepared inputs, or null if no selection is needed.\n */\nasync function prepareSelectionRequest<\n  TState extends Record<string, unknown> = Record<string, unknown>,\n  TContext = unknown,\n>(\n  request: ModelRequest<TState, TContext>,\n  options: LLMToolSelectorConfig,\n  runtime: Runtime<LLMToolSelectorConfig>\n): Promise<SelectionRequest | undefined> {\n  const model = runtime.context.model ?? options.model;\n  const maxTools = runtime.context.maxTools ?? options.maxTools;\n  const alwaysInclude =\n    runtime.context.alwaysInclude ?? options.alwaysInclude ?? [];\n  const systemPrompt =\n    runtime.context.systemPrompt ??\n    options.systemPrompt ??\n    DEFAULT_SYSTEM_PROMPT;\n\n  /**\n   * If no tools available, return null\n   */\n  if (!request.tools || request.tools.length === 0) {\n    return undefined;\n  }\n\n  /**\n   * Filter to only StructuredToolInterface instances (exclude provider-specific tool dicts)\n   */\n  const baseTools = request.tools.filter(\n    (tool): tool is StructuredToolInterface =>\n      typeof tool === \"object\" &&\n      \"name\" in tool &&\n      \"description\" in tool &&\n      typeof tool.name === \"string\"\n  );\n\n  /**\n   * Validate that alwaysInclude tools exist\n   */\n  if (alwaysInclude.length > 0) {\n    const availableToolNames = new Set(baseTools.map((tool) => tool.name));\n    const missingTools = alwaysInclude.filter(\n      (name) => !availableToolNames.has(name)\n    );\n    if (missingTools.length > 0) {\n      throw new Error(\n        `Tools in alwaysInclude not found in request: ${missingTools.join(\n          \", \"\n        )}. ` +\n          `Available tools: ${Array.from(availableToolNames).sort().join(\", \")}`\n      );\n    }\n  }\n\n  /**\n   * Separate tools that are always included from those available for selection\n   */\n  const availableTools = baseTools.filter(\n    (tool) => !alwaysInclude.includes(tool.name)\n  );\n\n  /**\n   * If no tools available for selection, return null\n   */\n  if (availableTools.length === 0) {\n    return undefined;\n  }\n\n  let systemMessage = systemPrompt;\n  /**\n   * If there's a maxTools limit, append instructions to the system prompt\n   */\n  if (maxTools !== undefined) {\n    systemMessage +=\n      `\\nIMPORTANT: List the tool names in order of relevance, ` +\n      `with the most relevant first. ` +\n      `If you exceed the maximum number of tools, ` +\n      `only the first ${maxTools} will be used.`;\n  }\n\n  /**\n   * Get the last user message from the conversation history\n   */\n  let lastUserMessage: HumanMessage | undefined;\n  for (const message of request.messages) {\n    if (HumanMessage.isInstance(message)) {\n      lastUserMessage = message;\n    }\n  }\n\n  if (!lastUserMessage) {\n    throw new Error(\"No user message found in request messages\");\n  }\n\n  const modelInstance = !model\n    ? (request.model as BaseLanguageModel)\n    : typeof model === \"string\"\n      ? await initChatModel(model)\n      : model;\n\n  const validToolNames = availableTools.map((tool) => tool.name);\n\n  return {\n    availableTools,\n    systemMessage,\n    lastUserMessage,\n    model: modelInstance,\n    validToolNames,\n  };\n}\n\n/**\n * Process the selection response and return filtered ModelRequest.\n *\n * @param response - The structured output response from the model.\n * @param availableTools - Tools available for selection.\n * @param validToolNames - Valid tool names that can be selected.\n * @param request - Original model request.\n * @param options - Configuration options.\n * @returns Modified ModelRequest with filtered tools.\n */\nfunction processSelectionResponse<\n  TState extends Record<string, unknown> = Record<string, unknown>,\n  TContext = unknown,\n>(\n  response: { tools: string[] },\n  availableTools: StructuredToolInterface[],\n  validToolNames: string[],\n  request: ModelRequest<TState, TContext>,\n  options: LLMToolSelectorConfig\n): ModelRequest<TState, TContext> {\n  const maxTools = options.maxTools;\n  const alwaysInclude = options.alwaysInclude ?? [];\n\n  const selectedToolNames: string[] = [];\n  const invalidToolSelections: string[] = [];\n\n  for (const toolName of response.tools) {\n    if (!validToolNames.includes(toolName)) {\n      invalidToolSelections.push(toolName);\n      continue;\n    }\n\n    /**\n     * Only add if not already selected and within maxTools limit\n     */\n    if (\n      !selectedToolNames.includes(toolName) &&\n      (maxTools === undefined || selectedToolNames.length < maxTools)\n    ) {\n      selectedToolNames.push(toolName);\n    }\n  }\n\n  if (invalidToolSelections.length > 0) {\n    throw new Error(\n      `Model selected invalid tools: ${invalidToolSelections.join(\", \")}`\n    );\n  }\n\n  /**\n   * Filter tools based on selection\n   */\n  const selectedTools = availableTools.filter((tool) =>\n    selectedToolNames.includes(tool.name)\n  );\n\n  /**\n   * Append always-included tools\n   */\n  const alwaysIncludedTools = (request.tools ?? []).filter(\n    (tool): tool is StructuredToolInterface =>\n      typeof tool === \"object\" &&\n      \"name\" in tool &&\n      typeof tool.name === \"string\" &&\n      alwaysInclude.includes(tool.name)\n  );\n  selectedTools.push(...alwaysIncludedTools);\n\n  /**\n   * Also preserve any provider-specific tool dicts from the original request\n   */\n  const providerTools = (request.tools ?? []).filter(\n    (tool) =>\n      !(\n        typeof tool === \"object\" &&\n        \"name\" in tool &&\n        \"description\" in tool &&\n        typeof tool.name === \"string\"\n      )\n  );\n\n  return {\n    ...request,\n    tools: [...selectedTools, ...providerTools],\n  };\n}\n", "import { z } from \"zod/v3\";\nimport { sha256 } from \"@langchain/core/utils/hash\";\nimport { AIMessage, HumanMessage, ToolMessage } from \"@langchain/core/messages\";\nimport type { InferInteropZodInput } from \"@langchain/core/utils/types\";\n\nimport { createMiddleware } from \"../middleware.js\";\n\n/**\n * Represents a detected PII match in content\n */\nexport interface PIIMatch {\n  /**\n   * The matched text\n   */\n  text: string;\n  /**\n   * The start index of the match\n   */\n  start: number;\n  /**\n   * The end index of the match\n   */\n  end: number;\n}\n\n/**\n * Error thrown when PII is detected and strategy is 'block'\n */\nexport class PIIDetectionError extends Error {\n  constructor(\n    public readonly piiType: string,\n    public readonly matches: PIIMatch[]\n  ) {\n    super(`PII detected: ${piiType} found ${matches.length} occurrence(s)`);\n    this.name = \"PIIDetectionError\";\n  }\n}\n\n/**\n * Strategy for handling detected PII\n */\nexport type PIIStrategy = \"block\" | \"redact\" | \"mask\" | \"hash\";\n\n/**\n * Built-in PII types\n */\nexport type BuiltInPIIType =\n  | \"email\"\n  | \"credit_card\"\n  | \"ip\"\n  | \"mac_address\"\n  | \"url\";\n\n/**\n * Custom detector function that takes content and returns matches\n */\nexport type PIIDetector = (content: string) => PIIMatch[];\nexport type Detector = PIIDetector | RegExp | string;\n\n/**\n * Configuration for a redaction rule\n */\nexport interface RedactionRuleConfig {\n  /**\n   * Type of PII to detect (built-in or custom name)\n   */\n  piiType: BuiltInPIIType | string;\n  /**\n   * Strategy for handling detected PII\n   */\n  strategy: PIIStrategy;\n  /**\n   * Custom detector function or regex pattern string\n   */\n  detector?: Detector;\n}\n\n/**\n * Resolved redaction rule with a concrete detector function\n */\nexport interface ResolvedRedactionRule {\n  piiType: string;\n  strategy: PIIStrategy;\n  detector: PIIDetector;\n}\n\n/**\n * Email detection regex pattern\n */\nconst EMAIL_PATTERN = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b/g;\n\n/**\n * Credit card detection regex pattern (basic, will be validated with Luhn)\n */\nconst CREDIT_CARD_PATTERN = /\\b(?:\\d{4}[-\\s]?){3}\\d{4}\\b/g;\n\n/**\n * IP address detection regex pattern\n */\nconst IP_PATTERN =\n  /\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/g;\n\n/**\n * MAC address detection regex pattern\n */\nconst MAC_ADDRESS_PATTERN = /\\b(?:[0-9A-Fa-f]{2}[:-]){5}(?:[0-9A-Fa-f]{2})\\b/g;\n\n/**\n * URL detection regex pattern\n */\nconst URL_PATTERN = /(?:https?:\\/\\/|www\\.)[^\\s<>\"{}|\\\\^`[\\]]+/gi;\n\n/**\n * Luhn algorithm for credit card validation\n */\nfunction luhnCheck(cardNumber: string): boolean {\n  const digits = cardNumber.replace(/\\D/g, \"\");\n  let sum = 0;\n  let isEven = false;\n\n  for (let i = digits.length - 1; i >= 0; i--) {\n    let digit = parseInt(digits[i], 10);\n\n    if (isEven) {\n      digit *= 2;\n      if (digit > 9) {\n        digit -= 9;\n      }\n    }\n\n    sum += digit;\n    isEven = !isEven;\n  }\n\n  return sum % 10 === 0;\n}\n\n/**\n * Convert regex match to PIIMatch\n */\nfunction regexMatchToPIIMatch(match: RegExpMatchArray): PIIMatch {\n  return {\n    text: match[0],\n    start: match.index ?? 0,\n    end: (match.index ?? 0) + match[0].length,\n  };\n}\n\n/**\n * Detect email addresses in content\n */\nexport function detectEmail(content: string): PIIMatch[] {\n  const matches: PIIMatch[] = [];\n  const regex = new RegExp(EMAIL_PATTERN);\n  let match: RegExpMatchArray | null;\n\n  while ((match = regex.exec(content)) !== null) {\n    matches.push(regexMatchToPIIMatch(match));\n  }\n\n  return matches;\n}\n\n/**\n * Detect credit card numbers in content (validated with Luhn algorithm)\n */\nexport function detectCreditCard(content: string): PIIMatch[] {\n  const matches: PIIMatch[] = [];\n  const regex = new RegExp(CREDIT_CARD_PATTERN);\n  let match: RegExpMatchArray | null;\n\n  while ((match = regex.exec(content)) !== null) {\n    const cardNumber = match[0].replace(/\\D/g, \"\");\n    // Credit cards are typically 13-19 digits\n    if (\n      cardNumber.length >= 13 &&\n      cardNumber.length <= 19 &&\n      luhnCheck(cardNumber)\n    ) {\n      matches.push(regexMatchToPIIMatch(match));\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Detect IP addresses in content (validated)\n */\nexport function detectIP(content: string): PIIMatch[] {\n  const matches: PIIMatch[] = [];\n  const regex = new RegExp(IP_PATTERN);\n  let match: RegExpMatchArray | null;\n\n  while ((match = regex.exec(content)) !== null) {\n    const ip = match[0];\n    // Additional validation: each octet should be 0-255\n    const parts = ip.split(\".\");\n    if (\n      parts.length === 4 &&\n      parts.every((part) => {\n        const num = parseInt(part, 10);\n        return num >= 0 && num <= 255;\n      })\n    ) {\n      matches.push(regexMatchToPIIMatch(match));\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Detect MAC addresses in content\n */\nexport function detectMacAddress(content: string): PIIMatch[] {\n  const matches: PIIMatch[] = [];\n  const regex = new RegExp(MAC_ADDRESS_PATTERN);\n  let match: RegExpMatchArray | null;\n\n  while ((match = regex.exec(content)) !== null) {\n    matches.push(regexMatchToPIIMatch(match));\n  }\n\n  return matches;\n}\n\n/**\n * Detect URLs in content\n */\nexport function detectUrl(content: string): PIIMatch[] {\n  const matches: PIIMatch[] = [];\n  const regex = new RegExp(URL_PATTERN);\n  let match: RegExpMatchArray | null;\n\n  while ((match = regex.exec(content)) !== null) {\n    matches.push(regexMatchToPIIMatch(match));\n  }\n\n  return matches;\n}\n\n/**\n * Built-in detector map\n */\nconst BUILT_IN_DETECTORS: Record<BuiltInPIIType, PIIDetector> = {\n  email: detectEmail,\n  credit_card: detectCreditCard,\n  ip: detectIP,\n  mac_address: detectMacAddress,\n  url: detectUrl,\n};\n\n/**\n * Resolve a redaction rule to a concrete detector function\n */\nexport function resolveRedactionRule(\n  config: RedactionRuleConfig\n): ResolvedRedactionRule {\n  let detector: PIIDetector;\n\n  if (config.detector) {\n    if (typeof config.detector === \"string\") {\n      // Regex pattern string\n      const regex = new RegExp(config.detector, \"g\");\n      detector = (content: string) => {\n        const matches: PIIMatch[] = [];\n        let match: RegExpMatchArray | null;\n        const regexCopy = new RegExp(regex);\n\n        while ((match = regexCopy.exec(content)) !== null) {\n          matches.push(regexMatchToPIIMatch(match));\n        }\n\n        return matches;\n      };\n      // eslint-disable-next-line no-instanceof/no-instanceof\n    } else if (config.detector instanceof RegExp) {\n      detector = (content: string) => {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (!(config.detector instanceof RegExp)) {\n          throw new Error(\"Detector is required\");\n        }\n        const matches: PIIMatch[] = [];\n        let match: RegExpMatchArray | null;\n        while ((match = config.detector.exec(content)) !== null) {\n          matches.push(regexMatchToPIIMatch(match));\n        }\n\n        return matches;\n      };\n    } else {\n      detector = config.detector;\n    }\n  } else {\n    // Use built-in detector\n    const builtInType = config.piiType as BuiltInPIIType;\n    if (!BUILT_IN_DETECTORS[builtInType]) {\n      throw new Error(\n        `Unknown PII type: ${config.piiType}. Must be one of: ${Object.keys(\n          BUILT_IN_DETECTORS\n        ).join(\", \")}, or provide a custom detector.`\n      );\n    }\n    detector = BUILT_IN_DETECTORS[builtInType];\n  }\n\n  return {\n    piiType: config.piiType,\n    strategy: config.strategy,\n    detector,\n  };\n}\n\n/**\n * Apply redact strategy: replace with [REDACTED_TYPE]\n */\nfunction applyRedactStrategy(\n  content: string,\n  matches: PIIMatch[],\n  piiType: string\n): string {\n  let result = content;\n  // Process matches in reverse order to preserve indices\n  for (let i = matches.length - 1; i >= 0; i--) {\n    const match = matches[i];\n    const replacement = `[REDACTED_${piiType.toUpperCase()}]`;\n    result =\n      result.slice(0, match.start) + replacement + result.slice(match.end);\n  }\n  return result;\n}\n\n/**\n * Apply mask strategy: partially mask PII (show last few characters)\n */\nfunction applyMaskStrategy(\n  content: string,\n  matches: PIIMatch[],\n  piiType: string\n): string {\n  let result = content;\n  // Process matches in reverse order to preserve indices\n  for (let i = matches.length - 1; i >= 0; i--) {\n    const match = matches[i];\n    const text = match.text;\n    let masked: string;\n\n    if (piiType === \"credit_card\") {\n      // Show last 4 digits: ****-****-****-1234\n      const digits = text.replace(/\\D/g, \"\");\n      const last4 = digits.slice(-4);\n      masked = `****-****-****-${last4}`;\n    } else if (piiType === \"email\") {\n      // Show first char and domain: j***@example.com\n      const [local, domain] = text.split(\"@\");\n      if (local && domain) {\n        masked = `${local[0]}***@${domain}`;\n      } else {\n        masked = \"***\";\n      }\n    } else {\n      // Default: show last 4 characters\n      const visibleChars = Math.min(4, text.length);\n      masked = `${\"*\".repeat(\n        Math.max(0, text.length - visibleChars)\n      )}${text.slice(-visibleChars)}`;\n    }\n\n    result = result.slice(0, match.start) + masked + result.slice(match.end);\n  }\n  return result;\n}\n\n/**\n * Apply hash strategy: replace with deterministic hash\n */\nfunction applyHashStrategy(\n  content: string,\n  matches: PIIMatch[],\n  piiType: string\n): string {\n  let result = content;\n  // Process matches in reverse order to preserve indices\n  for (let i = matches.length - 1; i >= 0; i--) {\n    const match = matches[i];\n    const hash = sha256(match.text).slice(0, 8);\n    const replacement = `<${piiType}_hash:${hash}>`;\n    result =\n      result.slice(0, match.start) + replacement + result.slice(match.end);\n  }\n  return result;\n}\n\n/**\n * Apply strategy to content based on matches\n */\nexport function applyStrategy(\n  content: string,\n  matches: PIIMatch[],\n  strategy: PIIStrategy,\n  piiType: string\n): string {\n  if (matches.length === 0) {\n    return content;\n  }\n\n  switch (strategy) {\n    case \"block\":\n      throw new PIIDetectionError(piiType, matches);\n    case \"redact\":\n      return applyRedactStrategy(content, matches, piiType);\n    case \"mask\":\n      return applyMaskStrategy(content, matches, piiType);\n    case \"hash\":\n      return applyHashStrategy(content, matches, piiType);\n    default:\n      throw new Error(`Unknown strategy: ${strategy}`);\n  }\n}\n\n/**\n * Configuration schema for PII middleware\n */\nconst contextSchema = z.object({\n  /**\n   * Whether to check user messages before model call\n   */\n  applyToInput: z.boolean().optional(),\n  /**\n   * Whether to check AI messages after model call\n   */\n  applyToOutput: z.boolean().optional(),\n  /**\n   * Whether to check tool result messages after tool execution\n   */\n  applyToToolResults: z.boolean().optional(),\n});\n\nexport type PIIMiddlewareConfig = InferInteropZodInput<typeof contextSchema>;\n\n/**\n * Process content for PII detection and apply strategy\n */\nfunction processContent(\n  content: string,\n  rule: ResolvedRedactionRule\n): { content: string; matches: PIIMatch[] } {\n  const matches = rule.detector(content);\n  if (matches.length === 0) {\n    return { content, matches: [] };\n  }\n\n  const sanitized = applyStrategy(\n    content,\n    matches,\n    rule.strategy,\n    rule.piiType\n  );\n  return { content: sanitized, matches };\n}\n\n/**\n * Creates a middleware that detects and handles personally identifiable information (PII)\n * in conversations.\n *\n * This middleware detects common PII types and applies configurable strategies to handle them.\n * It can detect emails, credit cards, IP addresses, MAC addresses, and URLs in both user input\n * and agent output.\n *\n * Built-in PII types:\n * - `email`: Email addresses\n * - `credit_card`: Credit card numbers (validated with Luhn algorithm)\n * - `ip`: IP addresses (validated)\n * - `mac_address`: MAC addresses\n * - `url`: URLs (both `http`/`https` and bare URLs)\n *\n * Strategies:\n * - `block`: Raise an exception when PII is detected\n * - `redact`: Replace PII with `[REDACTED_TYPE]` placeholders\n * - `mask`: Partially mask PII (e.g., `****-****-****-1234` for credit card)\n * - `hash`: Replace PII with deterministic hash (e.g., `<email_hash:a1b2c3d4>`)\n *\n * Strategy Selection Guide:\n * | Strategy | Preserves Identity? | Best For                                |\n * | -------- | ------------------- | --------------------------------------- |\n * | `block`  | N/A                 | Avoid PII completely                    |\n * | `redact` | No                  | General compliance, log sanitization    |\n * | `mask`   | No                  | Human readability, customer service UIs |\n * | `hash`   | Yes (pseudonymous)  | Analytics, debugging                    |\n *\n * @param piiType - Type of PII to detect. Can be a built-in type (`email`, `credit_card`, `ip`, `mac_address`, `url`) or a custom type name.\n * @param options - Configuration options\n * @param options.strategy - How to handle detected PII. Defaults to `\"redact\"`.\n * @param options.detector - Custom detector function or regex pattern string. If not provided, uses built-in detector for the `piiType`.\n * @param options.applyToInput - Whether to check user messages before model call. Defaults to `true`.\n * @param options.applyToOutput - Whether to check AI messages after model call. Defaults to `false`.\n * @param options.applyToToolResults - Whether to check tool result messages after tool execution. Defaults to `false`.\n *\n * @returns Middleware instance for use with `createAgent`\n *\n * @throws {PIIDetectionError} When PII is detected and strategy is `'block'`\n * @throws {Error} If `piiType` is not built-in and no detector is provided\n *\n * @example Basic usage\n * ```typescript\n * import { piiMiddleware } from \"langchain\";\n * import { createAgent } from \"langchain\";\n *\n * // Redact all emails in user input\n * const agent = createAgent({\n *   model: \"openai:gpt-4\",\n *   middleware: [\n *     piiMiddleware(\"email\", { strategy: \"redact\" }),\n *   ],\n * });\n * ```\n *\n * @example Different strategies for different PII types\n * ```typescript\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [\n *     piiMiddleware(\"credit_card\", { strategy: \"mask\" }),\n *     piiMiddleware(\"url\", { strategy: \"redact\" }),\n *     piiMiddleware(\"ip\", { strategy: \"hash\" }),\n *   ],\n * });\n * ```\n *\n * @example Custom PII type with regex\n * ```typescript\n * const agent = createAgent({\n *   model: \"openai:gpt-4\",\n *   middleware: [\n *     piiMiddleware(\"api_key\", {\n *       detector: \"sk-[a-zA-Z0-9]{32}\",\n *       strategy: \"block\",\n *     }),\n *   ],\n * });\n * ```\n *\n * @public\n */\nexport function piiMiddleware(\n  piiType: BuiltInPIIType | string,\n  options: {\n    strategy?: PIIStrategy;\n    detector?: Detector;\n    applyToInput?: boolean;\n    applyToOutput?: boolean;\n    applyToToolResults?: boolean;\n  } = {}\n): ReturnType<typeof createMiddleware> {\n  const { strategy = \"redact\", detector } = options;\n  const resolvedRule = resolveRedactionRule({\n    piiType,\n    strategy,\n    detector,\n  });\n\n  const middlewareName = `PIIMiddleware[${resolvedRule.piiType}]`;\n\n  return createMiddleware({\n    name: middlewareName,\n    contextSchema,\n    beforeModel: async (state, runtime) => {\n      const applyToInput =\n        runtime.context.applyToInput ?? options.applyToInput ?? true;\n      const applyToToolResults =\n        runtime.context.applyToToolResults ??\n        options.applyToToolResults ??\n        false;\n\n      if (!applyToInput && !applyToToolResults) {\n        return;\n      }\n\n      const messages = state.messages;\n      if (!messages || messages.length === 0) {\n        return;\n      }\n\n      const newMessages = [...messages];\n      let anyModified = false;\n\n      // Check user input if enabled\n      if (applyToInput) {\n        // Get last user message\n        let lastUserIdx: number | null = null;\n        for (let i = messages.length - 1; i >= 0; i--) {\n          if (HumanMessage.isInstance(messages[i])) {\n            lastUserIdx = i;\n            break;\n          }\n        }\n\n        if (lastUserIdx !== null) {\n          const lastUserMsg = messages[lastUserIdx];\n          if (lastUserMsg && lastUserMsg.content) {\n            const content = String(lastUserMsg.content);\n            const { content: newContent, matches } = processContent(\n              content,\n              resolvedRule\n            );\n\n            if (matches.length > 0) {\n              newMessages[lastUserIdx] = new HumanMessage({\n                content: newContent,\n                id: lastUserMsg.id,\n                name: lastUserMsg.name,\n              });\n              anyModified = true;\n            }\n          }\n        }\n      }\n\n      // Check tool results if enabled\n      if (applyToToolResults) {\n        // Find the last AIMessage, then process all ToolMessage objects after it\n        let lastAiIdx: number | null = null;\n        for (let i = messages.length - 1; i >= 0; i--) {\n          if (AIMessage.isInstance(messages[i])) {\n            lastAiIdx = i;\n            break;\n          }\n        }\n\n        if (lastAiIdx !== null) {\n          // Get all tool messages after the last AI message\n          for (let i = lastAiIdx + 1; i < messages.length; i++) {\n            const msg = messages[i];\n            if (ToolMessage.isInstance(msg)) {\n              if (!msg.content) {\n                continue;\n              }\n\n              const content = String(msg.content);\n              const { content: newContent, matches } = processContent(\n                content,\n                resolvedRule\n              );\n\n              if (matches.length > 0) {\n                newMessages[i] = new ToolMessage({\n                  content: newContent,\n                  id: msg.id,\n                  name: msg.name,\n                  tool_call_id: msg.tool_call_id,\n                });\n                anyModified = true;\n              }\n            }\n          }\n        }\n      }\n\n      if (anyModified) {\n        return { messages: newMessages };\n      }\n\n      return;\n    },\n    afterModel: async (state, runtime) => {\n      const applyToOutput =\n        runtime.context.applyToOutput ?? options.applyToOutput ?? false;\n\n      if (!applyToOutput) {\n        return;\n      }\n\n      const messages = state.messages;\n      if (!messages || messages.length === 0) {\n        return;\n      }\n\n      // Get last AI message\n      let lastAiIdx: number | null = null;\n      let lastAiMsg: AIMessage | null = null;\n      for (let i = messages.length - 1; i >= 0; i--) {\n        if (AIMessage.isInstance(messages[i])) {\n          lastAiMsg = messages[i];\n          lastAiIdx = i;\n          break;\n        }\n      }\n\n      if (lastAiIdx === null || !lastAiMsg || !lastAiMsg.content) {\n        return;\n      }\n\n      // Detect PII in message content\n      const content = String(lastAiMsg.content);\n      const { content: newContent, matches } = processContent(\n        content,\n        resolvedRule\n      );\n\n      if (matches.length === 0) {\n        return;\n      }\n\n      // Create updated message\n      const updatedMessage = new AIMessage({\n        content: newContent,\n        id: lastAiMsg.id,\n        name: lastAiMsg.name,\n        tool_calls: lastAiMsg.tool_calls,\n      });\n\n      // Return updated messages\n      const newMessages = [...messages];\n      newMessages[lastAiIdx] = updatedMessage;\n      return { messages: newMessages };\n    },\n  });\n}\n", "import { z } from \"zod/v3\";\nimport {\n  BaseMessage,\n  AIMessage,\n  HumanMessage,\n  ToolMessage,\n  RemoveMessage,\n  SystemMessage,\n} from \"@langchain/core/messages\";\nimport type { InferInteropZodInput } from \"@langchain/core/utils/types\";\n\nimport { createMiddleware } from \"../middleware.js\";\n\n/**\n * Type for the redaction map that stores original values by ID\n */\ntype RedactionMap = Record<string, string>;\n\n/**\n * Configuration schema for the Input Guardrails middleware\n */\nconst contextSchema = z.object({\n  /**\n   * A record of PII detection rules to apply\n   * @default DEFAULT_PII_RULES (with enabled rules only)\n   */\n  rules: z\n    .record(\n      z.string(),\n      z.instanceof(RegExp).describe(\"Regular expression pattern to match PII\")\n    )\n    .optional(),\n});\n\n/**\n * @deprecated\n */\nexport type PIIRedactionMiddlewareConfig = InferInteropZodInput<\n  typeof contextSchema\n>;\n\n/**\n * Generate a unique ID for a redaction\n */\nfunction generateRedactionId(): string {\n  return Math.random().toString(36).substring(2, 11);\n}\n\n/**\n * Apply PII detection rules to text with ID tracking\n */\nfunction applyPIIRules(\n  text: string,\n  rules: Record<string, RegExp>,\n  redactionMap: RedactionMap\n): string {\n  let processedText = text;\n\n  for (const [name, pattern] of Object.entries(rules)) {\n    const replacement = name.toUpperCase().replace(/[^a-zA-Z0-9_-]/g, \"\");\n    processedText = processedText.replace(pattern, (match) => {\n      const id = generateRedactionId();\n      redactionMap[id] = match;\n      // Create a trackable replacement like [REDACTED_SSN_abc123]\n      return `[REDACTED_${replacement}_${id}]`;\n    });\n  }\n\n  return processedText;\n}\n\ninterface ProcessHumanMessageConfig {\n  rules: Record<string, RegExp>;\n  redactionMap: RedactionMap;\n}\n\n/**\n * Process a single human message for PII detection and redaction\n */\nasync function processMessage(\n  message: BaseMessage,\n  config: ProcessHumanMessageConfig\n): Promise<BaseMessage> {\n  /**\n   * handle basic message types\n   */\n  if (\n    HumanMessage.isInstance(message) ||\n    ToolMessage.isInstance(message) ||\n    SystemMessage.isInstance(message)\n  ) {\n    const content = message.content as string;\n    const processedContent = await applyPIIRules(\n      content,\n      config.rules,\n      config.redactionMap\n    );\n\n    if (processedContent !== content) {\n      const MessageConstructor = Object.getPrototypeOf(message).constructor;\n      return new MessageConstructor({\n        ...message,\n        content: processedContent,\n      });\n    }\n\n    return message;\n  }\n\n  /**\n   * Handle AI messages\n   */\n  if (AIMessage.isInstance(message)) {\n    const content =\n      typeof message.content === \"string\"\n        ? message.content\n        : JSON.stringify(message.content);\n    const toolCalls = JSON.stringify(message.tool_calls);\n    const processedContent = await applyPIIRules(\n      content,\n      config.rules,\n      config.redactionMap\n    );\n    const processedToolCalls = await applyPIIRules(\n      toolCalls,\n      config.rules,\n      config.redactionMap\n    );\n\n    if (processedContent !== content || processedToolCalls !== toolCalls) {\n      return new AIMessage({\n        ...message,\n        content:\n          typeof message.content === \"string\"\n            ? processedContent\n            : JSON.parse(processedContent),\n        tool_calls: JSON.parse(processedToolCalls),\n      });\n    }\n\n    return message;\n  }\n\n  throw new Error(`Unsupported message type: ${message.type}`);\n}\n\n/**\n * Restore original values from redacted text using the redaction map\n */\nfunction restoreRedactedValues(\n  text: string,\n  redactionMap: RedactionMap\n): string {\n  let restoredText = text;\n\n  // Pattern to match redacted values like [REDACTED_SSN_abc123]\n  const redactionPattern = /\\[REDACTED_[A-Z_]+_(\\w+)\\]/g;\n\n  restoredText = restoredText.replace(redactionPattern, (match, id) => {\n    if (redactionMap[id]) {\n      return redactionMap[id];\n    }\n    return match; // Keep original if no mapping found\n  });\n\n  return restoredText;\n}\n\n/**\n * Restore redacted values in a message (creates a new message object)\n */\nfunction restoreMessage(\n  message: BaseMessage,\n  redactionMap: RedactionMap\n): { message: BaseMessage; changed: boolean } {\n  /**\n   * handle basic message types\n   */\n  if (\n    HumanMessage.isInstance(message) ||\n    ToolMessage.isInstance(message) ||\n    SystemMessage.isInstance(message)\n  ) {\n    const content = message.content as string;\n    const restoredContent = restoreRedactedValues(content, redactionMap);\n    if (restoredContent !== content) {\n      const MessageConstructor = Object.getPrototypeOf(message).constructor;\n      const newMessage = new MessageConstructor({\n        ...message,\n        content: restoredContent,\n      });\n      return { message: newMessage, changed: true };\n    }\n    return { message, changed: false };\n  }\n\n  /**\n   * handle AI messages\n   */\n  if (AIMessage.isInstance(message)) {\n    const content =\n      typeof message.content === \"string\"\n        ? message.content\n        : JSON.stringify(message.content);\n    const toolCalls = JSON.stringify(message.tool_calls);\n    const processedContent = restoreRedactedValues(content, redactionMap);\n    const processedToolCalls = restoreRedactedValues(toolCalls, redactionMap);\n    if (processedContent !== content || processedToolCalls !== toolCalls) {\n      return {\n        message: new AIMessage({\n          ...message,\n          content:\n            typeof message.content === \"string\"\n              ? processedContent\n              : JSON.parse(processedContent),\n          tool_calls: JSON.parse(processedToolCalls),\n        }),\n        changed: true,\n      };\n    }\n\n    return { message, changed: false };\n  }\n\n  throw new Error(`Unsupported message type: ${message.type}`);\n}\n\n/**\n * Creates a middleware that detects and redacts personally identifiable information (PII)\n * from messages before they are sent to model providers, and restores original values\n * in model responses for tool execution.\n *\n * ## Mechanism\n *\n * The middleware intercepts agent execution at two points:\n *\n * ### Request Phase (`wrapModelCall`)\n * - Applies regex-based pattern matching to all message content (HumanMessage, ToolMessage, SystemMessage, AIMessage)\n * - Processes both message text and AIMessage tool call arguments\n * - Each matched pattern generates:\n *   - Unique identifier: `generateRedactionId()`  `\"abc123\"`\n *   - Redaction marker: `[REDACTED_{RULE_NAME}_{ID}]`  `\"[REDACTED_SSN_abc123]\"`\n *   - Redaction map entry: `{ \"abc123\": \"123-45-6789\" }`\n * - Returns modified request with redacted message content\n *\n * ### Response Phase (`afterModel`)\n * - Scans AIMessage responses for redaction markers matching pattern: `/\\[REDACTED_[A-Z_]+_(\\w+)\\]/g`\n * - Replaces markers with original values from redaction map\n * - Handles both standard responses and structured output (via tool calls or JSON content)\n * - For structured output, restores values in both the tool call arguments and the `structuredResponse` state field\n * - Returns new message instances via RemoveMessage/AIMessage to update state\n *\n * ## Data Flow\n *\n * ```\n * User Input: \"My SSN is 123-45-6789\"\n *      [beforeModel]\n * Model Request: \"My SSN is [REDACTED_SSN_abc123]\"\n *      [model invocation]\n * Model Response: tool_call({ \"ssn\": \"[REDACTED_SSN_abc123]\" })\n *      [afterModel]\n * Tool Execution: tool({ \"ssn\": \"123-45-6789\" })\n * ```\n *\n * ## Limitations\n *\n * This middleware provides model provider isolation only. PII may still be present in:\n * - LangGraph state checkpoints (memory, databases)\n * - Network traffic between client and application server\n * - Application logs and trace data\n * - Tool execution arguments and responses\n * - Final agent output\n *\n * For comprehensive PII protection, implement additional controls at the application,\n * network, and storage layers.\n *\n * @param options - Configuration options\n * @param options.rules - Record of detection rules mapping rule names to regex patterns.\n *   Rule names are normalized to uppercase and used in redaction markers.\n *   Patterns must use the global flag (`/pattern/g`) to match all occurrences.\n *\n * @returns Middleware instance for use with `createAgent`\n *\n * @example Basic usage with custom rules\n * ```typescript\n * import { piiRedactionMiddleware } from \"langchain\";\n * import { createAgent } from \"langchain\";\n * import { tool } from \"@langchain/core/tools\";\n * import { z } from \"zod/v3\";\n *\n * const PII_RULES = {\n *   ssn: /\\b\\d{3}-?\\d{2}-?\\d{4}\\b/g,\n *   email: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b/g,\n *   phone: /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/g,\n * };\n *\n * const lookupUser = tool(async ({ ssn }) => {\n *   // Receives original value: \"123-45-6789\"\n *   return { name: \"John Doe\", account: \"active\" };\n * }, {\n *   name: \"lookup_user\",\n *   description: \"Look up user by SSN\",\n *   schema: z.object({ ssn: z.string() })\n * });\n *\n * const agent = createAgent({\n *   model: new ChatOpenAI({ model: \"gpt-4\" }),\n *   tools: [lookupUser],\n *   middleware: [piiRedactionMiddleware({ rules: PII_RULES })]\n * });\n *\n * const result = await agent.invoke({\n *   messages: [new HumanMessage(\"Look up SSN 123-45-6789\")]\n * });\n * // Model request: \"Look up SSN [REDACTED_SSN_abc123]\"\n * // Model response: tool_call({ \"ssn\": \"[REDACTED_SSN_abc123]\" })\n * // Tool receives: { \"ssn\": \"123-45-6789\" }\n * ```\n *\n * @example Runtime rule configuration via context\n * ```typescript\n * const agent = createAgent({\n *   model: new ChatOpenAI({ model: \"gpt-4\" }),\n *   tools: [someTool],\n *   middleware: [piiRedactionMiddleware()]\n * });\n *\n * // Configure rules at runtime via middleware context\n * const result = await agent.invoke(\n *   { messages: [new HumanMessage(\"...\")] },\n *   {\n *     configurable: {\n *       PIIRedactionMiddleware: {\n *         rules: {\n *           ssn: /\\b\\d{3}-?\\d{2}-?\\d{4}\\b/g,\n *           email: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b/g,\n *         }\n *       }\n *     }\n *   }\n * );\n * ```\n *\n * @example Custom rule patterns\n * ```typescript\n * const customRules = {\n *   employee_id: /EMP-\\d{6}/g,\n *   api_key: /sk-[a-zA-Z0-9]{32}/g,\n *   credit_card: /\\b\\d{4}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}\\b/g,\n * };\n *\n * const middleware = piiRedactionMiddleware({ rules: customRules });\n * // Generates markers like: [REDACTED_EMPLOYEE_ID_xyz789]\n * ```\n *\n * @deprecated\n */\nexport function piiRedactionMiddleware(\n  options: PIIRedactionMiddlewareConfig = {}\n): ReturnType<typeof createMiddleware> {\n  const redactionMap: RedactionMap = {};\n\n  console.warn(\n    \"DEPRECATED: piiRedactionMiddleware is deprecated. Please use piiMiddleware instead, go to https://docs.langchain.com/oss/javascript/langchain/middleware/built-in#pii-detection for more information.\"\n  );\n\n  return createMiddleware({\n    name: \"PIIRedactionMiddleware\",\n    contextSchema,\n    wrapModelCall: async (request, handler) => {\n      /**\n       * Merge options with context, following bigTool.ts pattern\n       */\n      const rules = request.runtime.context.rules ?? options.rules ?? {};\n\n      /**\n       * If no rules are provided, skip processing\n       */\n      if (Object.keys(rules).length === 0) {\n        return handler(request);\n      }\n\n      const processedMessages = await Promise.all(\n        request.state.messages.map((message: BaseMessage) =>\n          processMessage(message, {\n            rules,\n            redactionMap,\n          })\n        )\n      );\n\n      return handler({\n        ...request,\n        messages: processedMessages,\n      });\n    },\n    afterModel: async (state) => {\n      /**\n       * If no redactions were made, skip processing\n       */\n      if (Object.keys(redactionMap).length === 0) {\n        return;\n      }\n\n      const lastMessage = state.messages.at(-1);\n      if (!AIMessage.isInstance(lastMessage)) {\n        return;\n      }\n\n      /**\n       * In cases where we do structured output via tool calls, we also have to look at the second last message\n       * as we add a custom last message to the messages array.\n       */\n      const secondLastMessage = state.messages.at(-2);\n\n      const { message: restoredLastMessage, changed } = restoreMessage(\n        lastMessage,\n        redactionMap\n      );\n\n      if (!changed) {\n        return;\n      }\n\n      /**\n       * Identify if the last message is a structured response and restore the values if so\n       */\n      let structuredResponse: Record<string, unknown> | undefined;\n      if (\n        AIMessage.isInstance(lastMessage) &&\n        lastMessage?.tool_calls?.length === 0 &&\n        typeof lastMessage.content === \"string\" &&\n        lastMessage.content.startsWith(\"{\") &&\n        lastMessage.content.endsWith(\"}\")\n      ) {\n        try {\n          structuredResponse = JSON.parse(\n            restoreRedactedValues(lastMessage.content, redactionMap)\n          );\n        } catch {\n          // ignore\n        }\n      }\n\n      /**\n       * Check if the second last message is a structured response tool call\n       */\n      const isStructuredResponseToolCall =\n        AIMessage.isInstance(secondLastMessage) &&\n        secondLastMessage?.tool_calls?.length !== 0 &&\n        secondLastMessage?.tool_calls?.some((call) =>\n          call.name.startsWith(\"extract-\")\n        );\n      if (isStructuredResponseToolCall) {\n        const {\n          message: restoredSecondLastMessage,\n          changed: changedSecondLastMessage,\n        } = restoreMessage(secondLastMessage, redactionMap);\n        const structuredResponseRedacted = secondLastMessage.tool_calls?.find(\n          (call) => call.name.startsWith(\"extract-\")\n        )?.args;\n        const structuredResponse = structuredResponseRedacted\n          ? JSON.parse(\n              restoreRedactedValues(\n                JSON.stringify(structuredResponseRedacted),\n                redactionMap\n              )\n            )\n          : undefined;\n        if (changed || changedSecondLastMessage) {\n          return {\n            ...state,\n            ...(structuredResponse ? { structuredResponse } : {}),\n            messages: [\n              new RemoveMessage({ id: secondLastMessage.id as string }),\n              new RemoveMessage({ id: lastMessage.id as string }),\n              restoredSecondLastMessage,\n              restoredLastMessage,\n            ],\n          };\n        }\n      }\n\n      return {\n        ...state,\n        ...(structuredResponse ? { structuredResponse } : {}),\n        messages: [\n          new RemoveMessage({ id: lastMessage.id as string }),\n          restoredLastMessage,\n        ],\n      };\n    },\n  });\n}\n", "/**\n * Context editing middleware.\n *\n * This middleware mirrors Anthropic's context editing capabilities by clearing\n * older tool results once the conversation grows beyond a configurable token\n * threshold. The implementation is intentionally model-agnostic so it can be used\n * with any LangChain chat model.\n */\n\nimport type { BaseMessage } from \"@langchain/core/messages\";\nimport type { BaseLanguageModel } from \"@langchain/core/language_models/base\";\nimport {\n  AIMessage,\n  ToolMessage,\n  SystemMessage,\n} from \"@langchain/core/messages\";\n\nimport { countTokensApproximately } from \"./utils.js\";\nimport { createMiddleware } from \"../middleware.js\";\nimport {\n  getProfileLimits,\n  contextSizeSchema,\n  keepSchema,\n  type ContextSize,\n  type KeepSize,\n  type TokenCounter,\n} from \"./summarization.js\";\n\nconst DEFAULT_TOOL_PLACEHOLDER = \"[cleared]\";\nconst DEFAULT_TRIGGER_TOKENS = 100_000;\nconst DEFAULT_KEEP = 3;\n\n/**\n * Protocol describing a context editing strategy.\n *\n * Implement this interface to create custom strategies for managing\n * conversation context size. The `apply` method should modify the\n * messages array in-place and return the updated token count.\n *\n * @example\n * ```ts\n * import { HumanMessage, type ContextEdit, type BaseMessage  } from \"langchain\";\n *\n * class RemoveOldHumanMessages implements ContextEdit {\n *   constructor(private keepRecent: number = 10) {}\n *\n *   async apply({ messages, countTokens }) {\n *     // Check current token count\n *     const tokens = await countTokens(messages);\n *\n *     // Remove old human messages if over limit, keeping the most recent ones\n *     if (tokens > 50000) {\n *       const humanMessages: number[] = [];\n *\n *       // Find all human message indices\n *       for (let i = 0; i < messages.length; i++) {\n *         if (HumanMessage.isInstance(messages[i])) {\n *           humanMessages.push(i);\n *         }\n *       }\n *\n *       // Remove old human messages (keep only the most recent N)\n *       const toRemove = humanMessages.slice(0, -this.keepRecent);\n *       for (let i = toRemove.length - 1; i >= 0; i--) {\n *         messages.splice(toRemove[i]!, 1);\n *       }\n *     }\n *   }\n * }\n * ```\n */\nexport interface ContextEdit {\n  /**\n   * Apply an edit to the message list, returning the new token count.\n   *\n   * This method should:\n   * 1. Check if editing is needed based on `tokens` parameter\n   * 2. Modify the `messages` array in-place (if needed)\n   * 3. Return the new token count after modifications\n   *\n   * @param params - Parameters for the editing operation\n   * @returns The updated token count after applying edits\n   */\n  apply(params: {\n    /**\n     * Array of messages to potentially edit (modify in-place)\n     */\n    messages: BaseMessage[];\n    /**\n     * Function to count tokens in a message array\n     */\n    countTokens: TokenCounter;\n    /**\n     * Optional model instance for model profile information\n     */\n    model?: BaseLanguageModel;\n  }): void | Promise<void>;\n}\n\n/**\n * Configuration for clearing tool outputs when token limits are exceeded.\n */\nexport interface ClearToolUsesEditConfig {\n  /**\n   * Trigger conditions for context editing.\n   * Can be a single condition object (all properties must be met) or an array of conditions (any condition must be met).\n   *\n   * @example\n   * ```ts\n   * // Single condition: trigger if tokens >= 100000 AND messages >= 50\n   * trigger: { tokens: 100000, messages: 50 }\n   *\n   * // Multiple conditions: trigger if (tokens >= 100000 AND messages >= 50) OR (tokens >= 50000 AND messages >= 100)\n   * trigger: [\n   *   { tokens: 100000, messages: 50 },\n   *   { tokens: 50000, messages: 100 }\n   * ]\n   *\n   * // Fractional trigger: trigger at 80% of model's max input tokens\n   * trigger: { fraction: 0.8 }\n   * ```\n   */\n  trigger?: ContextSize | ContextSize[];\n\n  /**\n   * Context retention policy applied after editing.\n   * Specify how many tool results to preserve using messages, tokens, or fraction.\n   *\n   * @example\n   * ```ts\n   * // Keep 3 most recent tool results\n   * keep: { messages: 3 }\n   *\n   * // Keep tool results that fit within 1000 tokens\n   * keep: { tokens: 1000 }\n   *\n   * // Keep tool results that fit within 30% of model's max input tokens\n   * keep: { fraction: 0.3 }\n   * ```\n   */\n  keep?: KeepSize;\n\n  /**\n   * Whether to clear the originating tool call parameters on the AI message.\n   * @default false\n   */\n  clearToolInputs?: boolean;\n\n  /**\n   * List of tool names to exclude from clearing.\n   * @default []\n   */\n  excludeTools?: string[];\n\n  /**\n   * Placeholder text inserted for cleared tool outputs.\n   * @default \"[cleared]\"\n   */\n  placeholder?: string;\n\n  /**\n   * @deprecated Use `trigger: { tokens: value }` instead.\n   */\n  triggerTokens?: number;\n\n  /**\n   * @deprecated Use `keep: { messages: value }` instead.\n   */\n  keepMessages?: number;\n\n  /**\n   * @deprecated This property is deprecated and will be removed in a future version.\n   * Use `keep: { tokens: value }` or `keep: { messages: value }` instead to control retention.\n   */\n  clearAtLeast?: number;\n}\n\n/**\n * Strategy for clearing tool outputs when token limits are exceeded.\n *\n * This strategy mirrors Anthropic's `clear_tool_uses_20250919` behavior by\n * replacing older tool results with a placeholder text when the conversation\n * grows too large. It preserves the most recent tool results and can exclude\n * specific tools from being cleared.\n *\n * @example\n * ```ts\n * import { ClearToolUsesEdit } from \"langchain\";\n *\n * const edit = new ClearToolUsesEdit({\n *   trigger: { tokens: 100000 },  // Start clearing at 100K tokens\n *   keep: { messages: 3 },        // Keep 3 most recent tool results\n *   excludeTools: [\"important\"],   // Never clear \"important\" tool\n *   clearToolInputs: false,        // Keep tool call arguments\n *   placeholder: \"[cleared]\",      // Replacement text\n * });\n *\n * // Multiple trigger conditions\n * const edit2 = new ClearToolUsesEdit({\n *   trigger: [\n *     { tokens: 100000, messages: 50 },\n *     { tokens: 50000, messages: 100 }\n *   ],\n *   keep: { messages: 3 },\n * });\n *\n * // Fractional trigger with model profile\n * const edit3 = new ClearToolUsesEdit({\n *   trigger: { fraction: 0.8 },  // Trigger at 80% of model's max tokens\n *   keep: { fraction: 0.3 },     // Keep 30% of model's max tokens\n * });\n * ```\n */\nexport class ClearToolUsesEdit implements ContextEdit {\n  #triggerConditions: ContextSize[];\n\n  trigger: ContextSize | ContextSize[];\n  keep: KeepSize;\n  clearToolInputs: boolean;\n  excludeTools: Set<string>;\n  placeholder: string;\n  model: BaseLanguageModel;\n  clearAtLeast: number;\n\n  constructor(config: ClearToolUsesEditConfig = {}) {\n    // Handle deprecated parameters\n    let trigger: ContextSize | ContextSize[] | undefined = config.trigger;\n    if (config.triggerTokens !== undefined) {\n      console.warn(\n        \"triggerTokens is deprecated. Use `trigger: { tokens: value }` instead.\"\n      );\n      if (trigger === undefined) {\n        trigger = { tokens: config.triggerTokens };\n      }\n    }\n\n    let keep: KeepSize | undefined = config.keep;\n    if (config.keepMessages !== undefined) {\n      console.warn(\n        \"keepMessages is deprecated. Use `keep: { messages: value }` instead.\"\n      );\n      if (keep === undefined) {\n        keep = { messages: config.keepMessages };\n      }\n    }\n\n    // Set defaults\n    if (trigger === undefined) {\n      trigger = { tokens: DEFAULT_TRIGGER_TOKENS };\n    }\n    if (keep === undefined) {\n      keep = { messages: DEFAULT_KEEP };\n    }\n\n    // Validate trigger conditions\n    if (Array.isArray(trigger)) {\n      this.#triggerConditions = trigger.map((t) => contextSizeSchema.parse(t));\n      this.trigger = this.#triggerConditions;\n    } else {\n      const validated = contextSizeSchema.parse(trigger);\n      this.#triggerConditions = [validated];\n      this.trigger = validated;\n    }\n\n    // Validate keep\n    const validatedKeep = keepSchema.parse(keep);\n    this.keep = validatedKeep;\n\n    // Handle deprecated clearAtLeast\n    if (config.clearAtLeast !== undefined) {\n      console.warn(\n        \"clearAtLeast is deprecated and will be removed in a future version. \" +\n          \"It conflicts with the `keep` property. Use `keep: { tokens: value }` or \" +\n          \"`keep: { messages: value }` instead to control retention.\"\n      );\n    }\n    this.clearAtLeast = config.clearAtLeast ?? 0;\n\n    this.clearToolInputs = config.clearToolInputs ?? false;\n    this.excludeTools = new Set(config.excludeTools ?? []);\n    this.placeholder = config.placeholder ?? DEFAULT_TOOL_PLACEHOLDER;\n  }\n\n  async apply(params: {\n    messages: BaseMessage[];\n    model: BaseLanguageModel;\n    countTokens: TokenCounter;\n  }): Promise<void> {\n    const { messages, model, countTokens } = params;\n    const tokens = await countTokens(messages);\n\n    /**\n     * Always remove orphaned tool messages (those without corresponding AI messages)\n     * regardless of whether editing is triggered\n     */\n    const orphanedIndices: number[] = [];\n    for (let i = 0; i < messages.length; i++) {\n      const msg = messages[i];\n      if (ToolMessage.isInstance(msg)) {\n        // Check if this tool message has a corresponding AI message\n        const aiMessage = this.#findAIMessageForToolCall(\n          messages.slice(0, i),\n          msg.tool_call_id\n        );\n\n        if (!aiMessage) {\n          // Orphaned tool message - mark for removal\n          orphanedIndices.push(i);\n        } else {\n          // Check if the AI message actually has this tool call\n          const toolCall = aiMessage.tool_calls?.find(\n            (call) => call.id === msg.tool_call_id\n          );\n          if (!toolCall) {\n            // Orphaned tool message - mark for removal\n            orphanedIndices.push(i);\n          }\n        }\n      }\n    }\n\n    /**\n     * Remove orphaned tool messages in reverse order to maintain indices\n     */\n    for (let i = orphanedIndices.length - 1; i >= 0; i--) {\n      messages.splice(orphanedIndices[i]!, 1);\n    }\n\n    /**\n     * Recalculate tokens after removing orphaned messages\n     */\n    let currentTokens = tokens;\n    if (orphanedIndices.length > 0) {\n      currentTokens = await countTokens(messages);\n    }\n\n    /**\n     * Check if editing should be triggered\n     */\n    if (!this.#shouldEdit(messages, currentTokens, model)) {\n      return;\n    }\n\n    /**\n     * Find all tool message candidates with their actual indices in the messages array\n     */\n    const candidates: { idx: number; msg: ToolMessage }[] = [];\n    for (let i = 0; i < messages.length; i++) {\n      const msg = messages[i];\n      if (ToolMessage.isInstance(msg)) {\n        candidates.push({ idx: i, msg });\n      }\n    }\n\n    if (candidates.length === 0) {\n      return;\n    }\n\n    /**\n     * Determine how many tool results to keep based on keep policy\n     */\n    const keepCount = await this.#determineKeepCount(\n      candidates,\n      countTokens,\n      model\n    );\n\n    /**\n     * Keep the most recent tool messages based on keep policy\n     */\n    const candidatesToClear =\n      keepCount >= candidates.length\n        ? []\n        : keepCount > 0\n          ? candidates.slice(0, -keepCount)\n          : candidates;\n\n    /**\n     * If clearAtLeast is set, we may need to clear more messages to meet the token requirement\n     * This is a deprecated feature that conflicts with keep, but we support it for backwards compatibility\n     */\n    let clearedTokens = 0;\n    const initialCandidatesToClear = [...candidatesToClear];\n\n    for (const { idx, msg: toolMessage } of initialCandidatesToClear) {\n      /**\n       * Skip if already cleared\n       */\n      const contextEditing = toolMessage.response_metadata?.context_editing as\n        | { cleared?: boolean }\n        | undefined;\n      if (contextEditing?.cleared) {\n        continue;\n      }\n\n      /**\n       * Find the corresponding AI message\n       */\n      const aiMessage = this.#findAIMessageForToolCall(\n        messages.slice(0, idx),\n        toolMessage.tool_call_id\n      );\n\n      if (!aiMessage) {\n        continue;\n      }\n\n      /**\n       * Find the corresponding tool call\n       */\n      const toolCall = aiMessage.tool_calls?.find(\n        (call) => call.id === toolMessage.tool_call_id\n      );\n\n      if (!toolCall) {\n        continue;\n      }\n\n      /**\n       * Skip if tool is excluded\n       */\n      const toolName = toolMessage.name || toolCall.name;\n      if (this.excludeTools.has(toolName)) {\n        continue;\n      }\n\n      /**\n       * Clear the tool message\n       */\n      messages[idx] = new ToolMessage({\n        tool_call_id: toolMessage.tool_call_id,\n        content: this.placeholder,\n        name: toolMessage.name,\n        artifact: undefined,\n        response_metadata: {\n          ...toolMessage.response_metadata,\n          context_editing: {\n            cleared: true,\n            strategy: \"clear_tool_uses\",\n          },\n        },\n      });\n\n      /**\n       * Optionally clear the tool inputs\n       */\n      if (this.clearToolInputs) {\n        const aiMsgIdx = messages.indexOf(aiMessage);\n        if (aiMsgIdx >= 0) {\n          messages[aiMsgIdx] = this.#buildClearedToolInputMessage(\n            aiMessage,\n            toolMessage.tool_call_id\n          );\n        }\n      }\n\n      /**\n       * Recalculate tokens\n       */\n      const newTokenCount = await countTokens(messages);\n      clearedTokens = Math.max(0, currentTokens - newTokenCount);\n    }\n\n    /**\n     * If clearAtLeast is set and we haven't cleared enough tokens,\n     * continue clearing more messages (going backwards from keepCount)\n     * This is deprecated behavior but maintained for backwards compatibility\n     */\n    if (this.clearAtLeast > 0 && clearedTokens < this.clearAtLeast) {\n      /**\n       * Find remaining candidates that weren't cleared yet (those that were kept)\n       */\n      const remainingCandidates =\n        keepCount > 0 && keepCount < candidates.length\n          ? candidates.slice(-keepCount)\n          : [];\n\n      /**\n       * Clear additional messages until we've cleared at least clearAtLeast tokens\n       * Go backwards through the kept messages\n       */\n      for (let i = remainingCandidates.length - 1; i >= 0; i--) {\n        if (clearedTokens >= this.clearAtLeast) {\n          break;\n        }\n\n        const { idx, msg: toolMessage } = remainingCandidates[i]!;\n\n        /**\n         * Skip if already cleared\n         */\n        const contextEditing = toolMessage.response_metadata\n          ?.context_editing as { cleared?: boolean } | undefined;\n        if (contextEditing?.cleared) {\n          continue;\n        }\n\n        /**\n         * Find the corresponding AI message\n         */\n        const aiMessage = this.#findAIMessageForToolCall(\n          messages.slice(0, idx),\n          toolMessage.tool_call_id\n        );\n\n        if (!aiMessage) {\n          continue;\n        }\n\n        /**\n         * Find the corresponding tool call\n         */\n        const toolCall = aiMessage.tool_calls?.find(\n          (call) => call.id === toolMessage.tool_call_id\n        );\n\n        if (!toolCall) {\n          continue;\n        }\n\n        /**\n         * Skip if tool is excluded\n         */\n        const toolName = toolMessage.name || toolCall.name;\n        if (this.excludeTools.has(toolName)) {\n          continue;\n        }\n\n        /**\n         * Clear the tool message\n         */\n        messages[idx] = new ToolMessage({\n          tool_call_id: toolMessage.tool_call_id,\n          content: this.placeholder,\n          name: toolMessage.name,\n          artifact: undefined,\n          response_metadata: {\n            ...toolMessage.response_metadata,\n            context_editing: {\n              cleared: true,\n              strategy: \"clear_tool_uses\",\n            },\n          },\n        });\n\n        /**\n         * Optionally clear the tool inputs\n         */\n        if (this.clearToolInputs) {\n          const aiMsgIdx = messages.indexOf(aiMessage);\n          if (aiMsgIdx >= 0) {\n            messages[aiMsgIdx] = this.#buildClearedToolInputMessage(\n              aiMessage,\n              toolMessage.tool_call_id\n            );\n          }\n        }\n\n        /**\n         * Recalculate tokens\n         */\n        const newTokenCount = await countTokens(messages);\n        clearedTokens = Math.max(0, currentTokens - newTokenCount);\n      }\n    }\n  }\n\n  /**\n   * Determine whether editing should run for the current token usage\n   */\n  #shouldEdit(\n    messages: BaseMessage[],\n    totalTokens: number,\n    model: BaseLanguageModel\n  ): boolean {\n    /**\n     * Check each condition (OR logic between conditions)\n     */\n    for (const trigger of this.#triggerConditions) {\n      /**\n       * Within a single condition, all specified properties must be satisfied (AND logic)\n       */\n      let conditionMet = true;\n      let hasAnyProperty = false;\n\n      if (trigger.messages !== undefined) {\n        hasAnyProperty = true;\n        if (messages.length < trigger.messages) {\n          conditionMet = false;\n        }\n      }\n\n      if (trigger.tokens !== undefined) {\n        hasAnyProperty = true;\n        if (totalTokens < trigger.tokens) {\n          conditionMet = false;\n        }\n      }\n\n      if (trigger.fraction !== undefined) {\n        hasAnyProperty = true;\n        if (!model) {\n          continue;\n        }\n        const maxInputTokens = getProfileLimits(model);\n        if (typeof maxInputTokens === \"number\") {\n          const threshold = Math.floor(maxInputTokens * trigger.fraction);\n          if (threshold <= 0) {\n            continue;\n          }\n          if (totalTokens < threshold) {\n            conditionMet = false;\n          }\n        } else {\n          /**\n           * If fraction is specified but we can't get model limits, skip this condition\n           */\n          continue;\n        }\n      }\n\n      /**\n       * If condition has at least one property and all properties are satisfied, trigger editing\n       */\n      if (hasAnyProperty && conditionMet) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Determine how many tool results to keep based on keep policy\n   */\n  async #determineKeepCount(\n    candidates: Array<{ idx: number; msg: ToolMessage }>,\n    countTokens: TokenCounter,\n    model: BaseLanguageModel\n  ): Promise<number> {\n    if (\"messages\" in this.keep && this.keep.messages !== undefined) {\n      return this.keep.messages;\n    }\n\n    if (\"tokens\" in this.keep && this.keep.tokens !== undefined) {\n      /**\n       * For token-based keep, count backwards from the end until we exceed the token limit\n       * This is a simplified implementation - keeping N most recent tool messages\n       * A more sophisticated implementation would count actual tokens\n       */\n      const targetTokens = this.keep.tokens;\n      let tokenCount = 0;\n      let keepCount = 0;\n\n      for (let i = candidates.length - 1; i >= 0; i--) {\n        const candidate = candidates[i];\n        /**\n         * Estimate tokens for this tool message (simplified - could be improved)\n         */\n        const msgTokens = await countTokens([candidate.msg]);\n        if (tokenCount + msgTokens <= targetTokens) {\n          tokenCount += msgTokens;\n          keepCount++;\n        } else {\n          break;\n        }\n      }\n\n      return keepCount;\n    }\n\n    if (\"fraction\" in this.keep && this.keep.fraction !== undefined) {\n      if (!model) {\n        return DEFAULT_KEEP;\n      }\n      const maxInputTokens = getProfileLimits(model);\n      if (typeof maxInputTokens === \"number\") {\n        const targetTokens = Math.floor(maxInputTokens * this.keep.fraction);\n        if (targetTokens <= 0) {\n          return DEFAULT_KEEP;\n        }\n        /**\n         * Use token-based logic with fractional target\n         */\n        let tokenCount = 0;\n        let keepCount = 0;\n\n        for (let i = candidates.length - 1; i >= 0; i--) {\n          const candidate = candidates[i];\n          const msgTokens = await countTokens([candidate.msg]);\n          if (tokenCount + msgTokens <= targetTokens) {\n            tokenCount += msgTokens;\n            keepCount++;\n          } else {\n            break;\n          }\n        }\n\n        return keepCount;\n      }\n    }\n\n    return DEFAULT_KEEP;\n  }\n\n  #findAIMessageForToolCall(\n    previousMessages: BaseMessage[],\n    toolCallId: string\n  ): AIMessage | null {\n    // Search backwards through previous messages\n    for (let i = previousMessages.length - 1; i >= 0; i--) {\n      const msg = previousMessages[i];\n      if (AIMessage.isInstance(msg)) {\n        const hasToolCall = msg.tool_calls?.some(\n          (call) => call.id === toolCallId\n        );\n        if (hasToolCall) {\n          return msg;\n        }\n      }\n    }\n    return null;\n  }\n\n  #buildClearedToolInputMessage(\n    message: AIMessage,\n    toolCallId: string\n  ): AIMessage {\n    const updatedToolCalls = message.tool_calls?.map((toolCall) => {\n      if (toolCall.id === toolCallId) {\n        return { ...toolCall, args: {} };\n      }\n      return toolCall;\n    });\n\n    const metadata = { ...message.response_metadata };\n    const contextEntry = {\n      ...(metadata.context_editing as Record<string, unknown>),\n    };\n\n    const clearedIds = new Set<string>(\n      contextEntry.cleared_tool_inputs as string[] | undefined\n    );\n    clearedIds.add(toolCallId);\n    contextEntry.cleared_tool_inputs = Array.from(clearedIds).sort();\n    metadata.context_editing = contextEntry;\n\n    return new AIMessage({\n      content: message.content,\n      tool_calls: updatedToolCalls,\n      response_metadata: metadata,\n      id: message.id,\n      name: message.name,\n      additional_kwargs: message.additional_kwargs,\n    });\n  }\n}\n\n/**\n * Configuration for the Context Editing Middleware.\n */\nexport interface ContextEditingMiddlewareConfig {\n  /**\n   * Sequence of edit strategies to apply. Defaults to a single\n   * ClearToolUsesEdit mirroring Anthropic defaults.\n   */\n  edits?: ContextEdit[];\n\n  /**\n   * Whether to use approximate token counting (faster, less accurate)\n   * or exact counting implemented by the chat model (potentially slower, more accurate).\n   * Currently only OpenAI models support exact counting.\n   * @default \"approx\"\n   */\n  tokenCountMethod?: \"approx\" | \"model\";\n}\n\n/**\n * Middleware that automatically prunes tool results to manage context size.\n *\n * This middleware applies a sequence of edits when the total input token count\n * exceeds configured thresholds. By default, it uses the `ClearToolUsesEdit` strategy\n * which mirrors Anthropic's `clear_tool_uses_20250919` behaviour by clearing older\n * tool results once the conversation exceeds 100,000 tokens.\n *\n * ## Basic Usage\n *\n * Use the middleware with default settings to automatically manage context:\n *\n * @example Basic usage with defaults\n * ```ts\n * import { contextEditingMiddleware } from \"langchain\";\n * import { createAgent } from \"langchain\";\n *\n * const agent = createAgent({\n *   model: \"anthropic:claude-sonnet-4-5\",\n *   tools: [searchTool, calculatorTool],\n *   middleware: [\n *     contextEditingMiddleware(),\n *   ],\n * });\n * ```\n *\n * The default configuration:\n * - Triggers when context exceeds **100,000 tokens**\n * - Keeps the **3 most recent** tool results\n * - Uses **approximate token counting** (fast)\n * - Does not clear tool call arguments\n *\n * ## Custom Configuration\n *\n * Customize the clearing behavior with `ClearToolUsesEdit`:\n *\n * @example Custom ClearToolUsesEdit configuration\n * ```ts\n * import { contextEditingMiddleware, ClearToolUsesEdit } from \"langchain\";\n *\n * // Single condition: trigger if tokens >= 50000 AND messages >= 20\n * const agent1 = createAgent({\n *   model: \"anthropic:claude-sonnet-4-5\",\n *   tools: [searchTool, calculatorTool],\n *   middleware: [\n *     contextEditingMiddleware({\n *       edits: [\n *         new ClearToolUsesEdit({\n *           trigger: { tokens: 50000, messages: 20 },\n *           keep: { messages: 5 },\n *           excludeTools: [\"search\"],\n *           clearToolInputs: true,\n *         }),\n *       ],\n *       tokenCountMethod: \"approx\",\n *     }),\n *   ],\n * });\n *\n * // Multiple conditions: trigger if (tokens >= 50000 AND messages >= 20) OR (tokens >= 30000 AND messages >= 50)\n * const agent2 = createAgent({\n *   model: \"anthropic:claude-sonnet-4-5\",\n *   tools: [searchTool, calculatorTool],\n *   middleware: [\n *     contextEditingMiddleware({\n *       edits: [\n *         new ClearToolUsesEdit({\n *           trigger: [\n *             { tokens: 50000, messages: 20 },\n *             { tokens: 30000, messages: 50 },\n *           ],\n *           keep: { messages: 5 },\n *         }),\n *       ],\n *     }),\n *   ],\n * });\n *\n * // Fractional trigger with model profile\n * const agent3 = createAgent({\n *   model: chatModel,\n *   tools: [searchTool, calculatorTool],\n *   middleware: [\n *     contextEditingMiddleware({\n *       edits: [\n *         new ClearToolUsesEdit({\n *           trigger: { fraction: 0.8 },  // Trigger at 80% of model's max tokens\n *           keep: { fraction: 0.3 },     // Keep 30% of model's max tokens\n *           model: chatModel,\n *         }),\n *       ],\n *     }),\n *   ],\n * });\n * ```\n *\n * ## Custom Editing Strategies\n *\n * Implement your own context editing strategy by creating a class that\n * implements the `ContextEdit` interface:\n *\n * @example Custom editing strategy\n * ```ts\n * import { contextEditingMiddleware, type ContextEdit, type TokenCounter } from \"langchain\";\n * import type { BaseMessage } from \"@langchain/core/messages\";\n *\n * class CustomEdit implements ContextEdit {\n *   async apply(params: {\n *     tokens: number;\n *     messages: BaseMessage[];\n *     countTokens: TokenCounter;\n *   }): Promise<number> {\n *     // Implement your custom editing logic here\n *     // and apply it to the messages array, then\n *     // return the new token count after edits\n *     return countTokens(messages);\n *   }\n * }\n * ```\n *\n * @param config - Configuration options for the middleware\n * @returns A middleware instance that can be used with `createAgent`\n */\nexport function contextEditingMiddleware(\n  config: ContextEditingMiddlewareConfig = {}\n) {\n  const edits = config.edits ?? [new ClearToolUsesEdit()];\n  const tokenCountMethod = config.tokenCountMethod ?? \"approx\";\n\n  return createMiddleware({\n    name: \"ContextEditingMiddleware\",\n    wrapModelCall: async (request, handler) => {\n      if (!request.messages || request.messages.length === 0) {\n        return handler(request);\n      }\n\n      /**\n       * Use model's token counting method\n       */\n      const systemMsg = request.systemPrompt\n        ? [new SystemMessage(request.systemPrompt)]\n        : [];\n\n      const countTokens: TokenCounter =\n        tokenCountMethod === \"approx\"\n          ? countTokensApproximately\n          : async (messages: BaseMessage[]): Promise<number> => {\n              const allMessages = [...systemMsg, ...messages];\n\n              /**\n               * Check if model has getNumTokensFromMessages method\n               * currently only OpenAI models have this method\n               */\n              if (\"getNumTokensFromMessages\" in request.model) {\n                return (\n                  request.model as BaseLanguageModel & {\n                    getNumTokensFromMessages: (\n                      messages: BaseMessage[]\n                    ) => Promise<{\n                      totalCount: number;\n                      countPerMessage: number[];\n                    }>;\n                  }\n                )\n                  .getNumTokensFromMessages(allMessages)\n                  .then(({ totalCount }) => totalCount);\n              }\n\n              throw new Error(\n                `Model \"${request.model.getName()}\" does not support token counting`\n              );\n            };\n\n      /**\n       * Apply each edit in sequence\n       */\n      for (const edit of edits) {\n        await edit.apply({\n          messages: request.messages,\n          model: request.model as BaseLanguageModel,\n          countTokens,\n        });\n      }\n\n      return handler(request);\n    },\n  });\n}\n", "import { AIMessage, ToolMessage } from \"@langchain/core/messages\";\nimport { z as z4 } from \"zod/v4\";\nimport { z } from \"zod/v3\";\nimport type { InferInteropZodInput } from \"@langchain/core/utils/types\";\nimport type { ToolCall } from \"@langchain/core/messages/tool\";\n\nimport { createMiddleware } from \"../middleware.js\";\n\n/**\n * Build the error message content for ToolMessage when limit is exceeded.\n *\n * This message is sent to the model, so it should not reference thread/run concepts\n * that the model has no notion of.\n *\n * @param toolName - Tool name being limited (if specific tool), or undefined for all tools.\n * @returns A concise message instructing the model not to call the tool again.\n */\nfunction buildToolMessageContent(toolName: string | undefined): string {\n  // Always instruct the model not to call again, regardless of which limit was hit\n  if (toolName) {\n    return `Tool call limit exceeded. Do not call '${toolName}' again.`;\n  }\n  return \"Tool call limit exceeded. Do not make additional tool calls.\";\n}\n\nconst VALID_EXIT_BEHAVIORS = [\"continue\", \"error\", \"end\"] as const;\nconst DEFAULT_EXIT_BEHAVIOR = \"continue\";\n\n/**\n * Build the final AI message content for 'end' behavior.\n *\n * This message is displayed to the user, so it should include detailed information\n * about which limits were exceeded.\n *\n * @param threadCount - Current thread tool call count.\n * @param runCount - Current run tool call count.\n * @param threadLimit - Thread tool call limit (if set).\n * @param runLimit - Run tool call limit (if set).\n * @param toolName - Tool name being limited (if specific tool), or undefined for all tools.\n * @returns A formatted message describing which limits were exceeded.\n */\nfunction buildFinalAIMessageContent(\n  threadCount: number,\n  runCount: number,\n  threadLimit: number | undefined,\n  runLimit: number | undefined,\n  toolName: string | undefined\n): string {\n  const toolDesc = toolName ? `'${toolName}' tool` : \"Tool\";\n  const exceededLimits: string[] = [];\n\n  if (threadLimit !== undefined && threadCount > threadLimit) {\n    exceededLimits.push(\n      `thread limit exceeded (${threadCount}/${threadLimit} calls)`\n    );\n  }\n  if (runLimit !== undefined && runCount > runLimit) {\n    exceededLimits.push(`run limit exceeded (${runCount}/${runLimit} calls)`);\n  }\n\n  const limitsText = exceededLimits.join(\" and \");\n  return `${toolDesc} call limit reached: ${limitsText}.`;\n}\n\n/**\n * Schema for the exit behavior.\n */\nconst exitBehaviorSchema = z\n  .enum(VALID_EXIT_BEHAVIORS)\n  .default(DEFAULT_EXIT_BEHAVIOR);\n\n/**\n * Exception raised when tool call limits are exceeded.\n *\n * This exception is raised when the configured exit behavior is 'error'\n * and either the thread or run tool call limit has been exceeded.\n */\nexport class ToolCallLimitExceededError extends Error {\n  /**\n   * Current thread tool call count.\n   */\n  threadCount: number;\n  /**\n   * Current run tool call count.\n   */\n  runCount: number;\n  /**\n   * Thread tool call limit (if set).\n   */\n  threadLimit: number | undefined;\n  /**\n   * Run tool call limit (if set).\n   */\n  runLimit: number | undefined;\n  /**\n   * Tool name being limited (if specific tool), or undefined for all tools.\n   */\n  toolName: string | undefined;\n\n  constructor(\n    threadCount: number,\n    runCount: number,\n    threadLimit: number | undefined,\n    runLimit: number | undefined,\n    toolName: string | undefined = undefined\n  ) {\n    const message = buildFinalAIMessageContent(\n      threadCount,\n      runCount,\n      threadLimit,\n      runLimit,\n      toolName\n    );\n    super(message);\n\n    this.name = \"ToolCallLimitExceededError\";\n    this.threadCount = threadCount;\n    this.runCount = runCount;\n    this.threadLimit = threadLimit;\n    this.runLimit = runLimit;\n    this.toolName = toolName;\n  }\n}\n\n/**\n * Options for configuring the Tool Call Limit middleware.\n */\nexport const ToolCallLimitOptionsSchema = z.object({\n  /**\n   * Name of the specific tool to limit. If undefined, limits apply to all tools.\n   */\n  toolName: z.string().optional(),\n  /**\n   * Maximum number of tool calls allowed per thread.\n   * undefined means no limit.\n   */\n  threadLimit: z.number().optional(),\n  /**\n   * Maximum number of tool calls allowed per run.\n   * undefined means no limit.\n   */\n  runLimit: z.number().optional(),\n  /**\n   * What to do when limits are exceeded.\n   * - \"continue\": Block exceeded tools with error messages, let other tools continue (default)\n   * - \"error\": Raise a ToolCallLimitExceededError exception\n   * - \"end\": Stop execution immediately, injecting a ToolMessage and an AI message\n   *   for the single tool call that exceeded the limit. Raises NotImplementedError\n   *   if there are multiple tool calls.\n   *\n   * @default \"continue\"\n   */\n  exitBehavior: exitBehaviorSchema,\n});\n\nexport type ToolCallLimitConfig = InferInteropZodInput<\n  typeof ToolCallLimitOptionsSchema\n>;\n\n/**\n * Middleware state schema to track the number of model calls made at the thread and run level.\n */\nconst stateSchema = z.object({\n  threadToolCallCount: z.record(z.string(), z.number()).default({}),\n  runToolCallCount: z.record(z.string(), z.number()).default({}),\n});\n\nconst DEFAULT_TOOL_COUNT_KEY = \"__all__\";\n\n/**\n * Middleware that tracks tool call counts and enforces limits.\n *\n * This middleware monitors the number of tool calls made during agent execution\n * and can terminate the agent when specified limits are reached. It supports\n * both thread-level and run-level call counting with configurable exit behaviors.\n *\n * Thread-level: The middleware counts all tool calls in the entire message history\n * and persists this count across multiple runs (invocations) of the agent.\n *\n * Run-level: The middleware counts tool calls made after the last HumanMessage,\n * representing the current run (invocation) of the agent.\n *\n * @param options - Configuration options for the middleware\n * @param options.toolName - Name of the specific tool to limit. If undefined, limits apply to all tools.\n * @param options.threadLimit - Maximum number of tool calls allowed per thread. undefined means no limit.\n * @param options.runLimit - Maximum number of tool calls allowed per run. undefined means no limit.\n * @param options.exitBehavior - What to do when limits are exceeded.\n *   - \"continue\": Block exceeded tools with error messages, let other tools continue. Model decides when to end. (default)\n *   - \"error\": Raise a ToolCallLimitExceededError exception\n *   - \"end\": Stop execution immediately with a ToolMessage + AI message for the single tool call that exceeded the limit. Raises NotImplementedError if there are multiple tool calls.\n *\n * @throws {Error} If both limits are undefined, if exitBehavior is invalid, or if runLimit exceeds threadLimit.\n * @throws {NotImplementedError} If exitBehavior is \"end\" and there are multiple tool calls.\n *\n * @example Continue execution with blocked tools (default)\n * ```ts\n * import { toolCallLimitMiddleware } from \"@langchain/langchain/agents/middleware\";\n * import { createAgent } from \"@langchain/langchain/agents\";\n *\n * // Block exceeded tools but let other tools and model continue\n * const limiter = toolCallLimitMiddleware({\n *   threadLimit: 20,\n *   runLimit: 10,\n *   exitBehavior: \"continue\", // default\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [limiter]\n * });\n * ```\n *\n * @example Stop immediately when limit exceeded\n * ```ts\n * // End execution immediately with an AI message\n * const limiter = toolCallLimitMiddleware({\n *   runLimit: 5,\n *   exitBehavior: \"end\"\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [limiter]\n * });\n * ```\n *\n * @example Raise exception on limit\n * ```ts\n * // Strict limit with exception handling\n * const limiter = toolCallLimitMiddleware({\n *   toolName: \"search\",\n *   threadLimit: 5,\n *   exitBehavior: \"error\"\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [limiter]\n * });\n *\n * try {\n *   const result = await agent.invoke({ messages: [new HumanMessage(\"Task\")] });\n * } catch (error) {\n *   if (error instanceof ToolCallLimitExceededError) {\n *     console.log(`Search limit exceeded: ${error}`);\n *   }\n * }\n * ```\n */\nexport function toolCallLimitMiddleware(options: ToolCallLimitConfig) {\n  /**\n   * Validate that at least one limit is specified\n   */\n  if (options.threadLimit === undefined && options.runLimit === undefined) {\n    throw new Error(\n      \"At least one limit must be specified (threadLimit or runLimit)\"\n    );\n  }\n\n  /**\n   * Validate exitBehavior (Zod schema already validates, but provide helpful error)\n   */\n  const exitBehavior = options.exitBehavior ?? DEFAULT_EXIT_BEHAVIOR;\n  const parseResult = exitBehaviorSchema.safeParse(exitBehavior);\n  if (!parseResult.success) {\n    throw new Error(z4.prettifyError(parseResult.error).slice(2));\n  }\n\n  /**\n   * Validate that runLimit does not exceed threadLimit\n   */\n  if (\n    options.threadLimit !== undefined &&\n    options.runLimit !== undefined &&\n    options.runLimit > options.threadLimit\n  ) {\n    throw new Error(\n      `runLimit (${options.runLimit}) cannot exceed threadLimit (${options.threadLimit}). ` +\n        \"The run limit should be less than or equal to the thread limit.\"\n    );\n  }\n\n  /**\n   * Generate the middleware name based on the tool name\n   */\n  const middlewareName = options.toolName\n    ? `ToolCallLimitMiddleware[${options.toolName}]`\n    : \"ToolCallLimitMiddleware\";\n\n  return createMiddleware({\n    name: middlewareName,\n    stateSchema,\n    afterModel: {\n      canJumpTo: [\"end\"],\n      hook: (state) => {\n        /**\n         * Get the last AI message to check for tool calls\n         */\n        const lastAIMessage = [...state.messages]\n          .reverse()\n          .find(AIMessage.isInstance);\n\n        if (!lastAIMessage || !lastAIMessage.tool_calls) {\n          return undefined;\n        }\n\n        /**\n         * Helper to check if limit would be exceeded by one more call\n         */\n        const wouldExceedLimit = (\n          threadCount: number,\n          runCount: number\n        ): boolean => {\n          return (\n            (options.threadLimit !== undefined &&\n              threadCount + 1 > options.threadLimit) ||\n            (options.runLimit !== undefined && runCount + 1 > options.runLimit)\n          );\n        };\n\n        /**\n         * Helper to check if a tool call matches our filter\n         */\n        const matchesToolFilter = (toolCall: { name?: string }): boolean => {\n          return (\n            options.toolName === undefined || toolCall.name === options.toolName\n          );\n        };\n\n        /**\n         * Separate tool calls into allowed and blocked based on limits\n         */\n        const separateToolCalls = (\n          toolCalls: ToolCall[],\n          threadCount: number,\n          runCount: number\n        ): {\n          allowed: ToolCall[];\n          blocked: ToolCall[];\n          finalThreadCount: number;\n          finalRunCount: number;\n        } => {\n          const allowed: ToolCall[] = [];\n          const blocked: ToolCall[] = [];\n          let tempThreadCount = threadCount;\n          let tempRunCount = runCount;\n\n          for (const toolCall of toolCalls) {\n            if (!matchesToolFilter(toolCall)) {\n              // Tool call doesn't match our filter, skip it\n              continue;\n            }\n\n            if (wouldExceedLimit(tempThreadCount, tempRunCount)) {\n              blocked.push(toolCall);\n            } else {\n              allowed.push(toolCall);\n              tempThreadCount += 1;\n              tempRunCount += 1;\n            }\n          }\n\n          return {\n            allowed,\n            blocked,\n            finalThreadCount: tempThreadCount,\n            finalRunCount: tempRunCount + blocked.length,\n          };\n        };\n\n        /**\n         * Get the count key for this middleware instance\n         */\n        const countKey = options.toolName ?? DEFAULT_TOOL_COUNT_KEY;\n\n        /**\n         * Get current counts\n         */\n        const threadCounts = { ...(state.threadToolCallCount ?? {}) };\n        const runCounts = { ...(state.runToolCallCount ?? {}) };\n        const currentThreadCount = threadCounts[countKey] ?? 0;\n        const currentRunCount = runCounts[countKey] ?? 0;\n\n        /**\n         * Separate tool calls into allowed and blocked\n         */\n        const { allowed, blocked, finalThreadCount, finalRunCount } =\n          separateToolCalls(\n            lastAIMessage.tool_calls,\n            currentThreadCount,\n            currentRunCount\n          );\n\n        /**\n         * Update counts:\n         * - Thread count includes only allowed calls (blocked calls don't count towards thread-level tracking)\n         * - Run count includes blocked calls since they were attempted in this run\n         */\n        threadCounts[countKey] = finalThreadCount;\n        runCounts[countKey] = finalRunCount;\n\n        /**\n         * If no tool calls are blocked, just update counts\n         */\n        if (blocked.length === 0) {\n          if (allowed.length > 0) {\n            return {\n              threadToolCallCount: threadCounts,\n              runToolCallCount: runCounts,\n            };\n          }\n          return undefined;\n        }\n\n        /**\n         * Handle different exit behaviors\n         */\n        if (exitBehavior === \"error\") {\n          // Use hypothetical thread count to show which limit was exceeded\n          const hypotheticalThreadCount = finalThreadCount + blocked.length;\n          throw new ToolCallLimitExceededError(\n            hypotheticalThreadCount,\n            finalRunCount,\n            options.threadLimit,\n            options.runLimit,\n            options.toolName\n          );\n        }\n\n        /**\n         * Build tool message content (sent to model - no thread/run details)\n         */\n        const toolMsgContent = buildToolMessageContent(options.toolName);\n\n        /**\n         * Inject artificial error ToolMessages for blocked tool calls\n         */\n        const artificialMessages: Array<ToolMessage | AIMessage> = blocked.map(\n          (toolCall) =>\n            new ToolMessage({\n              content: toolMsgContent,\n              tool_call_id: toolCall.id!,\n              name: toolCall.name,\n              status: \"error\",\n            })\n        );\n\n        if (exitBehavior === \"end\") {\n          /**\n           * Check if there are tool calls to other tools that would continue executing\n           * For tool-specific limiters: check for calls to other tools\n           * For global limiters: check if there are multiple different tool types\n           */\n          let otherTools: ToolCall[] = [];\n          if (options.toolName !== undefined) {\n            /**\n             * Tool-specific limiter: check for calls to other tools\n             */\n            otherTools = lastAIMessage.tool_calls.filter(\n              (tc) => tc.name !== options.toolName\n            );\n          } else {\n            /**\n             * Global limiter: check if there are multiple different tool types\n             * If there are allowed calls, those would execute\n             * But even if all are blocked, we can't handle multiple tool types with \"end\"\n             */\n            const uniqueToolNames = new Set(\n              lastAIMessage.tool_calls.map((tc) => tc.name).filter(Boolean)\n            );\n            if (uniqueToolNames.size > 1) {\n              /**\n               * Multiple different tool types - use allowed calls to show which ones\n               */\n              otherTools =\n                allowed.length > 0 ? allowed : lastAIMessage.tool_calls;\n            }\n          }\n\n          if (otherTools.length > 0) {\n            const toolNames = Array.from(\n              new Set(otherTools.map((tc) => tc.name).filter(Boolean))\n            ).join(\", \");\n            throw new Error(\n              `Cannot end execution with other tool calls pending. Found calls to: ${toolNames}. Use 'continue' or 'error' behavior instead.`\n            );\n          }\n\n          /**\n           * Build final AI message content (displayed to user - includes thread/run details)\n           * Use hypothetical thread count (what it would have been if call wasn't blocked)\n           * to show which limit was actually exceeded\n           */\n          const hypotheticalThreadCount = finalThreadCount + blocked.length;\n          const finalMsgContent = buildFinalAIMessageContent(\n            hypotheticalThreadCount,\n            finalRunCount,\n            options.threadLimit,\n            options.runLimit,\n            options.toolName\n          );\n          artificialMessages.push(new AIMessage(finalMsgContent));\n\n          return {\n            threadToolCallCount: threadCounts,\n            runToolCallCount: runCounts,\n            jumpTo: \"end\" as const,\n            messages: artificialMessages,\n          };\n        }\n\n        /**\n         * For exit_behavior=\"continue\", return error messages to block exceeded tools\n         */\n        return {\n          threadToolCallCount: threadCounts,\n          runToolCallCount: runCounts,\n          messages: artificialMessages,\n        };\n      },\n    },\n    /**\n     * reset the run tool call count after the agent execution completes\n     */\n    afterAgent: () => ({\n      runToolCallCount: {},\n    }),\n  });\n}\n", "import { z } from \"zod/v3\";\nimport { Command } from \"@langchain/langgraph\";\nimport { tool } from \"@langchain/core/tools\";\nimport { AIMessage, ToolMessage } from \"@langchain/core/messages\";\n\nimport { createMiddleware } from \"../index.js\";\n\n/**\n * Description for the write_todos tool\n * Ported exactly from Python WRITE_TODOS_DESCRIPTION\n */\nconst WRITE_TODOS_DESCRIPTION = `Use this tool to create and manage a structured task list for your current work session. This helps you track progress, organize complex tasks, and demonstrate thoroughness to the user.\nIt also helps the user understand the progress of the task and overall progress of their requests.\nOnly use this tool if you think it will be helpful in staying organized. If the user's request is trivial and takes less than 3 steps, it is better to NOT use this tool and just do the taks directly.\n\n## When to Use This Tool\nUse this tool in these scenarios:\n\n1. Complex multi-step tasks - When a task requires 3 or more distinct steps or actions\n2. Non-trivial and complex tasks - Tasks that require careful planning or multiple operations\n3. User explicitly requests todo list - When the user directly asks you to use the todo list\n4. User provides multiple tasks - When users provide a list of things to be done (numbered or comma-separated)\n5. The plan may need future revisions or updates based on results from the first few steps. Keeping track of this in a list is helpful.\n\n## How to Use This Tool\n1. When you start working on a task - Mark it as in_progress BEFORE beginning work.\n2. After completing a task - Mark it as completed and add any new follow-up tasks discovered during implementation.\n3. You can also update future tasks, such as deleting them if they are no longer necessary, or adding new tasks that are necessary. Don't change previously completed tasks.\n4. You can make several updates to the todo list at once. For example, when you complete a task, you can mark the next task you need to start as in_progress.\n\n## When NOT to Use This Tool\nIt is important to skip using this tool when:\n1. There is only a single, straightforward task\n2. The task is trivial and tracking it provides no benefit\n3. The task can be completed in less than 3 trivial steps\n4. The task is purely conversational or informational\n\n## Examples of When to Use the Todo List\n\n<example>\nUser: I want to add a dark mode toggle to the application settings. Make sure you run the tests and build when you're done!\nAssistant: I'll help add a dark mode toggle to your application settings. Let me create a todo list to track this implementation.\n*Creates todo list with the following items:*\n1. Create dark mode toggle component in Settings page\n2. Add dark mode state management (context/store)\n3. Implement CSS-in-JS styles for dark theme\n4. Update existing components to support theme switching\n5. Run tests and build process, addressing any failures or errors that occur\n*Begins working on the first task*\n\n<reasoning>\nThe assistant used the todo list because:\n1. Adding dark mode in it of itself is a multi-step feature requiring UI, state management, and styling changes\n2. The assistant inferred that tests and build need to pass by adding \"Ensure tests and build succeed\" as the final task\n3. Both of the user's requests are complex and require multiple steps to complete.\n</reasoning>\n</example>\n\n<example>\nUser: Help me plan a comprehensive marketing campaign for our new product launch, including social media, email marketing, and press releases.\nAssistant: I'll help you plan a comprehensive marketing campaign for your product launch. Let me create a todo list to organize all the components.\n*Creates todo list with the following items:*\n1. Define target audience and key messaging\n2. Create social media content calendar and posting schedule\n3. Design email marketing sequence and automation flows\n4. Draft press release and identify media contacts\n5. Set up tracking and analytics for campaign performance\n6. Create visual assets and brand materials\n7. Coordinate launch timeline and deliverables\n*Begins working on the first task*\n\n<reasoning>\nThe assistant used the todo list because:\n1. Marketing campaign planning involves multiple distinct channels and activities\n2. Each component requires careful coordination and planning\n3. The systematic approach ensures all aspects of the launch are covered\n</reasoning>\n</example>\n\n<example>\nUser: Help me rename the function getCwd to getCurrentWorkingDirectory across my project\nAssistant: Let me first search through your codebase to find all occurrences of 'getCwd'.\n*Uses search tools to locate all instances of getCwd in the codebase*\nAssistant: I've found 15 instances of 'getCwd' across 8 different files. Let me create a todo list to track these changes.\n*Creates todo list with specific items for each file that needs updating*\n\n<reasoning>\nThe assistant used the todo list because:\n1. The assistant searched to understand the scope of the task\n2. Upon finding multiple occurrences across different files, it determined this was a complex task with multiple steps (>3)\n3. The todo list helps ensure every instance is tracked and updated systematically\n4. This approach prevents missing any occurrences and maintains consistency.\n</reasoning>\n</example>\n\n<example>\nUser: I need help organizing my home office: decluttering the desk, setting up a filing system, organizing digital files, and creating a daily workflow.\nAssistant: I'll help you organize your home office systematically. Let me create a todo list to track each area of organization.\n*Creates todo list with items like: 1) Sort and declutter desk items, 2) Set up physical filing system for documents, 3) Organize digital files and folders, 4) Create daily workflow and productivity systems, 5) Establish maintenance routines*\nLet's start with decluttering your desk space to create a clean foundation for the other organizational systems.\n\n<reasoning>\nThe assistant used the todo list because:\n1. The user provided multiple distinct organizational tasks\n2. Each area requires different approaches and careful planning\n3. Home organization benefits from systematic, step-by-step completion\n4. Progress tracking ensures all areas are addressed thoroughly\n</reasoning>\n</example>\n\n## Examples of When NOT to Use the Todo List\n\n<example>\nUser: How do I print 'Hello World' in Python?\nAssistant: In Python, you can print \"Hello World\" with this simple code:\n\n\\`\\`\\`python\nprint(\"Hello World\")\n\\`\\`\\`\n\nThis will output the text \"Hello World\" to the console when executed.</assistant>\n\n<reasoning>\nThe assistant did not use the todo list because this is a single, trivial task that can be completed in one step. There's no need to track multiple tasks or steps for such a straightforward request.\n</reasoning>\n</example>\n\n<example>\nUser: What's the best way to water houseplants?\nAssistant: The best way to water houseplants depends on the specific plant type, but here are some general guidelines:\n\n- Check soil moisture by inserting your finger about 1-2 inches into the soil\n- Water thoroughly when the top inch feels dry, allowing water to drain from the bottom\n- Use room temperature water and water in the morning when possible\n- Avoid overwatering, which is more harmful than underwatering for most plants\n\nDifferent plants have different needs, so it's important to research your specific varieties for optimal care.\n\n<reasoning>\nThe assistant did not use the todo list because this is an informational request with no actual tasks to complete. The user is simply asking for advice and explanation, not for the assistant to perform multiple steps or activities.\n</reasoning>\n</example>\n\n<example>\nUser: Can you add a comment to the calculateTotal function to explain what it does?\nAssistant: Sure, let me add a comment to the calculateTotal function to explain what it does.\n* Uses the Edit tool to add a comment to the calculateTotal function *\n\n<reasoning>\nThe assistant did not use the todo list because this is a single, straightforward task confined to one location. Adding a comment doesn't require tracking multiple steps or systematic organization.\n</reasoning>\n</example>\n\n<example>\nUser: What time is it in Tokyo right now?\nAssistant: I'll check the current time in Tokyo for you.\n\n*Searches for current time in Tokyo*\n\nThe current time in Tokyo, Japan is [current time]. Tokyo is in the Japan Standard Time (JST) zone, which is UTC+9.\n\n<reasoning>\nThe assistant did not use the todo list because this is a single information lookup with immediate results. There are no multiple steps to track or organize, making the todo list unnecessary for this straightforward request.\n</reasoning>\n</example>\n\n<example>\nUser: I need to write a function that checks if a number is prime and then test it out.\nAssistant: I'll help you write a function that checks if a number is prime and then test it out.\n*Writes function that checks if a number is prime*\n*Tests the function*\n\n<reasoning>\nEven though this is a multi-step task, it is very straightforward and can be completed in two trivial steps (which is less than 3 steps!). Using the todo list here is overkill and wastes time and tokens.\n</reasoning>\n</example>\n\n<example>\nUser: I want you to order a pizza from Dominos, order a burger from McDonald's, and order a salad from Subway.\nAssistant: I'll help you order a pizza from Dominos, order a burger from McDonald's, and order a salad from Subway.\n*Orders a pizza from Dominos*\n*Orders a burger from McDonald's*\n*Orders a salad from Subway*\n\n<reasoning>\nEven though this is a multi-step task, assuming the assistant has the ability to order from these restaurants, it is very straightforward and can be completed in three trivial tool calls. \nUsing the todo list here is overkill and wastes time and tokens. These three tool calls should be made in parallel, in fact.\n</reasoning>\n</example>\n\n\n## Task States and Management\n\n1. **Task States**: Use these states to track progress:\n   - pending: Task not yet started\n   - in_progress: Currently working on (you can have multiple tasks in_progress at a time if they are not related to each other and can be run in parallel)\n   - completed: Task finished successfully\n\n2. **Task Management**:\n   - Update task status in real-time as you work\n   - Mark tasks complete IMMEDIATELY after finishing (don't batch completions)\n   - Complete current tasks before starting new ones\n   - Remove tasks that are no longer relevant from the list entirely\n   - IMPORTANT: When you write this todo list, you should mark your first task (or tasks) as in_progress immediately!.\n   - IMPORTANT: Unless all tasks are completed, you should always have at least one task in_progress to show the user that you are working on something.\n\n3. **Task Completion Requirements**:\n   - ONLY mark a task as completed when you have FULLY accomplished it\n   - If you encounter errors, blockers, or cannot finish, keep the task as in_progress\n   - When blocked, create a new task describing what needs to be resolved\n   - Never mark a task as completed if:\n     - There are unresolved issues or errors\n     - Work is partial or incomplete\n     - You encountered blockers that prevent completion\n     - You couldn't find necessary resources or dependencies\n     - Quality standards haven't been met\n\n4. **Task Breakdown**:\n   - Create specific, actionable items\n   - Break complex tasks into smaller, manageable steps\n   - Use clear, descriptive task names\n\nBeing proactive with task management demonstrates attentiveness and ensures you complete all requirements successfully\nRemember: If you only need to make a few tool calls to complete a task, and it is clear what you need to do, it is better to just do the task directly and NOT call this tool at all.`;\n\nexport const TODO_LIST_MIDDLEWARE_SYSTEM_PROMPT = `## \\`write_todos\\`\n\nYou have access to the \\`write_todos\\` tool to help you manage and plan complex objectives. \nUse this tool for complex objectives to ensure that you are tracking each necessary step and giving the user visibility into your progress.\nThis tool is very helpful for planning complex objectives, and for breaking down these larger complex objectives into smaller steps.\n\nIt is critical that you mark todos as completed as soon as you are done with a step. Do not batch up multiple steps before marking them as completed.\nFor simple objectives that only require a few steps, it is better to just complete the objective directly and NOT use this tool.\nWriting todos takes time and tokens, use it when it is helpful for managing complex many-step problems! But not for simple few-step requests.\n\n## Important To-Do List Usage Notes to Remember\n- The \\`write_todos\\` tool should never be called multiple times in parallel.\n- Don't be afraid to revise the To-Do list as you go. New information may reveal new tasks that need to be done, or old tasks that are irrelevant.`;\n\nconst TodoStatus = z\n  .enum([\"pending\", \"in_progress\", \"completed\"])\n  .describe(\"Status of the todo\");\nconst TodoSchema = z.object({\n  content: z.string().describe(\"Content of the todo item\"),\n  status: TodoStatus,\n});\nconst stateSchema = z.object({\n  todos: z.array(TodoSchema).default([]),\n});\nexport type TodoMiddlewareState = z.infer<typeof stateSchema>;\n\nexport interface TodoListMiddlewareOptions {\n  /**\n   * Custom system prompt to guide the agent on using the todo tool.\n   * If not provided, uses the default {@link PLANNING_MIDDLEWARE_SYSTEM_PROMPT}.\n   */\n  systemPrompt?: string;\n  /**\n   * Custom description for the {@link writeTodos} tool.\n   * If not provided, uses the default {@link WRITE_TODOS_DESCRIPTION}.\n   */\n  toolDescription?: string;\n}\n\n/**\n * Creates a middleware that provides todo list management capabilities to agents.\n *\n * This middleware adds a `write_todos` tool that allows agents to create and manage\n * structured task lists for complex multi-step operations. It's designed to help\n * agents track progress, organize complex tasks, and provide users with visibility\n * into task completion status.\n *\n * The middleware automatically injects system prompts that guide the agent on when\n * and how to use the todo functionality effectively. It also enforces that the\n * `write_todos` tool is called at most once per model turn, since the tool replaces\n * the entire todo list and parallel calls would create ambiguity about precedence.\n *\n * @example\n * ```typescript\n * import { todoListMiddleware, createAgent } from 'langchain';\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [todoListMiddleware()],\n * });\n *\n * // Agent now has access to write_todos tool and todo state tracking\n * const result = await agent.invoke({\n *   messages: [new HumanMessage(\"Help me refactor my codebase\")]\n * });\n *\n * console.log(result.todos); // Array of todo items with status tracking\n * ```\n *\n * @returns A configured middleware instance that provides todo management capabilities\n *\n * @see {@link TodoMiddlewareState} for the state schema\n * @see {@link writeTodos} for the tool implementation\n */\nexport function todoListMiddleware(options?: TodoListMiddlewareOptions) {\n  /**\n   * Write todos tool - manages todo list with Command return\n   */\n  const writeTodos = tool(\n    ({ todos }, config) => {\n      return new Command({\n        update: {\n          todos,\n          messages: [\n            new ToolMessage({\n              content: `Updated todo list to ${JSON.stringify(todos)}`,\n              tool_call_id: config.toolCall?.id as string,\n            }),\n          ],\n        },\n      });\n    },\n    {\n      name: \"write_todos\",\n      description: options?.toolDescription ?? WRITE_TODOS_DESCRIPTION,\n      schema: z.object({\n        todos: z.array(TodoSchema).describe(\"List of todo items to update\"),\n      }),\n    }\n  );\n\n  return createMiddleware({\n    name: \"todoListMiddleware\",\n    stateSchema,\n    tools: [writeTodos],\n    wrapModelCall: (request, handler) =>\n      handler({\n        ...request,\n        systemMessage: request.systemMessage.concat(\n          `\\n\\n${options?.systemPrompt ?? TODO_LIST_MIDDLEWARE_SYSTEM_PROMPT}`\n        ),\n      }),\n    afterModel: (state) => {\n      /**\n       * Check for parallel write_todos tool calls and return errors if detected.\n       *\n       * The todo list is designed to be updated at most once per model turn. Since\n       * the `write_todos` tool replaces the entire todo list with each call, making\n       * multiple parallel calls would create ambiguity about which update should take\n       * precedence. This method prevents such conflicts by rejecting any response that\n       * contains multiple write_todos tool calls.\n       */\n      const messages = state.messages;\n      if (!messages || messages.length === 0) {\n        return undefined;\n      }\n\n      /**\n       * Find the last AI message\n       */\n      const lastAiMsg = [...messages]\n        .reverse()\n        .find((msg) => AIMessage.isInstance(msg));\n      if (\n        !lastAiMsg ||\n        !lastAiMsg.tool_calls ||\n        lastAiMsg.tool_calls.length === 0\n      ) {\n        return undefined;\n      }\n\n      /**\n       * Count write_todos tool calls\n       */\n      const writeTodosCalls = lastAiMsg.tool_calls.filter(\n        (tc) => tc.name === writeTodos.name\n      );\n\n      if (writeTodosCalls.length > 1) {\n        /**\n         * Create error tool messages for all write_todos calls\n         */\n        const errorMessages = writeTodosCalls.map(\n          (tc) =>\n            new ToolMessage({\n              content:\n                \"Error: The `write_todos` tool should never be called multiple times \" +\n                \"in parallel. Please call it only once per model invocation to update \" +\n                \"the todo list.\",\n              tool_call_id: tc.id as string,\n              status: \"error\",\n            })\n        );\n\n        /**\n         * Keep the tool calls in the AI message but return error messages\n         * This follows the same pattern as HumanInTheLoopMiddleware\n         */\n        return { messages: errorMessages };\n      }\n\n      return undefined;\n    },\n  });\n}\n", "import { z } from \"zod/v3\";\nimport { AIMessage } from \"@langchain/core/messages\";\nimport { InferInteropZodInput } from \"@langchain/core/utils/types\";\n\nimport { createMiddleware } from \"../middleware.js\";\n\nconst DEFAULT_EXIT_BEHAVIOR = \"end\";\n\nconst contextSchema = z.object({\n  /**\n   * The maximum number of model calls allowed per thread.\n   */\n  threadLimit: z.number().optional(),\n  /**\n   * The maximum number of model calls allowed per run.\n   */\n  runLimit: z.number().optional(),\n  /**\n   * The behavior to take when the limit is exceeded.\n   * - \"error\" will throw an error and stop the agent.\n   * - \"end\" will end the agent.\n   * @default \"end\"\n   */\n  exitBehavior: z.enum([\"error\", \"end\"]).optional(),\n});\nexport type ModelCallLimitMiddlewareConfig = Partial<\n  InferInteropZodInput<typeof contextSchema>\n>;\n\n/**\n * Middleware state schema to track the number of model calls made at the thread and run level.\n */\nconst stateSchema = z.object({\n  threadModelCallCount: z.number().default(0),\n  runModelCallCount: z.number().default(0),\n});\n\n/**\n * Error thrown when the model call limit is exceeded.\n *\n * @param threadLimit - The maximum number of model calls allowed per thread.\n * @param runLimit - The maximum number of model calls allowed per run.\n * @param threadCount - The number of model calls made at the thread level.\n * @param runCount - The number of model calls made at the run level.\n */\nclass ModelCallLimitMiddlewareError extends Error {\n  constructor({\n    threadLimit,\n    runLimit,\n    threadCount,\n    runCount,\n  }: {\n    threadLimit?: number;\n    runLimit?: number;\n    threadCount?: number;\n    runCount?: number;\n  }) {\n    const exceededHint: string[] = [];\n    if (typeof threadLimit === \"number\" && typeof threadCount === \"number\") {\n      exceededHint.push(\n        `thread level call limit reached with ${threadCount} model calls`\n      );\n    }\n    if (typeof runLimit === \"number\" && typeof runCount === \"number\") {\n      exceededHint.push(\n        `run level call limit reached with ${runCount} model calls`\n      );\n    }\n    super(\n      `Model call limits exceeded${\n        exceededHint.length > 0 ? `: ${exceededHint.join(\", \")}` : \"\"\n      }`\n    );\n    this.name = \"ModelCallLimitMiddlewareError\";\n  }\n}\n\n/**\n * Creates a middleware to limit the number of model calls at both thread and run levels.\n *\n * This middleware helps prevent excessive model API calls by enforcing limits on how many\n * times the model can be invoked. It supports two types of limits:\n *\n * - **Thread-level limit**: Restricts the total number of model calls across an entire conversation thread\n * - **Run-level limit**: Restricts the number of model calls within a single agent run/invocation\n *\n * ## How It Works\n *\n * The middleware intercepts model requests before they are sent and checks the current call counts\n * against the configured limits. If either limit is exceeded, it throws a `ModelCallLimitMiddlewareError`\n * to stop execution and prevent further API calls.\n *\n * ## Use Cases\n *\n * - **Cost Control**: Prevent runaway costs from excessive model calls in production\n * - **Testing**: Ensure agents don't make too many calls during development/testing\n * - **Safety**: Limit potential infinite loops or recursive agent behaviors\n * - **Rate Limiting**: Enforce organizational policies on model usage per conversation\n *\n * @param middlewareOptions - Configuration options for the call limits\n * @param middlewareOptions.threadLimit - Maximum number of model calls allowed per thread (optional)\n * @param middlewareOptions.runLimit - Maximum number of model calls allowed per run (optional)\n *\n * @returns A middleware instance that can be passed to `createAgent`\n *\n * @throws {ModelCallLimitMiddlewareError} When either the thread or run limit is exceeded\n *\n * @example\n * ```typescript\n * import { createAgent, modelCallLimitMiddleware } from \"langchain\";\n *\n * // Limit to 10 calls per thread and 3 calls per run\n * const agent = createAgent({\n *   model: \"openai:gpt-4o-mini\",\n *   tools: [myTool],\n *   middleware: [\n *     modelCallLimitMiddleware({\n *       threadLimit: 10,\n *       runLimit: 3\n *     })\n *   ]\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Limits can also be configured at runtime via context\n * const result = await agent.invoke(\n *   { messages: [\"Hello\"] },\n *   {\n *     configurable: {\n *       threadLimit: 5  // Override the default limit for this run\n *     }\n *   }\n * );\n * ```\n */\nexport function modelCallLimitMiddleware(\n  middlewareOptions?: ModelCallLimitMiddlewareConfig\n) {\n  return createMiddleware({\n    name: \"ModelCallLimitMiddleware\",\n    contextSchema,\n    stateSchema,\n    beforeModel: {\n      canJumpTo: [\"end\"],\n      hook: (state, runtime) => {\n        let exitBehavior =\n          runtime.context.exitBehavior ??\n          middlewareOptions?.exitBehavior ??\n          DEFAULT_EXIT_BEHAVIOR;\n\n        // @ts-expect-error - throw is deprecated\n        if (exitBehavior === \"throw\") {\n          console.warn(\n            \"The 'throw' exit behavior is deprecated. Please use 'error' instead.\"\n          );\n          exitBehavior = \"error\";\n        }\n\n        const threadLimit =\n          runtime.context.threadLimit ?? middlewareOptions?.threadLimit;\n        const runLimit =\n          runtime.context.runLimit ?? middlewareOptions?.runLimit;\n\n        const threadCount = state.threadModelCallCount;\n        const runCount = state.runModelCallCount;\n        if (typeof threadLimit === \"number\" && threadLimit <= threadCount) {\n          const error = new ModelCallLimitMiddlewareError({\n            threadLimit,\n            threadCount,\n          });\n          if (exitBehavior === \"end\") {\n            return {\n              jumpTo: \"end\",\n              messages: [new AIMessage(error.message)],\n            };\n          }\n\n          throw error;\n        }\n        if (typeof runLimit === \"number\" && runLimit <= runCount) {\n          const error = new ModelCallLimitMiddlewareError({\n            runLimit,\n            runCount,\n          });\n          if (exitBehavior === \"end\") {\n            return {\n              jumpTo: \"end\",\n              messages: [new AIMessage(error.message)],\n            };\n          }\n\n          throw error;\n        }\n\n        return state;\n      },\n    },\n    afterModel: (state) => ({\n      runModelCallCount: state.runModelCallCount + 1,\n      threadModelCallCount: state.threadModelCallCount + 1,\n    }),\n    afterAgent: () => ({\n      runModelCallCount: 0,\n    }),\n  });\n}\n", "import type { LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport { initChatModel } from \"../../chat_models/universal.js\";\nimport type { AgentMiddleware } from \"./types.js\";\nimport { createMiddleware } from \"../middleware.js\";\n\n/**\n * Middleware that provides automatic model fallback on errors.\n *\n * This middleware attempts to retry failed model calls with alternative models\n * in sequence. When a model call fails, it tries the next model in the fallback\n * list until either a call succeeds or all models have been exhausted.\n *\n * @example\n * ```ts\n * import { createAgent, modelFallbackMiddleware } from \"langchain\";\n *\n * // Create middleware with fallback models (not including primary)\n * const fallback = modelFallbackMiddleware(\n *   \"openai:gpt-4o-mini\",  // First fallback\n *   \"anthropic:claude-sonnet-4-5-20250929\",  // Second fallback\n * );\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",  // Primary model\n *   middleware: [fallback],\n *   tools: [],\n * });\n *\n * // If gpt-4o fails, automatically tries gpt-4o-mini, then claude\n * const result = await agent.invoke({\n *   messages: [{ role: \"user\", content: \"Hello\" }]\n * });\n * ```\n *\n * @param fallbackModels - The fallback models to try, in order.\n * @returns A middleware instance that handles model failures with fallbacks\n */\nexport function modelFallbackMiddleware(\n  /**\n   * The fallback models to try, in order.\n   */\n  ...fallbackModels: (string | LanguageModelLike)[]\n): AgentMiddleware {\n  return createMiddleware({\n    name: \"modelFallbackMiddleware\",\n    wrapModelCall: async (request, handler) => {\n      /**\n       * Try the primary model first\n       */\n      try {\n        return await handler(request);\n      } catch (error) {\n        /**\n         * If primary model fails, try fallback models in sequence\n         */\n        for (let i = 0; i < fallbackModels.length; i++) {\n          try {\n            const fallbackModel = fallbackModels[i];\n            const model =\n              typeof fallbackModel === \"string\"\n                ? await initChatModel(fallbackModel)\n                : fallbackModel;\n\n            return await handler({\n              ...request,\n              model,\n            });\n          } catch (fallbackError) {\n            /**\n             * If this is the last fallback, throw the error\n             */\n            if (i === fallbackModels.length - 1) {\n              throw fallbackError;\n            }\n            // Otherwise, continue to next fallback\n          }\n        }\n        /**\n         * If no fallbacks were provided, re-throw the original error\n         */\n        throw error;\n      }\n    },\n  });\n}\n", "import { z } from \"zod/v3\";\n\nexport const RetrySchema = z.object({\n  /**\n   * Maximum number of retry attempts after the initial call.\n   * Default is 2 retries (3 total attempts). Must be >= 0.\n   */\n  maxRetries: z.number().min(0).default(2),\n\n  /**\n   * Either an array of error constructors to retry on, or a function\n   * that takes an error and returns `true` if it should be retried.\n   * Default is to retry on all errors.\n   */\n  retryOn: z\n    .union([\n      z.function().args(z.instanceof(Error)).returns(z.boolean()),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      z.array(z.custom<new (...args: any[]) => Error>()),\n    ])\n    .default(() => () => true),\n\n  /**\n   * Multiplier for exponential backoff. Each retry waits\n   * `initialDelayMs * (backoffFactor ** retryNumber)` milliseconds.\n   * Set to 0.0 for constant delay. Default is 2.0.\n   */\n  backoffFactor: z.number().min(0).default(2.0),\n\n  /**\n   * Initial delay in milliseconds before first retry. Default is 1000 (1 second).\n   */\n  initialDelayMs: z.number().min(0).default(1000),\n\n  /**\n   * Maximum delay in milliseconds between retries. Caps exponential\n   * backoff growth. Default is 60000 (60 seconds).\n   */\n  maxDelayMs: z.number().min(0).default(60000),\n\n  /**\n   * Whether to add random jitter (25%) to delay to avoid thundering herd.\n   * Default is `true`.\n   */\n  jitter: z.boolean().default(true),\n});\n", "import { type ZodError } from \"zod/v3\";\nimport { z as z4 } from \"zod/v4\";\n\n/**\n * Error thrown when the configuration for a retry middleware is invalid.\n */\nexport class InvalidRetryConfigError extends Error {\n  cause: ZodError;\n\n  constructor(error: ZodError) {\n    const message = z4.prettifyError(error).slice(2);\n    super(message);\n    this.name = \"InvalidRetryConfigError\";\n    this.cause = error;\n  }\n}\n", "/**\n * Model retry middleware for agents.\n */\nimport { z } from \"zod/v3\";\nimport { AIMessage } from \"@langchain/core/messages\";\n\nimport { createMiddleware } from \"../middleware.js\";\nimport type { AgentMiddleware } from \"./types.js\";\nimport { sleep, calculateRetryDelay } from \"./utils.js\";\nimport { RetrySchema } from \"./constants.js\";\nimport { InvalidRetryConfigError } from \"./error.js\";\n\n/**\n * Configuration options for the Model Retry Middleware.\n */\nexport const ModelRetryMiddlewareOptionsSchema = z\n  .object({\n    /**\n     * Behavior when all retries are exhausted. Options:\n     * - `\"continue\"` (default): Return an AIMessage with error details, allowing\n     *   the agent to potentially handle the failure gracefully.\n     * - `\"error\"`: Re-raise the exception, stopping agent execution.\n     * - Custom function: Function that takes the exception and returns a string\n     *   for the AIMessage content, allowing custom error formatting.\n     */\n    onFailure: z\n      .union([\n        z.literal(\"error\"),\n        z.literal(\"continue\"),\n        z.function().args(z.instanceof(Error)).returns(z.string()),\n      ])\n      .default(\"continue\"),\n  })\n  .merge(RetrySchema);\n\nexport type ModelRetryMiddlewareConfig = z.input<\n  typeof ModelRetryMiddlewareOptionsSchema\n>;\n\n/**\n * Middleware that automatically retries failed model calls with configurable backoff.\n *\n * Supports retrying on specific exceptions and exponential backoff.\n *\n * @example Basic usage with default settings (2 retries, exponential backoff)\n * ```ts\n * import { createAgent, modelRetryMiddleware } from \"langchain\";\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [searchTool],\n *   middleware: [modelRetryMiddleware()],\n * });\n * ```\n *\n * @example Retry specific exceptions only\n * ```ts\n * import { modelRetryMiddleware } from \"langchain\";\n *\n * const retry = modelRetryMiddleware({\n *   maxRetries: 4,\n *   retryOn: [TimeoutError, NetworkError],\n *   backoffFactor: 1.5,\n * });\n * ```\n *\n * @example Custom exception filtering\n * ```ts\n * function shouldRetry(error: Error): boolean {\n *   // Only retry on rate limit errors\n *   if (error.name === \"RateLimitError\") {\n *     return true;\n *   }\n *   // Or check for specific HTTP status codes\n *   if (error.name === \"HTTPError\" && \"statusCode\" in error) {\n *     const statusCode = (error as any).statusCode;\n *     return statusCode === 429 || statusCode === 503;\n *   }\n *   return false;\n * }\n *\n * const retry = modelRetryMiddleware({\n *   maxRetries: 3,\n *   retryOn: shouldRetry,\n * });\n * ```\n *\n * @example Return error message instead of raising\n * ```ts\n * const retry = modelRetryMiddleware({\n *   maxRetries: 4,\n *   onFailure: \"continue\", // Return AIMessage with error instead of throwing\n * });\n * ```\n *\n * @example Custom error message formatting\n * ```ts\n * const formatError = (error: Error) =>\n *   `Model call failed: ${error.message}. Please try again later.`;\n *\n * const retry = modelRetryMiddleware({\n *   maxRetries: 4,\n *   onFailure: formatError,\n * });\n * ```\n *\n * @example Constant backoff (no exponential growth)\n * ```ts\n * const retry = modelRetryMiddleware({\n *   maxRetries: 5,\n *   backoffFactor: 0.0, // No exponential growth\n *   initialDelayMs: 2000, // Always wait 2 seconds\n * });\n * ```\n *\n * @example Raise exception on failure\n * ```ts\n * const retry = modelRetryMiddleware({\n *   maxRetries: 2,\n *   onFailure: \"error\", // Re-raise exception instead of returning message\n * });\n * ```\n *\n * @param config - Configuration options for the retry middleware\n * @returns A middleware instance that handles model failures with retries\n */\nexport function modelRetryMiddleware(\n  config: ModelRetryMiddlewareConfig = {}\n): AgentMiddleware {\n  const { success, error, data } =\n    ModelRetryMiddlewareOptionsSchema.safeParse(config);\n  if (!success) {\n    throw new InvalidRetryConfigError(error);\n  }\n  const {\n    maxRetries,\n    retryOn,\n    onFailure,\n    backoffFactor,\n    initialDelayMs,\n    maxDelayMs,\n    jitter,\n  } = data;\n\n  /**\n   * Check if the exception should trigger a retry.\n   */\n  const shouldRetryException = (error: Error): boolean => {\n    if (typeof retryOn === \"function\") {\n      return retryOn(error);\n    }\n    // retryOn is an array of error constructors\n    return retryOn.some(\n      (ErrorConstructor) => error.constructor === ErrorConstructor\n    );\n  };\n\n  // Use the exported calculateRetryDelay function with our config\n  const delayConfig = { backoffFactor, initialDelayMs, maxDelayMs, jitter };\n\n  /**\n   * Format the failure message when retries are exhausted.\n   */\n  const formatFailureMessage = (error: Error, attemptsMade: number): string => {\n    const errorType = error.constructor.name;\n    const attemptWord = attemptsMade === 1 ? \"attempt\" : \"attempts\";\n    return `Model call failed after ${attemptsMade} ${attemptWord} with ${errorType}: ${error.message}`;\n  };\n\n  /**\n   * Handle failure when all retries are exhausted.\n   */\n  const handleFailure = (error: Error, attemptsMade: number): AIMessage => {\n    if (onFailure === \"error\") {\n      throw error;\n    }\n\n    let content: string;\n    if (typeof onFailure === \"function\") {\n      content = onFailure(error);\n    } else {\n      content = formatFailureMessage(error, attemptsMade);\n    }\n\n    return new AIMessage({\n      content,\n    });\n  };\n\n  return createMiddleware({\n    name: \"modelRetryMiddleware\",\n    contextSchema: ModelRetryMiddlewareOptionsSchema,\n    wrapModelCall: async (request, handler) => {\n      // Initial attempt + retries\n      for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        try {\n          return await handler(request);\n        } catch (error) {\n          const attemptsMade = attempt + 1; // attempt is 0-indexed\n\n          // Ensure error is an Error instance\n          const err =\n            error && typeof error === \"object\" && \"message\" in error\n              ? (error as Error)\n              : new Error(String(error));\n\n          // Check if we should retry this exception\n          if (!shouldRetryException(err)) {\n            // Exception is not retryable, handle failure immediately\n            return handleFailure(err, attemptsMade);\n          }\n\n          // Check if we have more retries left\n          if (attempt < maxRetries) {\n            // Calculate and apply backoff delay\n            const delay = calculateRetryDelay(delayConfig, attempt);\n            if (delay > 0) {\n              await sleep(delay);\n            }\n            // Continue to next retry\n          } else {\n            // No more retries, handle failure\n            return handleFailure(err, attemptsMade);\n          }\n        }\n      }\n\n      // Unreachable: loop always returns via handler success or handleFailure\n      throw new Error(\"Unexpected: retry loop completed without returning\");\n    },\n  });\n}\n", "/**\n * Tool retry middleware for agents.\n */\nimport { z } from \"zod/v3\";\nimport { ToolMessage } from \"@langchain/core/messages\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\n\nimport { createMiddleware } from \"../middleware.js\";\nimport type { AgentMiddleware } from \"./types.js\";\nimport { sleep, calculateRetryDelay } from \"./utils.js\";\nimport { RetrySchema } from \"./constants.js\";\nimport { InvalidRetryConfigError } from \"./error.js\";\n\n/**\n * Configuration options for the Tool Retry Middleware.\n */\nexport const ToolRetryMiddlewareOptionsSchema = z\n  .object({\n    /**\n     * Optional list of tools or tool names to apply retry logic to.\n     * Can be a list of `BaseTool` instances or tool name strings.\n     * If `undefined`, applies to all tools. Default is `undefined`.\n     */\n    tools: z\n      .array(\n        z.union([z.custom<ClientTool>(), z.custom<ServerTool>(), z.string()])\n      )\n      .optional(),\n\n    /**\n     * Behavior when all retries are exhausted. Options:\n     * - `\"continue\"` (default): Return an AIMessage with error details, allowing\n     *   the agent to potentially handle the failure gracefully.\n     * - `\"error\"`: Re-raise the exception, stopping agent execution.\n     * - Custom function: Function that takes the exception and returns a string\n     *   for the AIMessage content, allowing custom error formatting.\n     *\n     * Deprecated values:\n     * - `\"raise\"`: use `\"error\"` instead.\n     * - `\"return_message\"`: use `\"continue\"` instead.\n     */\n    onFailure: z\n      .union([\n        z.literal(\"error\"),\n        z.literal(\"continue\"),\n        /**\n         * @deprecated Use `\"error\"` instead.\n         */\n        z.literal(\"raise\"),\n        /**\n         * @deprecated Use `\"continue\"` instead.\n         */\n        z.literal(\"return_message\"),\n        z.function().args(z.instanceof(Error)).returns(z.string()),\n      ])\n      .default(\"continue\"),\n  })\n  .merge(RetrySchema);\n\nexport type ToolRetryMiddlewareConfig = z.input<\n  typeof ToolRetryMiddlewareOptionsSchema\n>;\n\n/**\n * Middleware that automatically retries failed tool calls with configurable backoff.\n *\n * Supports retrying on specific exceptions and exponential backoff.\n *\n * @example Basic usage with default settings (2 retries, exponential backoff)\n * ```ts\n * import { createAgent, toolRetryMiddleware } from \"langchain\";\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [searchTool],\n *   middleware: [toolRetryMiddleware()],\n * });\n * ```\n *\n * @example Retry specific exceptions only\n * ```ts\n * import { toolRetryMiddleware } from \"langchain\";\n *\n * const retry = toolRetryMiddleware({\n *   maxRetries: 4,\n *   retryOn: [TimeoutError, NetworkError],\n *   backoffFactor: 1.5,\n * });\n * ```\n *\n * @example Custom exception filtering\n * ```ts\n * function shouldRetry(error: Error): boolean {\n *   // Only retry on 5xx errors\n *   if (error.name === \"HTTPError\" && \"statusCode\" in error) {\n *     const statusCode = (error as any).statusCode;\n *     return 500 <= statusCode && statusCode < 600;\n *   }\n *   return false;\n * }\n *\n * const retry = toolRetryMiddleware({\n *   maxRetries: 3,\n *   retryOn: shouldRetry,\n * });\n * ```\n *\n * @example Apply to specific tools with custom error handling\n * ```ts\n * const formatError = (error: Error) =>\n *   \"Database temporarily unavailable. Please try again later.\";\n *\n * const retry = toolRetryMiddleware({\n *   maxRetries: 4,\n *   tools: [\"search_database\"],\n *   onFailure: formatError,\n * });\n * ```\n *\n * @example Apply to specific tools using BaseTool instances\n * ```ts\n * import { tool } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const searchDatabase = tool(\n *   async ({ query }) => {\n *     // Search implementation\n *     return results;\n *   },\n *   {\n *     name: \"search_database\",\n *     description: \"Search the database\",\n *     schema: z.object({ query: z.string() }),\n *   }\n * );\n *\n * const retry = toolRetryMiddleware({\n *   maxRetries: 4,\n *   tools: [searchDatabase], // Pass BaseTool instance\n * });\n * ```\n *\n * @example Constant backoff (no exponential growth)\n * ```ts\n * const retry = toolRetryMiddleware({\n *   maxRetries: 5,\n *   backoffFactor: 0.0, // No exponential growth\n *   initialDelayMs: 2000, // Always wait 2 seconds\n * });\n * ```\n *\n * @example Raise exception on failure\n * ```ts\n * const retry = toolRetryMiddleware({\n *   maxRetries: 2,\n *   onFailure: \"raise\", // Re-raise exception instead of returning message\n * });\n * ```\n *\n * @param config - Configuration options for the retry middleware\n * @returns A middleware instance that handles tool failures with retries\n */\nexport function toolRetryMiddleware(\n  config: ToolRetryMiddlewareConfig = {}\n): AgentMiddleware {\n  const { success, error, data } =\n    ToolRetryMiddlewareOptionsSchema.safeParse(config);\n  if (!success) {\n    throw new InvalidRetryConfigError(error);\n  }\n  const {\n    maxRetries,\n    tools,\n    retryOn,\n    onFailure: onFailureConfig,\n    backoffFactor,\n    initialDelayMs,\n    maxDelayMs,\n    jitter,\n  } = data;\n\n  let onFailure = onFailureConfig;\n  if (onFailureConfig === \"raise\") {\n    console.warn(\n      \" `onFailure: 'raise'` is deprecated. Use `onFailure: 'error'` instead.\"\n    );\n    onFailure = \"error\";\n  } else if (onFailureConfig === \"return_message\") {\n    console.warn(\n      \" `onFailure: 'return_message'` is deprecated. Use `onFailure: 'continue'` instead.\"\n    );\n    onFailure = \"continue\";\n  }\n\n  // Extract tool names from BaseTool instances or strings\n  const toolFilter: string[] = [];\n  for (const tool of tools ?? []) {\n    if (typeof tool === \"string\") {\n      toolFilter.push(tool);\n    } else if (\"name\" in tool && typeof tool.name === \"string\") {\n      toolFilter.push(tool.name);\n    } else {\n      throw new TypeError(\n        \"Expected a tool name string or tool instance to be passed to toolRetryMiddleware\"\n      );\n    }\n  }\n\n  /**\n   * Check if retry logic should apply to this tool.\n   */\n  const shouldRetryTool = (toolName: string): boolean => {\n    if (toolFilter.length === 0) {\n      return true;\n    }\n    return toolFilter.includes(toolName);\n  };\n\n  /**\n   * Check if the exception should trigger a retry.\n   */\n  const shouldRetryException = (error: Error): boolean => {\n    if (typeof retryOn === \"function\") {\n      return retryOn(error);\n    }\n    // retryOn is an array of error constructors\n    return retryOn.some((ErrorConstructor) => {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      return error instanceof ErrorConstructor;\n    });\n  };\n\n  // Use the exported calculateRetryDelay function with our config\n  const delayConfig = { backoffFactor, initialDelayMs, maxDelayMs, jitter };\n\n  /**\n   * Format the failure message when retries are exhausted.\n   */\n  const formatFailureMessage = (\n    toolName: string,\n    error: Error,\n    attemptsMade: number\n  ): string => {\n    const errorType = error.constructor.name;\n    const attemptWord = attemptsMade === 1 ? \"attempt\" : \"attempts\";\n    return `Tool '${toolName}' failed after ${attemptsMade} ${attemptWord} with ${errorType}`;\n  };\n\n  /**\n   * Handle failure when all retries are exhausted.\n   */\n  const handleFailure = (\n    toolName: string,\n    toolCallId: string,\n    error: Error,\n    attemptsMade: number\n  ): ToolMessage => {\n    if (onFailure === \"error\") {\n      throw error;\n    }\n\n    let content: string;\n    if (typeof onFailure === \"function\") {\n      content = onFailure(error);\n    } else {\n      content = formatFailureMessage(toolName, error, attemptsMade);\n    }\n\n    return new ToolMessage({\n      content,\n      tool_call_id: toolCallId,\n      name: toolName,\n      status: \"error\",\n    });\n  };\n\n  return createMiddleware({\n    name: \"toolRetryMiddleware\",\n    contextSchema: ToolRetryMiddlewareOptionsSchema,\n    wrapToolCall: async (request, handler) => {\n      const toolName = (request.tool?.name ?? request.toolCall.name) as string;\n\n      // Check if retry should apply to this tool\n      if (!shouldRetryTool(toolName)) {\n        return handler(request);\n      }\n\n      const toolCallId = request.toolCall.id ?? \"\";\n\n      // Initial attempt + retries\n      for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        try {\n          return await handler(request);\n        } catch (error) {\n          const attemptsMade = attempt + 1; // attempt is 0-indexed\n\n          // Ensure error is an Error instance\n          const err =\n            error && typeof error === \"object\" && \"message\" in error\n              ? (error as Error)\n              : new Error(String(error));\n\n          // Check if we should retry this exception\n          if (!shouldRetryException(err)) {\n            // Exception is not retryable, handle failure immediately\n            return handleFailure(toolName, toolCallId, err, attemptsMade);\n          }\n\n          // Check if we have more retries left\n          if (attempt < maxRetries) {\n            // Calculate and apply backoff delay\n            const delay = calculateRetryDelay(delayConfig, attempt);\n            if (delay > 0) {\n              await sleep(delay);\n            }\n            // Continue to next retry\n          } else {\n            // No more retries, handle failure\n            return handleFailure(toolName, toolCallId, err, attemptsMade);\n          }\n        }\n      }\n\n      // Unreachable: loop always returns via handler success or handleFailure\n      throw new Error(\"Unexpected: retry loop completed without returning\");\n    },\n  });\n}\n", "import { HumanMessage, ToolMessage } from \"@langchain/core/messages\";\nimport type { BaseChatModel } from \"@langchain/core/language_models/chat_models\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\nimport { initChatModel } from \"../../chat_models/universal.js\";\nimport { createMiddleware } from \"../middleware.js\";\n\n/**\n * Options for configuring the Tool Emulator middleware.\n */\nexport interface ToolEmulatorOptions {\n  /**\n   * List of tool names (string) or tool instances to emulate.\n   * - If `undefined` (default), ALL tools will be emulated.\n   * - If empty array, no tools will be emulated.\n   * - If array with tool names/instances, only those tools will be emulated.\n   */\n  tools?: (string | ClientTool | ServerTool)[];\n\n  /**\n   * Model to use for emulation.\n   * - Can be a model identifier string (e.g., \"anthropic:claude-sonnet-4-5-20250929\")\n   * - Can be a BaseChatModel instance\n   * - Defaults to agent model\n   */\n  model?: string | BaseChatModel;\n}\n\n/**\n * Middleware that emulates specified tools using an LLM instead of executing them.\n *\n * This middleware allows selective emulation of tools for testing purposes.\n * By default (when `tools` is undefined), all tools are emulated. You can specify\n * which tools to emulate by passing a list of tool names or tool instances.\n *\n * @param options - Configuration options for the middleware\n * @param options.tools - List of tool names or tool instances to emulate. If undefined, all tools are emulated.\n * @param options.model - Model to use for emulation. Defaults to \"anthropic:claude-sonnet-4-5-20250929\".\n *\n * @example Emulate all tools (default behavior)\n * ```ts\n * import { toolEmulatorMiddleware } from \"@langchain/langchain/agents/middleware\";\n * import { createAgent } from \"@langchain/langchain/agents\";\n *\n * const middleware = toolEmulatorMiddleware();\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [getWeather, getUserLocation, calculator],\n *   middleware: [middleware],\n * });\n * ```\n *\n * @example Emulate specific tools by name\n * ```ts\n * const middleware = toolEmulatorMiddleware({\n *   tools: [\"get_weather\", \"get_user_location\"]\n * });\n * ```\n *\n * @example Use a custom model for emulation\n * ```ts\n * const middleware = toolEmulatorMiddleware({\n *   tools: [\"get_weather\"],\n *   model: \"anthropic:claude-sonnet-4-5-20250929\"\n * });\n * ```\n *\n * @example Emulate specific tools by passing tool instances\n * ```ts\n * const middleware = toolEmulatorMiddleware({\n *   tools: [getWeather, getUserLocation]\n * });\n * ```\n */\nexport function toolEmulatorMiddleware(\n  options: ToolEmulatorOptions = {}\n): ReturnType<typeof createMiddleware> {\n  let agentModel: BaseChatModel | undefined;\n  const { tools, model } = options;\n\n  /**\n   * Extract tool names from tools\n   */\n  const emulateAll = !tools || tools.length === 0;\n  const toolsToEmulate = new Set<string>();\n\n  if (!emulateAll && tools) {\n    for (const tool of tools) {\n      if (typeof tool === \"string\") {\n        toolsToEmulate.add(tool);\n      } else {\n        // Assume tool instance with .name property\n        const toolName =\n          typeof tool.name === \"string\" ? tool.name : String(tool.name);\n        toolsToEmulate.add(toolName);\n      }\n    }\n  }\n\n  /**\n   * Initialize emulator model\n   * We'll initialize it lazily in wrapToolCall to handle async initChatModel\n   */\n  let emulatorModel: BaseChatModel | undefined;\n  const getEmulatorModel = async (): Promise<BaseChatModel> => {\n    if (typeof model === \"object\") {\n      return model;\n    }\n    if (typeof model === \"string\") {\n      emulatorModel =\n        emulatorModel ??\n        (await initChatModel(model, { temperature: 1 }).catch((err) => {\n          console.error(\n            \"Error initializing emulator model, using agent model:\",\n            err\n          );\n          return agentModel as BaseChatModel;\n        }));\n      return emulatorModel;\n    }\n    return agentModel as BaseChatModel;\n  };\n\n  return createMiddleware({\n    name: \"ToolEmulatorMiddleware\",\n    wrapModelCall: async (request, handler) => {\n      agentModel = request.model as BaseChatModel;\n      return handler(request);\n    },\n    wrapToolCall: async (request, handler) => {\n      const toolName = request.toolCall.name;\n\n      // Check if this tool should be emulated\n      const shouldEmulate = emulateAll || toolsToEmulate.has(toolName);\n\n      if (!shouldEmulate) {\n        // Let it execute normally by calling the handler\n        return handler(request);\n      }\n\n      // Extract tool information for emulation\n      const toolArgs = request.toolCall.args;\n      const toolDescription =\n        request.tool?.description || \"No description available\";\n\n      // Build prompt for emulator LLM\n      const toolArgsString =\n        typeof toolArgs === \"string\" ? toolArgs : JSON.stringify(toolArgs);\n      const prompt = `You are emulating a tool call for testing purposes.\n\nTool: ${toolName}\nDescription: ${toolDescription}\nArguments: ${toolArgsString}\n\nGenerate a realistic response that this tool would return given these arguments.\nReturn ONLY the tool's output, no explanation or preamble. Introduce variation into your responses.`;\n\n      // Get emulated response from LLM\n      const emulator = await getEmulatorModel();\n      const response = await emulator.invoke([new HumanMessage(prompt)]);\n\n      // Extract content from response\n      const content =\n        typeof response.content === \"string\"\n          ? response.content\n          : JSON.stringify(response.content);\n\n      // Short-circuit: return emulated result without executing real tool\n      return new ToolMessage({\n        content,\n        tool_call_id: request.toolCall.id ?? \"\",\n        name: toolName,\n      });\n    },\n  });\n}\n", "import type { BaseMessage } from \"@langchain/core/messages\";\nimport { AIMessage, HumanMessage, ToolMessage } from \"@langchain/core/messages\";\nimport type { BaseChatModel } from \"@langchain/core/language_models/chat_models\";\nimport { BaseLanguageModel } from \"@langchain/core/language_models/base\";\n\nimport { initChatModel } from \"../../../../chat_models/universal.js\";\nimport { createMiddleware } from \"../../../middleware.js\";\nimport type { MiddlewareResult, AgentMiddleware } from \"../../types.js\";\nimport type { AgentBuiltInState } from \"../../../runtime.js\";\n\n/**\n * OpenAI model interface.\n */\ninterface OpenAIModel extends BaseLanguageModel {\n  getName: () => string;\n  _getClientOptions: () => unknown;\n  client: {\n    moderations: {\n      create: (\n        input: {\n          input: string | string[];\n          model: string;\n        },\n        options?: unknown\n      ) => Promise<ModerationResponse>;\n    };\n  };\n}\n\n/**\n * Check if the model is an OpenAI model that supports moderation.\n * @param model - The model to check.\n * @returns Whether the model is an OpenAI model that supports moderation.\n */\nfunction isOpenAIModel(model: unknown): model is OpenAIModel {\n  if (\n    !model ||\n    typeof model !== \"object\" ||\n    model === null ||\n    !(\"client\" in model) ||\n    !(\"_getClientOptions\" in model) ||\n    typeof model._getClientOptions !== \"function\"\n  ) {\n    return false;\n  }\n\n  /**\n   * client may not yet be initialized, so we need to check if the model has a _getClientOptions method.\n   */\n  model._getClientOptions();\n  return (\n    typeof model.client === \"object\" &&\n    model.client !== null &&\n    \"moderations\" in model.client &&\n    typeof model.client.moderations === \"object\" &&\n    model.client.moderations !== null &&\n    \"create\" in model.client.moderations &&\n    typeof model.client.moderations.create === \"function\"\n  );\n}\n\n/**\n * Stage where a violation occurred.\n */\nexport type ViolationStage = \"input\" | \"output\" | \"tool\";\n\n/**\n * Default template for violation messages.\n */\nconst DEFAULT_VIOLATION_TEMPLATE =\n  \"I'm sorry, but I can't comply with that request. It was flagged for {categories}.\";\n\n/**\n * Result of moderation.\n * @see https://platform.openai.com/docs/api-reference/moderations/object\n */\ninterface ModerationResult {\n  flagged: boolean;\n  categories: Record<string, boolean>;\n  category_scores: Record<string, number>;\n  category_applied_input_types: Record<string, string[]>;\n}\n\n/**\n * Moderation response.\n * @see https://platform.openai.com/docs/api-reference/moderations/create\n */\ninterface ModerationResponse {\n  id: string;\n  model: string;\n  results: ModerationResult[];\n}\n\ntype ModerationModel =\n  | \"omni-moderation-latest\"\n  | \"omni-moderation-2024-09-26\"\n  | \"text-moderation-latest\"\n  | \"text-moderation-stable\";\n\n/**\n * Error raised when OpenAI flags content and `exitBehavior` is set to `\"error\"`.\n */\nexport class OpenAIModerationError extends Error {\n  content: string;\n  stage: ViolationStage;\n  result: ModerationResult;\n  originalMessage: string;\n\n  constructor({\n    content,\n    stage,\n    result,\n    message,\n  }: {\n    content: string;\n    stage: ViolationStage;\n    result: ModerationResult;\n    message: string;\n  }) {\n    super(message);\n    this.name = \"OpenAIModerationError\";\n    this.content = content;\n    this.stage = stage;\n    this.result = result;\n    this.originalMessage = message;\n  }\n}\n\n/**\n * Options for configuring the OpenAI Moderation middleware.\n */\nexport interface OpenAIModerationMiddlewareOptions {\n  /**\n   * OpenAI model to use for moderation. Can be either a model name or a BaseChatModel instance.\n   * @example\n   * ```ts\n   * const model = new ChatOpenAI({ model: \"gpt-4o-mini\" });\n   * const middleware = openAIModerationMiddleware({ model });\n   * const agent = createAgent({\n   *   model,\n   *   middleware: [middleware],\n   * });\n   * ```\n   * @example\n   * ```ts\n   * const middleware = openAIModerationMiddleware({ model: \"gpt-4o-mini\" });\n   * const agent = createAgent({\n   *   model: \"gpt-5\",\n   *   middleware: [middleware],\n   * });\n   * ```\n   */\n  model: string | BaseChatModel;\n\n  /**\n   * Moderation model to use.\n   * @default \"omni-moderation-latest\"\n   */\n  moderationModel?: ModerationModel;\n\n  /**\n   * Whether to check user input messages.\n   * @default true\n   */\n  checkInput?: boolean;\n\n  /**\n   * Whether to check model output messages.\n   * @default true\n   */\n  checkOutput?: boolean;\n\n  /**\n   * Whether to check tool result messages.\n   * @default false\n   */\n  checkToolResults?: boolean;\n\n  /**\n   * How to handle violations.\n   * - `\"error\"`: Throw an error when content is flagged\n   * - `\"end\"`: End the agent execution and return a violation message\n   * - `\"replace\"`: Replace the flagged content with a violation message\n   * @default \"end\"\n   */\n  exitBehavior?: \"error\" | \"end\" | \"replace\";\n\n  /**\n   * Custom template for violation messages.\n   * Available placeholders: `{categories}`, `{category_scores}`, `{original_content}`\n   */\n  violationMessage?: string;\n}\n\n/**\n * Middleware that moderates agent traffic using OpenAI's moderation endpoint.\n *\n * This middleware checks messages for content policy violations at different stages:\n * - Input: User messages before they reach the model\n * - Output: AI model responses\n * - Tool results: Results returned from tool executions\n *\n * @param options - Configuration options for the middleware\n * @param options.model - OpenAI model to use for moderation. Can be either a model name or a BaseChatModel instance.\n * @param options.moderationModel - Moderation model to use.\n * @param options.checkInput - Whether to check user input messages.\n * @param options.checkOutput - Whether to check model output messages.\n * @param options.checkToolResults - Whether to check tool result messages.\n * @param options.exitBehavior - How to handle violations.\n * @param options.violationMessage - Custom template for violation messages.\n * @returns Middleware function that can be used to moderate agent traffic.\n *\n * @example  Using model instance\n * ```ts\n * import { createAgent, openAIModerationMiddleware } from \"langchain\";\n *\n * const middleware = openAIModerationMiddleware({\n *   checkInput: true,\n *   checkOutput: true,\n *   exitBehavior: \"end\"\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [...],\n *   middleware: [middleware],\n * });\n * ```\n *\n * @example Using model name\n * ```ts\n * import { createAgent, openAIModerationMiddleware } from \"langchain\";\n *\n * const middleware = openAIModerationMiddleware({\n *   model: \"gpt-4o-mini\",\n *   checkInput: true,\n *   checkOutput: true,\n *   exitBehavior: \"end\"\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [...],\n *   middleware: [middleware],\n * });\n * ```\n *\n * @example Custom violation message\n * ```ts\n * const middleware = openAIModerationMiddleware({\n *   violationMessage: \"Content flagged: {categories}. Scores: {category_scores}\"\n * });\n * ```\n */\nexport function openAIModerationMiddleware(\n  options: OpenAIModerationMiddlewareOptions\n): AgentMiddleware {\n  const {\n    model,\n    moderationModel = \"omni-moderation-latest\",\n    checkInput = true,\n    checkOutput = true,\n    checkToolResults = false,\n    exitBehavior = \"end\",\n    violationMessage,\n  } = options;\n\n  let openaiModel: OpenAIModel | undefined;\n  const initModerationModel = async (): Promise<OpenAIModel> => {\n    if (openaiModel) {\n      return openaiModel;\n    }\n\n    const resolvedModel =\n      typeof model === \"string\" ? await initChatModel(model) : model;\n\n    /**\n     * Check if the model is an OpenAI model.\n     */\n    if (!resolvedModel.getName().includes(\"ChatOpenAI\")) {\n      throw new Error(\n        `Model must be an OpenAI model to use moderation middleware. Got: ${resolvedModel.getName()}`\n      );\n    }\n\n    /**\n     * check if OpenAI model package supports moderation.\n     */\n    if (!isOpenAIModel(resolvedModel)) {\n      throw new Error(\n        \"Model must support moderation to use moderation middleware.\"\n      );\n    }\n\n    openaiModel = resolvedModel as unknown as OpenAIModel;\n    return openaiModel;\n  };\n\n  /**\n   * Extract text content from a message.\n   */\n  const extractText = (message: BaseMessage): string | null => {\n    if (message.content == null) {\n      return null;\n    }\n    const text = message.text;\n    return text || null;\n  };\n\n  /**\n   * Find the last index of a message type in the messages array.\n   */\n  const findLastIndex = (\n    messages: BaseMessage[],\n    messageType: typeof AIMessage | typeof HumanMessage | typeof ToolMessage\n  ): number | null => {\n    for (let idx = messages.length - 1; idx >= 0; idx--) {\n      if (messageType.isInstance(messages[idx])) {\n        return idx;\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Format violation message from moderation result.\n   */\n  const formatViolationMessage = (\n    content: string,\n    result: ModerationResult\n  ): string => {\n    // Convert categories to array of flagged category names\n    const categories: string[] = [];\n    const categoriesObj = result.categories as unknown as Record<\n      string,\n      boolean\n    >;\n    for (const [name, flagged] of Object.entries(categoriesObj)) {\n      if (flagged) {\n        categories.push(name.replace(/_/g, \" \"));\n      }\n    }\n\n    const categoryLabel =\n      categories.length > 0\n        ? categories.join(\", \")\n        : \"OpenAI's safety policies\";\n\n    const template = violationMessage || DEFAULT_VIOLATION_TEMPLATE;\n    const scoresJson = JSON.stringify(\n      result.category_scores as unknown as Record<string, number>,\n      null,\n      2\n    );\n\n    try {\n      return template\n        .replace(\"{categories}\", categoryLabel)\n        .replace(\"{category_scores}\", scoresJson)\n        .replace(\"{original_content}\", content);\n    } catch {\n      return template;\n    }\n  };\n\n  function moderateContent(\n    input: string | string[],\n    params?: { model?: ModerationModel; options?: unknown }\n  ): Promise<ModerationResponse> {\n    const clientOptions = openaiModel?._getClientOptions?.();\n    const moderationModel = params?.model ?? \"omni-moderation-latest\";\n    const moderationRequest = {\n      input,\n      model: moderationModel,\n    };\n    return openaiModel!.client.moderations.create(\n      moderationRequest,\n      clientOptions\n    );\n  }\n\n  /**\n   * Apply violation handling based on exit behavior.\n   */\n  const applyViolation = (\n    messages: BaseMessage[],\n    index: number | null,\n    stage: ViolationStage,\n    content: string,\n    result: ModerationResult\n  ): MiddlewareResult<Partial<AgentBuiltInState>> | undefined => {\n    const violationText = formatViolationMessage(content, result);\n\n    if (exitBehavior === \"error\") {\n      throw new OpenAIModerationError({\n        content,\n        stage,\n        result,\n        message: violationText,\n      });\n    }\n\n    if (exitBehavior === \"end\") {\n      return {\n        jumpTo: \"end\",\n        messages: [new AIMessage({ content: violationText })],\n      };\n    }\n\n    if (index == null) {\n      return undefined;\n    }\n\n    /**\n     * Replace the original message with a new message that contains the violation text.\n     */\n    const newMessages = [...messages];\n    const original = newMessages[index];\n    const MessageConstructor = Object.getPrototypeOf(original).constructor;\n    newMessages[index] = new MessageConstructor({\n      ...original,\n      content: violationText,\n    });\n\n    return { messages: newMessages };\n  };\n\n  /**\n   * Moderate user input messages.\n   */\n  const moderateUserMessage = async (\n    messages: BaseMessage[]\n  ): Promise<MiddlewareResult<Partial<AgentBuiltInState>> | null> => {\n    const idx = findLastIndex(messages, HumanMessage);\n    if (idx == null) {\n      return null;\n    }\n\n    const message = messages[idx];\n    const text = extractText(message);\n    if (!text) {\n      return null;\n    }\n\n    await initModerationModel();\n    const response = await moderateContent(text, {\n      model: moderationModel,\n    });\n\n    const flaggedResult = response.results.find((result) => result.flagged);\n    if (!flaggedResult) {\n      return null;\n    }\n\n    return applyViolation(messages, idx, \"input\", text, flaggedResult);\n  };\n\n  /**\n   * Moderate tool result messages.\n   */\n  const moderateToolMessages = async (\n    messages: BaseMessage[]\n  ): Promise<MiddlewareResult<Partial<AgentBuiltInState>> | null> => {\n    const lastAiIdx = findLastIndex(messages, AIMessage);\n    if (lastAiIdx == null) {\n      return null;\n    }\n\n    const working = [...messages];\n    let modified = false;\n\n    for (let idx = lastAiIdx + 1; idx < working.length; idx++) {\n      const msg = working[idx];\n      if (!ToolMessage.isInstance(msg)) {\n        continue;\n      }\n\n      const text = extractText(msg);\n      if (!text) {\n        continue;\n      }\n\n      await initModerationModel();\n      const response = await moderateContent(text, {\n        model: moderationModel,\n      });\n      const flaggedResult = response.results.find((result) => result.flagged);\n      if (!flaggedResult) {\n        continue;\n      }\n\n      const action = applyViolation(working, idx, \"tool\", text, flaggedResult);\n      if (action) {\n        if (\"jumpTo\" in action) {\n          return action;\n        }\n        if (\"messages\" in action) {\n          working.splice(\n            0,\n            working.length,\n            ...(action.messages as BaseMessage[])\n          );\n          modified = true;\n        }\n      }\n    }\n\n    if (modified) {\n      return { messages: working };\n    }\n\n    return null;\n  };\n\n  /**\n   * Moderate model output messages.\n   */\n  const moderateOutput = async (\n    messages: BaseMessage[]\n  ): Promise<MiddlewareResult<Partial<AgentBuiltInState>> | null> => {\n    const lastAiIdx = findLastIndex(messages, AIMessage);\n    if (lastAiIdx == null) {\n      return null;\n    }\n\n    const aiMessage = messages[lastAiIdx];\n    const text = extractText(aiMessage);\n    if (!text) {\n      return null;\n    }\n\n    await initModerationModel();\n    const response = await moderateContent(text, {\n      model: moderationModel,\n    });\n    const flaggedResult = response.results.find((result) => result.flagged);\n    if (!flaggedResult) {\n      return null;\n    }\n\n    return applyViolation(messages, lastAiIdx, \"output\", text, flaggedResult);\n  };\n\n  /**\n   * Moderate inputs (user messages and tool results) before model call.\n   */\n  const moderateInputs = async (\n    messages: BaseMessage[]\n  ): Promise<MiddlewareResult<Partial<AgentBuiltInState>> | null> => {\n    const working = [...messages];\n    let modified = false;\n\n    if (checkToolResults) {\n      const action = await moderateToolMessages(working);\n      if (action) {\n        if (\"jumpTo\" in action) {\n          return action;\n        }\n        if (\"messages\" in action) {\n          working.splice(\n            0,\n            working.length,\n            ...(action.messages as BaseMessage[])\n          );\n          modified = true;\n        }\n      }\n    }\n\n    if (checkInput) {\n      const action = await moderateUserMessage(working);\n      if (action) {\n        if (\"jumpTo\" in action) {\n          return action;\n        }\n        if (\"messages\" in action) {\n          working.splice(\n            0,\n            working.length,\n            ...(action.messages as BaseMessage[])\n          );\n          modified = true;\n        }\n      }\n    }\n\n    if (modified) {\n      return { messages: working };\n    }\n\n    return null;\n  };\n\n  return createMiddleware({\n    name: \"OpenAIModerationMiddleware\",\n    beforeModel: {\n      hook: async (\n        state\n      ): Promise<MiddlewareResult<Partial<AgentBuiltInState>> | undefined> => {\n        if (!checkInput && !checkToolResults) {\n          return undefined;\n        }\n\n        const messages = state.messages || [];\n        if (messages.length === 0) {\n          return undefined;\n        }\n\n        return (await moderateInputs(messages)) ?? undefined;\n      },\n      canJumpTo: [\"end\"],\n    },\n    afterModel: {\n      hook: async (\n        state\n      ): Promise<MiddlewareResult<Partial<AgentBuiltInState>> | undefined> => {\n        if (!checkOutput) {\n          return undefined;\n        }\n\n        const messages = state.messages || [];\n        if (messages.length === 0) {\n          return undefined;\n        }\n\n        return (await moderateOutput(messages)) ?? undefined;\n      },\n      canJumpTo: [\"end\"],\n    },\n  });\n}\n", "import { z } from \"zod/v3\";\nimport { InferInteropZodInput } from \"@langchain/core/utils/types\";\n\nimport { ConfigurableModel } from \"../../../../chat_models/universal.js\";\nimport { createMiddleware } from \"../../../middleware.js\";\n\nconst DEFAULT_ENABLE_CACHING = true;\nconst DEFAULT_TTL = \"5m\";\nconst DEFAULT_MIN_MESSAGES_TO_CACHE = 3;\nconst DEFAULT_UNSUPPORTED_MODEL_BEHAVIOR = \"warn\";\n\nconst contextSchema = z.object({\n  /**\n   * Whether to enable prompt caching.\n   * @default true\n   */\n  enableCaching: z.boolean().optional(),\n  /**\n   * The time-to-live for the cached prompt.\n   * @default \"5m\"\n   */\n  ttl: z.enum([\"5m\", \"1h\"]).optional(),\n  /**\n   * The minimum number of messages required before caching is applied.\n   * @default 3\n   */\n  minMessagesToCache: z.number().optional(),\n  /**\n   * The behavior to take when an unsupported model is used.\n   * - \"ignore\" will ignore the unsupported model and continue without caching.\n   * - \"warn\" will warn the user and continue without caching.\n   * - \"raise\" will raise an error and stop the agent.\n   * @default \"warn\"\n   */\n  unsupportedModelBehavior: z.enum([\"ignore\", \"warn\", \"raise\"]).optional(),\n});\nexport type PromptCachingMiddlewareConfig = Partial<\n  InferInteropZodInput<typeof contextSchema>\n>;\n\nclass PromptCachingMiddlewareError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PromptCachingMiddlewareError\";\n  }\n}\n\n/**\n * Creates a prompt caching middleware for Anthropic models to optimize API usage.\n *\n * This middleware automatically adds cache control headers to the last messages when using Anthropic models,\n * enabling their prompt caching feature. This can significantly reduce costs for applications with repetitive\n * prompts, long system messages, or extensive conversation histories.\n *\n * ## How It Works\n *\n * The middleware intercepts model requests and adds cache control metadata that tells Anthropic's\n * API to cache processed prompt prefixes. On subsequent requests with matching prefixes, the\n * cached representations are reused, skipping redundant token processing.\n *\n * ## Benefits\n *\n * - **Cost Reduction**: Avoid reprocessing the same tokens repeatedly (up to 90% savings on cached portions)\n * - **Lower Latency**: Cached prompts are processed faster as embeddings are pre-computed\n * - **Better Scalability**: Reduced computational load enables handling more requests\n * - **Consistent Performance**: Stable response times for repetitive queries\n *\n * @param middlewareOptions - Configuration options for the caching behavior\n * @param middlewareOptions.enableCaching - Whether to enable prompt caching (default: `true`)\n * @param middlewareOptions.ttl - Cache time-to-live: `\"5m\"` for 5 minutes or `\"1h\"` for 1 hour (default: `\"5m\"`)\n * @param middlewareOptions.minMessagesToCache - Minimum number of messages required before caching is applied (default: `3`)\n * @param middlewareOptions.unsupportedModelBehavior - The behavior to take when an unsupported model is used (default: `\"warn\"`)\n *\n * @returns A middleware instance that can be passed to `createAgent`\n *\n * @throws {Error} If used with non-Anthropic models\n *\n * @example\n * Basic usage with default settings\n * ```typescript\n * import { createAgent } from \"langchain\";\n * import { anthropicPromptCachingMiddleware } from \"langchain\";\n *\n * const agent = createAgent({\n *   model: \"anthropic:claude-3-5-sonnet\",\n *   middleware: [\n *     anthropicPromptCachingMiddleware()\n *   ]\n * });\n * ```\n *\n * @example\n * Custom configuration for longer conversations\n * ```typescript\n * const cachingMiddleware = anthropicPromptCachingMiddleware({\n *   ttl: \"1h\",  // Cache for 1 hour instead of default 5 minutes\n *   minMessagesToCache: 5  // Only cache after 5 messages\n * });\n *\n * const agent = createAgent({\n *   model: \"anthropic:claude-3-5-sonnet\",\n *   systemPrompt: \"You are a helpful assistant with deep knowledge of...\", // Long system prompt\n *   middleware: [cachingMiddleware]\n * });\n * ```\n *\n * @example\n * Conditional caching based on runtime context\n * ```typescript\n * const agent = createAgent({\n *   model: \"anthropic:claude-3-5-sonnet\",\n *   middleware: [\n *     anthropicPromptCachingMiddleware({\n *       enableCaching: true,\n *       ttl: \"5m\"\n *     })\n *   ]\n * });\n *\n * // Disable caching for specific requests\n * await agent.invoke(\n *   { messages: [new HumanMessage(\"Process this without caching\")] },\n *   {\n *     configurable: {\n *       middleware_context: { enableCaching: false }\n *     }\n *   }\n * );\n * ```\n *\n * @example\n * Optimal setup for customer support chatbot\n * ```typescript\n * const supportAgent = createAgent({\n *   model: \"anthropic:claude-3-5-sonnet\",\n *   systemPrompt: `You are a customer support agent for ACME Corp.\n *\n *     Company policies:\n *     - Always be polite and professional\n *     - Refer to knowledge base for product information\n *     - Escalate billing issues to human agents\n *     ... (extensive policies and guidelines)\n *   `,\n *   tools: [searchKnowledgeBase, createTicket, checkOrderStatus],\n *   middleware: [\n *     anthropicPromptCachingMiddleware({\n *       ttl: \"1h\",  // Long TTL for stable system prompt\n *       minMessagesToCache: 1  // Cache immediately due to large system prompt\n *     })\n *   ]\n * });\n * ```\n *\n * @remarks\n * - **Anthropic Only**: This middleware only works with Anthropic models and will throw an error if used with other providers\n * - **Automatic Application**: Caching is applied automatically when message count exceeds `minMessagesToCache`\n * - **Cache Scope**: Caches are isolated per API key and cannot be shared across different keys\n * - **TTL Options**: Only supports \"5m\" (5 minutes) and \"1h\" (1 hour) as TTL values per Anthropic's API\n * - **Best Use Cases**: Long system prompts, multi-turn conversations, repetitive queries, RAG applications\n * - **Cost Impact**: Cached tokens are billed at 10% of the base input token price, cache writes are billed at 25% of the base\n *\n * @see {@link createAgent} for agent creation\n * @see {@link https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching} Anthropic's prompt caching documentation\n * @public\n */\nexport function anthropicPromptCachingMiddleware(\n  middlewareOptions?: PromptCachingMiddlewareConfig\n) {\n  return createMiddleware({\n    name: \"PromptCachingMiddleware\",\n    contextSchema,\n    wrapModelCall: (request, handler) => {\n      /**\n       * Prefer runtime context values over middleware options values over defaults\n       */\n      const enableCaching =\n        request.runtime.context.enableCaching ??\n        middlewareOptions?.enableCaching ??\n        DEFAULT_ENABLE_CACHING;\n      const ttl =\n        request.runtime.context.ttl ?? middlewareOptions?.ttl ?? DEFAULT_TTL;\n      const minMessagesToCache =\n        request.runtime.context.minMessagesToCache ??\n        middlewareOptions?.minMessagesToCache ??\n        DEFAULT_MIN_MESSAGES_TO_CACHE;\n      const unsupportedModelBehavior =\n        request.runtime.context.unsupportedModelBehavior ??\n        middlewareOptions?.unsupportedModelBehavior ??\n        DEFAULT_UNSUPPORTED_MODEL_BEHAVIOR;\n\n      // Skip if caching is disabled\n      if (!enableCaching || !request.model) {\n        return handler(request);\n      }\n\n      const isAnthropicModel =\n        request.model.getName() === \"ChatAnthropic\" ||\n        (request.model.getName() === \"ConfigurableModel\" &&\n          (request.model as ConfigurableModel)._defaultConfig?.modelProvider ===\n            \"anthropic\");\n      if (!isAnthropicModel) {\n        // Get model name for better error context\n        const modelName = request.model.getName();\n        const modelInfo =\n          request.model.getName() === \"ConfigurableModel\"\n            ? `${modelName} (${\n                (request.model as ConfigurableModel)._defaultConfig\n                  ?.modelProvider\n              })`\n            : modelName;\n\n        const baseMessage = `Unsupported model '${modelInfo}'. Prompt caching requires an Anthropic model`;\n\n        if (unsupportedModelBehavior === \"raise\") {\n          throw new PromptCachingMiddlewareError(\n            `${baseMessage} (e.g., 'anthropic:claude-4-0-sonnet').`\n          );\n        } else if (unsupportedModelBehavior === \"warn\") {\n          console.warn(\n            `PromptCachingMiddleware: Skipping caching for ${modelName}. Consider switching to an Anthropic model for caching benefits.`\n          );\n        }\n        return handler(request);\n      }\n\n      const messagesCount =\n        request.state.messages.length + (request.systemPrompt ? 1 : 0);\n\n      if (messagesCount < minMessagesToCache) {\n        return handler(request);\n      }\n\n      /**\n       * The cache_control is applied at the final message formatting layer in ChatAnthropic,\n       * which avoids issues with message content block manipulation during earlier\n       * processing stages (e.g., streaming response reassembly).\n       *\n       * @see https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching\n       */\n      return handler({\n        ...request,\n        modelSettings: {\n          ...request.modelSettings,\n          cache_control: {\n            type: \"ephemeral\" as const,\n            ttl,\n          },\n        },\n      });\n    },\n  });\n}\n", "import { __export } from \"./_virtual/rolldown_runtime.js\";\nimport { initChatModel } from \"./chat_models/universal.js\";\nimport { MiddlewareError, MultipleStructuredOutputsError, MultipleToolsBoundError, StructuredOutputParsingError, ToolInvocationError } from \"./agents/errors.js\";\nimport { ProviderStrategy, ToolStrategy, providerStrategy, toolStrategy } from \"./agents/responses.js\";\nimport { countTokensApproximately } from \"./agents/middleware/utils.js\";\nimport { MIDDLEWARE_BRAND } from \"./agents/middleware/types.js\";\nimport { createMiddleware } from \"./agents/middleware.js\";\nimport { FakeToolCallingModel } from \"./agents/tests/utils.js\";\nimport { createAgent } from \"./agents/index.js\";\nimport { humanInTheLoopMiddleware } from \"./agents/middleware/hitl.js\";\nimport { summarizationMiddleware } from \"./agents/middleware/summarization.js\";\nimport { dynamicSystemPromptMiddleware } from \"./agents/middleware/dynamicSystemPrompt.js\";\nimport { llmToolSelectorMiddleware } from \"./agents/middleware/llmToolSelector.js\";\nimport { PIIDetectionError, applyStrategy, detectCreditCard, detectEmail, detectIP, detectMacAddress, detectUrl, piiMiddleware, resolveRedactionRule } from \"./agents/middleware/pii.js\";\nimport { piiRedactionMiddleware } from \"./agents/middleware/piiRedaction.js\";\nimport { ClearToolUsesEdit, contextEditingMiddleware } from \"./agents/middleware/contextEditing.js\";\nimport { ToolCallLimitExceededError, toolCallLimitMiddleware } from \"./agents/middleware/toolCallLimit.js\";\nimport { TODO_LIST_MIDDLEWARE_SYSTEM_PROMPT, todoListMiddleware } from \"./agents/middleware/todoListMiddleware.js\";\nimport { modelCallLimitMiddleware } from \"./agents/middleware/modelCallLimit.js\";\nimport { modelFallbackMiddleware } from \"./agents/middleware/modelFallback.js\";\nimport { modelRetryMiddleware } from \"./agents/middleware/modelRetry.js\";\nimport { toolRetryMiddleware } from \"./agents/middleware/toolRetry.js\";\nimport { toolEmulatorMiddleware } from \"./agents/middleware/toolEmulator.js\";\nimport { openAIModerationMiddleware } from \"./agents/middleware/provider/openai/moderation.js\";\nimport { anthropicPromptCachingMiddleware } from \"./agents/middleware/provider/anthropic/promptCaching.js\";\nimport \"./agents/middleware/index.js\";\nimport { AIMessage, AIMessageChunk, BaseMessage, BaseMessageChunk, HumanMessage, HumanMessageChunk, SystemMessage, SystemMessageChunk, ToolMessage, ToolMessageChunk, filterMessages, trimMessages } from \"@langchain/core/messages\";\nimport { DynamicStructuredTool, DynamicTool, StructuredTool, Tool, tool } from \"@langchain/core/tools\";\nimport { context } from \"@langchain/core/utils/context\";\nimport { InMemoryStore } from \"@langchain/core/stores\";\nimport { Document } from \"@langchain/core/documents\";\n\n//#region src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n\tAIMessage: () => AIMessage,\n\tAIMessageChunk: () => AIMessageChunk,\n\tBaseMessage: () => BaseMessage,\n\tBaseMessageChunk: () => BaseMessageChunk,\n\tClearToolUsesEdit: () => ClearToolUsesEdit,\n\tDocument: () => Document,\n\tDynamicStructuredTool: () => DynamicStructuredTool,\n\tDynamicTool: () => DynamicTool,\n\tFakeToolCallingModel: () => FakeToolCallingModel,\n\tHumanMessage: () => HumanMessage,\n\tHumanMessageChunk: () => HumanMessageChunk,\n\tInMemoryStore: () => InMemoryStore,\n\tMIDDLEWARE_BRAND: () => MIDDLEWARE_BRAND,\n\tMiddlewareError: () => MiddlewareError,\n\tMultipleStructuredOutputsError: () => MultipleStructuredOutputsError,\n\tMultipleToolsBoundError: () => MultipleToolsBoundError,\n\tPIIDetectionError: () => PIIDetectionError,\n\tProviderStrategy: () => ProviderStrategy,\n\tStructuredOutputParsingError: () => StructuredOutputParsingError,\n\tStructuredTool: () => StructuredTool,\n\tSystemMessage: () => SystemMessage,\n\tSystemMessageChunk: () => SystemMessageChunk,\n\tTODO_LIST_MIDDLEWARE_SYSTEM_PROMPT: () => TODO_LIST_MIDDLEWARE_SYSTEM_PROMPT,\n\tTool: () => Tool,\n\tToolCallLimitExceededError: () => ToolCallLimitExceededError,\n\tToolInvocationError: () => ToolInvocationError,\n\tToolMessage: () => ToolMessage,\n\tToolMessageChunk: () => ToolMessageChunk,\n\tToolStrategy: () => ToolStrategy,\n\tanthropicPromptCachingMiddleware: () => anthropicPromptCachingMiddleware,\n\tapplyStrategy: () => applyStrategy,\n\tcontext: () => context,\n\tcontextEditingMiddleware: () => contextEditingMiddleware,\n\tcountTokensApproximately: () => countTokensApproximately,\n\tcreateAgent: () => createAgent,\n\tcreateMiddleware: () => createMiddleware,\n\tdetectCreditCard: () => detectCreditCard,\n\tdetectEmail: () => detectEmail,\n\tdetectIP: () => detectIP,\n\tdetectMacAddress: () => detectMacAddress,\n\tdetectUrl: () => detectUrl,\n\tdynamicSystemPromptMiddleware: () => dynamicSystemPromptMiddleware,\n\tfilterMessages: () => filterMessages,\n\thumanInTheLoopMiddleware: () => humanInTheLoopMiddleware,\n\tinitChatModel: () => initChatModel,\n\tllmToolSelectorMiddleware: () => llmToolSelectorMiddleware,\n\tmodelCallLimitMiddleware: () => modelCallLimitMiddleware,\n\tmodelFallbackMiddleware: () => modelFallbackMiddleware,\n\tmodelRetryMiddleware: () => modelRetryMiddleware,\n\topenAIModerationMiddleware: () => openAIModerationMiddleware,\n\tpiiMiddleware: () => piiMiddleware,\n\tpiiRedactionMiddleware: () => piiRedactionMiddleware,\n\tproviderStrategy: () => providerStrategy,\n\tresolveRedactionRule: () => resolveRedactionRule,\n\tsummarizationMiddleware: () => summarizationMiddleware,\n\ttodoListMiddleware: () => todoListMiddleware,\n\ttool: () => tool,\n\ttoolCallLimitMiddleware: () => toolCallLimitMiddleware,\n\ttoolEmulatorMiddleware: () => toolEmulatorMiddleware,\n\ttoolRetryMiddleware: () => toolRetryMiddleware,\n\ttoolStrategy: () => toolStrategy,\n\ttrimMessages: () => trimMessages\n});\n\n//#endregion\nexport { AIMessage, AIMessageChunk, BaseMessage, BaseMessageChunk, ClearToolUsesEdit, Document, DynamicStructuredTool, DynamicTool, FakeToolCallingModel, HumanMessage, HumanMessageChunk, InMemoryStore, MIDDLEWARE_BRAND, MiddlewareError, MultipleStructuredOutputsError, MultipleToolsBoundError, PIIDetectionError, ProviderStrategy, StructuredOutputParsingError, StructuredTool, SystemMessage, SystemMessageChunk, TODO_LIST_MIDDLEWARE_SYSTEM_PROMPT, Tool, ToolCallLimitExceededError, ToolInvocationError, ToolMessage, ToolMessageChunk, ToolStrategy, anthropicPromptCachingMiddleware, applyStrategy, context, contextEditingMiddleware, countTokensApproximately, createAgent, createMiddleware, detectCreditCard, detectEmail, detectIP, detectMacAddress, detectUrl, dynamicSystemPromptMiddleware, filterMessages, humanInTheLoopMiddleware, initChatModel, llmToolSelectorMiddleware, modelCallLimitMiddleware, modelFallbackMiddleware, modelRetryMiddleware, openAIModerationMiddleware, piiMiddleware, piiRedactionMiddleware, providerStrategy, resolveRedactionRule, src_exports, summarizationMiddleware, todoListMiddleware, tool, toolCallLimitMiddleware, toolEmulatorMiddleware, toolRetryMiddleware, toolStrategy, trimMessages };\n//# sourceMappingURL=index.js.map"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,WAAO,UAAU,OAAO,OAAO,IAAI,MAAM,CAAC,GAAG;AAAA,MAC3C,IAAI,GAAG,KAAK;AACV,YACE,QAAQ,gBACR,QAAQ,eACR,QAAQ,iBACR,QAAQ,UACR;AACA,kBAAQ,KAAK,8GAA8G,GAAG,mIAAmI;AAAA,QACnQ;AAAA,MACF;AAAA,IACF,CAAC,CAAC;AAAA;AAAA;;;ACVF,IAAI,YAAY,OAAO;AAIvB,IAAIA,YAAW,CAAC,QAAQ,QAAQ;AAC/B,WAAS,QAAQ,IAAK,WAAU,QAAQ,MAAM;AAAA,IAC7C,KAAK,IAAI,IAAI;AAAA,IACb,YAAY;AAAA,EACb,CAAC;AACF;;;AC+BA,IAAM,iBAAiB,CAACC,KAAkBC,UAAgC;AACxE,QAAM,iBAAiB,CACrB,GAAG,IAAI,IACL,OAAO,IAAI,CAAC,MAAM;AAChB,QAAI,OAAO,MAAM,SACf,QAAO;AAGT,UAAM,uBAAuB,IAAK,EAAU,CAAE,CAAA;AAC9C,QACE,EAAE,aAAa,yBACf,OAAO,qBAAqB,YAAY,WAExC,OAAM,IAAI,MAAM,wBAAA;AAElB,WAAO,qBAAqB,QAAA;EAC7B,CAAA,CAAC,CAEL;AACD,QAAM,UAAU,IAAI,QAAA;AACpB,SAAO,eAAe,KAAK,CAAC,MAAM,MAAM,OAAA;AACzC;AA6ED,SAAgB,eACdC,mBACAC,SACwD;AACxD,MAAI,MAAM,QAAQ,iBAAA,EAChB,QAAO,gBAAgB,mBAAmB,OAAA;AAE5C,SAAO,eAAe,KAAK,CAACC,UAAwC;AAClE,WAAO,gBAAgB,OAAO,iBAAA;EAC/B,CAAA;AACF;AAED,SAAS,gBACPC,UACAC,UAAgC,CAAE,GACnB;AACf,QAAM,EACJ,cACA,cACA,cACA,cACA,YACA,WAAA,IACE;AAEJ,QAAMC,WAA0B,CAAE;AAElC,aAAW,OAAO,UAAU;AAC1B,QAAI,gBAAgB,IAAI,QAAQ,aAAa,SAAS,IAAI,IAAA,EACxD;aACS,gBAAgB,eAAe,KAAK,YAAA,EAC7C;aACS,cAAc,IAAI,MAAM,WAAW,SAAS,IAAI,EAAA,EACzD;AAIF,QAAI,EAAE,gBAAgB,cAAc,cAClC,UAAS,KAAK,GAAA;aAEd,gBACA,IAAI,QACJ,aAAa,KAAK,CAAC,UAAU,UAAU,IAAI,IAAA,EAE3C,UAAS,KAAK,GAAA;aACL,gBAAgB,eAAe,KAAK,YAAA,EAC7C,UAAS,KAAK,GAAA;aACL,cAAc,IAAI,MAAM,WAAW,KAAK,CAAC,OAAO,OAAO,IAAI,EAAA,EACpE,UAAS,KAAK,GAAA;EAEjB;AAED,SAAO;AACR;AA8DD,SAAgB,iBACdC,UACwD;AACxD,MAAI,MAAM,QAAQ,QAAA,EAChB,QAAO,kBAAkB,QAAA;AAE3B,SAAO,eAAe,KAAK,iBAAA;AAC5B;AAED,SAAS,kBAAkBH,UAAwC;AACjE,MAAI,CAAC,SAAS,OACZ,QAAO,CAAE;AAEX,QAAMI,SAAwB,CAAE;AAChC,aAAW,OAAO,UAAU;AAC1B,UAAM,OAAO;AACb,UAAM,OAAO,OAAO,IAAA;AACpB,QAAI,CAAC,KACH,QAAO,KAAK,IAAA;aAEZ,KAAK,QAAA,MAAc,UACnB,EAAE,KAAK,QAAA,MAAc,KAAK,QAAA,GAE1B,QAAO,KAAK,MAAM,IAAA;SACb;AACL,YAAM,YAAY,eAAe,IAAA;AACjC,YAAM,YAAY,eAAe,IAAA;AACjC,YAAM,eAAe,UAAU,OAAO,SAAA;AACtC,UACE,OAAO,UAAU,YAAY,YAC7B,OAAO,UAAU,YAAY,SAE7B,cAAa,UAAU,GAAG,UAAU,OAAA;EAAY,UAAU,OAAA;AAE5D,aAAO,KAAK,YAAY,YAAA,CAAa;IACtC;EACF;AACD,SAAO;AACR;AA4UD,SAAgB,aACdC,mBACAC,SACiE;AACjE,MAAI,MAAM,QAAQ,iBAAA,GAAoB;AACpC,UAAM,WAAW;AACjB,QAAI,CAAC,QACH,OAAM,IAAI,MAAM,wDAAA;AAElB,WAAO,oBAAoB,UAAU,OAAA;EACtC,OAAM;AACL,UAAM,iBAAiB;AACvB,WAAO,eAAe,KAAK,CAACP,UAC1B,oBAAoB,OAAO,cAAA,CAAe,EAC1C,WAAW,EACX,SAAS,gBACV,CAAA;EACF;AACF;AAED,eAAe,oBACbC,UACAO,SAC6B;AAC7B,QAAM,EACJ,WACA,cACA,WAAW,QACX,eAAe,OACf,OACA,SACA,gBAAgB,OAChB,aAAA,IACE;AACJ,MAAI,WAAW,aAAa,QAC1B,OAAM,IAAI,MACR,6DAAA;AAGJ,MAAI,iBAAiB,aAAa,QAChC,OAAM,IAAI,MACR,mEAAA;AAIJ,MAAIC;AACJ,MAAI,kBAAkB,aACpB,oBAAmB,OAAOC,SAAyC;AACjE,UAAM,cAAc,MAAM,QAAQ,IAChC,KAAK,IAAI,CAAC,QAAQ,aAAa,aAAa,IAAI,OAAA,CAAQ,CAAC;AAE3D,WAAO,YAAY,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAA;EACxD;MAED,oBAAmB,OAAOA,SACxB,aAAa,IAAA;AAGjB,MAAIC,mBACF;AACF,MAAI,aACF,KAAI,eAAe,aACjB,oBAAmB,aAAa;MAEhC,oBAAmB,OAAOC,SACxB,aAAa,IAAA;AAInB,MAAI,aAAa,QACf,QAAO,gBAAgB,UAAU;IAC/B;IACA,cAAc;IACd,cAAc;IACd,iBAAiB,eAAe,UAAU;IAC1C;EACD,CAAA;WACQ,aAAa,OACtB,QAAO,eAAe,UAAU;IAC9B;IACA,cAAc;IACd,cAAc;IACd;IACA;IACA;IACA;EACD,CAAA;MAED,OAAM,IAAI,MACR,2BAA2B,QAAA,sCAA8C;AAG9E;AAED,eAAe,gBACbX,UACAY,SAOwB;AACxB,QAAM,EAAE,WAAW,cAAc,cAAc,iBAAiB,MAAA,IAC9D;AACF,MAAI,eAAe,CAAC,GAAG,QAAS;AAChC,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK,GAAG;AAC/C,UAAM,oBAAoB,IAAI,IAAI,aAAa,MAAM,GAAG,CAAC,CAAA,IAAK;AAC9D,QAAK,MAAM,aAAa,iBAAA,KAAuB,WAAW;AACxD,YAAM,aAAa,SAAS;AAC5B;IACD;EACF;AACD,MAAI,MAAM,aAAa,UAAU,iBAAiB;AAChD,QAAI,kBAAkB;AACtB,QAAI,MAAM,QAAQ,aAAa,GAAA,EAAK,OAAA,GAAU;AAC5C,YAAM,WAAW,aAAa,GAAA;AAC9B,UAAI,OAAO,SAAS,YAAY,SAC9B,OAAM,IAAI,MAAM,kCAAA;AAGlB,YAAM,WAAW,SAAS,QAAQ;AAClC,YAAM,kBACJ,oBAAoB,SAChB,CAAC,GAAG,SAAS,OAAQ,EAAC,QAAA,IACtB,SAAS;AACf,eAAS,IAAI,GAAG,KAAK,UAAU,KAAK,GAAG;AACrC,cAAM,iBACJ,oBAAoB,UAChB,gBAAgB,MAAM,GAAG,CAAA,IACzB,gBAAgB,MAAM,CAAC,CAAA;AAC7B,cAAM,SAAS,OAAO,YACpB,OAAO,QAAQ,QAAA,EAAU,OACvB,CAAC,CAAC,CAAA,MAAO,MAAM,UAAU,CAAC,EAAE,WAAW,KAAA,CAAM,CAC9C;AAEH,cAAM,iBAAiB,qBAAqB,SAAS,QAAA,GAAW;UAC9D,GAAG;UACH,SAAS;QACV,CAAA;AACD,cAAM,iBAAiB,CAAC,GAAG,aAAa,MAAM,GAAG,GAAA,GAAM,cAAe;AACtE,YAAK,MAAM,aAAa,cAAA,KAAoB,WAAW;AACrD,yBAAe;AACf,iBAAO;AACP,4BAAkB;QACnB,MACC;MAEH;AACD,UAAI,mBAAmB,oBAAoB,OACzC,UAAS,UAAU,CAAC,GAAG,eAAgB,EAAC,QAAA;IAE3C;AACD,QAAI,CAAC,iBAAiB;AACpB,YAAM,WAAW,aAAa,GAAA;AAC9B,UAAIC;AACJ,UACE,MAAM,QAAQ,SAAS,OAAA,KACvB,SAAS,QAAQ,KACf,CAAC,UAAU,OAAO,UAAU,YAAY,MAAM,SAAS,MAAA,GAEzD;AACA,cAAM,YAAY,SAAS,QAAQ,KACjC,CAAC,UAAU,MAAM,SAAS,UAAU,MAAM,IAAA;AAE5C,eAAO,WAAW;MACnB,WAAU,OAAO,SAAS,YAAY,SACrC,QAAO,SAAS;AAElB,UAAI,MAAM;AACR,cAAM,aAAa,MAAM,aAAa,IAAA;AACtC,cAAM,YAAY,WAAW;AAC7B,YAAI,oBAAoB,OACtB,YAAW,QAAA;AAEb,iBAAS,IAAI,GAAG,IAAI,YAAY,GAAG,KAAK,GAAG;AACzC,qBAAW,IAAA;AACX,mBAAS,UAAU,WAAW,KAAK,EAAA;AACnC,cACG,MAAM,aAAa,CAAC,GAAG,aAAa,MAAM,GAAG,GAAA,GAAM,QAAS,CAAA,KAC7D,WACA;AACA,gBAAI,oBAAoB,OACtB,UAAS,UAAU,CAAC,GAAG,UAAW,EAAC,QAAA,EAAU,KAAK,EAAA;AAEpD,2BAAe,CAAC,GAAG,aAAa,MAAM,GAAG,GAAA,GAAM,QAAS;AACxD,mBAAO;AACP;UACD;QACF;MACF;IACF;EACF;AAED,MAAI,OAAO;AACT,UAAM,WAAW,MAAM,QAAQ,KAAA,IAAS,QAAQ,CAAC,KAAM;AACvD,WAAO,MAAM,KAAK,CAAC,eAAe,aAAa,MAAM,CAAA,GAAI,QAAA,EACvD,QAAO;EAEV;AAED,SAAO,aAAa,MAAM,GAAG,GAAA;AAC9B;AAED,eAAe,eACbb,UACAc,SAewB;AACxB,QAAM,EACJ,eAAe,OACf,gBAAgB,OAChB,OACA,SACA,GAAG,KAAA,IACD;AAGJ,MAAI,eAAe,SAAS,IAAI,CAAC,YAAY;AAC3C,UAAM,SAAS,OAAO,YACpB,OAAO,QAAQ,OAAA,EAAS,OACtB,CAAC,CAAC,CAAA,MAAO,MAAM,UAAU,CAAC,EAAE,WAAW,KAAA,CAAM,CAC9C;AAEH,WAAO,qBACL,QAAQ,QAAA,GACR,QACA,mBAAmB,OAAA,CAAQ;EAE9B,CAAA;AAED,MAAI,OAAO;AACT,UAAM,WAAW,MAAM,QAAQ,KAAA,IAAS,QAAQ,CAAC,KAAM;AACvD,WACE,aAAa,SAAS,KACtB,CAAC,eAAe,aAAa,aAAa,SAAS,CAAA,GAAI,QAAA,EAEvD,gBAAe,aAAa,MAAM,GAAG,EAAA;EAExC;AAED,QAAM,gBACJ,iBAAiB,aAAa,CAAA,GAAI,QAAA,MAAc;AAClD,MAAI,YAAY,gBACZ,aAAa,MAAM,GAAG,CAAA,EAAG,OAAO,aAAa,MAAM,CAAA,EAAG,QAAA,CAAS,IAC/D,aAAa,QAAA;AAEjB,cAAY,MAAM,gBAAgB,WAAW;IAC3C,GAAG;IACH,iBAAiB,eAAe,SAAS;IACzC,OAAO;EACR,CAAA;AAED,MAAI,cACF,QAAO,CAAC,UAAU,CAAA,GAAI,GAAG,UAAU,MAAM,CAAA,EAAG,QAAA,CAAU;MAEtD,QAAO,UAAU,QAAA;AAEpB;AAED,IAAMC,iBAMF;EACF,OAAO;IACL,SAAS;IACT,cAAc;EACf;EACD,IAAI;IACF,SAAS;IACT,cAAc;EACf;EACD,QAAQ;IACN,SAAS;IACT,cAAc;EACf;EACD,WAAW;IACT,SAAS;IACT,cAAc;EACf;EACD,MAAM;IACJ,SAAS;IACT,cAAc;EACf;EACD,UAAU;IACR,SAAS;IACT,cAAc;EACf;EACD,SAAS;IACP,SAAS;IACT,cAAc;EACf;EACD,QAAQ;IACN,SAAS;IACT,cAAc;EACf;AACF;AAgBD,SAAS,qBACPC,aACAC,QACAC,aACgC;AAChC,MAAIC;AACJ,MAAIC;AAEJ,UAAQ,aAAR;IACE,KAAK;AACH,UAAI,YACF,SAAQ,IAAI,kBAAkB,MAAA;UAE9B,OAAM,IAAI,aAAa,MAAA;AAEzB;IACF,KAAK;AACH,UAAI,aAAa;AACf,YAAIC,gBAAsC,EACxC,GAAG,OACJ;AACD,YAAI,gBAAgB,cAClB,iBAAgB;UACd,GAAG;UACH,kBAAkB,cAAc,YAAY,IAAI,CAAC,QAAQ;YACvD,GAAG;YACH,MAAM;YACN,OAAO;YACP,MAAM,KAAK,UAAU,GAAG,IAAA;UACzB,EAAA;QACF;AAEH,gBAAQ,IAAI,eAAe,aAAA;MAC5B,MACC,OAAM,IAAI,UAAU,MAAA;AAEtB;IACF,KAAK;AACH,UAAI,YACF,SAAQ,IAAI,mBAAmB,MAAA;UAE/B,OAAM,IAAI,cAAc,MAAA;AAE1B;IACF,KAAK;AACH,UAAI,YACF,SAAQ,IAAI,mBAAmB;QAC7B,GAAG;QACH,mBAAmB;UACjB,GAAG,OAAO;UACV,iBAAiB;QAClB;MACF,CAAA;UAED,OAAM,IAAI,cAAc;QACtB,GAAG;QACH,mBAAmB;UACjB,GAAG,OAAO;UACV,iBAAiB;QAClB;MACF,CAAA;AAEH;IACF,KAAK;AACH,UAAI,kBAAkB,OACpB,KAAI,YACF,SAAQ,IAAI,iBAAiB,MAAA;UAE7B,OAAM,IAAI,YAAY,MAAA;UAGxB,OAAM,IAAI,MACR,yFAAA;AAGJ;IACF,KAAK;AACH,UAAI,YACF,SAAQ,IAAI,qBAAqB,MAAA;WAC5B;AACL,YAAI,CAAC,OAAO,KACV,OAAM,IAAI,MAAM,0CAAA;AAElB,cAAM,IAAI,gBAAgB,MAAA;MAC3B;AACD;IACF,KAAK;AACH,UAAI,UAAU,OACZ,KAAI,YACF,SAAQ,IAAI,iBAAiB,MAAA;UAE7B,OAAM,IAAI,YAAY,MAAA;UAGxB,OAAM,IAAI,MACR,iFAAA;AAGJ;IACF;AACE,YAAM,IAAI,MAAM,6BAA6B,WAAA,EAAa;EAC7D;AAED,MAAI,eAAe,MACjB,QAAO;AAET,MAAI,IACF,QAAO;AAET,QAAM,IAAI,MAAM,6BAA6B,WAAA,EAAa;AAC3D;AAED,SAAS,YAAYC,OAAsC;AACzD,QAAM,YAAY,MAAM,QAAA;AACxB,MAAIF;AACJ,QAAM,SAAS,OAAO,YACpB,OAAO,QAAQ,KAAA,EAAO,OACpB,CAAC,CAAC,CAAA,MAAO,CAAC,CAAC,QAAQ,kBAAmB,EAAC,SAAS,CAAA,KAAM,CAAC,EAAE,WAAW,KAAA,CAAM,CAC3E;AAGH,MAAI,aAAa,eACf,OAAM,qBAAqB,WAAW,MAAA;AAGxC,MAAI,CAAC,IACH,OAAM,IAAI,MACR,oCAAoC,SAAA,2BAAoC,OAAO,KAC7E,cAAA,CACD,EAAE;AAIP,SAAO;AACR;AAQD,SAAgB,oBAAoBT,MAAiC;AACnE,QAAM,SAAS,KAAK,MAAM,IAAA;AAC1B,SAAO,QAAQ,QAAQ,CACrB,GAAG,OAAO,MAAM,GAAG,EAAA,EAAI,IAAI,CAAC,MAAM,GAAG,CAAA;CAAK,GAC1C,OAAO,OAAO,SAAS,CAAA,CACxB,CAAA;AACF;;;AC1kCD,IAAa,oBAAoB;EAC/B;EACA;EACA;EACA;EACA;EACA;AACD;;;ACPD,IAAaY,qBAAoB;EAC/B;EACA;EACA;EACA;EACA;AACD;;;ACGD,IAAaC,sBAAoB;EAC/B;EACA;EACA,GAAGC;EACH,GAAGC;AACJ;;;ACDD,IAAI,mBAAmB,CAAC;AACxBC,UAAS,kBAAkB;AAAA,EAC1B,WAAW,MAAM;AAAA,EACjB,gBAAgB,MAAM;AAAA,EACtB,aAAa,MAAM;AAAA,EACnB,kBAAkB,MAAM;AAAA,EACxB,aAAa,MAAM;AAAA,EACnB,kBAAkB,MAAM;AAAA,EACxB,2BAA2B,MAAM;AAAA,EACjC,iBAAiB,MAAM;AAAA,EACvB,sBAAsB,MAAM;AAAA,EAC5B,cAAc,MAAM;AAAA,EACpB,mBAAmB,MAAM;AAAA,EACzB,mBAAmB,MAAM;AAAA,EACzB,eAAe,MAAM;AAAA,EACrB,eAAe,MAAM;AAAA,EACrB,oBAAoB,MAAM;AAAA,EAC1B,aAAa,MAAM;AAAA,EACnB,kBAAkB,MAAM;AAAA,EACxB,yBAAyB,MAAM;AAAA,EAC/B,aAAa,MAAM;AAAA,EACnB,aAAa,MAAM;AAAA,EACnB,WAAW,MAAM;AAAA,EACjB,cAAc,MAAM;AAAA,EACpB,4BAA4B,MAAM;AAAA,EAClC,wBAAwB,MAAM;AAAA,EAC9B,gBAAgB,MAAM;AAAA,EACtB,2BAA2B,MAAM;AAAA,EACjC,+BAA+B,MAAM;AAAA,EACrC,qBAAqB,MAAM;AAAA,EAC3B,uBAAuB,MAAM;AAAA,EAC7B,gBAAgB,MAAM;AAAA,EACtB,iBAAiB,MAAM;AAAA,EACvB,MAAM,MAAM;AAAA,EACZ,aAAa,MAAM;AAAA,EACnB,kBAAkB,MAAM;AAAA,EACxB,sBAAsB,MAAM;AAAA,EAC5B,eAAe,MAAM;AAAA,EACrB,oBAAoB,MAAM;AAAA,EAC1B,eAAe,MAAM;AAAA,EACrB,oBAAoB,MAAM;AAAA,EAC1B,oBAAoB,MAAM;AAAA,EAC1B,oBAAoB,MAAM;AAAA,EAC1B,mBAAmB,MAAM;AAAA,EACzB,wBAAwB,MAAM;AAAA,EAC9B,gBAAgB,MAAM;AAAA,EACtB,qBAAqB,MAAM;AAAA,EAC3B,kBAAkB,MAAM;AAAA,EACxB,WAAW,MAAM;AAAA,EACjB,uBAAuB,MAAM;AAAA,EAC7B,yBAAyB,MAAM;AAAA,EAC/B,iBAAiB,MAAM;AAAA,EACvB,sBAAsB,MAAM;AAAA,EAC5B,eAAe,MAAM;AAAA,EACrB,oBAAoB,MAAM;AAAA,EAC1B,mBAAmB,MAAM;AAAA,EACzB,iCAAiC,MAAM;AAAA,EACvC,+BAA+B,MAAM;AAAA,EACrC,iCAAiC,MAAM;AAAA,EACvC,cAAc,MAAM;AAAA,EACpB,kBAAkB,MAAM;AAAA,EACxB,uBAAuB,MAAM;AAAA,EAC7B,oBAAoB,MAAM;AAAA,EAC1B,oBAAoB,MAAM;AAAA,EAC1B,eAAe,MAAM;AAAA,EACrB,cAAc,MAAM;AACrB,CAAC;;;;;;;;;;AC7DD,IAAsB,kBAAtB,cACU,aAEV;AAIC;AAMD,IAAa,oBAAb,cACU,gBAEV;EACE,OAAO,UAAkB;AACvB,WAAO;EACR;EAED,eAAe,CAAC,kBAAkB,eAAgB;EAElD,kBAAkB;EAElB;EAEA,YAAYC,OAAe;AACzB,UAAM,EAAE,MAAO,CAAA;AACf,SAAK,QAAQ;EACd;EAED,WAAW;AACT,WAAO,KAAK;EACb;EAED,iBAAiB;AACf,WAAO,CAAC,IAAI,aAAa,KAAK,KAAA,CAAO;EACtC;AACF;AAaD,IAAa,kBAAb,cACU,gBAEV;EACE,eAAe,CAAC,kBAAkB,eAAgB;EAElD,kBAAkB;EAElB,OAAO,UAAU;AACf,WAAO;EACR;EAED;EAMA,YAAYC,QAA+C;AACzD,QAAI,MAAM,QAAQ,MAAA,EAEhB,UAAS,EAAE,UAAU,OAAQ;AAG/B,UAAM,MAAA;AACN,SAAK,WAAW,OAAO;EACxB;EAED,WAAW;AACT,WAAO,gBAAgB,KAAK,QAAA;EAC7B;EAED,iBAAiB;AACf,WAAO,KAAK;EACb;AACF;AAkBD,IAAa,mBAAb,cAAsC,gBAAgB;EACpD,eAAe,CAAC,kBAAkB,eAAgB;EAElD,kBAAkB;EAElB,OAAO,UAAU;AACf,WAAO;EACR;EAED;;EAGA;EAMA,YAAYC,QAA+C;AACzD,QAAI,EAAE,cAAc,QAElB,UAAS,EAAE,UAAU,OAAQ;AAG/B,UAAM,MAAA;AACN,SAAK,WAAW,OAAO;EACxB;EAED,WAAW;AACT,WAAO,KAAK,SAAS;EACtB;EAED,iBAAiB;AACf,WAAO,CACL,IAAI,aAAa,EACf,SAAS,CACP;MACE,MAAM;MACN,WAAW;QACT,QAAQ,KAAK,SAAS;QACtB,KAAK,KAAK,SAAS;MACpB;IACF,CACF,EACF,CAAA,CACF;EACF;AACF;;;AC/JD,IAAI,YAAY,mBAAmB,MAAM,EAAA;AACzC,IAAI,QAAQ;EAAC;EAAa;EAAS;EAAO;AAAI;AAC9C,IAAI,QAAQ;EAAC;EAAI;EAAI;EAAG;AAAE;AAC1B,IAAI,IAAI;EACN;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;EAAY;EAAY;EAC5D;EAAY;EAAY;EAAY;AACrC;AAGD,IAAI,SAAS,CAAE;AAEf,SAAS,OAAO,OAAO,cAAc;AACnC,MAAI,cAAc;AAChB,WAAO,CAAA,IACL,OAAO,EAAA,IACP,OAAO,CAAA,IACP,OAAO,CAAA,IACP,OAAO,CAAA,IACP,OAAO,CAAA,IACP,OAAO,CAAA,IACP,OAAO,CAAA,IACP,OAAO,CAAA,IACP,OAAO,CAAA,IACP,OAAO,CAAA,IACP,OAAO,EAAA,IACP,OAAO,EAAA,IACP,OAAO,EAAA,IACP,OAAO,EAAA,IACP,OAAO,EAAA,IACP,OAAO,EAAA,IACL;AACJ,SAAK,SAAS;EACf,MACC,MAAK,SAAS;IAAC;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;IAAG;EAAE;AAGnE,MAAI,OAAO;AACT,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;EACX,OAAM;AAEL,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;AACV,SAAK,KAAK;EACX;AAED,OAAK,QAAQ,KAAK,QAAQ,KAAK,QAAQ,KAAK,SAAS;AACrD,OAAK,YAAY,KAAK,SAAS;AAC/B,OAAK,QAAQ;AACb,OAAK,QAAQ;AACd;AAED,OAAO,UAAU,SAAS,SAAU,SAAS;AAC3C,MAAI,KAAK,UACP;AAEF,MAAI,WACF,OAAO,OAAO;AAChB,MAAI,SAAS,UAAU;AACrB,QAAI,SAAS,UACX;UAAI,YAAY,KACd,OAAM,IAAI,MAAM,KAAA;eACP,gBAAgB,QAAQ,gBAAgB,YACjD,WAAU,IAAI,WAAW,OAAA;eAChB,CAAC,MAAM,QAAQ,OAAA,GACxB;YAAI,CAAC,gBAAgB,CAAC,YAAY,OAAO,OAAA,EACvC,OAAM,IAAI,MAAM,KAAA;MACjB;IACF,MAED,OAAM,IAAI,MAAM,KAAA;AAElB,gBAAY;EACb;AACD,MAAI,MACFC,SAAQ,GACR,GACA,SAAS,QAAQ,QACjBC,WAAS,KAAK;AAChB,SAAOD,SAAQ,QAAQ;AACrB,QAAI,KAAK,QAAQ;AACf,WAAK,SAAS;AACdC,eAAO,CAAA,IAAK,KAAK;AACjB,WAAK,QACHA,SAAO,EAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACL;IACL;AAED,QAAI,UACF,MAAK,IAAI,KAAK,OAAOD,SAAQ,UAAU,IAAI,IAAI,EAAEA,OAC/CC,UAAO,MAAM,CAAA,KAAM,QAAQD,MAAA,KAAU,MAAM,MAAM,CAAA;QAGnD,MAAK,IAAI,KAAK,OAAOA,SAAQ,UAAU,IAAI,IAAI,EAAEA,QAAO;AACtD,aAAO,QAAQ,WAAWA,MAAA;AAC1B,UAAI,OAAO,IACTC,UAAO,MAAM,CAAA,KAAM,QAAQ,MAAM,MAAM,CAAA;eAC9B,OAAO,MAAO;AACvBA,iBAAO,MAAM,CAAA,MAAO,MAAQ,SAAS,MAAO,MAAM,MAAM,CAAA;AACxDA,iBAAO,MAAM,CAAA,MAAO,MAAQ,OAAO,OAAU,MAAM,MAAM,CAAA;MAC1D,WAAU,OAAO,SAAU,QAAQ,OAAQ;AAC1CA,iBAAO,MAAM,CAAA,MAAO,MAAQ,SAAS,OAAQ,MAAM,MAAM,CAAA;AACzDA,iBAAO,MAAM,CAAA,MAAO,MAAS,SAAS,IAAK,OAAU,MAAM,MAAM,CAAA;AACjEA,iBAAO,MAAM,CAAA,MAAO,MAAQ,OAAO,OAAU,MAAM,MAAM,CAAA;MAC1D,OAAM;AACL,eACE,UACG,OAAO,SAAU,KAAO,QAAQ,WAAW,EAAED,MAAA,IAAS;AAC3DC,iBAAO,MAAM,CAAA,MAAO,MAAQ,SAAS,OAAQ,MAAM,MAAM,CAAA;AACzDA,iBAAO,MAAM,CAAA,MAAO,MAAS,SAAS,KAAM,OAAU,MAAM,MAAM,CAAA;AAClEA,iBAAO,MAAM,CAAA,MAAO,MAAS,SAAS,IAAK,OAAU,MAAM,MAAM,CAAA;AACjEA,iBAAO,MAAM,CAAA,MAAO,MAAQ,OAAO,OAAU,MAAM,MAAM,CAAA;MAC1D;IACF;AAGH,SAAK,gBAAgB;AACrB,SAAK,SAAS,IAAI,KAAK;AACvB,QAAI,KAAK,IAAI;AACX,WAAK,QAAQA,SAAO,EAAA;AACpB,WAAK,QAAQ,IAAI;AACjB,WAAK,KAAA;AACL,WAAK,SAAS;IACf,MACC,MAAK,QAAQ;EAEhB;AACD,MAAI,KAAK,QAAQ,YAAY;AAC3B,SAAK,UAAW,KAAK,QAAQ,cAAe;AAC5C,SAAK,QAAQ,KAAK,QAAQ;EAC3B;AACD,SAAO;AACR;AAED,OAAO,UAAU,WAAW,WAAY;AACtC,MAAI,KAAK,UACP;AAEF,OAAK,YAAY;AACjB,MAAIA,WAAS,KAAK,QAChB,IAAI,KAAK;AACXA,WAAO,EAAA,IAAM,KAAK;AAClBA,WAAO,MAAM,CAAA,KAAM,MAAM,IAAI,CAAA;AAC7B,OAAK,QAAQA,SAAO,EAAA;AACpB,MAAI,KAAK,IAAI;AACX,QAAI,CAAC,KAAK,OACR,MAAK,KAAA;AAEPA,aAAO,CAAA,IAAK,KAAK;AACjBA,aAAO,EAAA,IACLA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,CAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACPA,SAAO,EAAA,IACL;EACL;AACDA,WAAO,EAAA,IAAO,KAAK,UAAU,IAAM,KAAK,UAAU;AAClDA,WAAO,EAAA,IAAM,KAAK,SAAS;AAC3B,OAAK,KAAA;AACN;AAED,OAAO,UAAU,OAAO,WAAY;AAClC,MAAI,IAAI,KAAK,IACX,IAAI,KAAK,IACT,IAAI,KAAK,IACT,IAAI,KAAK,IACT,IAAI,KAAK,IACT,IAAI,KAAK,IACT,IAAI,KAAK,IACT,IAAI,KAAK,IACTA,WAAS,KAAK,QACd,GACA,IACA,IACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA;AAEF,OAAK,IAAI,IAAI,IAAI,IAAI,EAAE,GAAG;AAExB,SAAKA,SAAO,IAAI,EAAA;AAChB,UAAO,OAAO,IAAM,MAAM,OAAS,OAAO,KAAO,MAAM,MAAQ,OAAO;AACtE,SAAKA,SAAO,IAAI,CAAA;AAChB,UAAO,OAAO,KAAO,MAAM,OAAS,OAAO,KAAO,MAAM,MAAQ,OAAO;AACvEA,aAAO,CAAA,IAAMA,SAAO,IAAI,EAAA,IAAM,KAAKA,SAAO,IAAI,CAAA,IAAK,MAAO;EAC3D;AAED,OAAK,IAAI;AACT,OAAK,IAAI,GAAG,IAAI,IAAI,KAAK,GAAG;AAC1B,QAAI,KAAK,OAAO;AACd,UAAI,KAAK,OAAO;AACd,aAAK;AACL,aAAKA,SAAO,CAAA,IAAK;AACjB,YAAK,KAAK,aAAc;AACxB,YAAK,KAAK,YAAa;MACxB,OAAM;AACL,aAAK;AACL,aAAKA,SAAO,CAAA,IAAK;AACjB,YAAK,KAAK,cAAe;AACzB,YAAK,KAAK,aAAc;MACzB;AACD,WAAK,QAAQ;IACd,OAAM;AACL,YACI,MAAM,IAAM,KAAK,OACjB,MAAM,KAAO,KAAK,OAClB,MAAM,KAAO,KAAK;AACtB,YACI,MAAM,IAAM,KAAK,OACjB,MAAM,KAAO,KAAK,OAClB,MAAM,KAAO,KAAK;AACtB,WAAK,IAAI;AACT,YAAM,KAAM,IAAI,IAAK;AACrB,WAAM,IAAI,IAAM,CAAC,IAAI;AACrB,WAAK,IAAI,KAAK,KAAK,EAAE,CAAA,IAAKA,SAAO,CAAA;AACjC,WAAK,KAAK;AACV,UAAK,IAAI,MAAO;AAChB,UAAK,KAAK,MAAO;IAClB;AACD,UACI,MAAM,IAAM,KAAK,OACjB,MAAM,KAAO,KAAK,OAClB,MAAM,KAAO,KAAK;AACtB,UACI,MAAM,IAAM,KAAK,OACjB,MAAM,KAAO,KAAK,OAClB,MAAM,KAAO,KAAK;AACtB,SAAK,IAAI;AACT,UAAM,KAAM,IAAI,IAAK;AACrB,SAAM,IAAI,IAAM,CAAC,IAAI;AACrB,SAAK,IAAI,KAAK,KAAK,EAAE,IAAI,CAAA,IAAKA,SAAO,IAAI,CAAA;AACzC,SAAK,KAAK;AACV,QAAK,IAAI,MAAO;AAChB,QAAK,KAAK,MAAO;AACjB,UACI,MAAM,IAAM,KAAK,OACjB,MAAM,KAAO,KAAK,OAClB,MAAM,KAAO,KAAK;AACtB,UACI,MAAM,IAAM,KAAK,OACjB,MAAM,KAAO,KAAK,OAClB,MAAM,KAAO,KAAK;AACtB,SAAK,IAAI;AACT,UAAM,KAAM,IAAI,IAAK;AACrB,SAAM,IAAI,IAAM,CAAC,IAAI;AACrB,SAAK,IAAI,KAAK,KAAK,EAAE,IAAI,CAAA,IAAKA,SAAO,IAAI,CAAA;AACzC,SAAK,KAAK;AACV,QAAK,IAAI,MAAO;AAChB,QAAK,KAAK,MAAO;AACjB,UACI,MAAM,IAAM,KAAK,OACjB,MAAM,KAAO,KAAK,OAClB,MAAM,KAAO,KAAK;AACtB,UACI,MAAM,IAAM,KAAK,OACjB,MAAM,KAAO,KAAK,OAClB,MAAM,KAAO,KAAK;AACtB,SAAK,IAAI;AACT,UAAM,KAAM,IAAI,IAAK;AACrB,SAAM,IAAI,IAAM,CAAC,IAAI;AACrB,SAAK,IAAI,KAAK,KAAK,EAAE,IAAI,CAAA,IAAKA,SAAO,IAAI,CAAA;AACzC,SAAK,KAAK;AACV,QAAK,IAAI,MAAO;AAChB,QAAK,KAAK,MAAO;AACjB,SAAK,sBAAsB;EAC5B;AAED,OAAK,KAAM,KAAK,KAAK,KAAM;AAC3B,OAAK,KAAM,KAAK,KAAK,KAAM;AAC3B,OAAK,KAAM,KAAK,KAAK,KAAM;AAC3B,OAAK,KAAM,KAAK,KAAK,KAAM;AAC3B,OAAK,KAAM,KAAK,KAAK,KAAM;AAC3B,OAAK,KAAM,KAAK,KAAK,KAAM;AAC3B,OAAK,KAAM,KAAK,KAAK,KAAM;AAC3B,OAAK,KAAM,KAAK,KAAK,KAAM;AAC5B;AAED,OAAO,UAAU,MAAM,WAAY;AACjC,OAAK,SAAA;AAEL,MAAI,KAAK,KAAK,IACZ,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK;AAEZ,MAAIC,OACF,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAU,KAAK,EAAA,IACf,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAU,KAAK,EAAA,IACf,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAU,KAAK,EAAA,IACf,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAU,KAAK,EAAA,IACf,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAU,KAAK,EAAA,IACf,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAU,KAAK,EAAA,IACf,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAU,KAAK,EAAA;AACjB,MAAI,CAAC,KAAK,MACR,CAAAA,QACE,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,KAAM,EAAA,IACxB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAW,OAAO,IAAK,EAAA,IACvB,UAAU,KAAK,EAAA;AAEnB,SAAOA;AACR;AAED,OAAO,UAAU,WAAW,OAAO,UAAU;AAE7C,OAAO,UAAU,SAAS,WAAY;AACpC,OAAK,SAAA;AAEL,MAAI,KAAK,KAAK,IACZ,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK,IACV,KAAK,KAAK;AAEZ,MAAIC,OAAM;IACP,OAAO,KAAM;IACb,OAAO,KAAM;IACb,OAAO,IAAK;IACb,KAAK;IACJ,OAAO,KAAM;IACb,OAAO,KAAM;IACb,OAAO,IAAK;IACb,KAAK;IACJ,OAAO,KAAM;IACb,OAAO,KAAM;IACb,OAAO,IAAK;IACb,KAAK;IACJ,OAAO,KAAM;IACb,OAAO,KAAM;IACb,OAAO,IAAK;IACb,KAAK;IACJ,OAAO,KAAM;IACb,OAAO,KAAM;IACb,OAAO,IAAK;IACb,KAAK;IACJ,OAAO,KAAM;IACb,OAAO,KAAM;IACb,OAAO,IAAK;IACb,KAAK;IACJ,OAAO,KAAM;IACb,OAAO,KAAM;IACb,OAAO,IAAK;IACb,KAAK;EACN;AACD,MAAI,CAAC,KAAK,MACR,CAAAA,KAAI,KACD,OAAO,KAAM,KACb,OAAO,KAAM,KACb,OAAO,IAAK,KACb,KAAK,GAAA;AAGT,SAAOA;AACR;AAED,OAAO,UAAU,QAAQ,OAAO,UAAU;AAE1C,OAAO,UAAU,cAAc,WAAY;AACzC,OAAK,SAAA;AAEL,MAAI,SAAS,IAAI,YAAY,KAAK,QAAQ,KAAK,EAAA;AAC/C,MAAI,WAAW,IAAI,SAAS,MAAA;AAC5B,WAAS,UAAU,GAAG,KAAK,EAAA;AAC3B,WAAS,UAAU,GAAG,KAAK,EAAA;AAC3B,WAAS,UAAU,GAAG,KAAK,EAAA;AAC3B,WAAS,UAAU,IAAI,KAAK,EAAA;AAC5B,WAAS,UAAU,IAAI,KAAK,EAAA;AAC5B,WAAS,UAAU,IAAI,KAAK,EAAA;AAC5B,WAAS,UAAU,IAAI,KAAK,EAAA;AAC5B,MAAI,CAAC,KAAK,MACR,UAAS,UAAU,IAAI,KAAK,EAAA;AAE9B,SAAO;AACR;AAED,IAAa,SAAS,IAAI,YAAsB;AAC9C,SAAO,IAAI,OAAO,OAAO,IAAA,EAAM,OAAO,QAAQ,KAAK,EAAA,CAAG,EAAE,IAAA;AACzD;;;ACnfD,IAAI,eAAe,CAAC;AACpBC,UAAS,cAAc,EAAE,QAAQ,MAAM,OAAO,CAAC;;;;;;;;;;;ACA/C,IAAaC,wBAAwC,IAAI,YACvD,OAAO,QAAQ,KAAK,GAAA,CAAI;AAE1B,SAAgB,4BACdC,kBACA;AACA,MAAI,iBAAiB,YAAY,OAC/B,QAAO;IACL,MAAM,iBAAiB;IACvB,SAAS,8BAA8B,iBAAiB,OAAA;EACzD;MAED,QAAO,EAAE,MAAM,iBAAiB,KAAM;AAEzC;AAED,SAAgB,oBAAoBC,YAAwB;AAC1D,QAAMC,kBAAoC,EACxC,MAAM,WAAW,KAClB;AACD,MAAK,WAA8B,YAAY,OAC7C,iBAAgB,UAAW,WAA8B,QAAQ,OAAA;AAEnE,SAAO;AACR;AAKD,IAAsB,YAAtB,MAAkD;EACtC,aAA6B;;;;;;;EAQvC,sBAAsBC,cAAoC;AACxD,SAAK,aAAa;EACnB;AAKF;AAED,IAAM,aAAa,oBAAI,IAAA;AAKvB,IAAa,gBAAb,MAAaC,uBAAwC,UAAa;EACxD;EAER,YAAYC,MAAsB;AAChC,UAAA;AACA,SAAK,QAAQC,QAAO,oBAAI,IAAA;EACzB;;;;;;;;EASD,OAAOC,QAAgBC,QAAmC;AACxD,WAAO,QAAQ,QACb,KAAK,MAAM,IAAI,KAAK,WAAW,QAAQ,MAAA,CAAO,KAAK,IAAA;EAEtD;;;;;;;EAQD,MAAM,OAAOD,QAAgBC,QAAgBC,OAAyB;AACpE,SAAK,MAAM,IAAI,KAAK,WAAW,QAAQ,MAAA,GAAS,KAAA;EACjD;;;;;;EAOD,OAAO,SAAwB;AAC7B,WAAO,IAAIL,eAAc,UAAA;EAC1B;AACF;;;;;;;;;;;;;AChED,IAAa,0BAA0B,CAACM,cAAqC;AAC3E,MAAI,UAAU,WAAW,OAAA,EACvB,QAAO;AAGT,MAAI,UAAU,WAAW,mBAAA,EACvB,QAAO;AAGT,MAAI,UAAU,WAAW,gBAAA,EACvB,QAAO;AAGT,MAAI,UAAU,WAAW,WAAA,EACvB,QAAO;AAGT,MAAI,UAAU,WAAW,QAAA,EACvB,QAAO;AAGT,MAAI,UAAU,WAAW,QAAA,EACvB,QAAO;AAGT,SAAO;AACR;AAED,IAAa,0BAA0B,CAACC,cAA+B;AACrE,UAAQ,WAAR;IACE,KAAK;AACH,aAAO;IACT;AACE,aAAO;EACV;AACF;AAaD,IAAa,sBAAsB,CAACD,cAA8B;AAChE,QAAM,iBAAiB,wBAAwB,SAAA;AAE/C,UAAQ,gBAAR;IAEE,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IAGT,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IAGT,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IAGT,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IACT,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IAGT,KAAK;IACL,KAAK;AACH,aAAO;IACT,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IAGT,KAAK;IACL,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAO;IACT,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IAGT,KAAK;IACL,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAO;IAGT,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IACT,KAAK;IACL,KAAK;AACH,aAAO;IAGT,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IACT,KAAK;IACL,KAAK;AACH,aAAO;IAET;AACE,aAAO;EACV;AACF;AAOD,SAAgB,aAAaE,OAAuC;AAClE,MAAI,OAAOC,UAAS,YAAY,CAACA,MAAM,QAAO;AAC9C,MACE,UAAUA,SACVA,MAAK,SAAS,cACd,cAAcA,SACd,OAAOA,MAAK,aAAa,YACzBA,MAAK,YACL,UAAUA,MAAK,YACf,gBAAgBA,MAAK,SAErB,QAAO;AAET,SAAO;AACR;AAOD,IAAa,qBAAqB,OAAO,EACvC,QACA,UAAA,MAC4B;AAC5B,MAAI;AAEJ,MAAI;AACF,iBACE,MAAM,iBAAiB,wBAAwB,SAAA,CAAU,GACzD,OAAO,MAAA,EAAQ;EAClB,QAAO;AACN,YAAQ,KACN,yEAAA;AAKF,gBAAY,KAAK,KAAK,OAAO,SAAS,CAAA;EACvC;AAED,QAAM,YAAY,oBAAoB,SAAA;AACtC,SAAO,YAAY;AACpB;AAED,IAAM,eAAe,MAAM;AAkB3B,IAAsB,gBAAtB,cAKU,SAEV;;;;EAIE;EAEA;EAEA;EAEA;EAEA,IAAI,gBAA0D;AAC5D,WAAO;MACL,WAAW;MACX,SAAS;IACV;EACF;EAED,YAAYC,QAA6B;AACvC,UAAM,MAAA;AACN,SAAK,UAAU,OAAO,WAAW,aAAA;AACjC,SAAK,YAAY,OAAO;AACxB,SAAK,OAAO,OAAO,QAAQ,CAAE;AAC7B,SAAK,WAAW,OAAO,YAAY,CAAE;EACtC;AACF;AAyJD,IAAsB,oBAAtB,cAMU,cAIV;;;;EAIE,IAAI,WAAqB;AACvB,WAAO;MAAC;MAAQ;MAAW;MAAU;MAAQ;MAAY;IAAY;EACtE;;;;;EAMD;EAEA;EAEA,YAAY,EACV,WACA,iBACA,GAAG,OAAA,GACuB;AAC1B,UAAM,EAAE,OAAO,GAAG,KAAA,IAAS;AAC3B,UAAM;MACJ,WAAW,aAAa;MACxB,GAAG;IACJ,CAAA;AACD,QAAI,OAAO,UAAU,SACnB,MAAK,QAAQ;aACJ,MACT,MAAK,QAAQ,cAAc,OAAA;QAE3B,MAAK,QAAQ;AAEf,SAAK,SAAS,IAAI,YAAY,UAAU,CAAE,CAAA;EAC3C;EAYO;;;;;;EAOR,MAAM,aAAaC,SAAyB;AAE1C,QAAIC;AACJ,QAAI,OAAO,YAAY,SACrB,eAAc;;AASd,oBAAc,QACX,IAAI,CAAC,SAAS;AACb,YAAI,OAAO,SAAS,SAAU,QAAO;AACrC,YAAI,KAAK,SAAS,UAAU,UAAU,KAAM,QAAO,KAAK;AACxD,eAAO;MACR,CAAA,EACA,KAAK,EAAA;AAIV,QAAI,YAAY,KAAK,KAAK,YAAY,SAAS,CAAA;AAE/C,QAAI,CAAC,KAAK,UACR,KAAI;AACF,WAAK,YAAY,MAAM,iBACrB,eAAe,OACX,wBAAwB,KAAK,SAAA,IAC7B,MAAA;IAEP,SAAQ,OAAO;AACd,cAAQ,KACN,2EACA,KAAA;IAEH;AAGH,QAAI,KAAK,UACP,KAAI;AACF,kBAAY,KAAK,UAAU,OAAO,WAAA,EAAa;IAChD,SAAQ,OAAO;AACd,cAAQ,KACN,2EACA,KAAA;IAEH;AAGH,WAAO;EACR;EAED,OAAiB,2BACfC,OAC0B;AAC1B,QAAI,OAAO,UAAU,SACnB,QAAO,IAAI,kBAAkB,KAAA;aACpB,MAAM,QAAQ,KAAA,EACvB,QAAO,IAAI,gBAAgB,MAAM,IAAI,0BAAA,CAA2B;QAEhE,QAAO;EAEV;;;;EAMD,qBAA0C;AACxC,WAAO,CAAE;EACV;;;;;;EAOD,wCAEE,EAAE,QAAAC,SAAQ,GAAG,YAAA,GACL;AAER,UAAMC,SAA8B;MAClC,GAAG,KAAK,mBAAA;MACR,GAAG;MACH,OAAO,KAAK,SAAA;MACZ,QAAQ,KAAK,WAAA;IACd;AACD,UAAM,kBAAkB,OAAO,QAAQ,MAAA,EAAQ,OAC7C,CAAC,CAAC,GAAG,KAAA,MAAW,UAAU,MAAA;AAE5B,UAAM,oBAAoB,gBACvB,IAAI,CAAC,CAAC,KAAK,KAAA,MAAW,GAAG,GAAA,IAAO,KAAK,UAAU,KAAA,CAAM,EAAE,EACvD,KAAA,EACA,KAAK,GAAA;AACR,WAAO;EACR;;;;;EAMD,YAA2B;AACzB,WAAO;MACL,GAAG,KAAK,mBAAA;MACR,OAAO,KAAK,SAAA;MACZ,QAAQ,KAAK,WAAA;IACd;EACF;;;;;EAMD,aAAa,YAAYC,OAAkD;AACzE,UAAM,IAAI,MAAM,uBAAA;EACjB;;;;;;EAOD,IAAI,UAAwB;AAC1B,WAAO,CAAE;EACV;AA6EF;;;ACzoBD,IAAa,sBAAb,cAAyD,SAGvD;EACA,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe,CAAC,kBAAkB,WAAY;EAE9C,kBAAkB;EAElB;EAEA,YAAYC,QAAuD;AACjE,UAAM,MAAA;AACN,QAAI,OACF,MAAK,OAAO,OAAO;EAEtB;EAED,MAAM,OACJC,OACAC,SACmB;AACnB,UAAMC,UAAS,aAAa,OAAA;AAC5B,QAAI,KAAK,KACP,OAAM,KAAK,KAAK,OAAOA,OAAA;AAGzB,WAAO,KAAK,gBACV,CAACF,YAAoB,QAAQ,QAAQG,OAAAA,GACrC,OACAD,OAAA;EAEH;EAED,OAAO,UACLE,WACAC,SAC0B;AAC1B,UAAMH,UAAS,aAAa,OAAA;AAC5B,QAAII;AACJ,QAAI,uBAAuB;AAE3B,qBAAiB,SAAS,KAAK,2BAC7B,WACA,CAACC,UAAoC,OACrCL,OAAA,GACC;AACD,YAAM;AACN,UAAI,qBACF,KAAI,gBAAgB,OAClB,eAAc;UAEd,KAAI;AAEF,sBAAc,OAAO,aAAa,KAAA;MACnC,QAAO;AACN,sBAAc;AACd,+BAAuB;MACxB;IAGN;AAED,QAAI,KAAK,QAAQ,gBAAgB,OAC/B,OAAM,KAAK,KAAK,aAAaA,OAAA;EAEhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8BD,OAAO,OAILM,SACgD;AAChD,WAAO,IAAI,eAAe,IAAI,YAAY,EAAE,OAAO,QAAS,CAAA,CAAA;EAC7D;AACF;;;AClJD,IAAaC,QAAO,CAAIC,OAAmB,GAAA;AAE3C,SAAS,2BAAkDC,SAAY;AACrE,QAAM,MAAM,QAAQ;AACpB,SAAO,IAAI,IAAI;IACb,GAAG;IACH,SAAS,QAAQ;IACjB,mBAAmB;MACjB,GAAG,QAAQ;MACX,gBAAgB;IACjB;EACF,CAAA;AACF;;;;;;;;AC4ID,SAAS,kBAAkBC,UAAwC;AACjE,QAAMC,kBAAiC,CAAE;AACzC,aAAW,WAAW,UAAU;AAC9B,QAAI,iBAAiB;AACrB,QAAI,MAAM,QAAQ,QAAQ,OAAA,EACxB,UAAS,MAAM,GAAG,MAAM,QAAQ,QAAQ,QAAQ,OAAO;AACrD,YAAM,QAAQ,QAAQ,QAAQ,GAAA;AAC9B,UAAI,kBAAkB,KAAA,KAAU,qBAAqB,KAAA,GACnD;YAAI,mBAAmB,QAGrB,kBAAiB,IAAK,QAAQ,YAAoB;UAChD,GAAG;UACH,SAAS;YACP,GAAG,QAAQ,QAAQ,MAAM,GAAG,GAAA;YAC5B,0BAA0B,KAAA;YAC1B,GAAG,QAAQ,QAAQ,MAAM,MAAM,CAAA;UAChC;QACF,CAAA;MACF;IAEJ;AAEH,oBAAgB,KAAK,cAAA;EACtB;AACD,SAAO;AACR;AAuBD,IAAsB,gBAAtB,MAAsBC,uBAIZ,kBAAkD;EAQ1D,eAAe;IAAC;IAAa;IAAe,KAAK,SAAA;EAAW;EAE5D,mBAAmB;EAEnB;EAEA,IAAI,WAAqB;AACvB,WAAO,CAAC,GAAG,MAAM,UAAU,eAAgB;EAC5C;EAED,YAAYC,QAA6B;AACvC,UAAM,MAAA;AACN,SAAK,gBAAgBC,MAAK,MAAM;AAC9B,YAAM,gBACJ,OAAO,iBAAiB,uBAAuB,mBAAA;AACjD,UAAI,iBAAiB,CAAC,MAAM,IAAK,EAAC,SAAS,aAAA,EACzC,QAAO;AAET,aAAO;IACR,CAAA;EACF;EAMS,6CACRC,SAC6C;AAE7C,UAAM,CAAC,gBAAgB,WAAA,IACrB,MAAM,uCAAuC,OAAA;AAC9C,gBAA0C,SAAS,eAAe;AACnE,WAAO,CAAC,gBAAgB,WAAyC;EAClE;;;;;;;EAqBD,MAAM,OACJC,OACAC,SAC4B;AAC5B,UAAM,cAAcL,eAAc,2BAA2B,KAAA;AAC7D,UAAM,SAAS,MAAM,KAAK,eACxB,CAAC,WAAY,GACb,SACA,SAAS,SAAA;AAEX,UAAM,iBAAiB,OAAO,YAAY,CAAA,EAAG,CAAA;AAE7C,WAAO,eAAe;EACvB;EAGD,OAAO,sBACLM,WACAC,UACAC,aACqC;AACrC,UAAM,IAAI,MAAM,kBAAA;EACjB;EAED,OAAO,gBACLJ,OACAC,SACmC;AAEnC,QACE,KAAK,0BACHL,eAAc,UAAU,yBAC1B,KAAK,iBAEL,OAAM,KAAK,OAAO,OAAO,OAAA;SACpB;AACL,YAAM,SAASA,eAAc,2BAA2B,KAAA;AACxD,YAAM,WAAW,OAAO,eAAA;AACxB,YAAM,CAAC,gBAAgB,WAAA,IACrB,KAAK,6CAA6C,OAAA;AAEpD,YAAM,sBAAsB;QAC1B,GAAG,eAAe;QAClB,GAAG,KAAK,YAAY,WAAA;MACrB;AACD,YAAM,mBAAmB,MAAM,gBAAgB,UAC7C,eAAe,WACf,KAAK,WACL,eAAe,MACf,KAAK,MACL,qBACA,KAAK,UACL,EAAE,SAAS,KAAK,QAAS,CAAA;AAE3B,YAAM,QAAQ;QACZ,SAAS;QACT,mBAAmB,MAAM,iBAAiB,WAAA;QAC1C,YAAY;MACb;AACD,YAAM,gBAAgB,YAAY,iBAAiB,KAAK;AACxD,YAAM,cAAc,MAAM,kBAAkB,qBAC1C,KAAK,OAAA,GACL,CAAC,kBAAkB,QAAA,CAAU,GAC7B,eAAe,OACf,QACA,OACA,QACA,QACA,eAAe,OAAA;AAEjB,UAAIS;AAEJ,UAAIC;AACJ,UAAI;AACF,yBAAiB,SAAS,KAAK,sBAC7B,UACA,aACA,cAAc,CAAA,CAAA,GACb;AACD,cAAI,MAAM,QAAQ,MAAM,MAAM;AAC5B,kBAAM,QAAQ,aAAa,GAAG,CAAA,GAAI;AAClC,gBAAI,SAAS,KAAM,OAAM,QAAQ,UAAU,OAAO,KAAA,EAAO;UAC1D;AACD,gBAAM,QAAQ,oBAAoB;YAChC,GAAG,MAAM;YACT,GAAG,MAAM,QAAQ;UAClB;AACD,cAAI,kBAAkB,KACpB,OAAM,2BACJ,MAAM,OAAA;cAGR,OAAM,MAAM;AAEd,cAAI,CAAC,gBACH,mBAAkB;cAElB,mBAAkB,gBAAgB,OAAO,KAAA;AAE3C,cACE,iBAAiB,MAAM,OAAA,KACvB,MAAM,QAAQ,mBAAmB,OAEjC,aAAY,EACV,YAAY;YACV,cAAc,MAAM,QAAQ,eAAe;YAC3C,kBAAkB,MAAM,QAAQ,eAAe;YAC/C,aAAa,MAAM,QAAQ,eAAe;UAC3C,EACF;QAEJ;MACF,SAAQ,KAAK;AACZ,cAAM,QAAQ,KACX,eAAe,CAAE,GAAE,IAAI,CAAC,eACvB,YAAY,eAAe,GAAA,CAAI,CAChC;AAEH,cAAM;MACP;AACD,YAAM,QAAQ,KACX,eAAe,CAAE,GAAE,IAAI,CAAC,eACvB,YAAY,aAAa;QAEvB,aAAa,CAAC,CAAC,eAAkC,CAAC;QAClD;MACD,CAAA,CAAC,CACH;IAEJ;EACF;EAED,YAAYC,SAAqD;AAC/D,UAAM,eAAe,KAAK,QAAA,EAAU,WAAW,MAAA,IAC3C,KAAK,QAAA,EAAU,QAAQ,QAAQ,EAAA,IAC/B,KAAK,QAAA;AAET,WAAO;MACL,eAAe;MACf,SAAS,QAAQ;MACjB,aAAa;IACd;EACF;;EAGD,MAAM,kBACJC,UACAC,eACAC,gBACAC,oBACoB;AACpB,UAAM,eAAe,SAAS,IAAI,CAAC,gBACjC,YAAY,IAAI,0BAAA,CAA2B;AAG7C,QAAIC;AACJ,QACE,uBAAuB,UACvB,mBAAmB,WAAW,aAAa,OAE3C,eAAc;SACT;AACL,YAAM,sBAAsB;QAC1B,GAAG,eAAe;QAClB,GAAG,KAAK,YAAY,aAAA;MACrB;AAED,YAAM,mBAAmB,MAAM,gBAAgB,UAC7C,eAAe,WACf,KAAK,WACL,eAAe,MACf,KAAK,MACL,qBACA,KAAK,UACL,EAAE,SAAS,KAAK,QAAS,CAAA;AAE3B,YAAM,QAAQ;QACZ,SAAS;QACT,mBAAmB,MAAM,iBAAiB,aAAA;QAC1C,YAAY;MACb;AACD,oBAAc,MAAM,kBAAkB,qBACpC,KAAK,OAAA,GACL,aAAa,IAAI,iBAAA,GACjB,eAAe,OACf,QACA,OACA,QACA,QACA,eAAe,OAAA;IAElB;AACD,UAAM,gBAAgB,cAAc,iBAAiB,KAAK;AAC1D,UAAMC,cAAkC,CAAE;AAC1C,UAAMC,aAAuC,CAAE;AAI/C,UAAM,sBAAsB,CAAC,CAAC,cAAc,CAAA,EAAG,SAAS,KACtD,+BAAA;AAEF,QACE,uBACA,CAAC,KAAK,oBACN,aAAa,WAAW,KACxB,KAAK,0BACHlB,eAAc,UAAU,sBAE1B,KAAI;AACF,YAAM,SAAS,MAAM,KAAK,sBACxB,aAAa,CAAA,GACb,eACA,cAAc,CAAA,CAAA;AAEhB,UAAI;AAEJ,UAAIU;AACJ,uBAAiB,SAAS,QAAQ;AAChC,YAAI,MAAM,QAAQ,MAAM,MAAM;AAC5B,gBAAM,QAAQ,aAAa,GAAG,CAAA,GAAI;AAClC,cAAI,SAAS,KAAM,OAAM,QAAQ,UAAU,OAAO,KAAA,EAAO;QAC1D;AACD,YAAI,eAAe,OACjB,cAAa;YAEb,cAAa,OAAO,YAAY,KAAA;AAElC,YACE,iBAAiB,MAAM,OAAA,KACvB,MAAM,QAAQ,mBAAmB,OAEjC,aAAY,EACV,YAAY;UACV,cAAc,MAAM,QAAQ,eAAe;UAC3C,kBAAkB,MAAM,QAAQ,eAAe;UAC/C,aAAa,MAAM,QAAQ,eAAe;QAC3C,EACF;MAEJ;AACD,UAAI,eAAe,OACjB,OAAM,IAAI,MAAM,+CAAA;AAElB,kBAAY,KAAK,CAAC,UAAW,CAAA;AAC7B,YAAM,cAAc,CAAA,EAAG,aAAa;QAClC;QACA;MACD,CAAA;IACF,SAAQ,GAAG;AACV,YAAM,cAAc,CAAA,EAAG,eAAe,CAAA;AACtC,YAAM;IACP;SACI;AAEL,YAAM,UAAU,MAAM,QAAQ,WAC5B,aAAa,IAAI,OAAO,aAAa,MAAM;AACzC,cAAM,kBAAkB,MAAM,KAAK,UACjC,aACA;UAAE,GAAG;UAAe,aAAa;QAAG,GACpC,cAAc,CAAA,CAAA;AAEhB,YAAI,kBAAkB,KACpB,YAAW,cAAc,gBAAgB,YACvC,YAAW,UAAU,2BACnB,WAAW,OAAA;AAIjB,eAAO;MACR,CAAA,CAAC;AAGJ,YAAM,QAAQ,IACZ,QAAQ,IAAI,OAAO,SAAS,MAAM;AAChC,YAAI,QAAQ,WAAW,aAAa;AAClC,gBAAM,SAAS,QAAQ;AACvB,qBAAW,cAAc,OAAO,aAAa;AAC3C,gBAAI,WAAW,QAAQ,MAAM,MAAM;AACjC,oBAAM,QAAQ,aAAa,GAAG,CAAA,GAAI;AAClC,kBAAI,SAAS,KAAM,YAAW,QAAQ,UAAU,OAAO,KAAA,EAAO;YAC/D;AACD,uBAAW,QAAQ,oBAAoB;cACrC,GAAG,WAAW;cACd,GAAG,WAAW,QAAQ;YACvB;UACF;AACD,cAAI,OAAO,YAAY,WAAW,EAChC,QAAO,YAAY,CAAA,EAAG,QAAQ,oBAAoB;YAChD,GAAG,OAAO;YACV,GAAG,OAAO,YAAY,CAAA,EAAG,QAAQ;UAClC;AAEH,sBAAY,CAAA,IAAK,OAAO;AACxB,qBAAW,CAAA,IAAK,OAAO;AACvB,iBAAO,cAAc,CAAA,GAAI,aAAa;YACpC,aAAa,CAAC,OAAO,WAAY;YACjC,WAAW,OAAO;UACnB,CAAA;QACF,OAAM;AAEL,gBAAM,cAAc,CAAA,GAAI,eAAe,QAAQ,MAAA;AAC/C,iBAAO,QAAQ,OAAO,QAAQ,MAAA;QAC/B;MACF,CAAA,CAAC;IAEL;AAED,UAAMS,SAAoB;MACxB;MACA,WAAW,WAAW,SAClB,KAAK,oBAAoB,GAAG,UAAA,IAC5B;IACL;AACD,WAAO,eAAe,QAAQ,SAAS;MACrC,OAAO,cACH,EAAE,QAAQ,aAAa,IAAI,CAAC,YAAY,QAAQ,KAAA,EAAQ,IACxD;MACJ,cAAc;IACf,CAAA;AACD,WAAO;EACR;EAED,MAAM,gBAAgB,EACpB,UACA,OACA,cACA,eACA,eAAA,GAaA;AACA,UAAM,eAAe,SAAS,IAAI,CAAC,gBACjC,YAAY,IAAI,0BAAA,CAA2B;AAG7C,UAAM,sBAAsB;MAC1B,GAAG,eAAe;MAClB,GAAG,KAAK,YAAY,aAAA;IACrB;AAED,UAAM,mBAAmB,MAAM,gBAAgB,UAC7C,eAAe,WACf,KAAK,WACL,eAAe,MACf,KAAK,MACL,qBACA,KAAK,UACL,EAAE,SAAS,KAAK,QAAS,CAAA;AAE3B,UAAM,QAAQ;MACZ,SAAS;MACT,mBAAmB,MAAM,iBAAiB,aAAA;MAC1C,YAAY;IACb;AACD,UAAM,cAAc,MAAM,kBAAkB,qBAC1C,KAAK,OAAA,GACL,aAAa,IAAI,iBAAA,GACjB,eAAe,OACf,QACA,OACA,QACA,QACA,eAAe,OAAA;AAIjB,UAAMC,uBAAiC,CAAE;AACzC,UAAM,UAAU,MAAM,QAAQ,WAC5B,aAAa,IAAI,OAAO,aAAaC,WAAU;AAE7C,YAAM,SACJrB,eAAc,2BAA2B,WAAA,EAAa,SAAA;AACxD,YAAM,SAAS,MAAM,MAAM,OAAO,QAAQ,YAAA;AAE1C,UAAI,UAAU,KACZ,sBAAqB,KAAKqB,MAAA;AAG5B,aAAO;IACR,CAAA,CAAC;AAKJ,UAAM,gBAAgB,QACnB,IAAI,CAAC,QAAQA,YAAW;MAAE;MAAQ,YAAY,cAAcA,MAAA;IAAQ,EAAA,EACpE,OACC,CAAC,EAAE,OAAA,MACA,OAAO,WAAW,eAAe,OAAO,SAAS,QAClD,OAAO,WAAW,UAAA;AAIxB,UAAM,gBAAgB,cAAc,iBAAiB,KAAK;AAC1D,UAAMC,cAA8B,CAAE;AACtC,UAAM,QAAQ,IACZ,cAAc,IAAI,OAAO,EAAE,QAAQ,eAAe,WAAA,GAAc,MAAM;AACpE,UAAI,cAAc,WAAW,aAAa;AACxC,cAAM,SAAS,cAAc;AAC7B,oBAAY,CAAA,IAAK,OAAO,IAAI,CAACC,aAAW;AACtC,cACE,aAAaA,YACb,cAAcA,SAAO,OAAA,KACrB,YAAYA,SAAO,OAAA,GACnB;AACAA,qBAAO,QAAQ,iBAAiB;cAC9B,cAAc;cACd,eAAe;cACf,cAAc;YACf;AACD,gBAAI,kBAAkB,KACpBA,UAAO,UAAU,2BAA2BA,SAAO,OAAA;UAEtD;AACDA,mBAAO,iBAAiB;YACtB,GAAGA,SAAO;YACV,YAAY,CAAE;UACf;AACD,iBAAOA;QACR,CAAA;AACD,YAAI,OAAO,OACT,OAAM,YAAY,kBAAkB,OAAO,CAAA,EAAG,IAAA;AAEhD,eAAO,YAAY,aACjB,EACE,aAAa,CAAC,MAAO,EACtB,GACD,QACA,QACA,QACA,EACE,QAAQ,KACT,CAAA;MAEJ,OAAM;AAEL,cAAM,YAAY,eAChB,cAAc,QACd,QACA,QACA,QACA,EACE,QAAQ,KACT,CAAA;AAEH,eAAO,QAAQ,OAAO,cAAc,MAAA;MACrC;IACF,CAAA,CAAC;AAGJ,UAAM,SAAS;MACb;MACA;MACA,oBAAoB;IACrB;AAKD,WAAO,eAAe,QAAQ,SAAS;MACrC,OAAO,cACH,EAAE,QAAQ,aAAa,IAAI,CAAC,YAAY,QAAQ,KAAA,EAAQ,IACxD;MACJ,cAAc;IACf,CAAA;AAED,WAAO;EACR;;;;;;;;EASD,MAAM,SACJX,UACAY,SACAC,WACoB;AAEpB,QAAIC;AACJ,QAAI,MAAM,QAAQ,OAAA,EAChB,iBAAgB,EAAE,MAAM,QAAS;QAEjC,iBAAgB;AAGlB,UAAM,eAAe,SAAS,IAAI,CAAC,gBACjC,YAAY,IAAI,0BAAA,CAA2B;AAG7C,UAAM,CAAC,gBAAgB,WAAA,IACrB,KAAK,6CAA6C,aAAA;AACpD,mBAAe,YAAY,eAAe,aAAa;AAEvD,QAAI,CAAC,KAAK,MACR,QAAO,KAAK,kBAAkB,cAAc,aAAa,cAAA;AAG3D,UAAM,EAAE,MAAA,IAAU;AAClB,UAAM,eAAe,KAAK,wCACxB,WAAA;AAGF,UAAM,EAAE,aAAa,sBAAsB,mBAAA,IACzC,MAAM,KAAK,gBAAgB;MACzB,UAAU;MACV;MACA;MACA,eAAe;MACf,gBAAgB;IACjB,CAAA;AAEH,QAAI,YAAY,CAAE;AAClB,QAAI,qBAAqB,SAAS,GAAG;AACnC,YAAM,UAAU,MAAM,KAAK,kBACzB,qBAAqB,IAAI,CAAC,MAAM,aAAa,CAAA,CAAA,GAC7C,aACA,gBACA,uBAAuB,SACnB,qBAAqB,IAAI,CAAC,MAAM,qBAAqB,CAAA,CAAA,IACrD,MAAA;AAEN,YAAM,QAAQ,IACZ,QAAQ,YAAY,IAAI,OAAO,YAAYL,WAAU;AACnD,cAAM,cAAc,qBAAqBA,MAAA;AACzC,oBAAY,WAAA,IAAe;AAE3B,cAAM,SAASrB,eAAc,2BAC3B,aAAa,WAAA,CAAA,EACb,SAAA;AACF,eAAO,MAAM,OAAO,QAAQ,cAAc,UAAA;MAC3C,CAAA,CAAC;AAEJ,kBAAY,QAAQ,aAAa,CAAE;IACpC;AAED,WAAO;MAAE;MAAa;IAAW;EAClC;;;;EAMD,iBAAiB2B,UAA2C;AAC1D,WAAO,CAAE;EACV;EAED,aAAqB;AACnB,WAAO;EACR;;;;;;;;EAWD,MAAM,eACJC,cACAJ,SACAC,WACoB;AACpB,UAAMI,iBAAkC,aAAa,IAAI,CAAC,gBACxD,YAAY,eAAA,CAAgB;AAE9B,WAAO,KAAK,SAAS,gBAAgB,SAAS,SAAA;EAC/C;EAoDD,qBAIEC,cAIAC,SASI;AACJ,QAAI,OAAO,KAAK,cAAc,WAC5B,OAAM,IAAI,MACR,uEAAuE;AAG3E,QAAIC,SAAQ,OACV,OAAM,IAAI,MACR,2DAA2D;AAI/D,UAAMC,SACJ;AACF,UAAM,OAAOD,SAAQ;AACrB,UAAM,cACJ,qBAAqB,MAAA,KAAW;AAClC,UAAM,SAASA,SAAQ;AACvB,UAAM,aAAaA,SAAQ;AAC3B,QAAI,WAAW,WACb,OAAM,IAAI,MACR,uFAAuF;AAI3F,QAAI,eAAe,QAAQ;AAC3B,QAAIE;AACJ,QAAI,mBAAmB,MAAA,EACrB,SAAQ,CACN;MACE,MAAM;MACN,UAAU;QACR,MAAM;QACN;QACA,YAAY,aAAa,MAAA;MAC1B;IACF,CACF;SACI;AACL,UAAI,UAAU,OACZ,gBAAe,OAAO;AAExB,cAAQ,CACN;QACE,MAAM;QACN,UAAU;UACR,MAAM;UACN;UACA,YAAY;QACb;MACF,CACF;IACF;AAED,UAAM,MAAM,KAAK,UAAU,KAAA;AAC3B,UAAM,eAAe,eAAe,KAClC,CAACC,UAAuC;AACtC,UAAI,CAAC,eAAe,WAAW,KAAA,EAC7B,OAAM,IAAI,MAAM,iCAAA;AAElB,UAAI,CAAC,MAAM,cAAc,MAAM,WAAW,WAAW,EACnD,OAAM,IAAI,MAAM,sCAAA;AAElB,YAAM,WAAW,MAAM,WAAW,KAChC,CAAC,OAAO,GAAG,SAAS,YAAA;AAEtB,UAAI,CAAC,SACH,OAAM,IAAI,MAAM,gCAAgC,YAAA,GAAe;AAEjE,aAAO,SAAS;IACjB,CAAA;AAGH,QAAI,CAAC,WACH,QAAO,IAAI,KAAK,YAAA,EAAc,WAAW,EACvC,SAAS,mBACV,CAAA;AAGH,UAAM,eAAe,oBAAoB,OAAO,EAE9C,QAAQ,CAACC,OAAYJ,aAAW,aAAa,OAAO,MAAM,KAAKA,QAAAA,EAChE,CAAA;AACD,UAAM,aAAa,oBAAoB,OAAO,EAC5C,QAAQ,MAAM,KACf,CAAA;AACD,UAAM,qBAAqB,aAAa,cAAc,EACpD,WAAW,CAAC,UAAW,EACxB,CAAA;AACD,WAAO,iBAAiB,KAGtB,CACA,EACE,KAAK,IACN,GACD,kBACD,CAAA,EAAE,WAAW,EACZ,SAAS,2BACV,CAAA;EACF;AACF;AAMD,IAAsB,kBAAtB,cAEU,cAA2B;EAOnC,MAAM,UACJlC,UACAa,SACA0B,YACqB;AACrB,UAAM,OAAO,MAAM,KAAK,MAAM,UAAU,SAAS,UAAA;AACjD,UAAM,UAAU,IAAI,UAAU,IAAA;AAC9B,QAAI,OAAO,QAAQ,YAAY,SAC7B,OAAM,IAAI,MACR,uEAAA;AAGJ,WAAO,EACL,aAAa,CACX;MACE,MAAM,QAAQ;MACd;IACD,CACF,EACF;EACF;AACF;;;AC//BD,IAAa,iBAAb,cAIU,SAA8B;EACtC,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe,CAAC,kBAAkB,WAAY;EAE9C,kBAAkB;EAElB;EAEA,YAAYC,QAET;AACD,UAAM,MAAA;AACN,SAAK,YAAY,OAAO;EACzB;EAED,MAAM,OACJC,OACAC,SACoB;AACpB,UAAM,EAAE,KAAK,OAAO,YAAA,IAAgB;AACpC,UAAM,WAAW,KAAK,UAAU,GAAA;AAChC,QAAI,aAAa,OACf,OAAM,IAAI,MAAM,oCAAoC,GAAA,IAAO;AAE7D,WAAO,SAAS,OAAO,aAAa,aAAa,OAAA,CAAQ;EAC1D;EAoBD,MAAM,MACJC,QACAC,SACAC,cACgC;AAChC,UAAM,OAAO,OAAO,IAAI,CAAC,UAAU,MAAM,GAAA;AACzC,UAAM,eAAe,OAAO,IAAI,CAAC,UAAU,MAAM,KAAA;AACjD,UAAM,aAAa,KAAK,KAAK,CAAC,QAAQ,KAAK,UAAU,GAAA,MAAS,MAAA;AAC9D,QAAI,eAAe,OACjB,OAAM,IAAI,MAAM,wDAAwD;AAE1E,UAAM,YAAY,KAAK,IAAI,CAAC,QAAQ,KAAK,UAAU,GAAA,CAAA;AACnD,UAAM,cAAc,KAAK,gBAAgB,WAAW,CAAE,GAAE,OAAO,MAAA;AAC/D,UAAM,iBACJ,YAAY,CAAA,GAAI,kBAAkB,cAAc;AAClD,UAAM,YACJ,kBAAkB,iBAAiB,IAAI,iBAAiB,OAAO;AACjE,UAAM,eAAe,CAAE;AACvB,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK,WAAW;AACvD,YAAM,gBAAgB,aACnB,MAAM,GAAG,IAAI,SAAA,EACb,IAAI,CAAC,aAAaC,QACjB,UAAUA,GAAAA,EAAG,OAAO,aAAa,YAAYA,GAAAA,CAAAA,CAAG;AAEpD,YAAM,cAAc,MAAM,QAAQ,IAAI,aAAA;AACtC,mBAAa,KAAK,WAAA;IACnB;AACD,WAAO,aAAa,KAAA;EACrB;EAED,MAAM,OACJL,OACAC,SAC4C;AAC5C,UAAM,EAAE,KAAK,OAAO,YAAA,IAAgB;AACpC,UAAM,WAAW,KAAK,UAAU,GAAA;AAChC,QAAI,aAAa,OACf,OAAM,IAAI,MAAM,oCAAoC,GAAA,IAAO;AAE7D,WAAO,SAAS,OAAO,aAAa,OAAA;EACrC;AACF;;;AChED,IAAa,iBAAb,cAAqE,SAGnE;EACA,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe,CAAC,kBAAkB,WAAY;EAE9C,kBAAkB;EAElB;EAEA;EAEA,YAAYK,QAGT;AACD,UAAM,MAAA;AACN,SAAK,WAAW,OAAO;AACvB,SAAK,UAAU,OAAO;EACvB;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BD,OAAO,KACLC,UAIA;AACA,QAAI,SAAS,SAAS,EACpB,OAAM,IAAI,MAAM,6CAAA;AAElB,UAAM,cAAc,SAAS,MAAM,GAAG,EAAA;AAItC,UAAMC,kBAAiD,YAAY,IACjE,CAAC,CAAC,WAAW,QAAA,MAAc,CACzB,kBAAkB,SAAA,GAClB,kBAAkB,QAAA,CACnB,CAAA;AAEH,UAAM,gBAAgB,kBACpB,SAAS,SAAS,SAAS,CAAA,CAAA;AAE7B,WAAO,IAAI,KAAK;MACd,UAAU;MACV,SAAS;IACV,CAAA;EACF;EAED,MAAM,QACJC,OACAC,SACAC,YACoB;AACpB,QAAI;AACJ,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK,GAAG;AAChD,YAAM,CAAC,WAAW,cAAA,IAAkB,KAAK,SAAS,CAAA;AAClD,YAAM,iBAAiB,MAAM,UAAU,OACrC,OACA,YAAYC,SAAQ,EAClB,WAAW,YAAY,SAAS,aAAa,IAAI,CAAA,EAAG,EACrD,CAAA,CAAC;AAEJ,UAAI,gBAAgB;AAClB,iBAAS,MAAM,eAAe,OAC5B,OACA,YAAYA,SAAQ,EAClB,WAAW,YAAY,SAAS,UAAU,IAAI,CAAA,EAAG,EAClD,CAAA,CAAC;AAEJ;MACD;IACF;AACD,QAAI,CAAC,OACH,UAAS,MAAM,KAAK,QAAQ,OAC1B,OACA,YAAYA,SAAQ,EAClB,WAAW,YAAY,SAAS,gBAAA,EACjC,CAAA,CAAC;AAGN,WAAO;EACR;EAED,MAAM,OACJH,OACAI,UAAyB,CAAE,GACP;AACpB,WAAO,KAAK,gBAAgB,KAAK,SAAS,OAAOD,OAAA;EAClD;EAED,OAAO,gBAAgBH,OAAiBC,SAAkC;AACxE,UAAM,mBAAmB,MAAM,4BAA4BE,OAAA;AAC3D,UAAM,aAAa,MAAM,kBAAkB,iBACzC,KAAK,OAAA,GACL,cAAc,OAAO,OAAA,GACrBA,SAAQ,OACR,QACA,QACA,QACAA,SAAQ,OAAA;AAEV,QAAI;AACJ,QAAI,uBAAuB;AAC3B,QAAI;AACJ,QAAI;AACF,eAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK,GAAG;AAChD,cAAM,CAAC,WAAW,cAAA,IAAkB,KAAK,SAAS,CAAA;AAClD,cAAM,iBAAiB,MAAM,UAAU,OACrC,OACA,YAAYA,SAAQ,EAClB,WAAW,YAAY,SAAS,aAAa,IAAI,CAAA,EAAG,EACrD,CAAA,CAAC;AAEJ,YAAI,gBAAgB;AAClB,mBAAS,MAAM,eAAe,OAC5B,OACA,YAAYA,SAAQ,EAClB,WAAW,YAAY,SAAS,UAAU,IAAI,CAAA,EAAG,EAClD,CAAA,CAAC;AAEJ,2BAAiB,SAAS,QAAQ;AAChC,kBAAM;AACN,gBAAI,qBACF,KAAI,gBAAgB,OAClB,eAAc;gBAEd,KAAI;AACF,4BAAc,OAAO,aAAa,KAAA;YACnC,QAAO;AACN,4BAAc;AACd,qCAAuB;YACxB;UAGN;AACD;QACD;MACF;AACD,UAAI,WAAW,QAAW;AACxB,iBAAS,MAAM,KAAK,QAAQ,OAC1B,OACA,YAAYA,SAAQ,EAClB,WAAW,YAAY,SAAS,gBAAA,EACjC,CAAA,CAAC;AAEJ,yBAAiB,SAAS,QAAQ;AAChC,gBAAM;AACN,cAAI,qBACF,KAAI,gBAAgB,OAClB,eAAc;cAEd,KAAI;AACF,0BAAc,OAAO,aAAa,KAAA;UACnC,QAAO;AACN,0BAAc;AACd,mCAAuB;UACxB;QAGN;MACF;IACF,SAAQ,GAAG;AACV,YAAM,YAAY,iBAAiB,CAAA;AACnC,YAAM;IACP;AACD,UAAM,YAAY,eAAe,eAAe,CAAE,CAAA;EACnD;AACF;;;AClKD,IAAa,6BAAb,cAGU,gBAAqC;EAC7C;EAEA;EAEA;EAEA;EAEA;EAEA,YAAYE,QAA+D;AACzE,QAAIC,eAAyB,eAAe,KAAK,CAAC,OAAO,YACvD,KAAK,cAAc,OAAO,WAAW,CAAE,CAAA,CAAC,EACxC,WAAW,EAAE,SAAS,cAAe,CAAA;AAEvC,UAAM,cAAc,OAAO,sBAAsB,OAAO;AACxD,QAAI,YACF,gBAAe,oBAAoB,OAAO,EAAA,CACvC,WAAA,GAAc,aAChB,CAAA,EAAE,WAAW,EAAE,SAAS,gBAAiB,CAAA;AAG5C,UAAM,QAAQ,aACX,KACC,OAAO,SAAS,cAAc,EAC5B,OAAO,CAAC,KAAKC,aAAW,KAAK,aAAa,KAAKA,YAAU,CAAE,CAAA,EAC5D,CAAA,CAAC,EAEH,WAAW,EAAE,SAAS,6BAA8B,CAAA;AAEvD,UAAMA,UAAS,OAAO,UAAU,CAAE;AAElC,UAAM;MACJ,GAAG;MACH,QAAAA;MACA;IACD,CAAA;AACD,SAAK,WAAW,OAAO;AACvB,SAAK,oBAAoB,OAAO;AAChC,SAAK,mBAAmB,OAAO;AAC/B,SAAK,oBAAoB,OAAO;AAChC,SAAK,qBAAqB,OAAO;EAClC;EAED,kBAEEC,YACoB;AACpB,QAAI;AACJ,QACE,OAAO,eAAe,YACtB,CAAC,MAAM,QAAQ,UAAA,KACf,CAAC,cAAc,UAAA,GACf;AACA,UAAI;AACJ,UAAI,KAAK,iBACP,OAAM,KAAK;eACF,OAAO,KAAK,UAAA,EAAY,WAAW,EAC5C,OAAM,OAAO,KAAK,UAAA,EAAY,CAAA;UAE9B,OAAM;AAER,UAAI,MAAM,QAAQ,WAAW,GAAA,CAAA,KAAS,MAAM,QAAQ,WAAW,GAAA,EAAK,CAAA,CAAA,EAClE,oBAAmB,WAAW,GAAA,EAAK,CAAA;UAEnC,oBAAmB,WAAW,GAAA;IAEjC,MACC,oBAAmB;AAErB,QAAI,OAAO,qBAAqB,SAC9B,QAAO,CAAC,IAAI,aAAa,gBAAA,CAAkB;aAClC,MAAM,QAAQ,gBAAA,EACvB,QAAO;aACE,cAAc,gBAAA,EACvB,QAAO,CAAC,gBAAiB;QAEzB,OAAM,IAAI,MACR;MAAkE,KAAK,UACrE,kBACA,MACA,CAAA,CACD,EAAE;EAGR;EAED,mBAEEC,aACoB;AACpB,QAAI;AACJ,QACE,CAAC,MAAM,QAAQ,WAAA,KACf,CAAC,cAAc,WAAA,KACf,OAAO,gBAAgB,UACvB;AACA,UAAI;AACJ,UAAI,KAAK,sBAAsB,OAC7B,OAAM,KAAK;eACF,OAAO,KAAK,WAAA,EAAa,WAAW,EAC7C,OAAM,OAAO,KAAK,WAAA,EAAa,CAAA;UAE/B,OAAM;AAIR,UAAI,YAAY,gBAAgB,OAC9B,qBAAoB,YAAY,YAAY,CAAA,EAAG,CAAA,EAAG;UAElD,qBAAoB,YAAY,GAAA;IAEnC,MACC,qBAAoB;AAGtB,QAAI,OAAO,sBAAsB,SAC/B,QAAO,CAAC,IAAI,UAAU,iBAAA,CAAmB;aAChC,MAAM,QAAQ,iBAAA,EACvB,QAAO;aACE,cAAc,iBAAA,EACvB,QAAO,CAAC,iBAAkB;QAE1B,OAAM,IAAI,MACR,uEAAuE,KAAK,UAC1E,mBACA,MACA,CAAA,CACD,EAAE;EAGR;EAED,MAAM,cAEJC,OACAC,QACwB;AACxB,UAAM,UAAU,QAAQ,cAAc;AACtC,UAAM,WAAW,MAAM,QAAQ,YAAA;AAC/B,QAAI,KAAK,uBAAuB,OAC9B,QAAO,SAAS,OAAO,KAAK,kBAAkB,KAAA,CAAM;AAEtD,WAAO;EACR;EAED,MAAM,aAAaC,KAAUC,SAAuC;AAClE,UAAM,UAAUN,QAAO,cAAc;AAGrC,QAAI;AAEJ,QAAI,MAAM,QAAQ,IAAI,MAAA,KAAW,MAAM,QAAQ,IAAI,OAAO,CAAA,CAAA,EACxD,UAAS,IAAI,OAAO,CAAA;QAEpB,UAAS,IAAI;AAEf,QAAI,gBAAgB,KAAK,kBAAkB,MAAA;AAG3C,QAAI,KAAK,uBAAuB,QAAW;AACzC,YAAM,mBAAmB,MAAM,QAAQ,YAAA;AACvC,sBAAgB,cAAc,MAAM,iBAAiB,MAAA;IACtD;AAED,UAAM,cAAc,IAAI;AACxB,QAAI,CAAC,YACH,OAAM,IAAI,MACR,4CAA4C,KAAK,UAC/C,KACA,MACA,CAAA,CACD,EAAE;AAGP,UAAM,iBAAiB,KAAK,mBAAmB,WAAA;AAC/C,UAAM,QAAQ,YAAY,CAAC,GAAG,eAAe,GAAG,cAAe,CAAA;EAChE;EAED,MAAM,gBAAgB,SAA4C;AAChE,UAAMA,UAAS,MAAM,MAAM,aAAa,GAAG,OAAA;AAE3C,QAAI,CAACA,QAAO,gBAAgB,CAACA,QAAO,aAAa,WAAW;AAC1D,YAAM,eAAe,EAAA,CAClB,KAAK,oBAAoB,OAAA,GAAU,MACrC;AACD,YAAM,gBAAgB,EAAE,cAAc,EAAE,WAAW,MAAO,EAAE;AAC5D,YAAM,IAAI,MACR;mBACsB,KAAK,UAAU,YAAA,CAAa,KAAK,KAAK,UACxD,aAAA,CACD,GAAG;IAET;AAED,UAAM,EAAE,UAAA,IAAcA,QAAO;AAC7B,IAAAA,QAAO,aAAa,iBAClB,MAAM,KAAK,kBAAkB,SAAA;AAC/B,WAAOA;EACR;AACF;;;ACxSD,IAAI,oBAAoB,CAAC;AACzBO,UAAS,mBAAmB;AAAA,EAC3B,gBAAgB,MAAM;AAAA,EACtB,UAAU,MAAM;AAAA,EAChB,gBAAgB,MAAM;AAAA,EACtB,iBAAiB,MAAM;AAAA,EACvB,gBAAgB,MAAM;AAAA,EACtB,cAAc,MAAM;AAAA,EACpB,gBAAgB,MAAM;AAAA,EACtB,aAAa,MAAM;AAAA,EACnB,kBAAkB,MAAM;AAAA,EACxB,qBAAqB,MAAM;AAAA,EAC3B,cAAc,MAAM;AAAA,EACpB,eAAe,MAAM;AAAA,EACrB,kBAAkB,MAAM;AAAA,EACxB,kBAAkB,MAAM;AAAA,EACxB,uBAAuB,MAAM;AAAA,EAC7B,4BAA4B,MAAM;AAAA,EAClC,mBAAmB,MAAM;AAAA,EACzB,cAAc,MAAM;AAAA,EACpB,6BAA6B,MAAM;AAAA,EACnC,cAAc,MAAM;AAAA,EACpB,aAAa,MAAM;AAAA,EACnB,wBAAwB,MAAM;AAAA,EAC9B,gBAAgB,MAAM;AACvB,CAAC;;;;;;;;;;;ACgBD,IAAa,wBAAwB;EACnC,QAAQ;IACN,SAAS;IACT,WAAW;EACZ;EACD,WAAW;IACT,SAAS;IACT,WAAW;EACZ;EACD,cAAc;IACZ,SAAS;IACT,WAAW;EACZ;EACD,QAAQ;IACN,SAAS;IACT,WAAW;EACZ;EACD,mBAAmB;IACjB,SAAS;IACT,WAAW;EACZ;EACD,uBAAuB;IACrB,SAAS;IACT,WAAW;EACZ;EACD,gBAAgB;IACd,SAAS;IACT,WAAW;EACZ;EACD,QAAQ;IACN,SAAS;IACT,WAAW;EACZ;EACD,WAAW;IACT,SAAS;IACT,WAAW;EACZ;EACD,SAAS;IACP,SAAS;IACT,WAAW;EACZ;EACD,MAAM;IACJ,SAAS;IACT,WAAW;EACZ;EACD,UAAU;IACR,SAAS;IACT,WAAW;EACZ;EACD,SAAS;IACP,SAAS;IACT,WAAW;EACZ;EACD,UAAU;IACR,SAAS;IACT,WAAW;EACZ;EACD,KAAK;IACH,SAAS;IACT,WAAW;EACZ;EACD,WAAW;IACT,SAAS;IACT,WAAW;IACX,uBAAuB;EACxB;EACD,UAAU;IACR,SAAS;IACT,WAAW;IACX,uBAAuB;EACxB;EACD,YAAY;IACV,SAAS;IACT,WAAW;IACX,uBAAuB;EACxB;AACF;AAED,IAAM,sBAAsB,OAAO,KACjC,qBAAA;AAcF,eAAsB,wBAAwBC,WAAmB;AAE/D,QAAM,gBAAgB,OAAO,QAAQ,qBAAA,EAAuB,KAC1D,CAAC,CAAA,EAAGC,QAAAA,MAAYA,SAAO,cAAc,SAAA;AAGvC,MAAI,CAAC,cACH,QAAO;AAGT,QAAM,CAAA,EAAGA,OAAA,IAAU;AACnB,MAAI;AACF,UAAM,SAAS,MAAM,OAAOA,QAAO;AACnC,WAAO,OAAOA,QAAO,SAAA;EACtB,SAAQC,GAAY;AACnB,UAAM,MAAM;AACZ,QACE,UAAU,OACV,IAAI,MAAM,SAAA,EAAW,SAAS,sBAAA,KAC9B,aAAa,OACb,OAAO,IAAI,YAAY,UACvB;AACA,YAAM,MAAM,IAAI,QAAQ,WAAW,SAAA,IAC/B,IAAI,QAAQ,MAAM,CAAA,IAClB,IAAI;AACR,YAAM,mBAAmB,IACtB,MAAM,uBAAA,EAAyB,CAAA,EAC/B,MAAM,GAAA,EAAK,CAAA;AACd,YAAM,IAAI,MACR,oBAAoB,gBAAA,uCACD,gBAAA,wBAAwC,gBAAA,IAAoB;IAElF;AACD,UAAM;EACP;AACF;AAED,eAAe,qBACbC,OACAC,eAEAC,SAA8B,CAAE,GACR;AACxB,QAAM,oBAAoB,iBAAiB,oBAAoB,KAAA;AAC/D,MAAI,CAAC,kBACH,OAAM,IAAI,MACR,+CAA+C,KAAA,4CAAiD;AAIpG,QAAMJ,UAAS,sBACb,iBAAA;AAEF,MAAI,CAACA,SAAQ;AACX,UAAM,YAAY,oBAAoB,KAAK,IAAA;AAC3C,UAAM,IAAI,MACR,gCAAgC,iBAAA;;iCAA0D,SAAA,EAAW;EAExG;AAED,QAAM,EAAE,eAAe,SAAS,GAAG,aAAA,IAAiB;AACpD,QAAM,gBAAgB,MAAM,wBAAwBA,QAAO,SAAA;AAC3D,SAAO,IAAI,cAAc;IAAE;IAAO,GAAG;EAAc,CAAA;AACpD;AAaD,SAAgB,oBAAoBK,WAAuC;AACzE,MACE,UAAU,WAAW,OAAA,KACrB,UAAU,WAAW,OAAA,KACrB,UAAU,WAAW,OAAA,KACrB,UAAU,WAAW,IAAA,KACrB,UAAU,WAAW,IAAA,KACrB,UAAU,WAAW,IAAA,EAErB,QAAO;WACE,UAAU,WAAW,QAAA,EAC9B,QAAO;WACE,UAAU,WAAW,SAAA,EAC9B,QAAO;WACE,UAAU,WAAW,oBAAA,EAC9B,QAAO;WACE,UAAU,WAAW,QAAA,EAC9B,QAAO;WACE,UAAU,WAAW,SAAA,EAC9B,QAAO;WACE,UAAU,WAAW,SAAA,EAC9B,QAAO;WACE,UAAU,WAAW,OAAA,KAAY,UAAU,WAAW,MAAA,EAC/D,QAAO;MAEP,QAAO;AAEV;AA+BD,IAAa,oBAAb,MAAaC,2BAIH,cAA2C;EACnD,WAAmB;AACjB,WAAO;EACR;EAED,eAAe,CAAC,aAAa,aAAc;EAG3C,iBAAuC,CAAE;;;;EAKzC,sBAAwC;;;;EAKxC;;;;;EAOA,0BAA+C,CAAE;;EAGzC,sBAAsB,oBAAI,IAAA;;EAM1B;EAER,YAAYC,QAAiC;AAC3C,UAAM,MAAA;AACN,SAAK,iBAAiB,OAAO,iBAAiB,CAAE;AAEhD,QAAI,OAAO,uBAAuB,MAChC,MAAK,sBAAsB;QAE3B,MAAK,sBAAsB,OAAO,sBAAsB,CACtD,SACA,eACD;AAGH,QAAI,OAAO,aACT,MAAK,gBAAgB,OAAO,aAAa,SAAS,GAAA,IAC9C,OAAO,eACP,GAAG,OAAO,YAAA;QAEd,MAAK,gBAAgB;AAGvB,SAAK,0BACH,OAAO,0BAA0B,KAAK;AAExC,SAAK,WAAW,OAAO,WAAW;EACnC;EAED,MAAM,kBACJC,SAGA;AAEA,UAAM,WAAW,KAAK,UAAUR,WAAU,CAAE,CAAA;AAC5C,UAAM,cAAc,KAAK,oBAAoB,IAAI,QAAA;AACjD,QAAI,YACF,QAAO;AAIT,UAAM,SAAS;MAAE,GAAG,KAAK;MAAgB,GAAG,KAAK,aAAaA,OAAA;IAAS;AACvE,QAAI,mBAAmB,MAAM,qBAC3B,OAAO,OACP,OAAO,eACP,MAAA;AAIF,eAAW,CAAC,QAAQ,IAAA,KAAS,OAAO,QAAQ,KAAK,uBAAA,EAC/C,KACE,UAAU,oBAEV,OAAQ,iBAAyB,MAAA,MAAY,WAG7C,oBAAmB,MAAO,iBAAyB,MAAA,EAAQ,GAAG,IAAA;AAKlE,SAAK,oBAAoB,IAAI,UAAU,gBAAA;AACvC,WAAO;EACR;EAED,MAAM,UACJS,UACAC,SACAC,YACqB;AACrB,UAAM,QAAQ,MAAM,KAAK,kBAAkB,OAAA;AAC3C,WAAO,MAAM,UAAU,UAAU,WAAW,CAAE,GAAE,UAAA;EACjD;EAEQ,UACPC,OAEAC,QAC0C;AAC1C,UAAM,sBAAsB,EAAE,GAAG,KAAK,wBAAyB;AAC/D,wBAAoB,YAAY,CAAC,OAAO,MAAO;AAC/C,WAAO,IAAIP,mBAAyC;MAClD,eAAe,KAAK;MACpB,oBAAoB,KAAK;MACzB,cAAc,KAAK;MACnB,wBAAwB;IACzB,CAAA;EACF;EAGD,uBAA8D,CAC5D,WACG,SACmD;AACtD,UAAM,sBAAsB,EAAE,GAAG,KAAK,wBAAyB;AAC/D,wBAAoB,uBAAuB,CAAC,QAAQ,GAAG,IAAK;AAC5D,WAAO,IAAIA,mBAAyC;MAClD,eAAe,KAAK;MACpB,oBAAoB,KAAK;MACzB,cAAc,KAAK;MACnB,wBAAwB;IACzB,CAAA;EACF;EAGD,aAAaE,SAA8C;AACzD,UAAM,eAAeR,SAAQ,gBAAgB,CAAE;AAE/C,QAAIc,cAAmC,CAAE;AAEzC,eAAW,CAAC,KAAK,KAAA,KAAU,OAAO,QAAQ,YAAA,EACxC,KAAI,IAAI,WAAW,KAAK,aAAA,GAAgB;AACtC,YAAM,cAAc,KAAK,cAAc,KAAK,KAAK,aAAA;AACjD,kBAAY,WAAA,IAAe;IAC5B;AAGH,QAAI,KAAK,wBAAwB,MAC/B,eAAc,OAAO,YACnB,OAAO,QAAQ,WAAA,EAAa,OAAO,CAAC,CAAC,GAAA,MACnC,KAAK,oBAAoB,SAAS,GAAA,CAAI,CACvC;AAIL,WAAO;EACR;EAED,cAAcC,KAAaC,QAAwB;AACjD,WAAO,IAAI,WAAW,MAAA,IAAU,IAAI,MAAM,OAAO,MAAA,IAAU;EAC5D;;;;;;EAOD,WACER,SACwD;AACxD,UAAMS,eAA+B,EAAE,GAAIjB,WAAU,CAAE,EAAG;AAC1D,UAAM,cAAc,KAAK,aAAa,YAAA;AAEtC,UAAMkB,kBAAkC,OAAO,YAC7C,OAAO,QAAQ,YAAA,EAAc,OAAO,CAAC,CAAC,CAAA,MAAO,MAAM,cAAA,CAAe;AAGpE,oBAAgB,eAAe,OAAO,YACpC,OAAO,QAAQ,aAAa,gBAAgB,CAAE,CAAA,EAAE,OAC9C,CAAC,CAAC,CAAA,MACA,KAAK,iBACL,CAAC,OAAO,KAAK,WAAA,EAAa,SACxB,KAAK,cAAc,GAAG,KAAK,aAAA,CAAc,CAC1C,CACJ;AAGH,UAAM,uBAAuB,IAAIZ,mBAAyC;MACxE,eAAe;QAAE,GAAG,KAAK;QAAgB,GAAG;MAAa;MACzD,oBAAoB,MAAM,QAAQ,KAAK,mBAAA,IACnC,CAAC,GAAG,KAAK,mBAAoB,IAC7B,KAAK;MACT,cAAc,KAAK;MACnB,wBAAwB,KAAK;IAC9B,CAAA;AAED,WAAO,IAAI,gBAAuD;MAChE,QAAQ;MACR,OAAO;IACR,CAAA;EACF;EAED,MAAM,OACJa,OACAC,SACyB;AACzB,UAAM,QAAQ,MAAM,KAAK,kBAAkB,OAAA;AAC3C,UAAMpB,UAAS,aAAa,OAAA;AAC5B,WAAO,MAAM,OAAO,OAAOA,OAAA;EAC5B;EAED,MAAM,OACJmB,OACAC,SACiD;AACjD,UAAM,QAAQ,MAAM,KAAK,kBAAkB,OAAA;AAC3C,UAAM,mBAAmB,IAAI,wBAAwB;MACnD,WAAW,MAAM,MAAM,OAAO,OAAO,OAAA;MACrC,QAAQ;IACT,CAAA;AACD,UAAM,iBAAiB;AACvB,WAAO,uBAAuB,mBAAmB,gBAAA;EAClD;EAoBD,MAAM,MACJC,QACAC,SACAC,cACqC;AAGrC,WAAO,MAAM,MAAM,QAAQ,SAAS,YAAA;EACrC;EAED,OAAO,UACLC,WACAC,SACgC;AAChC,UAAM,QAAQ,MAAM,KAAK,kBAAkB,OAAA;AAC3C,UAAMzB,UAAS,aAAa,OAAA;AAE5B,WAAO,MAAM,UAAU,WAAWA,OAAA;EACnC;EAED,OAAO,UACLmB,OACAO,SACAC,eAC6B;AAC7B,UAAM,QAAQ,MAAM,KAAK,kBAAkB,OAAA;AAC3C,UAAM3B,UAAS,aAAa,OAAA;AAE5B,WAAO,MAAM,UAAU,OAAOA,SAAQ;MACpC,GAAG;MACH,eAAe;MACf,cAAc,eAAe;MAC7B,cAAc,eAAe;MAC7B,aAAa,eAAe;MAC5B,cAAc,eAAe;MAC7B,cAAc,eAAe;MAC7B,aAAa,eAAe;IAC7B,CAAA;EACF;EAiBD,aACEmB,OACAS,SAIAC,eACkD;AAClD,UAAM,YAAY;AAClB,oBAAgB,mBAAmB;AACjC,YAAM,QAAQ,MAAM,UAAU,kBAAkB,OAAA;AAChD,YAAM7B,UAAS,aAAa,OAAA;AAC5B,YAAM,cAAc,MAAM,aAAa,OAAOA,SAAQ,aAAA;AAEtD,uBAAiB,SAAS,YACxB,OAAM;IAET;AACD,WAAO,uBAAuB,mBAAmB,iBAAA,CAAkB;EACpE;;;;;;EAOD,IAAI,UAAwB;AAC1B,QAAI,KAAK,SACP,QAAO,KAAK;AAEd,UAAM,WAAW,KAAK,UAAU,CAAE,CAAA;AAClC,UAAM,WAAW,KAAK,oBAAoB,IAAI,QAAA;AAC9C,WAAO,UAAU,WAAW,CAAE;EAC/B;AACF;AAyRD,eAAsB,cAKpB8B,OAEAC,QAMmD;AAEnD,MAAI,EAAE,oBAAoB,cAAc,eAAe,SAAS,GAAG,OAAA,IACjE;IACE,cAAc;IACd,GAAI,UAAU,CAAE;EACjB;AACH,MAAI,kBAAkB,UAAa,OAAO,SAAS,GAAA,GAAM;AACvD,UAAM,CAAC,UAAU,GAAG,cAAA,IAAkB,MAAM,MAAM,GAAA;AAClD,UAAM,kBACJ,eAAe,WAAW,IACtB,CAAC,QAAS,IACV,CAAC,UAAU,eAAe,KAAK,GAAA,CAAK;AAC1C,QAAI,oBAAoB,SAAS,gBAAgB,CAAA,CAAA,EAE/C,EAAC,eAAe,KAAA,IAAS;EAE5B;AACD,MAAI,yBAAyB,MAAM,QAAQ,kBAAA,IACvC,CAAC,GAAG,kBAAmB,IACvB;AAEJ,MAAI,CAAC,SAAS,2BAA2B,OACvC,0BAAyB,CAAC,SAAS,eAAgB;AAErD,MAAI,gBAAgB,2BAA2B,OAC7C,SAAQ,KACN,mBAAmB,YAAA,sIAEF;AAKrB,QAAMC,aAAkC,EAAE,GAAG,OAAQ;AAErD,MAAIC;AAEJ,MAAI,2BAA2B,OAC7B,qBAAoB,IAAI,kBAAyC;IAC/D,eAAe;MACb,GAAG;MACH;MACA;IACD;IACD;IACA;EACD,CAAA;OACI;AACL,QAAI,MACF,YAAW,QAAQ;AAErB,QAAI,cACF,YAAW,gBAAgB;AAE7B,wBAAoB,IAAI,kBAAyC;MAC/D,eAAe;MACf;MACA,oBAAoB;MACpB;IACD,CAAA;EACF;AAGD,QAAM,kBAAkB,kBAAA;AACxB,SAAO;AACR;;;;AC/8BD,SAAgB,uCAAuC;AACrD,qCAAmC,yBACjC,IAAI,0CAAA,CAAmB;;;;ACW3B,IAAa,qBAAb,cAAwC,MAAM;EAC5C;EAEA,YAAY,SAAkB,QAAmC;AAC/D,QAAI,eAAe,WAAW;AAC9B,QAAI,QAAQ,cACV,gBAAe,GAAG,YAAA;;2EAA4F,OAAO,aAAA;;AAEvH,UAAM,YAAA;AACN,SAAK,gBAAgB,QAAQ;;;AAIjC,IAAa,gBAAb,cAAmC,mBAAmB;EACpD,IAAI,eAAe;AACjB,WAAO;;;AAIX,IAAa,sBAAb,cAAyC,mBAAmB;EAC1D,YAAY,SAAkB,QAAmC;AAC/D,UAAM,SAAS,MAAA;AACf,SAAK,OAAO;;EAGd,WAAW,oBAAoB;AAC7B,WAAO;;;AAIX,IAAa,kBAAb,cAAqC,mBAAmB;EACtD,YAAY,SAAkB,QAAmC;AAC/D,UAAM,SAAS,MAAA;AACf,SAAK,OAAO;;EAGd,WAAW,oBAAoB;AAC7B,WAAO;;;AAIX,IAAa,iBAAb,cAAoC,cAAc;EAChD;EAEA,YAAY,YAA0B,QAAmC;AACvE,UAAM,KAAK,UAAU,YAAY,MAAM,CAAA,GAAI,MAAA;AAC3C,SAAK,OAAO;AACZ,SAAK,aAAa,cAAc,CAAA;;EAGlC,WAAW,oBAAoB;AAC7B,WAAO;;;AAKX,IAAa,gBAAb,cAAmC,eAAe;EAEhD,YAAY,SAAc,QAAmC;AAC3D,UAAM,CAAC,EAAE,OAAO,QAAA,CAAS,GAAG,MAAA;AAC5B,SAAK,OAAO;;EAGd,WAAW,oBAAoB;AAC7B,WAAO;;;AAIX,IAAa,gBAAb,cAAmC,cAAc;EAC/C;EAEA,YAAY,SAAkB;AAC5B,UAAA;AACA,SAAK,OAAO;AACZ,SAAK,UAAU;;EAGjB,WAAW,oBAAoB;AAC7B,WAAO;;;AAIX,SAAgB,gBAAgB,GAAiC;AAC/D,SACE,MAAM,UACL,EAAoB,SAAS,cAAc;;AAIhD,SAAgB,gBAAgB,GAAiC;AAC/D,SAAO,MAAM,UAAc,EAAoB,iBAAiB;;AAGlE,SAAgB,iBAAiB,GAAkC;AACjE,SACE,MAAM,UACN,CACE,eAAe,mBACf,cAAc,iBAAA,EACd,SAAU,EAAY,IAAA;;AAI5B,IAAa,kBAAb,cAAqC,mBAAmB;EACtD,YAAY,SAAkB,QAAmC;AAC/D,UAAM,SAAS,MAAA;AACf,SAAK,OAAO;;EAGd,WAAW,oBAAoB;AAC7B,WAAO;;;AAIX,IAAa,oBAAb,cAAuC,mBAAmB;EACxD,YAAY,SAAkB,QAAmC;AAC/D,UAAM,SAAS,MAAA;AACf,SAAK,OAAO;;EAGd,WAAW,oBAAoB;AAC7B,WAAO;;;AAIX,IAAa,qBAAb,cAAwC,mBAAmB;EACzD,YAAY,SAAkB,QAAmC;AAC/D,UAAM,SAAS,MAAA;AACf,SAAK,OAAO;;EAGd,WAAW,oBAAoB;AAC7B,WAAO;;;AAkBX,IAAa,uBAAb,cAA0C,mBAAmB;EAC3D,YAAY,SAAkB,QAAmC;AAC/D,UAAM,SAAS,MAAA;AACf,SAAK,OAAO;;EAGd,WAAW,oBAAoB;AAC7B,WAAO;;;AAmCX,IAAa,uBAAb,cAA0C,mBAAmB;;;;;;EAM3D,YAAY,SAAkB,QAAmC;AAC/D,UAAM,SAAS,MAAA;AACf,SAAK,OAAO;AACZ,SAAK,UACH;;;;;EAMJ,WAAW,oBAAoB;AAC7B,WAAO;;;;;AC/NX,SAAgB,MAAM,UAA0B;AAC9C,SAAO,GAAG,EAAE,SAAA,CAAA;;AAOd,SAAgB,MAAM,MAAc,WAA2B;AAC7D,QAAM,iBAAiB,UACpB,QAAQ,MAAM,EAAA,EACd,MAAM,OAAA,EACN,IAAA,CAAK,SAAS,SAAS,MAAM,EAAA,CAAA;AAChC,SAAO,WAAG,MAAM,IAAI,WAAW,cAAA,CAAA;;;;ACdjC,IAAaC,SAAQ;AACrB,IAAa,YAAY;AACzB,IAAa,YAAY;AACzB,IAAa,SAAS;;;ACGtB,IAAI,qBAAqB;AACzB,IAAI,wBAAwB;AAE5B,IAAI,MAAM,CAAA;AACV,IAAI,gBAAgB,CAAA;AAEpB,SAAS,iBAAiB;AACxB,SAAO;IACL,YAAY,OAAO;IACnB,YAAY,OAAO;;;AAKvB,SAAgB,UAAU,KAAK,UAAW,QAAS,SAAU;AAC3D,MAAI,OAAO,YAAY,YACrB,WAAU,eAAA;AAGZ,SAAO,KAAK,IAAI,GAAG,CAAA,GAAI,QAAW,GAAG,OAAA;AACrC,MAAI;AACJ,MAAI;AACF,QAAI,cAAc,WAAW,EAC3B,OAAM,KAAK,UAAU,KAAK,UAAU,MAAA;QAEpC,OAAM,KAAK,UAAU,KAAK,oBAAoB,QAAA,GAAW,MAAA;WAEpD,GAAG;AACV,WAAO,KAAK,UACV,qEAAA;;AAGF,WAAO,IAAI,WAAW,GAAG;AACvB,UAAI,OAAO,IAAI,IAAA;AACf,UAAI,KAAK,WAAW,EAClB,QAAO,eAAe,KAAK,CAAA,GAAI,KAAK,CAAA,GAAI,KAAK,CAAA,CAAA;UAE7C,MAAK,CAAA,EAAG,KAAK,CAAA,CAAA,IAAM,KAAK,CAAA;;;AAI9B,SAAO;;AAGT,SAAS,WAAW,SAAS,KAAK,GAAG,QAAQ;AAC3C,MAAI,qBAAqB,OAAO,yBAAyB,QAAQ,CAAA;AACjE,MAAI,mBAAmB,QAAQ,OAC7B,KAAI,mBAAmB,cAAc;AACnC,WAAO,eAAe,QAAQ,GAAG,EAAE,OAAO,QAAA,CAAA;AAC1C,QAAI,KAAK;MAAC;MAAQ;MAAG;MAAK;;QAE1B,eAAc,KAAK;IAAC;IAAK;IAAG;;OAEzB;AACL,WAAO,CAAA,IAAK;AACZ,QAAI,KAAK;MAAC;MAAQ;MAAG;;;;AAIzB,SAAS,OAAO,KAAK,GAAG,WAAW,OAAO,QAAQ,OAAO,SAAS;AAChE,WAAS;AACT,MAAI;AACJ,MAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;AAC3C,SAAK,IAAI,GAAG,IAAI,MAAM,QAAQ,IAC5B,KAAI,MAAM,CAAA,MAAO,KAAK;AACpB,iBAAW,uBAAuB,KAAK,GAAG,MAAA;AAC1C;;AAIJ,QACE,OAAO,QAAQ,eAAe,eAC9B,QAAQ,QAAQ,YAChB;AACA,iBAAW,oBAAoB,KAAK,GAAG,MAAA;AACvC;;AAGF,QACE,OAAO,QAAQ,eAAe,eAC9B,YAAY,IAAI,QAAQ,YACxB;AACA,iBAAW,oBAAoB,KAAK,GAAG,MAAA;AACvC;;AAGF,UAAM,KAAK,GAAA;AAEX,QAAI,MAAM,QAAQ,GAAA,EAChB,MAAK,IAAI,GAAG,IAAI,IAAI,QAAQ,IAC1B,QAAO,IAAI,CAAA,GAAI,GAAG,GAAG,OAAO,KAAK,OAAO,OAAA;SAErC;AACL,UAAI,OAAO,OAAO,KAAK,GAAA;AACvB,WAAK,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAChC,YAAI,MAAM,KAAK,CAAA;AACf,eAAO,IAAI,GAAA,GAAM,KAAK,GAAG,OAAO,KAAK,OAAO,OAAA;;;AAGhD,UAAM,IAAA;;;AA4GV,SAAS,oBAAoB,UAAU;AACrC,aACE,OAAO,aAAa,cAChB,WACA,SAAU,GAAG,GAAG;AACd,WAAO;;AAEf,SAAO,SAAU,KAAK,KAAK;AACzB,QAAI,cAAc,SAAS,EACzB,UAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,UAAI,OAAO,cAAc,CAAA;AACzB,UAAI,KAAK,CAAA,MAAO,OAAO,KAAK,CAAA,MAAO,KAAK;AACtC,cAAM,KAAK,CAAA;AACX,sBAAc,OAAO,GAAG,CAAA;AACxB;;;AAIN,WAAO,SAAS,KAAK,MAAM,KAAK,GAAA;;;;;ACtOpC,IAAaC,4BAAsC,CAAE;;;ACDrD,IAAI,iBAAiB,CAAC;;;;;;;;;ACQtB,IAAsB,yBAAtB,cAAqD,aAAa;;;;;;;;;EAiBhE,MAAa,YAAYC,UAAwC;AAC/D,eAAW,WAAW,SACpB,OAAM,KAAK,WAAW,OAAA;EAEzB;AAGF;AAMD,IAAsB,6BAAtB,cAAyD,aAAa;;;;;;;;EAgB7D,eAAeC,SAAgC;AACpD,WAAO,KAAK,WAAW,IAAI,aAAa,OAAA,CAAA;EACzC;;;;;;;;EASM,aAAaA,SAAgC;AAClD,WAAO,KAAK,WAAW,IAAI,UAAU,OAAA,CAAA;EACtC;;;;;;;;;EAUD,MAAa,YAAYD,UAAwC;AAC/D,eAAW,WAAW,SACpB,OAAM,KAAK,WAAW,OAAA;EAEzB;;;;EAKM,QAAuB;AAC5B,UAAM,IAAI,MAAM,kBAAA;EACjB;AACF;AAOD,IAAa,6BAAb,cAAgD,2BAA2B;EACzE,eAAe;IAAC;IAAa;IAAU;IAAW;EAAY;EAEtD,WAA0B,CAAE;EAEpC,YAAYE,UAA0B;AACpC,UAAM,GAAG,SAAA;AACT,SAAK,WAAW,YAAY,CAAE;EAC/B;;;;;;EAOD,MAAM,cAAsC;AAC1C,WAAO,KAAK;EACb;;;;;;EAOD,MAAM,WAAWC,SAAsB;AACrC,SAAK,SAAS,KAAK,OAAA;EACpB;;;;;EAMD,MAAM,QAAQ;AACZ,SAAK,WAAW,CAAE;EACnB;AACF;;;;;ACrGD,IAAsB,aAAtB,MAEA;;;;;EAKE;EAEA,YAAYC,QAA0B;AACpC,SAAK,SAAS,IAAI,YAAY,UAAU,CAAE,CAAA;EAC3C;AAkBF;;;AC3DD,IAAI,cAAc,CAAC;;;;;;;;;;AC0BnB,IAAsB,aAAtB,MAAiC;AA0BhC;AAED,IAAM,WAAW,CAACC,QAAoCC,QAAiB;AACrE,MAAI,QAAQ,OACV,QAAO,OAAO,GAAA;AAEhB,QAAM,OAAO,OAAO,KAAK,MAAA;AACzB,MAAI,KAAK,WAAW,EAClB,QAAO,OAAO,KAAK,CAAA,CAAA;AAEtB;AAOD,IAAa,gBAAgB,CAACC,aAA0BC,aAAsB;AAC5E,QAAM,QAAQ,SAAS,aAAa,QAAA;AACpC,MAAI,CAAC,OAAO;AACV,UAAM,OAAO,OAAO,KAAK,WAAA;AACzB,UAAM,IAAI,MACR,qBAAqB,KAAK,MAAA,kEAAwE;EAErG;AACD,SAAO;AACR;AAQD,IAAa,iBAAiB,CAC5BC,cACAC,cACG;AACH,QAAM,QAAQ,SAAS,cAAc,SAAA;AACrC,MAAI,CAAC,SAAS,UAAU,IAAI;AAC1B,UAAM,OAAO,OAAO,KAAK,YAAA;AACzB,UAAM,IAAI,MACR,sBAAsB,KAAK,MAAA,oEAA0E;EAExG;AACD,SAAO;AACR;AAOD,SAAgB,kBACdC,QACAC,iBACQ;AACR,QAAM,kBAAkB,OAAO,KAAK,MAAA,EAAQ,OAC1C,CAAC,QAAQ,CAAC,gBAAgB,SAAS,GAAA,KAAQ,QAAQ,MAAA;AAErD,MAAI,gBAAgB,WAAW,EAC7B,OAAM,IAAI,MACR,mCAAmC,gBAAgB,MAAA,EAAQ;AAG/D,SAAO,gBAAgB,CAAA;AACxB;;;;;;;;AClHD,IAAsB,YAAtB,cAA8C,aAAa;AA4B1D;AAsBD,IAAa,gBAAb,cAA4C,UAAqB;EAC/D,eAAe,CAAC,aAAa,SAAU;EAE7B,QAA2B,CAAE;;;;;;EAOvC,MAAM,KAAKC,MAAgB;AACzB,WAAO,KAAK,IAAI,CAAC,QAAQ,KAAK,MAAM,GAAA,CAAA;EACrC;;;;;;EAOD,MAAM,KAAKC,eAA6C;AACtD,eAAW,CAAC,KAAK,KAAA,KAAU,cACzB,MAAK,MAAM,GAAA,IAAO;EAErB;;;;;;EAOD,MAAM,QAAQD,MAA+B;AAC3C,eAAW,OAAO,KAChB,QAAO,KAAK,MAAM,GAAA;EAErB;;;;;;;EAQD,OAAO,UAAUE,QAAqD;AACpE,UAAM,OAAO,OAAO,KAAK,KAAK,KAAA;AAC9B,eAAW,OAAO,KAChB,KAAI,WAAW,UAAa,IAAI,WAAW,MAAA,EACzC,OAAM;EAGX;AACF;;;;;ACzCD,IAAsB,gBAAtB,cAIU,SAEV;;;;EAIE;;;;EAKA;;;;;EAMA;;;;EAKA;;;;;;;EAQA,YAAYC,QAA6B;AACvC,UAAM,MAAA;AACN,SAAK,YAAY,QAAQ;AACzB,SAAK,OAAO,QAAQ,QAAQ,CAAE;AAC9B,SAAK,WAAW,QAAQ,YAAY,CAAE;AACtC,SAAK,UAAU,QAAQ,WAAW;EACnC;;;;;;;;;;;;;;;;;;;;EAqBD,sBACEC,QACAC,YACwC;AACxC,UAAM,IAAI,MAAM,kBAAA;EACjB;;;;;;;;;;EAWD,MAAM,OACJC,OACAC,SACwC;AACxC,UAAM,eAAe,aAAa,uBAAuB,OAAA,CAAQ;AACjE,UAAM,mBAAmB,MAAM,gBAAgB,UAC7C,aAAa,WACb,KAAK,WACL,aAAa,MACb,KAAK,MACL,aAAa,UACb,KAAK,UACL,EAAE,SAAS,KAAK,QAAS,CAAA;AAE3B,UAAM,aAAa,MAAM,kBAAkB,qBACzC,KAAK,OAAA,GACL,OACA,aAAa,OACb,QACA,QACA,QACA,aAAa,OAAA;AAEf,QAAI;AACF,YAAM,UAAU,MAAM,KAAK,sBAAsB,OAAO,UAAA;AACxD,YAAM,YAAY,mBAAmB,OAAA;AACrC,aAAO;IACR,SAAQ,OAAO;AACd,YAAM,YAAY,qBAAqB,KAAA;AACvC,YAAM;IACP;EACF;AACF;;;;;;;;;ACkBD,IAAa,uBAAb,cAGU,cAEV;EACE,OAAO,UAAU;AACf,WAAO;EACR;EAED,IAAI,eAAe;AACjB,WAAO,CAAC,kBAAkB,cAAe;EAC1C;;;;;;EAOD;;;;;EAMA,IAAI;;;;;;;;;EAUJ,aAAa;;;;;;;;;;;EAYb;;;;;;EAOA;;;;;;EAOA,mBAA2B;AACzB,WAAO,KAAK,YAAY,iBAAA;EACzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4CD,YAAYC,QAAsC;AAChD,UAAM,MAAA;AACN,SAAK,cAAc,OAAO;AAC1B,SAAK,IAAI,OAAO,KAAK,KAAK;AAC1B,SAAK,aAAa,OAAO,cAAc,KAAK;AAC5C,SAAK,SAAS,OAAO;AACrB,QAAI,OAAO,eAAe,MACxB,MAAK,eAAe,OAAO;EAE9B;;;;;;;;;;;;;;;;;EAkBD,MAAM,sBACJC,OACAC,YAC8B;AAC9B,QAAI,KAAK,eAAe,OAAO;AAC7B,UAAI,OAAO,KAAK,YAAY,+BAA+B,WACzD,OAAM,IAAI,MACR,4CAA4C,KAAK,iBAAA,CAAkB,kDAAkD;AAGzH,aAAO,KAAK,YAAY,2BACtB,OACA;QACE,GAAG,KAAK;QACR,QAAQ,KAAK;QACb,GAAG,KAAK;MACT,GACD,YAAY,SAAS,aAAA,CAAc;IAEtC;AACD,WAAO,KAAK,YAAY,iBACtB,OACA,KAAK,GACL,KAAK,QACL,YAAY,SAAS,aAAA,CAAc;EAEtC;;;;;;;;;;;;;EAcD,MAAM,aACJC,WACAC,SAC0B;AAC1B,WAAO,KAAK,YAAY,aAAa,WAAW,OAAA;EACjD;AACF;AAqLD,IAAsB,cAAtB,cACU,aAEV;;;;;;;EAUE,eAAe;IAAC;IAAa;IAAgB,KAAK,iBAAA;EAAmB;;;;;EAMrE;;;;;;;EASA,YAAYC,YAAiCC,UAA+B;AAC1E,UAAM,QAAA;AACN,SAAK,aAAa;EACnB;;;;;;;EA+CD,MAAM,OAAOC,SAA8C;AACzD,UAAM,IAAI,MAAM,kBAAA;EACjB;;;;;;;;;;;EA4BD,MAAM,iBACJN,OACA,IAAI,GACJO,SAAyC,QACzCC,aAAoC,QACN;AAC9B,UAAM,UAAU,MAAM,KAAK,gCACzB,MAAM,KAAK,WAAW,WAAW,KAAA,GACjC,GACA,MAAA;AAGF,WAAO,QAAQ,IAAI,CAAC,WAAW,OAAO,CAAA,CAAA;EACvC;;;;;;;;;;;;EAaD,MAAM,0BACJR,OACA,IAAI,GACJO,SAAyC,QACzCC,aAAoC,QACI;AACxC,WAAO,KAAK,gCACV,MAAM,KAAK,WAAW,WAAW,KAAA,GACjC,GACA,MAAA;EAEH;;;;;;;;;;;;;;;;EAsCD,OAAO,UACLC,QACAC,YACAC,aAEAC,WACsB;AACtB,UAAM,IAAI,MACR,qGAAA;EAEH;;;;;;;;;;;;;;EAeD,OAAO,cACLC,OACAF,aAEAC,WACsB;AACtB,UAAM,IAAI,MACR,qGAAA;EAEH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwCD,YACEE,WACAC,QACAC,WACAC,MACAC,UACAC,SAC4B;AAC5B,QAAI,OAAO,cAAc,SACvB,QAAO,IAAI,qBAAqB;MAC9B,aAAa;MACb,GAAG;MACH;MACA,MAAM,CAAC,GAAI,QAAQ,CAAE,GAAG,KAAK,iBAAA,CAAmB;MAChD;MACA;MACA;IACD,CAAA;SACI;AACL,YAAM,SAAS;QACb,aAAa;QACb,GAAG,WAAW;QACd,QAAQ,WAAW;QACnB,MAAM,CAAC,GAAI,WAAW,QAAQ,CAAE,GAAG,KAAK,iBAAA,CAAmB;QAC3D,UAAU,WAAW;QACrB,SAAS,WAAW;QACpB,WAAW,WAAW;QACtB,YAAY,WAAW;MACxB;AACD,UAAI,WAAW,eAAe,MAC5B,QAAO,IAAI,qBAAqB;QAC9B,GAAG;QACH,cAAc,UAAU;MACzB,CAAA;AAEH,aAAO,IAAI,qBAAqB,EAAE,GAAG,OAAQ,CAAA;IAC9C;EACF;AACF;AAkBD,IAAsB,sBAAtB,cAAkD,YAAY;;;;;;;;;;;;;;;;EA6B5D,OAAO,KACLC,YACAT,aAC8B;AAC9B,UAAM,IAAI,MAAM,iBAAA;EACjB;AACF;;;;;ACt3BD,IAAsB,qBAAtB,MAAmE;AAMlE;;;;;AC+DD,IAAa,kBAAb,cAAqC,mBAAmB;EACtD;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAEA;EAGA;EAEA;EAEA,YAAYU,QAA+B;AACzC,UAAA;AAEA,QAAI,OAAO,UAAU,OAAO,aAC1B,OAAM,IAAI,MAAM,kDAAA;AAElB,SAAK,SAAS,OAAO,UAAU,IAAI,OAAO,QAAQ,YAAA;AAClD,SAAK,aAAa,OAAO,aAAa,OAAO,WAAW,MAAM,GAAA,IAAO,CAAE;AACvE,SAAK,gBAAgB,OAAO,iBAAiB;AAC7C,SAAK,YAAY,OAAO;AACxB,SAAK,cAAc,OAAO;AAC1B,SAAK,aAAa,OAAO;AACzB,SAAK,OAAO,OAAO;AACnB,SAAK,SAAS,OAAO;AACrB,SAAK,eAAe,OAAO;AAC3B,SAAK,SAAS,OAAO;AACrB,SAAK,QAAQ,OAAO;AACpB,SAAK,WAAW,OAAO;AACvB,SAAK,SAAS,OAAO;EACtB;EAED,MAAM,OAA4B;AAChC,UAAMC,YAAiC,CAAE;AACzC,qBAAiB,WAAW,KAAK,OAAO,aAAa;MACnD,WAAW,KAAK;MAChB,aAAa,KAAK;MAClB,YAAY,KAAK;MACjB,MAAM,KAAK;MACX,QAAQ,KAAK;MACb,cAAc,KAAK;MACnB,QAAQ,KAAK;MACb,OAAO,KAAK;MACZ,UAAU,KAAK;MACf,QAAQ,KAAK;IACd,CAAA,GAAG;AACF,UAAI,UAAU,QAAQ;AACtB,iBAAW,OAAO,KAAK,WACrB,WAAU,QAAQ,GAAA;AAEpB,YAAM,aAAa,KAAK,cAAc,OAAA;AAEtC,YAAMC,WAAkB;AACxB,OAAC,cAAc,aAAc,EAAC,QAAQ,CAAC,MAAM;AAC3C,YAAI,KAAK,UACP;cAAI,OAAO,SAAS,CAAA,MAAO,SAEzB,UAAS,CAAA,IAAK,SAAS,CAAA,EAAG,SAAA;QAC3B;MAEJ,CAAA;AAED,gBAAU,KAAK;QACb,aAAa;QACb;MACD,CAAA;IACF;AACD,WAAO;EACR;AACF;AAED,SAAS,WAAWC,GAA2B;AAC7C,MAAI,OAAO,MAAM,SACf,QAAO;MAEP,KAAI;AACF,WAAO,KAAK,UAAU,GAAG,MAAM,CAAA;EAChC,QAAO;AACN,WAAO,OAAO,CAAA;EACf;AAEJ;;;AC/KD,IAAsB,sBAAtB,cAAkD,aAAa;EAC7D,eAAe;IAAC;IAAkB;IAAqB;EAAO;AAe/D;;;ACRD,IAAsB,qBAAtB,MAAyC;;;;;;;;EAiBvC,MAAM,eACJC,KACAC,SAC6B;AAC7B,UAAM,SAAS,KAAK,UAAU,GAAA;AAC9B,WAAO,OAAO,QAAQ,SAAS,oBAAoB,CAAE,CAAA;EACtD;AACF;AAOD,IAAa,4BAAb,cAA+C,mBAAmB;EAChE;EAEA;EAOA,YACEC,gBACAC,eAKI,CAAE,GACN;AACA,UAAA;AACA,SAAK,gBAAgB;AACrB,SAAK,eAAe;EACrB;;;;;;;EAQD,UAAUH,KAAqD;AAC7D,eAAW,CAAC,WAAW,MAAA,KAAW,KAAK,aACrC,KAAI,UAAU,GAAA,EACZ,QAAO;AAGX,WAAO,KAAK;EACb;AACF;AAMD,SAAgB,MAAMA,KAAiD;AACrE,SAAO,IAAI,WAAA,MAAiB;AAC7B;AAMD,SAAgB,YACdA,KACsB;AACtB,SAAO,IAAI,WAAA,MAAiB;AAC7B;;;AC9FD,SAAS,eAAeI,MAAsB;AAC5C,SAAO,KAAK,MAAM,MAAA,EAAQ;AAC3B;AAqDD,IAAa,6BAAb,MAAaC,oCAAmC,oBAAoB;EACxD,WAAsB,CAAE;EAElC;EAEA,gBAA0C;EAE1C,YAAY;EAEZ,qBAA+B,CAAE;EAEjC,YAAYC,MAAuC;AACjD,UAAM,IAAA;AACN,SAAK,gBAAgB,KAAK;AAC1B,SAAK,YAAY,KAAK,aAAa;AACnC,SAAK,gBAAgB,KAAK,iBAAiB;EAC5C;;;;;;EAOD,MAAM,WAAWC,SAAiC;AAChD,SAAK,SAAS,KAAK,OAAA;AACnB,UAAM,gBAAgB,MAAM,KAAK,cAAc,OAAO,OAAA;AACtD,SAAK,mBAAmB,KAAK,KAAK,cAAc,aAAA,CAAc;EAC/D;;;;;;;EAQD,MAAM,4BACJC,GACAC,QACmB;AACnB,QAAI,EAAE,SAAS,EACb,QAAO;AAGT,UAAM,EAAE,UAAU,cAAA,IAAkB;AACpC,UAAM,iBAAiB,MAAM,QAAQ,IACnC,SAAS,IAAI,CAACC,OAAgB,cAAc,OAAO,EAAA,CAAG,CAAC;AAEzD,WAAO,eAAe,IAAI,CAACC,OAAe,KAAK,cAAc,EAAA,CAAG;EACjE;;;;;;;EAQD,MAAM,eAAeC,gBAA6C;AAChE,UAAM,SAAS,OAAO,OAAO,cAAA,EAAgB,KAAK,GAAA;AAClD,QAAI,kBAAkB,KAAK,YAAY,KAAK,cAAc,MAAA;AAC1D,QAAI,IAAI;AACR,UAAMC,WAAsB,CAAE;AAE9B,WAAO,kBAAkB,KAAK,IAAI,KAAK,SAAS,QAAQ;AACtD,YAAM,YAAY,kBAAkB,KAAK,mBAAmB,CAAA;AAC5D,UAAI,YAAY,EACd;WACK;AACL,iBAAS,KAAK,KAAK,SAAS,CAAA,CAAA;AAC5B,0BAAkB;MACnB;AACD,WAAK;IACN;AAED,WAAO;EACR;;;;;;;;EASD,aAAa,aACXA,UACAC,MACA;AACA,UAAM,WAAW,IAAIT,4BAA2B,IAAA;AAChD,UAAM,QAAQ,IAAI,SAAS,IAAI,CAAC,OAAO,SAAS,WAAW,EAAA,CAAG,CAAC;AAC/D,WAAO;EACR;AACF;;;AC/ID,SAAS,aAAgBU,QAAgC;AACvD,SAAO,OAAO,KAAK,MAAA,EAChB,KAAA,EACA,IAAI,CAAC,QAAQ,OAAO,GAAA,CAAA;AACxB;AAuDD,IAAa,oCAAb,MAAaC,2CAEH,oBAAoB;EAC5B;EAEA;EAEA;EAEA,YAAYC,MAAiD;AAC3D,UAAM,IAAA;AACN,SAAK,cAAc,KAAK;AACxB,SAAK,YAAY,KAAK;AACtB,QAAI,KAAK,gBAAgB,OACvB,MAAK,uBAAuB,KAAK,YAAY,YAAY;MACvD,GAAG,KAAK,KAAK;MACb,QAAQ,KAAK;IACd,CAAA;aACQ,KAAK,qBACd,MAAK,uBAAuB,KAAK;QAEjC,OAAM,IAAI,MACR,mEAAmE;EAGxE;;;;;;;EAQD,MAAM,WAAWC,SAAiC;AAChD,UAAM,YAAY,KAAK,aAAa,OAAO,KAAK,OAAA;AAChD,UAAM,gBAAgB,aACpB,UAAU,OACR,CAAC,KAAK,SAAS;MAAE,GAAG;OAAM,GAAA,GAAM,QAAQ,GAAA;IAAM,IAC9C,CAAE,CAAA,CACH,EACD,KAAK,GAAA;AAEP,UAAM,KAAK,qBAAqB,aAAa,CAC3C,IAAI,SAAS;MACX,aAAa;MACb,UAAU;IACX,CAAA,CACF,CAAA;EACF;;;;;;;;EASD,MAAM,eACJC,gBACoB;AACpB,UAAM,YAAY,KAAK,aAAa,OAAO,KAAK,cAAA;AAChD,UAAM,QAAQ,aACZ,UAAU,OACR,CAAC,KAAK,SAAS;MAAE,GAAG;OAAM,GAAA,GAAM,eAAe,GAAA;IAAM,IACrD,CAAE,CAAA,CACH,EACD,KAAK,GAAA;AAEP,UAAM,cAAc,MAAM,KAAK,qBAAqB,OAAO,KAAA;AAE3D,UAAM,WAAW,YAAY,IAAI,CAAC,QAAQ,IAAI,QAAA;AAC9C,QAAI,KAAK,YAEP,QAAO,SAAS,IAAI,CAAC,YAClB,KAAK,YAAyB,OAC7B,CAAC,KAAK,SAAS;MAAE,GAAG;OAAM,GAAA,GAAM,QAAQ,GAAA;IAAM,IAC9C,CAAE,CAAA,CACH;AAGL,WAAO;EACR;;;;;;;;;;;;;;;EAgBD,aAAa,aACXC,UACAC,YACAC,gBACAC,UAGoC,CAAE,GACM;AAC5C,UAAM,YAAY,QAAQ,aAAa;AACvC,UAAM,iBAAiB,SAAS,IAAI,CAAC,YACnC,aACE,YACI,UAAU,OACR,CAAC,KAAK,SAAS;MAAE,GAAG;OAAM,GAAA,GAAM,QAAQ,GAAA;IAAM,IAC9C,CAAE,CAAA,IAEJ,OAAA,EACJ,KAAK,GAAA,CAAI;AAGb,UAAM,cAAc,MAAM,eAAe,UACvC,gBACA,UACA,YACA,OAAA;AAGF,WAAO,IAAIP,mCAAkC;MAC3C;MACA,GAAG,QAAQ,KAAK;MAChB,aAAa,QAAQ;MACrB,WAAW,QAAQ;IACpB,CAAA;EACF;AACF;;;AClMD,IAAI,4BAA4B,CAAC;AACjCQ,UAAS,2BAA2B;AAAA,EACnC,qBAAqB,MAAM;AAAA,EAC3B,oBAAoB,MAAM;AAAA,EAC1B,2BAA2B,MAAM;AAAA,EACjC,4BAA4B,MAAM;AAAA,EAClC,mCAAmC,MAAM;AAAA,EACzC,aAAa,MAAM;AAAA,EACnB,OAAO,MAAM;AACd,CAAC;;;ACbD,IAAa,mBAAmB;AA0DhC,IAAsB,gBAAtB,cACU,aAEV;EACE,eAAe,CAAC,aAAa,gBAAiB;AAa/C;;;ACtCD,IAAa,kBAAb,MAAgE;EAC9D;EAEA;EAEA;EAEA;EAEA;EAEA;EAEQ,aAA6B;EAErC,YAAYC,QAA4B;AACtC,SAAK,MAAM,OAAO;AAClB,SAAK,cAAc,OAAO;AAC1B,SAAK,WAAW,OAAO;EACxB;EAED,sBAAsBC,cAAoC;AACxD,SAAK,aAAa;EACnB;EAED,kBAAwB;AACtB,UAAM,gBAAgB;MAAC;MAAS;MAAgB;IAAgB;AAEhE,eAAW,OAAO,cAChB,KAAI,OAAO,KAAK,SACd,OAAM,IAAI,MACR,+BAA+B,GAAA,0DAA6D,cAAc,KACxG,IAAA,CACD,GAAG;AAKV,UAAM,cAAc,KAAK,kBAAkB,KAAK,WAAA;AAEhD,QAAI;AACF,YAAM,eAAe,KAAK,sBAAsB,KAAK,QAAA;AACrD,WAAK,cAAc;AACnB,WAAK,eAAe;IACrB,SAAQ,GAAG;AACV,YAAM,IAAI,MACR,4BAA4B,CAAA,wDAAyD;IAExF;AAED,SAAK,QAAQ,KAAK,kBAAkB,KAAK,cAAc,KAAK,YAAA;AAE5D,QAAI,CAAC,KAAK,IACR,MAAK,MAAM,KAAK;EAEnB;EAED,aAAgC;AAC9B,WAAO,IAAI,SAAS;MAClB,aAAa,KAAK;MAClB,UAAU,KAAK;IAChB,CAAA;EACF;EAED,OAAO,aACLC,UACAC,KACiB;AACjB,UAAM,MAAM,IAAI,KAAK;MACnB,aAAa,SAAS;MACtB,UAAU,SAAS;MACnB,KAAK,OAAQ,SAAiD;IAC/D,CAAA;AACD,QAAI,gBAAA;AACJ,WAAO;EACR;EAEO,kBAAkBC,aAA6B;AACrD,UAAM,aAAa,KAAK,WAAW,WAAA;AACnC,WAAOC,WAAO,YAAY,gBAAA;EAC3B;EAEO,sBAAsBC,MAAuC;AACnE,UAAM,kBAAkB,KAAK,UAAU,MAAM,OAAO,KAAK,IAAA,EAAM,KAAA,CAAM;AACrE,UAAM,aAAa,KAAK,WAAW,eAAA;AACnC,WAAOD,WAAO,YAAY,gBAAA;EAC3B;AACF;AAyCD,SAAgB,OAAUE,MAAcC,UAAsB;AAC5D,QAAMC,UAAiB,CAAE;AACzB,MAAIC,eAAoB,CAAE;AAE1B,WAAS,QAAQ,CAAC,SAAS;AACzB,iBAAa,KAAK,IAAA;AAElB,QAAI,aAAa,UAAU,MAAM;AAC/B,cAAQ,KAAK,YAAA;AACb,qBAAe,CAAE;IAClB;EACF,CAAA;AAED,MAAI,aAAa,SAAS,EACxB,SAAQ,KAAK,YAAA;AAGf,SAAO;AACR;AAED,SAAgB,oBACdC,iBAC2B;AAC3B,QAAM,OAAO,oBAAI,IAAA;AACjB,QAAMC,eAA0C,CAAE;AAElD,aAAW,aAAa,iBAAiB;AACvC,QAAI,CAAC,UAAU,MACb,OAAM,IAAI,MAAM,sCAAA;AAGlB,QAAI,CAAC,KAAK,IAAI,UAAU,KAAA,GAAQ;AAC9B,WAAK,IAAI,UAAU,KAAA;AACnB,mBAAa,KAAK,SAAA;IACnB;EACF;AACD,SAAO;AACR;AAED,SAAgB,qBACdC,aAC2C;AAC3C,MAAI,gBAAgB,KAClB,QAAO,CAACC,SAA4B;WAC3B,OAAO,gBAAgB,SAChC,QAAO,CAACC,QAA2B,IAAI,SAAS,WAAA;WACvC,OAAO,gBAAgB,WAChC,QAAO;MAEP,OAAM,IAAI,MACR,2DAA2D,OAAO,WAAA,EAAa;AAGpF;AAGD,IAAa,wBAAwB,CAACC,QAAwC;AAC5E,MACE,UAAU,OACV,OAAO,IAAI,SAAS,cACpB,kBAAkB,OAClB,OAAO,IAAI,iBAAiB,WAE5B,QAAO;AAET,SAAO;AACR;AA4BD,eAAsB,MAAMC,MAA0C;AACpE,QAAM,EAAE,YAAY,eAAe,aAAa,QAAA,IAAY;AAC5D,QAAM,EACJ,YAAY,KACZ,SACA,aACA,mBAAmB,KACnB,cAAc,MAAA,IACZ,WAAW,CAAE;AAEjB,MAAI,YAAY,iBAAiB,CAAC,YAChC,OAAM,IAAI,MACR,yGAAA;AAIJ,QAAM,OAAO,sBAAsB,UAAA,IAC/B,MAAM,WAAW,KAAA,IACjB;AAEJ,QAAM,mBAAmB,qBAAqB,eAAe,IAAA;AAE7D,QAAM,eAAe,MAAM,cAAc,QAAA;AACzC,MAAI,WAAW;AACf,MAAI,aAAa;AACjB,MAAI,aAAa;AACjB,MAAI,aAAa;AAEjB,QAAM,UAAU,OAA0B,aAAa,KAAK,IAAA;AAE5D,aAAW,SAAS,SAAS;AAC3B,UAAM,aAAa,oBACjB,MAAM,IAAI,CAAC,QAAQ,gBAAgB,aAAa,GAAA,CAAI,CAAC;AAGvD,UAAM,YAAY,WAAW,IAAI,CAAC,QAAQ,iBAAiB,GAAA,CAAI;AAE/D,QAAI,YAAY,cACd,YAAW,QAAQ,CAAC,YAAYC,YAAU;AACxC,YAAM,SAAS,UAAUA,OAAAA;AACzB,UAAI,WAAW,KACb,OAAM,IAAI,MACR,0DAAA;IAGL,CAAA;AAGH,UAAM,cAAc,MAAM,cAAc,OACtC,WAAW,IAAI,CAAC,QAAQ,IAAI,GAAA,CAAI;AAGlC,UAAMC,OAAiB,CAAE;AACzB,UAAMC,cAAmC,CAAE;AAC3C,UAAMC,eAAyB,CAAE;AACjC,UAAM,WAAW,oBAAI,IAAA;AACrB,eAAW,QAAQ,CAAC,WAAW,MAAM;AACnC,YAAM,YAAY,YAAY,CAAA;AAC9B,UAAI,UACF,KAAI,YACF,UAAS,IAAI,UAAU,GAAA;WAClB;AACL,qBAAa,KAAK,UAAU,GAAA;AAC5B;MACD;AAEH,WAAK,KAAK,UAAU,GAAA;AACpB,kBAAY,KAAK,UAAU,WAAA,CAAY;IACxC,CAAA;AAED,QAAI,aAAa,SAAS,GAAG;AAC3B,YAAM,cAAc,OAAO,cAAc,EAAE,aAAa,aAAc,CAAA;AACtE,oBAAc,aAAa;IAC5B;AAED,QAAI,YAAY,SAAS,GAAG;AAC1B,YAAM,YAAY,aAAa,aAAa,EAAE,KAAK,KAAM,CAAA;AACzD,kBAAY,YAAY,SAAS,SAAS;AAC1C,oBAAc,SAAS;IACxB;AAED,UAAM,cAAc,OAClB,WAAW,IAAI,CAAC,QAAQ,IAAI,GAAA,GAC5B;MAAE,aAAa;MAAc,UAAU;IAAW,CAAA;AAGpD,QAAI,YAAY,eAAe;AAC7B,gBAAU,QAAQ,CAAC,aAAa;AAC9B,YAAI,CAAC,SAAU,OAAM,IAAI,MAAM,0BAAA;MAChC,CAAA;AACD,YAAM,eAAe,MAAM,cAAc,SAAS;QAChD,QAAQ;QACR,UAAU;MACX,CAAA;AAED,UAAI,aAAa,SAAS,GAAG;AAC3B,cAAM,YAAY,OAAO,EAAE,KAAK,aAAc,CAAA;AAC9C,cAAM,cAAc,WAAW,YAAA;AAC/B,sBAAc,aAAa;MAC5B;IACF;EACF;AAED,MAAI,YAAY,QAAQ;AACtB,QAAI,eAAe,MAAM,cAAc,SAAS;MAC9C,QAAQ;MACR,OAAO;IACR,CAAA;AACD,WAAO,aAAa,SAAS,GAAG;AAC9B,YAAM,YAAY,OAAO,EAAE,KAAK,aAAc,CAAA;AAC9C,YAAM,cAAc,WAAW,YAAA;AAC/B,oBAAc,aAAa;AAC3B,qBAAe,MAAM,cAAc,SAAS;QAC1C,QAAQ;QACR,OAAO;MACR,CAAA;IACF;EACF;AAED,SAAO;IACL;IACA;IACA;IACA;EACD;AACF;;;AC9XD,IAAI,mBAAmB,CAAC;AACxBC,UAAS,kBAAkB;AAAA,EAC1B,eAAe,MAAM;AAAA,EACrB,kBAAkB,MAAM;AAAA,EACxB,iBAAiB,MAAM;AAAA,EACvB,QAAQ,MAAM;AAAA,EACd,qBAAqB,MAAM;AAAA,EAC3B,sBAAsB,MAAM;AAAA,EAC5B,uBAAuB,MAAM;AAAA,EAC7B,OAAO,MAAM;AACd,CAAC;;;;;;;;ACsBD,IAAsB,UAAtB,MAAsBC,iBAEZ,kBAAuC;EAQ/C,eAAe;IAAC;IAAa;IAAQ,KAAK,SAAA;EAAW;;;;;;;;;EAUrD,MAAM,OACJC,OACAC,SACiB;AACjB,UAAM,cAAcF,SAAQ,2BAA2B,KAAA;AACvD,UAAM,SAAS,MAAM,KAAK,eACxB,CAAC,WAAY,GACb,SACA,SAAS,SAAA;AAEX,WAAO,OAAO,YAAY,CAAA,EAAG,CAAA,EAAG;EACjC;EAGD,OAAO,sBACLG,QACAC,UACAC,aACiC;AACjC,UAAM,IAAI,MAAM,kBAAA;EACjB;EAES,6CACRC,SAC6C;AAE7C,UAAM,CAAC,gBAAgB,WAAA,IACrB,MAAM,uCAAuC,OAAA;AAC9C,gBAA0C,SAAS,eAAe;AACnE,WAAO,CAAC,gBAAgB,WAAyC;EAClE;EAED,OAAO,gBACLL,OACAC,SACwB;AAExB,QACE,KAAK,0BAA0BF,SAAQ,UAAU,sBAEjD,OAAM,KAAK,OAAO,OAAO,OAAA;SACpB;AACL,YAAM,SAASA,SAAQ,2BAA2B,KAAA;AAClD,YAAM,CAAC,gBAAgB,WAAA,IACrB,KAAK,6CAA6C,OAAA;AACpD,YAAM,mBAAmB,MAAM,gBAAgB,UAC7C,eAAe,WACf,KAAK,WACL,eAAe,MACf,KAAK,MACL,eAAe,UACf,KAAK,UACL,EAAE,SAAS,KAAK,QAAS,CAAA;AAE3B,YAAM,QAAQ;QACZ,SAAS;QACT,mBAAmB,MAAM,iBAAiB,WAAA;QAC1C,YAAY;MACb;AACD,YAAM,cAAc,MAAM,kBAAkB,eAC1C,KAAK,OAAA,GACL,CAAC,OAAO,SAAA,CAAW,GACnB,eAAe,OACf,QACA,OACA,QACA,QACA,eAAe,OAAA;AAEjB,UAAI,aAAa,IAAI,gBAAgB,EACnC,MAAM,GACP,CAAA;AACD,UAAI;AACF,yBAAiB,SAAS,KAAK,sBAC7B,OAAO,SAAA,GACP,aACA,cAAc,CAAA,CAAA,GACb;AACD,cAAI,CAAC,WACH,cAAa;cAEb,cAAa,WAAW,OAAO,KAAA;AAEjC,cAAI,OAAO,MAAM,SAAS,SACxB,OAAM,MAAM;QAEf;MACF,SAAQ,KAAK;AACZ,cAAM,QAAQ,KACX,eAAe,CAAE,GAAE,IAAI,CAAC,eACvB,YAAY,eAAe,GAAA,CAAI,CAChC;AAEH,cAAM;MACP;AACD,YAAM,QAAQ,KACX,eAAe,CAAE,GAAE,IAAI,CAAC,eACvB,YAAY,aAAa,EACvB,aAAa,CAAC,CAAC,UAAW,CAAC,EAC5B,CAAA,CAAC,CACH;IAEJ;EACF;;;;;;;;;EAUD,MAAM,eACJO,cACAC,SACAC,WACoB;AACpB,UAAMC,UAAoB,aAAa,IAAI,CAAC,gBAC1C,YAAY,SAAA,CAAU;AAExB,WAAO,KAAK,SAAS,SAAS,SAAS,SAAA;EACxC;;;;EAeD,iBAAiBC,UAA2C;AAC1D,WAAO,CAAE;EACV;EAED,kBAAkBC,WAAmC;AACnD,UAAMC,aAA0B,CAAE;AAElC,aAAS,IAAI,GAAG,IAAI,UAAU,YAAY,QAAQ,KAAK,GAAG;AACxD,YAAM,UAAU,UAAU,YAAY,CAAA;AAEtC,UAAI,MAAM,EACR,YAAW,KAAK;QACd,aAAa,CAAC,OAAQ;QACtB,WAAW,UAAU;MACtB,CAAA;WACI;AACL,cAAM,YAAY,UAAU,YACxB;UAAE,GAAG,UAAU;UAAW,YAAY,CAAE;QAAE,IAC1C;AAEJ,mBAAW,KAAK;UACd,aAAa,CAAC,OAAQ;UACtB;QACD,CAAA;MACF;IACF;AAED,WAAO;EACR;;EAGD,MAAM,kBACJH,SACAI,eACAC,gBACAC,oBACoB;AACpB,QAAIC;AACJ,QACE,uBAAuB,UACvB,mBAAmB,WAAW,QAAQ,OAEtC,eAAc;SACT;AACL,YAAM,mBAAmB,MAAM,gBAAgB,UAC7C,eAAe,WACf,KAAK,WACL,eAAe,MACf,KAAK,MACL,eAAe,UACf,KAAK,UACL,EAAE,SAAS,KAAK,QAAS,CAAA;AAE3B,YAAM,QAAQ;QACZ,SAAS;QACT,mBAAmB,MAAM,iBAAiB,aAAA;QAC1C,YAAY,QAAQ;MACrB;AACD,oBAAc,MAAM,kBAAkB,eACpC,KAAK,OAAA,GACL,SACA,eAAe,OACf,QACA,OACA,QACA,QACA,gBAAgB,OAAA;IAEnB;AAID,UAAM,sBAAsB,CAAC,CAAC,cAAc,CAAA,EAAG,SAAS,KACtD,+BAAA;AAEF,QAAIC;AACJ,QACE,uBACA,QAAQ,WAAW,KACnB,KAAK,0BAA0BlB,SAAQ,UAAU,sBAEjD,KAAI;AACF,YAAM,SAAS,MAAM,KAAK,sBACxB,QAAQ,CAAA,GACR,eACA,cAAc,CAAA,CAAA;AAEhB,UAAI;AACJ,uBAAiB,SAAS,OACxB,KAAI,eAAe,OACjB,cAAa;UAEb,cAAa,OAAO,YAAY,KAAA;AAGpC,UAAI,eAAe,OACjB,OAAM,IAAI,MAAM,+CAAA;AAElB,eAAS;QAAE,aAAa,CAAC,CAAC,UAAW,CAAC;QAAE,WAAW,CAAE;MAAE;AACvD,YAAM,cAAc,CAAA,EAAG,aAAa,MAAA;IACrC,SAAQ,GAAG;AACV,YAAM,cAAc,CAAA,EAAG,eAAe,CAAA;AACtC,YAAM;IACP;SACI;AACL,UAAI;AACF,iBAAS,MAAM,KAAK,UAAU,SAAS,eAAe,cAAc,CAAA,CAAA;MACrE,SAAQ,KAAK;AACZ,cAAM,QAAQ,KACX,eAAe,CAAE,GAAE,IAAI,CAAC,eACvB,YAAY,eAAe,GAAA,CAAI,CAChC;AAEH,cAAM;MACP;AAED,YAAMmB,mBAAgC,KAAK,kBAAkB,MAAA;AAC7D,YAAM,QAAQ,KACX,eAAe,CAAE,GAAE,IAAI,CAAC,YAAY,MACnC,YAAY,aAAa,iBAAiB,CAAA,CAAA,CAAG,CAC9C;IAEJ;AACD,UAAM,SAAS,aAAa,IAAI,CAAC,YAAY,QAAQ,KAAA,KAAU;AAI/D,WAAO,eAAe,QAAQ,SAAS;MACrC,OAAO,SAAS,EAAE,OAAQ,IAAG;MAC7B,cAAc;IACf,CAAA;AACD,WAAO;EACR;EAED,MAAM,gBAAgB,EACpB,SACA,OACA,cACA,eACA,gBACA,MAAA,GAcA;AACA,UAAM,mBAAmB,MAAM,gBAAgB,UAC7C,eAAe,WACf,KAAK,WACL,eAAe,MACf,KAAK,MACL,eAAe,UACf,KAAK,UACL,EAAE,SAAS,KAAK,QAAS,CAAA;AAE3B,UAAM,QAAQ;MACZ,SAAS;MACT,mBAAmB,MAAM,iBAAiB,aAAA;MAC1C,YAAY,QAAQ;IACrB;AACD,UAAM,cAAc,MAAM,kBAAkB,eAC1C,KAAK,OAAA,GACL,SACA,OACA,QACA,OACA,QACA,QACA,gBAAgB,OAAA;AAIlB,UAAMC,uBAAiC,CAAE;AACzC,UAAM,UAAU,MAAM,QAAQ,WAC5B,QAAQ,IAAI,OAAO,QAAQC,WAAU;AACnC,YAAM,SAAS,MAAM,MAAM,OAAO,QAAQ,YAAA;AAC1C,UAAI,UAAU,KACZ,sBAAqB,KAAKA,MAAA;AAE5B,aAAO;IACR,CAAA,CAAC;AAKJ,UAAM,gBAAgB,QACnB,IAAI,CAAC,QAAQA,YAAW;MAAE;MAAQ,YAAY,cAAcA,MAAA;IAAQ,EAAA,EACpE,OACC,CAAC,EAAE,OAAA,MACA,OAAO,WAAW,eAAe,OAAO,SAAS,QAClD,OAAO,WAAW,UAAA;AAIxB,UAAMC,cAA8B,CAAE;AACtC,UAAM,QAAQ,IACZ,cAAc,IAAI,OAAO,EAAE,QAAQ,eAAe,WAAA,GAAc,MAAM;AACpE,UAAI,cAAc,WAAW,aAAa;AACxC,cAAM,SAAS,cAAc;AAC7B,oBAAY,CAAA,IAAK,OAAO,IAAI,CAACC,aAAW;AACtCA,mBAAO,iBAAiB;YACtB,GAAGA,SAAO;YACV,YAAY,CAAE;UACf;AACD,iBAAOA;QACR,CAAA;AACD,YAAI,OAAO,OACT,OAAM,YAAY,kBAAkB,OAAO,CAAA,EAAG,IAAA;AAEhD,eAAO,YAAY,aACjB,EACE,aAAa,CAAC,MAAO,EACtB,GACD,QACA,QACA,QACA,EACE,QAAQ,KACT,CAAA;MAEJ,OAAM;AAEL,cAAM,YAAY,eAChB,cAAc,QACd,QACA,QACA,QACA,EACE,QAAQ,KACT,CAAA;AAEH,eAAO,QAAQ,OAAO,cAAc,MAAA;MACrC;IACF,CAAA,CAAC;AAGJ,UAAM,SAAS;MACb;MACA;MACA,oBAAoB;IACrB;AAKD,WAAO,eAAe,QAAQ,SAAS;MACrC,OAAO,cACH,EAAE,QAAQ,aAAa,IAAI,CAAC,YAAY,QAAQ,KAAA,EAAQ,IACxD;MACJ,cAAc;IACf,CAAA;AAED,WAAO;EACR;;;;EAKD,MAAM,SACJb,SACAF,SACAC,WACoB;AACpB,QAAI,CAAC,MAAM,QAAQ,OAAA,EACjB,OAAM,IAAI,MAAM,iDAAA;AAGlB,QAAIe;AACJ,QAAI,MAAM,QAAQ,OAAA,EAChB,iBAAgB,EAAE,MAAM,QAAS;QAEjC,iBAAgB;AAGlB,UAAM,CAAC,gBAAgB,WAAA,IACrB,KAAK,6CAA6C,aAAA;AACpD,mBAAe,YAAY,eAAe,aAAa;AAEvD,QAAI,CAAC,KAAK,MACR,QAAO,KAAK,kBAAkB,SAAS,aAAa,cAAA;AAGtD,UAAM,EAAE,MAAA,IAAU;AAClB,UAAM,eAAe,KAAK,wCACxB,WAAA;AAEF,UAAM,EAAE,aAAa,sBAAsB,mBAAA,IACzC,MAAM,KAAK,gBAAgB;MACzB;MACA;MACA;MACA,eAAe;MACf,gBAAgB;MAChB,OAAO,eAAe;IACvB,CAAA;AAEH,QAAI,YAAY,CAAE;AAClB,QAAI,qBAAqB,SAAS,GAAG;AACnC,YAAM,UAAU,MAAM,KAAK,kBACzB,qBAAqB,IAAI,CAAC,MAAM,QAAQ,CAAA,CAAA,GACxC,aACA,gBACA,uBAAuB,SACnB,qBAAqB,IAAI,CAAC,MAAM,qBAAqB,CAAA,CAAA,IACrD,MAAA;AAEN,YAAM,QAAQ,IACZ,QAAQ,YAAY,IAAI,OAAO,YAAYH,WAAU;AACnD,cAAM,cAAc,qBAAqBA,MAAA;AACzC,oBAAY,WAAA,IAAe;AAC3B,eAAO,MAAM,OAAO,QAAQ,WAAA,GAAc,cAAc,UAAA;MACzD,CAAA,CAAC;AAEJ,kBAAY,QAAQ,aAAa,CAAE;IACpC;AAED,WAAO;MAAE;MAAa;IAAW;EAClC;;;;EAMD,qBAA0C;AACxC,WAAO,CAAE;EACV;EAOD,aAAqB;AACnB,WAAO;EACR;AACF;AASD,IAAsB,MAAtB,cAEU,QAAqB;EAU7B,MAAM,UACJX,SACAe,SACAC,YACoB;AACpB,UAAMJ,cAA8B,MAAM,QAAQ,IAChD,QAAQ,IAAI,CAAC,QAAQ,gBACnB,KAAK,MAAM,QAAQ;MAAE,GAAG;MAAS;IAAa,GAAE,UAAA,EAAY,KAC1D,CAAC,SAAS,CAAC,EAAE,KAAM,CAAC,CAAA,CACrB,CACF;AAEH,WAAO,EAAE,YAAa;EACvB;AACF;;;AC5jBD,IAAI,kBAAkB,CAAC;;;ACKvB,IAAI,qBAAqB,CAAC;AAC1BK,UAAS,oBAAoB;AAAA,EAC5B,YAAY,MAAM;AAAA,EAClB,SAAS,MAAM;AAChB,CAAC;;;ACQD,IAAsB,sBAAtB,cAA+D,SAG7D;;;;;;;;;EAsBA,sBACEC,aACAC,SACAC,WACY;AACZ,WAAO,KAAK,YAAY,aAAa,SAAA;EACtC;EAES,qBAAqBC,SAA8B;AAC3D,WAAO,OAAO,QAAQ,YAAY,WAC9B,QAAQ,UACR,KAAK,4BAA4B,QAAQ,OAAA;EAC9C;EAES,4BAA4BC,SAAiC;AACrE,WAAO,KAAK,UAAU,OAAA;EACvB;;;;;;;;;;;EAYD,MAAM,OACJC,OACAC,SACY;AACZ,QAAI,OAAO,UAAU,SACnB,QAAO,KAAK,gBACV,OAAOC,SAAeC,cACpB,KAAK,YAAY,CAAC,EAAE,MAAMC,QAAO,CAAC,GAAED,WAAS,SAAA,GAC/C,OACA;MAAE,GAAG;MAAS,SAAS;IAAU,CAAA;QAGnC,QAAO,KAAK,gBACV,OAAOE,SAAoBF,cACzB,KAAK,YACH,CACE;MACE,SAASC;MACT,MAAM,KAAK,qBAAqBA,OAAAA;IACjC,CACF,GACDD,WAAS,SAAA,GAEb,OACA;MAAE,GAAG;MAAS,SAAS;IAAU,CAAA;EAGtC;AACF;AAKD,IAAsB,mBAAtB,cAEU,oBAAuB;EAC/B,YACER,aACAE,WACY;AACZ,WAAO,KAAK,MAAM,YAAY,CAAA,EAAG,MAAM,SAAA;EACxC;EAUD,MAAM,gBACJS,MACAV,SACAC,WACY;AACZ,WAAO,KAAK,MAAM,MAAM,SAAA;EACzB;;;;EAkBD,QAAgB;AACd,UAAM,IAAI,MAAM,uBAAA;EACjB;AACF;AAoBD,IAAa,wBAAb,cAA2C,MAAM;EAC/C;EAEA;EAEA;EAEA,YACEU,SACAC,WACAC,aACA,YAAY,OACZ;AACA,UAAM,OAAA;AACN,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,YAAY;AAEjB,QAAI,WACF;UAAI,gBAAgB,UAAa,cAAc,OAC7C,OAAM,IAAI,MACR,2EAAA;IAEH;AAGH,4BAAwB,MAAM,wBAAA;EAC/B;AACF;;;AClLD,IAAsB,4BAAtB,cAEU,iBAAoB;EAC5B,OAAO,WACLC,gBACmB;AACnB,qBAAiB,SAAS,eACxB,KAAI,OAAO,UAAU,SACnB,OAAM,KAAK,YAAY,CAAC,EAAE,MAAM,MAAO,CAAC,CAAA;QAExC,OAAM,KAAK,YAAY,CACrB;MACE,SAAS;MACT,MAAM,KAAK,qBAAqB,KAAA;IACjC,CACF,CAAA;EAGN;;;;;;;;EASD,OAAO,UACLA,gBACAC,SACmB;AACnB,WAAO,KAAK,2BACV,gBACA,KAAK,WAAW,KAAK,IAAA,GACrB;MACE,GAAG;MACH,SAAS;IACV,CAAA;EAEJ;AACF;AASD,IAAsB,sCAAtB,cAEU,0BAA6B;EAC3B,OAAO;EAEjB,YAAYC,QAAmD;AAC7D,UAAM,MAAA;AACN,SAAK,OAAO,QAAQ,QAAQ,KAAK;EAClC;EASD,OAAO,WACLF,gBACmB;AACnB,QAAIG;AACJ,QAAIC;AACJ,qBAAiB,SAAS,gBAAgB;AACxC,UAAI,OAAO,UAAU,YAAY,OAAO,MAAM,YAAY,SACxD,OAAM,IAAI,MAAM,kCAAA;AAElB,UAAIC;AACJ,UAAI,mBAAmB,KAAA,GAAQ;AAC7B,YAAI,OAAO,MAAM,YAAY,SAC3B,OAAM,IAAI,MAAM,0CAAA;AAElB,mBAAW,IAAI,oBAAoB;UACjC,SAAS;UACT,MAAM,MAAM;QACb,CAAA;MACF,WAAU,cAAc,KAAA,GAAQ;AAC/B,YAAI,OAAO,MAAM,YAAY,SAC3B,OAAM,IAAI,MAAM,0CAAA;AAElB,mBAAW,IAAI,oBAAoB;UACjC,SAAS,eAAe,KAAA;UACxB,MAAM,MAAM;QACb,CAAA;MACF,MACC,YAAW,IAAI,gBAAgB,EAAE,MAAM,MAAO,CAAA;AAGhD,UAAI,WAAW,OACb,UAAS;UAET,UAAS,OAAO,OAAO,QAAA;AAGzB,YAAM,SAAS,MAAM,KAAK,mBAAmB,CAAC,MAAO,CAAA;AACrD,UACE,WAAW,UACX,WAAW,QACX,CAAC,kBAAkB,QAAQ,UAAA,GAC3B;AACA,YAAI,KAAK,KACP,OAAM,KAAK,MAAM,YAAY,MAAA;YAE7B,OAAM;AAER,qBAAa;MACd;IACF;EACF;EAED,wBAAgC;AAC9B,WAAO;EACR;AACF;;;ACtID,IAAa,oBAAb,cAAuC,0BAAsC;EAC3E,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAkB;IAAkB;EAAQ;EAE5D,kBAAkB;EAER,cAAgD,IAAI,YAAA;EAE9D,MAAMC,MAAmC;AACvC,WAAO,QAAQ,QAAQ,KAAK,YAAY,OAAO,IAAA,CAAK;EACrD;EAED,wBAAgC;AAC9B,WAAO;EACR;AACF;;;AChBD,IAAsB,mBAAtB,cAA+C,0BAE7C;EACA;EAEA,OAAO,WACLC,gBAC0B;AAC1B,QAAI,SAAS;AACb,qBAAiB,SAAS,gBAAgB;AACxC,UAAI,OAAO,UAAU,SAEnB,WAAU;UAGV,WAAU,MAAM;AAGlB,UAAI,CAAC,KAAK,IAAI;AACZ,cAAM,QAAQ,MAAM,KAAK,MAAM,MAAA;AAC/B,YAAI,MAAM,SAAS,GAAG;AAEpB,qBAAW,QAAQ,MAAM,MAAM,GAAG,EAAA,EAChC,OAAM,CAAC,IAAK;AAGd,mBAAS,MAAM,MAAM,SAAS,CAAA;QAC/B;MACF,OAAM;AAEL,cAAM,UAAU,CAAC,GAAG,OAAO,SAAS,KAAK,EAAA,CAAI;AAC7C,YAAI,QAAQ,SAAS,GAAG;AACtB,cAAI,UAAU;AAEd,qBAAW,SAAS,QAAQ,MAAM,GAAG,EAAA,GAAK;AACxC,kBAAM,CAAC,MAAM,CAAA,CAAG;AAChB,wBAAY,MAAM,SAAS,KAAK,MAAM,CAAA,EAAG;UAC1C;AAED,mBAAS,OAAO,MAAM,OAAA;QACvB;MACF;IACF;AAGD,eAAW,QAAQ,MAAM,KAAK,MAAM,MAAA,EAClC,OAAM,CAAC,IAAK;EAEf;AACF;AAMD,IAAa,iCAAb,cAAoD,iBAAiB;EACnE,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAkB;IAAkB;EAAO;EAE3D,kBAAkB;;;;;;;EAQlB,MAAM,MAAMC,MAAiC;AAC3C,QAAI;AACF,aAAO,KACJ,KAAA,EACA,MAAM,GAAA,EACN,IAAI,CAAC,MAAM,EAAE,KAAA,CAAM;IACvB,QAAO;AACN,YAAM,IAAI,sBAAsB,2BAA2B,IAAA,IAAQ,IAAA;IACpE;EACF;;;;;;EAOD,wBAAgC;AAC9B,WAAO;EACR;AACF;AAMD,IAAa,yBAAb,cAA4C,iBAAiB;EAC3D,eAAe;IAAC;IAAkB;IAAkB;EAAO;EAEnD;EAEA;EAER,YAAY,EAAE,QAAQ,UAAA,GAAsD;AAC1E,UAAM,GAAG,SAAA;AACT,SAAK,SAAS;AACd,SAAK,YAAY,aAAa;EAC/B;;;;;;;;EASD,MAAM,MAAMA,MAAiC;AAC3C,QAAI;AACF,YAAM,QAAQ,KACX,KAAA,EACA,MAAM,KAAK,SAAA,EACX,IAAI,CAAC,MAAM,EAAE,KAAA,CAAM;AACtB,UAAI,KAAK,WAAW,UAAa,MAAM,WAAW,KAAK,OACrD,OAAM,IAAI,sBACR,uCAAuC,KAAK,MAAA,SAAe,MAAM,MAAA,GAAS;AAG9E,aAAO;IACR,SAAQ,GAAG;AACV,UAAI,OAAO,eAAe,CAAA,MAAO,sBAAsB,UACrD,OAAM;AAER,YAAM,IAAI,sBAAsB,2BAA2B,IAAA,EAAM;IAClE;EACF;;;;;;;EAQD,wBAAgC;AAC9B,WAAO,qCACL,KAAK,WAAW,SAAY,KAAK,GAAG,KAAK,MAAA,GAAS,uBAC7B,KAAK,SAAA,eAAwB,KAAK,SAAA,OACvD,KAAK,SAAA;EAER;AACF;AAED,IAAa,2BAAb,cAA8C,iBAAiB;EAC7D,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAkB;IAAkB;EAAO;EAE3D,kBAAkB;EAElB,wBAAgC;AAC9B,WAAO;;;;;;;EACR;EAED,KAAK;EAEL,MAAM,MAAMA,MAAiC;AAC3C,WAAO,CAAC,GAAI,KAAK,SAAS,KAAK,EAAA,KAAO,CAAE,CAAE,EAAC,IAAI,CAAC,MAAM,EAAE,CAAA,CAAA;EACzD;AACF;AAED,IAAa,2BAAb,cAA8C,iBAAiB;EAC7D,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAkB;IAAkB;EAAO;EAE3D,kBAAkB;EAElB,wBAAgC;AAC9B,WAAO;;;;;;;EACR;EAED,KAAK;EAEL,MAAM,MAAMA,MAAiC;AAC3C,WAAO,CAAC,GAAI,KAAK,SAAS,KAAK,EAAA,KAAO,CAAE,CAAE,EAAC,IAAI,CAAC,MAAM,EAAE,CAAA,CAAA;EACzD;AACF;;;AC/KD,IAAa,qBAAb,cAAwC,0BAAkC;EACxE,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAkB;IAAkB;EAAS;EAE7D,kBAAkB;;;;;;;;;EAUlB,MAAMC,MAA+B;AACnC,WAAO,QAAQ,QAAQ,IAAA;EACxB;EAED,wBAAgC;AAC9B,WAAO;EACR;EAES,qBAAqBC,SAAoC;AACjE,WAAO,QAAQ;EAChB;EAES,yBACRC,UACQ;AACR,UAAM,IAAI,MACR,oEAAoE;EAEvE;EAES,wBAAwBC,SAA+B;AAC/D,YAAQ,QAAQ,MAAhB;MACE,KAAK;MACL,KAAK;AACH,YAAI,UAAU,QAEZ,QAAO,KAAK,qBAAqB,OAAA;AAEnC;MACF,KAAK;AACH,YAAI,eAAe,QAEjB,QAAO,KAAK,yBACV,OAAA;AAGJ;MACF;AACE,cAAM,IAAI,MACR,kBAAkB,QAAQ,IAAA,+BAAmC;IAElE;AACD,UAAM,IAAI,MAAM,yBAAyB,QAAQ,IAAA,EAAM;EACxD;EAES,4BAA4BC,SAAiC;AACrE,WAAO,QAAQ,OACb,CAACC,KAAaC,SACZ,MAAM,KAAK,wBAAwB,IAAA,GACrC,EAAA;EAEH;AACF;;;AC5DD,IAAa,yBAAb,cAEU,iBAA2C;EACnD,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAa;IAAkB;EAAa;EAE5D,SAAS;AACP,WAAO,KAAK,qBAAA;EACb;EAED,YAAmBC,QAAW;AAC5B,UAAM,MAAA;AADW,SAAA,SAAA;EAElB;;;;;;EAOD,OAAO,cAAwCA,QAAW;AACxD,WAAO,IAAI,KAAK,MAAA;EACjB;;;;;;;EAQD,OAAO,yBACLC,SACA;AACA,UAAM,YAAY,iBAAE,OAClB,OAAO,YACL,OAAO,QAAQ,OAAA,EAAS,IACtB,CAAC,CAAC,MAAM,WAAA,MACN,CAAC,MAAM,iBAAE,OAAA,EAAS,SAAS,WAAA,CAAa,CAAA,CAC3C,CACF;AAGH,WAAO,IAAI,KAAK,SAAA;EACjB;;;;;;;EAQD,wBAAgC;AAC9B,WAAO;;;;;;;;;;;;EAYT,KAAK,UAAU,aAAa,KAAK,MAAA,CAAO,CAAC;;;EAGxC;;;;;;EAOD,MAAM,MAAMC,MAAiD;AAC3D,QAAI;AACF,YAAM,cAAc,KAAK,KAAA;AAEzB,YAAMC,QAEJ,YAAY,MAAM,+BAAA,IAAmC,CAAA,KAErD,YAAY,MAAM,yBAAA,IAA6B,CAAA,KAE/C;AAEF,YAAM,cAAcA,MACjB,QAAQ,6BAA6B,CAAC,QAAQ,kBAAkB;AAC/D,cAAM,sBAAsB,cAAc,QAAQ,OAAO,KAAA;AACzD,eAAO,IAAI,mBAAA;MACZ,CAAA,EACA,QAAQ,OAAO,EAAA;AAElB,aAAO,MAAM,kBAAkB,KAAK,QAAQ,KAAK,MAAM,WAAA,CAAY;IACpE,SAAQ,GAAG;AACV,YAAM,IAAI,sBACR,2BAA2B,IAAA,aAAiB,CAAA,IAC5C,IAAA;IAEH;EACF;AACF;AAMD,IAAa,qCAAb,cAEU,uBAA0B;EAClC,OAAO,UAAU;AACf,WAAO;EACR;EAED,sBACEC,SACQ;AACR,UAAM,qBAAqB,SAAS,sBAAsB;AAC1D,QAAI,qBAAqB,EACvB,OAAM,IAAI,MAAM,iDAAA;AAGlB,WAAO;;EAA0F,KAAK,qBACpG,aAAa,KAAK,MAAA,CAAO,EAExB,WAAW,KAAK,IAAI,OAAO,kBAAA,CAAmB,EAC9C,WAAW,KAAK,IAAI,OAAO,kBAAA,CAAmB,CAAC;;EACnD;EAEO,qBACNC,aACA,SAAS,GACD;AACR,UAAM,SAAS;AASf,QAAI,UAAU,QAAQ;AACpB,UAAIC,YAAW;AACf,UAAIC;AACJ,UAAI,MAAM,QAAQ,OAAO,IAAA,GAAO;AAC9B,cAAM,UAAU,OAAO,KAAK,UAAU,CAACC,WAASA,WAAS,MAAA;AACzD,YAAI,YAAY,IAAI;AAClB,UAAAF,YAAW;AACX,iBAAO,KAAK,OAAO,SAAS,CAAA;QAC7B;AACD,eAAO,OAAO,KAAK,KAAK,KAAA;MACzB,MACC,QAAO,OAAO;AAGhB,UAAI,OAAO,SAAS,YAAY,OAAO,YAAY;AACjD,cAAMG,gBAAc,OAAO,cACvB,OAAO,OAAO,WAAA,KACd;AACJ,cAAM,aAAa,OAAO,QAAQ,OAAO,UAAA,EACtC,IAAI,CAAC,CAAC,KAAK,KAAA,MAAW;AACrB,gBAAM,aAAa,OAAO,UAAU,SAAS,GAAA,IACzC,KACA;AACJ,iBAAO,GAAG,IAAI,OAAO,MAAA,CAAO,IAAI,GAAA,MAAS,KAAK,qBAC5C,OACA,SAAS,CAAA,CACV,GAAG,UAAA;QACL,CAAA,EACA,KAAK,IAAA;AACR,eAAO;EAAM,UAAA;EAAe,IAAI,OAAO,SAAS,CAAA,CAAE,IAAIA,aAAAA;MACvD;AACD,UAAI,OAAO,SAAS,WAAW,OAAO,OAAO;AAC3C,cAAMA,gBAAc,OAAO,cACvB,OAAO,OAAO,WAAA,KACd;AACJ,eAAO;EAAW,IAAI,OAAO,MAAA,CAAO,GAAG,KAAK,qBAC1C,OAAO,OACP,SAAS,CAAA,CACV;EAAK,IAAI,OAAO,SAAS,CAAA,CAAE,KAAKA,aAAAA;MAClC;AACD,YAAM,aAAaH,YAAW,gBAAgB;AAC9C,YAAM,cAAc,OAAO,cAAc,OAAO,OAAO,WAAA,KAAgB;AACvE,aAAO,GAAG,IAAA,GAAO,WAAA,GAAc,UAAA;IAChC;AAED,QAAI,WAAW,OACb,QAAO,OAAO,MACX,IAAI,CAAC,MAAM,KAAK,qBAAqB,GAAG,MAAA,CAAO,EAC/C,KAAK;EAAK,IAAI,OAAO,SAAS,CAAA,CAAE,EAAE;AAGvC,UAAM,IAAI,MAAM,yBAAA;EACjB;EAED,OAAO,cAAwCN,QAAW;AACxD,WAAO,IAAI,KAAQ,MAAA;EACpB;EAED,OAAO,yBACLC,SACA;AACA,UAAM,YAAY,iBAAE,OAClB,OAAO,YACL,OAAO,QAAQ,OAAA,EAAS,IACtB,CAAC,CAAC,MAAM,WAAA,MACN,CAAC,MAAM,iBAAE,OAAA,EAAS,SAAS,WAAA,CAAa,CAAA,CAC3C,CACF;AAGH,WAAO,IAAI,KAAuB,SAAA;EACnC;AACF;AAYD,IAAsB,mCAAtB,cAGU,iBAAoB;EACpB;EAER,YAAY,EAAE,YAAA,GAA0D;AACtE,UAAM,GAAG,SAAA;AACT,SAAK,wBAAwB,IAAI,mCAC/B,WAAA;EAEH;EAUD,MAAM,MAAMC,MAA0B;AACpC,QAAI;AACJ,QAAI;AACF,oBAAc,MAAM,KAAK,sBAAsB,MAAM,IAAA;IACtD,SAAQ,GAAG;AACV,YAAM,IAAI,sBACR,2BAA2B,IAAA,aAAiB,CAAA,IAC5C,IAAA;IAEH;AAED,WAAO,KAAK,gBAAgB,WAAA;EAC7B;EAED,wBAAgC;AAC9B,WAAO,KAAK,sBAAsB,sBAAA;EACnC;AACF;;;AC/RD,IAAa,mBAAb,cAGU,oCAAuC;EAC/C,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe,CAAC,kBAAkB,gBAAiB;EAEnD,kBAAkB;;EAGT,oBAAuBQ,OAAUC,QAAc;AACtD,QAAI,KAAK,KACP,QAAO,MAAM,oBAAoB,OAAO,MAAA;AAE1C,WAAO;EACR;EAES,MACRC,MACAC,MACyB;AACzB,QAAI,CAAC,KACH,QAAO;AAET,QAAI,CAAC,KACH,QAAO,CAAC;MAAE,IAAI;MAAW,MAAM;MAAI,OAAO;IAAM,CAAC;AAEnD,WAAO,QAAQ,MAAM,IAAA;EACtB;EAID,MAAM,mBACJC,aACwB;AACxB,WAAO,kBAAkB,YAAY,CAAA,EAAG,IAAA;EACzC;EAED,MAAM,MAAMC,MAA0B;AACpC,WAAO,kBAAkB,MAAM,KAAK,KAAA;EACrC;EAED,wBAAgC;AAC9B,WAAO;EACR;;;;;;;;EASS,qBAAqBC,SAA8B;AAC3D,WAAO,QAAQ;EAChB;AACF;;;AC/DD,IAAM,gBAAgB,WAAY;AAChC,QAAMC,QAAW,CAAE;AACnBC,QAAI,SAAS,SAAU,QAAQ,KAAK;AAClC,WAAO,IAAI,UAAU,QAAQ,GAAA;EAC9B;AACDA,QAAI,YAAY;AAChBA,QAAI,YAAY;AAChBA,QAAI,eAAe;AAWnBA,QAAI,oBAAoB,KAAK;AAE7B,QAAM,UAAU;IACd;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACD;AAEDA,QAAI,SAAS;IACX;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACD;AAED,WAAS,UAAU,QAAQ,KAAK;AAC9B,QAAI,EAAE,gBAAgB,WACpB,QAAO,IAAI,UAAU,QAAQ,GAAA;AAG/B,QAAI,SAAS;AACb,iBAAa,MAAA;AACb,WAAO,IAAI,OAAO,IAAI;AACtB,WAAO,sBAAsBA,MAAI;AACjC,WAAO,MAAM,OAAO,CAAE;AACtB,WAAO,IAAI,YAAY,OAAO,IAAI,aAAa,OAAO,IAAI;AAC1D,WAAO,YAAY,OAAO,IAAI,YAAY,gBAAgB;AAC1D,WAAO,OAAO,CAAE;AAChB,WAAO,SAAS,OAAO,aAAa,OAAO,UAAU;AACrD,WAAO,MAAM,OAAO,QAAQ;AAC5B,WAAO,SAAS,CAAC,CAAC;AAClB,WAAO,WAAW,CAAC,EAAE,UAAU,OAAO,IAAI;AAC1C,WAAO,QAAQ,EAAE;AACjB,WAAO,iBAAiB,OAAO,IAAI;AACnC,WAAO,WAAW,OAAO,iBACrB,OAAO,OAAOA,MAAI,YAAA,IAClB,OAAO,OAAOA,MAAI,QAAA;AACtB,WAAO,aAAa,CAAE;AAKtB,QAAI,OAAO,IAAI,MACb,QAAO,KAAK,OAAO,OAAO,MAAA;AAI5B,WAAO,gBAAgB,OAAO,IAAI,aAAa;AAC/C,QAAI,OAAO,cACT,QAAO,WAAW,OAAO,OAAO,OAAO,SAAS;AAElD,SAAK,QAAQ,SAAA;EACd;AAED,MAAI,CAAC,OAAO,OACV,QAAO,SAAS,SAAU,GAAG;AAC3B,aAAS,IAAI;IAAE;AACf,MAAE,YAAY;AACd,QAAI,OAAO,IAAI,EAAA;AACf,WAAO;EACR;AAGH,MAAI,CAAC,OAAO,KACV,QAAO,OAAO,SAAU,GAAG;AACzB,QAAI,IAAI,CAAE;AACV,aAAS,KAAK,EAAG,KAAI,EAAE,eAAe,CAAA,EAAI,GAAE,KAAK,CAAA;AACjD,WAAO;EACR;AAGH,WAAS,kBAAkB,QAAQ;AACjC,QAAI,aAAa,KAAK,IAAIA,MAAI,mBAAmB,EAAA;AACjD,QAAI,YAAY;AAChB,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,IAAI,GAAG,KAAK;AAC9C,UAAI,MAAM,OAAO,QAAQ,CAAA,CAAA,EAAI;AAC7B,UAAI,MAAM,WAKR,SAAQ,QAAQ,CAAA,GAAhB;QACE,KAAK;AACH,oBAAU,MAAA;AACV;QAEF,KAAK;AACH,mBAAS,QAAQ,WAAW,OAAO,KAAA;AACnC,iBAAO,QAAQ;AACf;QAEF,KAAK;AACH,mBAAS,QAAQ,YAAY,OAAO,MAAA;AACpC,iBAAO,SAAS;AAChB;QAEF;AACE,gBAAM,QAAQ,iCAAiC,QAAQ,CAAA,CAAA;MAC1D;AAEH,kBAAY,KAAK,IAAI,WAAW,GAAA;IACjC;AAED,QAAI,IAAIA,MAAI,oBAAoB;AAChC,WAAO,sBAAsB,IAAI,OAAO;EACzC;AAED,WAAS,aAAa,QAAQ;AAC5B,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,IAAI,GAAG,IACzC,QAAO,QAAQ,CAAA,CAAA,IAAM;EAExB;AAED,WAAS,aAAa,QAAQ;AAC5B,cAAU,MAAA;AACV,QAAI,OAAO,UAAU,IAAI;AACvB,eAAS,QAAQ,WAAW,OAAO,KAAA;AACnC,aAAO,QAAQ;IAChB;AACD,QAAI,OAAO,WAAW,IAAI;AACxB,eAAS,QAAQ,YAAY,OAAO,MAAA;AACpC,aAAO,SAAS;IACjB;EACF;AAED,YAAU,YAAY;IACpB,KAAK,WAAY;AACf,UAAI,IAAA;IACL;IACM;IACP,QAAQ,WAAY;AAClB,WAAK,QAAQ;AACb,aAAO;IACR;IACD,OAAO,WAAY;AACjB,aAAO,KAAK,MAAM,IAAA;IACnB;IACD,OAAO,WAAY;AACjB,mBAAa,IAAA;IACd;EACF;AAED,MAAI,SAAS;AACb,MAAI,CAAC,OAAQ,UAAS,WAAY;EAAE;AAEpC,MAAI,cAAcA,MAAI,OAAO,OAAO,SAAU,IAAI;AAChD,WAAO,OAAO,WAAW,OAAO;EACjC,CAAA;AAED,WAAS,aAAa,QAAQ,KAAK;AACjC,WAAO,IAAI,UAAU,QAAQ,GAAA;EAC9B;AAED,WAAS,UAAU,QAAQ,KAAK;AAC9B,QAAI,EAAE,gBAAgB,WACpB,QAAO,IAAI,UAAU,QAAQ,GAAA;AAG/B,WAAO,MAAM,IAAA;AAEb,SAAK,UAAU,IAAI,UAAU,QAAQ,GAAA;AACrC,SAAK,WAAW;AAChB,SAAK,WAAW;AAEhB,QAAI,KAAK;AAET,SAAK,QAAQ,QAAQ,WAAY;AAC/B,SAAG,KAAK,KAAA;IACT;AAED,SAAK,QAAQ,UAAU,SAAU,IAAI;AACnC,SAAG,KAAK,SAAS,EAAA;AAIjB,SAAG,QAAQ,QAAQ;IACpB;AAED,SAAK,WAAW;AAEhB,gBAAY,QAAQ,SAAU,IAAI;AAChC,aAAO,eAAe,IAAI,OAAO,IAAI;QACnC,KAAK,WAAY;AACf,iBAAO,GAAG,QAAQ,OAAO,EAAA;QAC1B;QACD,KAAK,SAAU,GAAG;AAChB,cAAI,CAAC,GAAG;AACN,eAAG,mBAAmB,EAAA;AACtB,eAAG,QAAQ,OAAO,EAAA,IAAM;AACxB,mBAAO;UACR;AACD,aAAG,GAAG,IAAI,CAAA;QACX;QACD,YAAY;QACZ,cAAc;MACf,CAAA;IACF,CAAA;EACF;AAED,YAAU,YAAY,OAAO,OAAO,OAAO,WAAW,EACpD,aAAa,EACX,OAAO,UACR,EACF,CAAA;AAED,YAAU,UAAU,QAAQ,SAAU,MAAM;AAC1C,SAAK,QAAQ,MAAM,KAAK,SAAA,CAAU;AAClC,SAAK,KAAK,QAAQ,IAAA;AAClB,WAAO;EACR;AAED,YAAU,UAAU,MAAM,SAAU,OAAO;AACzC,QAAI,SAAS,MAAM,OACjB,MAAK,MAAM,KAAA;AAEb,SAAK,QAAQ,IAAA;AACb,WAAO;EACR;AAED,YAAU,UAAU,KAAK,SAAU,IAAI,SAAS;AAC9C,QAAI,KAAK;AACT,QAAI,CAAC,GAAG,QAAQ,OAAO,EAAA,KAAO,YAAY,QAAQ,EAAA,MAAQ,GACxD,IAAG,QAAQ,OAAO,EAAA,IAAM,WAAY;AAClC,UAAI,OACF,UAAU,WAAW,IACjB,CAAC,UAAU,CAAA,CAAG,IACd,MAAM,MAAM,MAAM,SAAA;AACxB,WAAK,OAAO,GAAG,GAAG,EAAA;AAClB,SAAG,KAAK,MAAM,IAAI,IAAA;IACnB;AAGH,WAAO,OAAO,UAAU,GAAG,KAAK,IAAI,IAAI,OAAA;EACzC;AAID,MAAI,QAAQ;AACZ,MAAI,UAAU;AACd,MAAI,gBAAgB;AACpB,MAAI,kBAAkB;AACtB,MAAI,SAAS;IAAE,KAAK;IAAe,OAAO;EAAiB;AAQ3D,MAAI,YACF;AAEF,MAAI,WACF;AAEF,MAAI,cACF;AACF,MAAI,aACF;AAEF,WAASC,cAAa,GAAG;AACvB,WAAO,MAAM,OAAO,MAAM,QAAQ,MAAM,QAAQ,MAAM;EACvD;AAED,WAAS,QAAQ,GAAG;AAClB,WAAO,MAAM,OAAO,MAAM;EAC3B;AAED,WAAS,YAAY,GAAG;AACtB,WAAO,MAAM,OAAOA,cAAa,CAAA;EAClC;AAED,WAAS,QAAQ,OAAO,GAAG;AACzB,WAAO,MAAM,KAAK,CAAA;EACnB;AAED,WAAS,SAAS,OAAO,GAAG;AAC1B,WAAO,CAAC,QAAQ,OAAO,CAAA;EACxB;AAED,MAAI,IAAI;AACRD,QAAI,QAAQ;IACV,OAAO;IACP,kBAAkB;IAClB,MAAM;IACN,aAAa;IACb,WAAW;IACX,WAAW;IACX,kBAAkB;IAClB,SAAS;IACT,gBAAgB;IAChB,aAAa;IACb,oBAAoB;IACpB,kBAAkB;IAClB,SAAS;IACT,gBAAgB;IAChB,eAAe;IACf,OAAO;IACP,cAAc;IACd,gBAAgB;IAChB,WAAW;IACX,gBAAgB;IAChB,kBAAkB;IAClB,UAAU;IACV,gBAAgB;IAChB,QAAQ;IACR,aAAa;IACb,uBAAuB;IACvB,cAAc;IACd,qBAAqB;IACrB,qBAAqB;IACrB,uBAAuB;IACvB,uBAAuB;IACvB,uBAAuB;IACvB,WAAW;IACX,qBAAqB;IACrB,QAAQ;IACR,eAAe;EAChB;AAEDA,QAAI,eAAe;IACjB,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,MAAM;IACN,MAAM;EACP;AAEDA,QAAI,WAAW;IACb,KAAK;IACL,IAAI;IACJ,IAAI;IACJ,MAAM;IACN,MAAM;IACN,OAAO;IACP,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,KAAK;IACL,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,OAAO;IACP,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,KAAK;IACL,MAAM;IACN,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,OAAO;IACP,OAAO;IACP,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,MAAM;IACN,MAAM;IACN,KAAK;IACL,MAAM;IACN,OAAO;IACP,MAAM;IACN,OAAO;IACP,QAAQ;IACR,KAAK;IACL,QAAQ;IACR,MAAM;IACN,KAAK;IACL,MAAM;IACN,OAAO;IACP,KAAK;IACL,KAAK;IACL,MAAM;IACN,KAAK;IACL,QAAQ;IACR,MAAM;IACN,MAAM;IACN,MAAM;IACN,OAAO;IACP,OAAO;IACP,MAAM;IACN,QAAQ;IACR,OAAO;IACP,MAAM;IACN,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,OAAO;IACP,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,MAAM;IACN,MAAM;IACN,OAAO;IACP,OAAO;IACP,MAAM;IACN,OAAO;IACP,OAAO;IACP,SAAS;IACT,MAAM;IACN,KAAK;IACL,OAAO;IACP,MAAM;IACN,OAAO;IACP,QAAQ;IACR,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,SAAS;IACT,IAAI;IACJ,KAAK;IACL,OAAO;IACP,KAAK;IACL,SAAS;IACT,KAAK;IACL,KAAK;IACL,KAAK;IACL,OAAO;IACP,OAAO;IACP,MAAM;IACN,OAAO;IACP,OAAO;IACP,SAAS;IACT,MAAM;IACN,KAAK;IACL,OAAO;IACP,MAAM;IACN,OAAO;IACP,QAAQ;IACR,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,SAAS;IACT,IAAI;IACJ,KAAK;IACL,QAAQ;IACR,OAAO;IACP,KAAK;IACL,SAAS;IACT,KAAK;IACL,KAAK;IACL,KAAK;IACL,OAAO;IACP,UAAU;IACV,OAAO;IACP,KAAK;IACL,MAAM;IACN,MAAM;IACN,QAAQ;IACR,MAAM;IACN,KAAK;IACL,KAAK;IACL,KAAK;IACL,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,MAAM;IACN,OAAO;IACP,QAAQ;IACR,MAAM;IACN,OAAO;IACP,SAAS;IACT,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,OAAO;IACP,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,QAAQ;IACR,MAAM;IACN,OAAO;IACP,OAAO;IACP,OAAO;IACP,MAAM;IACN,OAAO;IACP,IAAI;IACJ,MAAM;IACN,KAAK;IACL,OAAO;IACP,QAAQ;IACR,OAAO;IACP,MAAM;IACN,OAAO;IACP,KAAK;IACL,KAAK;IACL,IAAI;IACJ,KAAK;IACL,KAAK;IACL,KAAK;IACL,QAAQ;IACR,KAAK;IACL,MAAM;IACN,OAAO;IACP,IAAI;IACJ,OAAO;IACP,IAAI;IACJ,IAAI;IACJ,KAAK;IACL,KAAK;IACL,MAAM;IACN,MAAM;IACN,MAAM;IACN,OAAO;IACP,QAAQ;IACR,MAAM;IACN,MAAM;IACN,OAAO;IACP,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,MAAM;IACN,KAAK;IACL,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,OAAO;EACR;AAED,SAAO,KAAKA,MAAI,QAAA,EAAU,QAAQ,SAAU,KAAK;AAC/C,QAAI,IAAIA,MAAI,SAAS,GAAA;AACrB,QAAIE,MAAI,OAAO,MAAM,WAAW,OAAO,aAAa,CAAA,IAAK;AACzDF,UAAI,SAAS,GAAA,IAAOE;EACrB,CAAA;AAED,WAAS,KAAKF,MAAI,MAChBA,OAAI,MAAMA,MAAI,MAAM,CAAA,CAAA,IAAM;AAI5B,MAAIA,MAAI;AAER,WAAS,KAAK,QAAQ,OAAO,MAAM;AACjC,WAAO,KAAA,KAAU,OAAO,KAAA,EAAO,IAAA;EAChC;AAED,WAAS,SAAS,QAAQ,UAAU,MAAM;AACxC,QAAI,OAAO,SAAU,WAAU,MAAA;AAC/B,SAAK,QAAQ,UAAU,IAAA;EACxB;AAED,WAAS,UAAU,QAAQ;AACzB,WAAO,WAAW,SAAS,OAAO,KAAK,OAAO,QAAA;AAC9C,QAAI,OAAO,SAAU,MAAK,QAAQ,UAAU,OAAO,QAAA;AACnD,WAAO,WAAW;EACnB;AAED,WAAS,SAAS,KAAK,MAAM;AAC3B,QAAI,IAAI,KAAM,QAAO,KAAK,KAAA;AAC1B,QAAI,IAAI,UAAW,QAAO,KAAK,QAAQ,QAAQ,GAAA;AAC/C,WAAO;EACR;AAED,WAAS,MAAM,QAAQ,IAAI;AACzB,cAAU,MAAA;AACV,QAAI,OAAO,cACT,OACE,aACA,OAAO,OACP,eACA,OAAO,SACP,aACA,OAAO;AAEX,SAAK,IAAI,MAAM,EAAA;AACf,WAAO,QAAQ;AACf,SAAK,QAAQ,WAAW,EAAA;AACxB,WAAO;EACR;AAED,WAAS,IAAI,QAAQ;AACnB,QAAI,OAAO,WAAW,CAAC,OAAO,WAC5B,YAAW,QAAQ,mBAAA;AACrB,QACE,OAAO,UAAU,EAAE,SACnB,OAAO,UAAU,EAAE,oBACnB,OAAO,UAAU,EAAE,KAEnB,OAAM,QAAQ,gBAAA;AAEhB,cAAU,MAAA;AACV,WAAO,IAAI;AACX,WAAO,SAAS;AAChB,SAAK,QAAQ,OAAA;AACb,cAAU,KAAK,QAAQ,OAAO,QAAQ,OAAO,GAAA;AAC7C,WAAO;EACR;AAED,WAAS,WAAW,QAAQ,SAAS;AACnC,QAAI,OAAO,WAAW,YAAY,EAAE,kBAAkB,WACpD,OAAM,IAAI,MAAM,wBAAA;AAElB,QAAI,OAAO,OACT,OAAM,QAAQ,OAAA;EAEjB;AAED,WAAS,OAAO,QAAQ;AACtB,QAAI,CAAC,OAAO,OAAQ,QAAO,UAAU,OAAO,QAAQ,OAAO,SAAA,EAAA;AAC3D,QAAI,SAAS,OAAO,KAAK,OAAO,KAAK,SAAS,CAAA,KAAM;AACpD,QAAI,MAAO,OAAO,MAAM;MAAE,MAAM,OAAO;MAAS,YAAY,CAAE;IAAE;AAGhE,QAAI,OAAO,IAAI,MACb,KAAI,KAAK,OAAO;AAElB,WAAO,WAAW,SAAS;AAC3B,aAAS,QAAQ,kBAAkB,GAAA;EACpC;AAED,WAAS,MAAM,MAAM,WAAW;AAC9B,QAAI,IAAI,KAAK,QAAQ,GAAA;AACrB,QAAI,WAAW,IAAI,IAAI,CAAC,IAAI,IAAK,IAAG,KAAK,MAAM,GAAA;AAC/C,QAAI,SAAS,SAAS,CAAA;AACtB,QAAI,QAAQ,SAAS,CAAA;AAGrB,QAAI,aAAa,SAAS,SAAS;AACjC,eAAS;AACT,cAAQ;IACT;AAED,WAAO;MAAU;MAAe;IAAO;EACxC;AAED,WAAS,OAAO,QAAQ;AACtB,QAAI,CAAC,OAAO,OACV,QAAO,aAAa,OAAO,WAAW,OAAO,SAAA,EAAA;AAG/C,QACE,OAAO,WAAW,QAAQ,OAAO,UAAA,MAAgB,MACjD,OAAO,IAAI,WAAW,eAAe,OAAO,UAAA,GAC5C;AACA,aAAO,aAAa,OAAO,cAAc;AACzC;IACD;AAED,QAAI,OAAO,IAAI,OAAO;AACpB,UAAI,KAAK,MAAM,OAAO,YAAY,IAAA;AAClC,UAAI,SAAS,GAAG;AAChB,UAAI,QAAQ,GAAG;AAEf,UAAI,WAAW,QAEb,KAAI,UAAU,SAAS,OAAO,gBAAgB,cAC5C,YACE,QACA,kCACE,gBACA,eAEA,OAAO,WAAA;eAGX,UAAU,WACV,OAAO,gBAAgB,gBAEvB,YACE,QACA,oCACE,kBACA,eAEA,OAAO,WAAA;WAEN;AACL,YAAI,MAAM,OAAO;AACjB,YAAI,SAAS,OAAO,KAAK,OAAO,KAAK,SAAS,CAAA,KAAM;AACpD,YAAI,IAAI,OAAO,OAAO,GACpB,KAAI,KAAK,OAAO,OAAO,OAAO,EAAA;AAEhC,YAAI,GAAG,KAAA,IAAS,OAAO;MACxB;AAMH,aAAO,WAAW,KAAK,CAAC,OAAO,YAAY,OAAO,WAAY,CAAA;IAC/D,OAAM;AAEL,aAAO,IAAI,WAAW,OAAO,UAAA,IAAc,OAAO;AAClD,eAAS,QAAQ,eAAe;QAC9B,MAAM,OAAO;QACb,OAAO,OAAO;MACf,CAAA;IACF;AAED,WAAO,aAAa,OAAO,cAAc;EAC1C;AAED,WAAS,QAAQ,QAAQ,aAAa;AACpC,QAAI,OAAO,IAAI,OAAO;AAEpB,UAAI,MAAM,OAAO;AAGjB,UAAI,KAAK,MAAM,OAAO,OAAA;AACtB,UAAI,SAAS,GAAG;AAChB,UAAI,QAAQ,GAAG;AACf,UAAI,MAAM,IAAI,GAAG,GAAG,MAAA,KAAW;AAE/B,UAAI,IAAI,UAAU,CAAC,IAAI,KAAK;AAC1B,mBACE,QACA,+BAA+B,KAAK,UAAU,OAAO,OAAA,CAAQ;AAE/D,YAAI,MAAM,GAAG;MACd;AAED,UAAI,SAAS,OAAO,KAAK,OAAO,KAAK,SAAS,CAAA,KAAM;AACpD,UAAI,IAAI,MAAM,OAAO,OAAO,IAAI,GAC9B,QAAO,KAAK,IAAI,EAAA,EAAI,QAAQ,SAAU,GAAG;AACvC,iBAAS,QAAQ,mBAAmB;UAClC,QAAQ;UACR,KAAK,IAAI,GAAG,CAAA;QACb,CAAA;MACF,CAAA;AAMH,eAAS,IAAI,GAAG,IAAI,OAAO,WAAW,QAAQ,IAAI,GAAG,KAAK;AACxD,YAAI,KAAK,OAAO,WAAW,CAAA;AAC3B,YAAI,OAAO,GAAG,CAAA;AACd,YAAI,QAAQ,GAAG,CAAA;AACf,YAAI,WAAW,MAAM,MAAM,IAAA;AAC3B,YAAI,SAAS,SAAS;AACtB,YAAI,QAAQ,SAAS;AACrB,YAAI,MAAM,WAAW,KAAK,KAAK,IAAI,GAAG,MAAA,KAAW;AACjD,YAAI,IAAI;UACA;UACC;UACC;UACD;UACF;QACN;AAID,YAAI,UAAU,WAAW,WAAW,CAAC,KAAK;AACxC,qBACE,QACA,+BAA+B,KAAK,UAAU,MAAA,CAAO;AAEvD,YAAE,MAAM;QACT;AACD,eAAO,IAAI,WAAW,IAAA,IAAQ;AAC9B,iBAAS,QAAQ,eAAe,CAAA;MACjC;AACD,aAAO,WAAW,SAAS;IAC5B;AAED,WAAO,IAAI,gBAAgB,CAAC,CAAC;AAG7B,WAAO,UAAU;AACjB,WAAO,KAAK,KAAK,OAAO,GAAA;AACxB,aAAS,QAAQ,aAAa,OAAO,GAAA;AACrC,QAAI,CAAC,aAAa;AAEhB,UAAI,CAAC,OAAO,YAAY,OAAO,QAAQ,YAAA,MAAkB,SACvD,QAAO,QAAQ,EAAE;UAEjB,QAAO,QAAQ,EAAE;AAEnB,aAAO,MAAM;AACb,aAAO,UAAU;IAClB;AACD,WAAO,aAAa,OAAO,cAAc;AACzC,WAAO,WAAW,SAAS;EAC5B;AAED,WAAS,SAAS,QAAQ;AACxB,QAAI,CAAC,OAAO,SAAS;AACnB,iBAAW,QAAQ,wBAAA;AACnB,aAAO,YAAY;AACnB,aAAO,QAAQ,EAAE;AACjB;IACD;AAED,QAAI,OAAO,QAAQ;AACjB,UAAI,OAAO,YAAY,UAAU;AAC/B,eAAO,UAAU,OAAO,OAAO,UAAU;AACzC,eAAO,UAAU;AACjB,eAAO,QAAQ,EAAE;AACjB;MACD;AACD,eAAS,QAAQ,YAAY,OAAO,MAAA;AACpC,aAAO,SAAS;IACjB;AAID,QAAI,IAAI,OAAO,KAAK;AACpB,QAAI,UAAU,OAAO;AACrB,QAAI,CAAC,OAAO,OACV,WAAU,QAAQ,OAAO,SAAA,EAAA;AAE3B,QAAI,UAAU;AACd,WAAO,KAAK;AACV,UAAI,QAAQ,OAAO,KAAK,CAAA;AACxB,UAAI,MAAM,SAAS,QAEjB,YAAW,QAAQ,sBAAA;UAEnB;IAEH;AAGD,QAAI,IAAI,GAAG;AACT,iBAAW,QAAQ,4BAA4B,OAAO,OAAA;AACtD,aAAO,YAAY,OAAO,OAAO,UAAU;AAC3C,aAAO,QAAQ,EAAE;AACjB;IACD;AACD,WAAO,UAAU;AACjB,QAAIE,MAAI,OAAO,KAAK;AACpB,WAAOA,QAAM,GAAG;AACd,UAAI,MAAO,OAAO,MAAM,OAAO,KAAK,IAAA;AACpC,aAAO,UAAU,OAAO,IAAI;AAC5B,eAAS,QAAQ,cAAc,OAAO,OAAA;AAEtC,UAAI,IAAI,CAAE;AACV,eAAS,KAAK,IAAI,GAChB,GAAE,CAAA,IAAK,IAAI,GAAG,CAAA;AAGhB,UAAI,SAAS,OAAO,KAAK,OAAO,KAAK,SAAS,CAAA,KAAM;AACpD,UAAI,OAAO,IAAI,SAAS,IAAI,OAAO,OAAO,GAExC,QAAO,KAAK,IAAI,EAAA,EAAI,QAAQ,SAAU,GAAG;AACvC,YAAIC,KAAI,IAAI,GAAG,CAAA;AACf,iBAAS,QAAQ,oBAAoB;UAAE,QAAQ;UAAG,KAAKA;QAAG,CAAA;MAC3D,CAAA;IAEJ;AACD,QAAI,MAAM,EAAG,QAAO,aAAa;AACjC,WAAO,UAAU,OAAO,cAAc,OAAO,aAAa;AAC1D,WAAO,WAAW,SAAS;AAC3B,WAAO,QAAQ,EAAE;EAClB;AAED,WAAS,YAAY,QAAQ;AAC3B,QAAI,SAAS,OAAO;AACpB,QAAI,WAAW,OAAO,YAAA;AACtB,QAAI;AACJ,QAAI,SAAS;AAEb,QAAI,OAAO,SAAS,MAAA,EAClB,QAAO,OAAO,SAAS,MAAA;AAEzB,QAAI,OAAO,SAAS,QAAA,EAClB,QAAO,OAAO,SAAS,QAAA;AAEzB,aAAS;AACT,QAAI,OAAO,OAAO,CAAA,MAAO,IACvB,KAAI,OAAO,OAAO,CAAA,MAAO,KAAK;AAC5B,eAAS,OAAO,MAAM,CAAA;AACtB,YAAM,SAAS,QAAQ,EAAA;AACvB,eAAS,IAAI,SAAS,EAAA;IACvB,OAAM;AACL,eAAS,OAAO,MAAM,CAAA;AACtB,YAAM,SAAS,QAAQ,EAAA;AACvB,eAAS,IAAI,SAAS,EAAA;IACvB;AAEH,aAAS,OAAO,QAAQ,OAAO,EAAA;AAC/B,QAAI,MAAM,GAAA,KAAQ,OAAO,YAAA,MAAkB,QAAQ;AACjD,iBAAW,QAAQ,0BAAA;AACnB,aAAO,MAAM,OAAO,SAAS;IAC9B;AAED,WAAO,OAAO,cAAc,GAAA;EAC7B;AAED,WAAS,gBAAgB,QAAQ,GAAG;AAClC,QAAI,MAAM,KAAK;AACb,aAAO,QAAQ,EAAE;AACjB,aAAO,mBAAmB,OAAO;IAClC,WAAU,CAACF,cAAa,CAAA,GAAI;AAG3B,iBAAW,QAAQ,kCAAA;AACnB,aAAO,WAAW;AAClB,aAAO,QAAQ,EAAE;IAClB;EACF;AAED,WAAS,OAAO,OAAO,GAAG;AACxB,QAAI,SAAS;AACb,QAAI,IAAI,MAAM,OACZ,UAAS,MAAM,OAAO,CAAA;AAExB,WAAO;EACR;AAED,WAAS,MAAM,OAAO;AACpB,QAAI,SAAS;AACb,QAAI,KAAK,MACP,OAAM,KAAK;AAEb,QAAI,OAAO,OACT,QAAO,MACL,QACA,sDAAA;AAGJ,QAAI,UAAU,KACZ,QAAO,IAAI,MAAA;AAEb,QAAI,OAAO,UAAU,SACnB,SAAQ,MAAM,SAAA;AAEhB,QAAI,IAAI;AACR,QAAI,IAAI;AACR,WAAO,MAAM;AACX,UAAI,OAAO,OAAO,GAAA;AAClB,aAAO,IAAI;AAEX,UAAI,CAAC,EACH;AAGF,UAAI,OAAO,eAAe;AACxB,eAAO;AACP,YAAI,MAAM,MAAM;AACd,iBAAO;AACP,iBAAO,SAAS;QACjB,MACC,QAAO;MAEV;AAED,cAAQ,OAAO,OAAf;QACE,KAAK,EAAE;AACL,iBAAO,QAAQ,EAAE;AACjB,cAAI,MAAM,SACR;AAEF,0BAAgB,QAAQ,CAAA;AACxB;QAEF,KAAK,EAAE;AACL,0BAAgB,QAAQ,CAAA;AACxB;QAEF,KAAK,EAAE;AACL,cAAI,OAAO,WAAW,CAAC,OAAO,YAAY;AACxC,gBAAI,SAAS,IAAI;AACjB,mBAAO,KAAK,MAAM,OAAO,MAAM,KAAK;AAClC,kBAAI,OAAO,OAAO,GAAA;AAClB,kBAAI,KAAK,OAAO,eAAe;AAC7B,uBAAO;AACP,oBAAI,MAAM,MAAM;AACd,yBAAO;AACP,yBAAO,SAAS;gBACjB,MACC,QAAO;cAEV;YACF;AACD,mBAAO,YAAY,MAAM,UAAU,QAAQ,IAAI,CAAA;UAChD;AACD,cACE,MAAM,OACN,EAAE,OAAO,WAAW,OAAO,cAAc,CAAC,OAAO,SACjD;AACA,mBAAO,QAAQ,EAAE;AACjB,mBAAO,mBAAmB,OAAO;UAClC,OAAM;AACL,gBAAI,CAACA,cAAa,CAAA,MAAO,CAAC,OAAO,WAAW,OAAO,YACjD,YAAW,QAAQ,iCAAA;AAErB,gBAAI,MAAM,IACR,QAAO,QAAQ,EAAE;gBAEjB,QAAO,YAAY;UAEtB;AACD;QAEF,KAAK,EAAE;AAEL,cAAI,MAAM,IACR,QAAO,QAAQ,EAAE;cAEjB,QAAO,UAAU;AAEnB;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,IACR,QAAO,QAAQ,EAAE;eACZ;AACL,mBAAO,UAAU,MAAM;AACvB,mBAAO,QAAQ,EAAE;UAClB;AACD;QAEF,KAAK,EAAE;AAEL,cAAI,MAAM,KAAK;AACb,mBAAO,QAAQ,EAAE;AACjB,mBAAO,WAAW;UACnB,WAAUA,cAAa,CAAA,GAAI;UAE3B,WAAU,QAAQ,WAAW,CAAA,GAAI;AAChC,mBAAO,QAAQ,EAAE;AACjB,mBAAO,UAAU;UAClB,WAAU,MAAM,KAAK;AACpB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,UAAU;UAClB,WAAU,MAAM,KAAK;AACpB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,eAAe,OAAO,eAAe;UAC7C,OAAM;AACL,uBAAW,QAAQ,aAAA;AAEnB,gBAAI,OAAO,mBAAmB,IAAI,OAAO,UAAU;AACjD,kBAAI,MAAM,OAAO,WAAW,OAAO;AACnC,kBAAI,IAAI,MAAM,GAAA,EAAK,KAAK,GAAA,IAAO;YAChC;AACD,mBAAO,YAAY,MAAM;AACzB,mBAAO,QAAQ,EAAE;UAClB;AACD;QAEF,KAAK,EAAE;AACL,eAAK,OAAO,WAAW,GAAG,YAAA,MAAkB,OAAO;AACjD,qBAAS,QAAQ,aAAA;AACjB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,WAAW;AAClB,mBAAO,QAAQ;UAChB,WAAU,OAAO,WAAW,MAAM,MAAM;AACvC,mBAAO,QAAQ,EAAE;AACjB,mBAAO,UAAU;AACjB,mBAAO,WAAW;UACnB,YAAW,OAAO,WAAW,GAAG,YAAA,MAAkB,SAAS;AAC1D,mBAAO,QAAQ,EAAE;AACjB,gBAAI,OAAO,WAAW,OAAO,QAC3B,YAAW,QAAQ,6CAAA;AAErB,mBAAO,UAAU;AACjB,mBAAO,WAAW;UACnB,WAAU,MAAM,KAAK;AACpB,qBAAS,QAAQ,qBAAqB,OAAO,QAAA;AAC7C,mBAAO,WAAW;AAClB,mBAAO,QAAQ,EAAE;UAClB,WAAU,QAAQ,CAAA,GAAI;AACrB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,YAAY;UACpB,MACC,QAAO,YAAY;AAErB;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,OAAO,GAAG;AAClB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,IAAI;UACZ;AACD,iBAAO,YAAY;AACnB;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,KAAK;AACb,mBAAO,QAAQ,EAAE;AACjB,qBAAS,QAAQ,aAAa,OAAO,OAAA;AACrC,mBAAO,UAAU;UAClB,OAAM;AACL,mBAAO,WAAW;AAClB,gBAAI,MAAM,IACR,QAAO,QAAQ,EAAE;qBACR,QAAQ,CAAA,GAAI;AACrB,qBAAO,QAAQ,EAAE;AACjB,qBAAO,IAAI;YACZ;UACF;AACD;QAEF,KAAK,EAAE;AACL,iBAAO,WAAW;AAClB,cAAI,MAAM,OAAO,GAAG;AAClB,mBAAO,IAAI;AACX,mBAAO,QAAQ,EAAE;UAClB;AACD;QAEF,KAAK,EAAE;AACL,iBAAO,WAAW;AAClB,cAAI,MAAM,IACR,QAAO,QAAQ,EAAE;mBACR,QAAQ,CAAA,GAAI;AACrB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,IAAI;UACZ;AACD;QAEF,KAAK,EAAE;AACL,iBAAO,WAAW;AAClB,cAAI,MAAM,OAAO,GAAG;AAClB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,IAAI;UACZ;AACD;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,IACR,QAAO,QAAQ,EAAE;cAEjB,QAAO,WAAW;AAEpB;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,KAAK;AACb,mBAAO,QAAQ,EAAE;AACjB,mBAAO,UAAU,SAAS,OAAO,KAAK,OAAO,OAAA;AAC7C,gBAAI,OAAO,QACT,UAAS,QAAQ,aAAa,OAAO,OAAA;AAEvC,mBAAO,UAAU;UAClB,OAAM;AACL,mBAAO,WAAW,MAAM;AACxB,mBAAO,QAAQ,EAAE;UAClB;AACD;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,KAAK;AACb,uBAAW,QAAQ,mBAAA;AAGnB,mBAAO,WAAW,OAAO;AACzB,mBAAO,QAAQ,EAAE;UAClB,MACC,QAAO,QAAQ,EAAE;AAEnB;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,IACR,QAAO,QAAQ,EAAE;cAEjB,QAAO,SAAS;AAElB;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,IACR,QAAO,QAAQ,EAAE;eACZ;AACL,mBAAO,SAAS,MAAM;AACtB,mBAAO,QAAQ,EAAE;UAClB;AACD;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,KAAK;AACb,gBAAI,OAAO,MACT,UAAS,QAAQ,WAAW,OAAO,KAAA;AAErC,qBAAS,QAAQ,cAAA;AACjB,mBAAO,QAAQ;AACf,mBAAO,QAAQ,EAAE;UAClB,WAAU,MAAM,IACf,QAAO,SAAS;eACX;AACL,mBAAO,SAAS,OAAO;AACvB,mBAAO,QAAQ,EAAE;UAClB;AACD;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,IACR,QAAO,QAAQ,EAAE;mBACRA,cAAa,CAAA,EACtB,QAAO,QAAQ,EAAE;cAEjB,QAAO,gBAAgB;AAEzB;QAEF,KAAK,EAAE;AACL,cAAI,CAAC,OAAO,gBAAgBA,cAAa,CAAA,EACvC;mBACS,MAAM,IACf,QAAO,QAAQ,EAAE;cAEjB,QAAO,gBAAgB;AAEzB;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,KAAK;AACb,qBAAS,QAAQ,2BAA2B;cAC1C,MAAM,OAAO;cACb,MAAM,OAAO;YACd,CAAA;AACD,mBAAO,eAAe,OAAO,eAAe;AAC5C,mBAAO,QAAQ,EAAE;UAClB,OAAM;AACL,mBAAO,gBAAgB,MAAM;AAC7B,mBAAO,QAAQ,EAAE;UAClB;AACD;QAEF,KAAK,EAAE;AACL,cAAI,QAAQ,UAAU,CAAA,EACpB,QAAO,WAAW;eACb;AACL,mBAAO,MAAA;AACP,gBAAI,MAAM,IACR,SAAQ,MAAA;qBACC,MAAM,IACf,QAAO,QAAQ,EAAE;iBACZ;AACL,kBAAI,CAACA,cAAa,CAAA,EAChB,YAAW,QAAQ,+BAAA;AAErB,qBAAO,QAAQ,EAAE;YAClB;UACF;AACD;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,KAAK;AACb,oBAAQ,QAAQ,IAAA;AAChB,qBAAS,MAAA;UACV,OAAM;AACL,uBACE,QACA,gDAAA;AAEF,mBAAO,QAAQ,EAAE;UAClB;AACD;QAEF,KAAK,EAAE;AAEL,cAAIA,cAAa,CAAA,EACf;mBACS,MAAM,IACf,SAAQ,MAAA;mBACC,MAAM,IACf,QAAO,QAAQ,EAAE;mBACR,QAAQ,WAAW,CAAA,GAAI;AAChC,mBAAO,aAAa;AACpB,mBAAO,cAAc;AACrB,mBAAO,QAAQ,EAAE;UAClB,MACC,YAAW,QAAQ,wBAAA;AAErB;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,IACR,QAAO,QAAQ,EAAE;mBACR,MAAM,KAAK;AACpB,uBAAW,QAAQ,yBAAA;AACnB,mBAAO,cAAc,OAAO;AAC5B,mBAAO,MAAA;AACP,oBAAQ,MAAA;UACT,WAAUA,cAAa,CAAA,EACtB,QAAO,QAAQ,EAAE;mBACR,QAAQ,UAAU,CAAA,EAC3B,QAAO,cAAc;cAErB,YAAW,QAAQ,wBAAA;AAErB;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,IACR,QAAO,QAAQ,EAAE;mBACRA,cAAa,CAAA,EACtB;eACK;AACL,uBAAW,QAAQ,yBAAA;AACnB,mBAAO,IAAI,WAAW,OAAO,UAAA,IAAc;AAC3C,mBAAO,cAAc;AACrB,qBAAS,QAAQ,eAAe;cAC9B,MAAM,OAAO;cACb,OAAO;YACR,CAAA;AACD,mBAAO,aAAa;AACpB,gBAAI,MAAM,IACR,SAAQ,MAAA;qBACC,QAAQ,WAAW,CAAA,GAAI;AAChC,qBAAO,aAAa;AACpB,qBAAO,QAAQ,EAAE;YAClB,OAAM;AACL,yBAAW,QAAQ,wBAAA;AACnB,qBAAO,QAAQ,EAAE;YAClB;UACF;AACD;QAEF,KAAK,EAAE;AACL,cAAIA,cAAa,CAAA,EACf;mBACS,QAAQ,CAAA,GAAI;AACrB,mBAAO,IAAI;AACX,mBAAO,QAAQ,EAAE;UAClB,OAAM;AACL,uBAAW,QAAQ,0BAAA;AACnB,mBAAO,QAAQ,EAAE;AACjB,mBAAO,cAAc;UACtB;AACD;QAEF,KAAK,EAAE;AACL,cAAI,MAAM,OAAO,GAAG;AAClB,gBAAI,MAAM,IACR,QAAO,QAAQ,EAAE;gBAEjB,QAAO,eAAe;AAExB;UACD;AACD,iBAAO,MAAA;AACP,iBAAO,IAAI;AACX,iBAAO,QAAQ,EAAE;AACjB;QAEF,KAAK,EAAE;AACL,cAAIA,cAAa,CAAA,EACf,QAAO,QAAQ,EAAE;mBACR,MAAM,IACf,SAAQ,MAAA;mBACC,MAAM,IACf,QAAO,QAAQ,EAAE;mBACR,QAAQ,WAAW,CAAA,GAAI;AAChC,uBAAW,QAAQ,kCAAA;AACnB,mBAAO,aAAa;AACpB,mBAAO,cAAc;AACrB,mBAAO,QAAQ,EAAE;UAClB,MACC,YAAW,QAAQ,wBAAA;AAErB;QAEF,KAAK,EAAE;AACL,cAAI,CAAC,YAAY,CAAA,GAAI;AACnB,gBAAI,MAAM,IACR,QAAO,QAAQ,EAAE;gBAEjB,QAAO,eAAe;AAExB;UACD;AACD,iBAAO,MAAA;AACP,cAAI,MAAM,IACR,SAAQ,MAAA;cAER,QAAO,QAAQ,EAAE;AAEnB;QAEF,KAAK,EAAE;AACL,cAAI,CAAC,OAAO,QACV,KAAIA,cAAa,CAAA,EACf;mBACS,SAAS,WAAW,CAAA,EAC7B,KAAI,OAAO,QAAQ;AACjB,mBAAO,UAAU,OAAO;AACxB,mBAAO,QAAQ,EAAE;UAClB,MACC,YAAW,QAAQ,iCAAA;cAGrB,QAAO,UAAU;mBAEV,MAAM,IACf,UAAS,MAAA;mBACA,QAAQ,UAAU,CAAA,EAC3B,QAAO,WAAW;mBACT,OAAO,QAAQ;AACxB,mBAAO,UAAU,OAAO,OAAO;AAC/B,mBAAO,UAAU;AACjB,mBAAO,QAAQ,EAAE;UAClB,OAAM;AACL,gBAAI,CAACA,cAAa,CAAA,EAChB,YAAW,QAAQ,gCAAA;AAErB,mBAAO,QAAQ,EAAE;UAClB;AACD;QAEF,KAAK,EAAE;AACL,cAAIA,cAAa,CAAA,EACf;AAEF,cAAI,MAAM,IACR,UAAS,MAAA;cAET,YAAW,QAAQ,mCAAA;AAErB;QAEF,KAAK,EAAE;QACP,KAAK,EAAE;QACP,KAAK,EAAE;AACL,cAAI;AACJ,cAAI;AACJ,kBAAQ,OAAO,OAAf;YACE,KAAK,EAAE;AACL,4BAAc,EAAE;AAChB,uBAAS;AACT;YAEF,KAAK,EAAE;AACL,4BAAc,EAAE;AAChB,uBAAS;AACT;YAEF,KAAK,EAAE;AACL,4BAAc,EAAE;AAChB,uBAAS;AACT;UACH;AAED,cAAI,MAAM,IACR,KAAI,OAAO,IAAI,kBAAkB;AAC/B,gBAAI,eAAe,YAAY,MAAA;AAC/B,mBAAO,SAAS;AAChB,mBAAO,QAAQ;AACf,mBAAO,MAAM,YAAA;UACd,OAAM;AACL,mBAAO,MAAA,KAAW,YAAY,MAAA;AAC9B,mBAAO,SAAS;AAChB,mBAAO,QAAQ;UAChB;mBAED,QAAQ,OAAO,OAAO,SAAS,aAAa,aAAa,CAAA,EAEzD,QAAO,UAAU;eACZ;AACL,uBAAW,QAAQ,kCAAA;AACnB,mBAAO,MAAA,KAAW,MAAM,OAAO,SAAS;AACxC,mBAAO,SAAS;AAChB,mBAAO,QAAQ;UAChB;AAED;QAEF;AACE,gBAAM,IAAI,MAAM,QAAQ,oBAAoB,OAAO,KAAA;MAEtD;IACF;AAED,QAAI,OAAO,YAAY,OAAO,oBAC5B,mBAAkB,MAAA;AAEpB,WAAO;EACR;AAID,MAAI,CAAC,OAAO,cAAA,EACT,WAAY;AACX,QAAI,qBAAqB,OAAO;AAChC,QAAI,QAAQ,KAAK;AACjB,QAAI,gBAAgB,WAAY;AAC9B,UAAI,WAAW;AACf,UAAI,YAAY,CAAE;AAClB,UAAI;AACJ,UAAI;AACJ,UAAIG,SAAQ;AACZ,UAAI,SAAS,UAAU;AACvB,UAAI,CAAC,OACH,QAAO;AAET,UAAI,SAAS;AACb,aAAO,EAAEA,SAAQ,QAAQ;AACvB,YAAI,YAAY,OAAO,UAAUA,MAAA,CAAA;AACjC,YACE,CAAC,SAAS,SAAA,KACV,YAAY,KACZ,YAAY,WACZ,MAAM,SAAA,MAAe,UAErB,OAAM,WAAW,yBAAyB,SAAA;AAE5C,YAAI,aAAa,MAEf,WAAU,KAAK,SAAA;aACV;AAGL,uBAAa;AACb,2BAAiB,aAAa,MAAM;AACpC,yBAAgB,YAAY,OAAS;AACrC,oBAAU,KAAK,eAAe,YAAA;QAC/B;AACD,YAAIA,SAAQ,MAAM,UAAU,UAAU,SAAS,UAAU;AACvD,oBAAU,mBAAmB,MAAM,MAAM,SAAA;AACzC,oBAAU,SAAS;QACpB;MACF;AACD,aAAO;IACR;AAED,QAAI,OAAO,eACT,QAAO,eAAe,QAAQ,iBAAiB;MAC7C,OAAO;MACP,cAAc;MACd,UAAU;IACX,CAAA;QAED,QAAO,gBAAgB;EAE1B,GAAA;AAEH,SAAOJ;AACR;AAED,IAAM,MAAuB,cAAA;;;ACzlD7B,IAAa,0BAA0B;;;;;;;;;;;;;;;;;;;;;;;AA8BvC,IAAa,kBAAb,cAAqC,oCAA+C;EAClF;EAEA,YAAYK,QAAgC;AAC1C,UAAM,MAAA;AAEN,SAAK,OAAO,QAAQ;EACrB;EAED,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe,CAAC,kBAAkB,gBAAiB;EAEnD,kBAAkB;EAER,MACRC,MACAC,MACyB;AACzB,QAAI,CAAC,KACH,QAAO;AAET,QAAI,CAAC,KACH,QAAO,CAAC;MAAE,IAAI;MAAW,MAAM;MAAI,OAAO;IAAM,CAAC;AAEnD,WAAO,QAAQ,MAAM,IAAA;EACtB;EAED,MAAM,mBACJC,aACgC;AAChC,WAAO,iBAAiB,YAAY,CAAA,EAAG,IAAA;EACxC;EAED,MAAM,MAAMC,MAAkC;AAC5C,WAAO,iBAAiB,IAAA;EACzB;EAED,wBAAgC;AAC9B,UAAM,WAAW,CAAC,EAAE,KAAK,QAAQ,KAAK,KAAK,SAAS;AACpD,WAAO,WACH,wBAAwB,QAAQ,UAAU,KAAK,MAAM,KAAK,IAAA,KAAS,EAAA,IACnE;EACL;AACF;AAED,IAAM,QAAQ,CAACA,SACb,KACG,MAAM,IAAA,EACN,IAAI,CAAC,SAAS,KAAK,QAAQ,QAAQ,EAAA,CAAG,EACtC,KAAK,IAAA,EACL,KAAA;AAWL,IAAM,oBAAoB,CAACC,UAAmC;AAC5D,MAAI,OAAO,KAAK,KAAA,EAAO,WAAW,EAChC,QAAO,CAAE;AAEX,QAAMC,SAAoB,CAAE;AAC5B,MAAI,MAAM,SAAS,SAAS,GAAG;AAC7B,WAAO,MAAM,IAAA,IAAQ,MAAM,SAAS,IAAI,iBAAA;AACxC,WAAO;EACR,OAAM;AACL,WAAO,MAAM,IAAA,IAAQ,MAAM,QAAQ;AACnC,WAAO;EACR;AACF;AAED,SAAgB,iBAAiBC,GAAsB;AACrD,QAAM,gBAAgB,MAAM,CAAA;AAC5B,QAAM,SAAS,IAAI,OAAO,IAAA;AAC1B,MAAIC,eAA6B,CAAE;AACnC,QAAMC,eAA+B,CAAE;AAGvC,SAAO,YAAY,CAACC,SAAc;AAChC,UAAM,UAAU;MACd,MAAM,KAAK;MACX,YAAY,KAAK;MACjB,UAAU,CAAE;MACZ,MAAM;MACN,eAAe,KAAK;IACrB;AAED,QAAI,aAAa,SAAS,GAAG;AAC3B,YAAM,gBAAgB,aAAa,aAAa,SAAS,CAAA;AACzD,oBAAc,SAAS,KAAK,OAAA;IAC7B,MACC,gBAAe;AAGjB,QAAI,CAAC,KAAK,cACR,cAAa,KAAK,OAAA;EAErB;AAED,SAAO,aAAa,MAAM;AACxB,QAAI,aAAa,SAAS,GAAG;AAC3B,YAAM,cAAc,aAAa,IAAA;AACjC,UAAI,aAAa,WAAW,KAAK,YAC/B,gBAAe;IAElB;EACF;AAGD,SAAO,SAAS,CAACC,SAAc;AAC7B,QAAI,aAAa,SAAS,GAAG;AAC3B,YAAM,iBAAiB,aAAa,aAAa,SAAS,CAAA;AAC1D,qBAAe,QAAQ;IACxB;EACF;AAGD,SAAO,cAAc,CAACC,SAAc;AAClC,QAAI,aAAa,SAAS,GAAG;AAC3B,YAAM,iBAAiB,aAAa,aAAa,SAAS,CAAA;AAC1D,qBAAe,WAAW,KAAK,IAAA,IAAQ,KAAK;IAC7C;EACF;AAGD,QAAM,QAAQ,oBAAoB,KAAK,aAAA;AACvC,QAAM,YAAY,QAAQ,MAAM,CAAA,IAAK;AACrC,SAAO,MAAM,SAAA,EAAW,MAAA;AAGxB,MAAI,gBAAgB,aAAa,SAAS,OACxC,gBAAe,aAAa,SAAS,CAAA;AAGvC,SAAO,kBAAkB,YAAA;AAC1B;;;ACxKD,IAAI,yBAAyB,CAAC;AAC9BC,UAAS,wBAAwB;AAAA,EAChC,kCAAkC,MAAM;AAAA,EACxC,qCAAqC,MAAM;AAAA,EAC3C,qBAAqB,MAAM;AAAA,EAC3B,kBAAkB,MAAM;AAAA,EACxB,2BAA2B,MAAM;AAAA,EACjC,mBAAmB,MAAM;AAAA,EACzB,gCAAgC,MAAM;AAAA,EACtC,wBAAwB,MAAM;AAAA,EAC9B,oCAAoC,MAAM;AAAA,EAC1C,kBAAkB,MAAM;AAAA,EACxB,kBAAkB,MAAM;AAAA,EACxB,0BAA0B,MAAM;AAAA,EAChC,0BAA0B,MAAM;AAAA,EAChC,uBAAuB,MAAM;AAAA,EAC7B,oBAAoB,MAAM;AAAA,EAC1B,wBAAwB,MAAM;AAAA,EAC9B,iBAAiB,MAAM;AAAA,EACvB,yBAAyB,MAAM;AAAA,EAC/B,mBAAmB,MAAM;AAAA,EACzB,kBAAkB,MAAM;AAAA,EACxB,kBAAkB,MAAM;AACzB,CAAC;;;ACTD,IAAa,wBAAb,cAA2C,oBAA4B;EACrE,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAa;IAAkB;EAAmB;EAElE,kBAAkB;EAElB,WAAW;EAEX,YAAYC,SAAiC;AAC3C,UAAA;AACA,SAAK,WAAWC,SAAQ,YAAY,KAAK;EAC1C;;;;;;;EAQD,MAAM,YACJC,aACiB;AACjB,QAAI,aAAa,YAAY,CAAA,GAAI;AAC/B,YAAM,MAAM,YAAY,CAAA;AACxB,YAAM,eAAe,IAAI,QAAQ,kBAAkB;AACnD,UAAI,CAAC,aACH,OAAM,IAAI,MACR,+BAA+B,KAAK,UAAU,WAAA,CAAY,EAAE;AAGhE,UAAI,CAAC,aAAa,UAChB,OAAM,IAAI,MACR,iCAAiC,KAAK,UAAU,WAAA,CAAY,EAAE;AAGlE,UAAI,KAAK,SACP,QAAO,aAAa;AAEtB,aAAO,KAAK,UAAU,YAAA;IACvB,MACC,OAAM,IAAI,MACR,6BAA6B,KAAK,UAAU,WAAA,CAAY,EAAE;EAG/D;AACF;AAMD,IAAa,4BAAb,cAGU,oCAA4C;EACpD,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAa;IAAkB;EAAmB;EAElE,kBAAkB;EAElB;EAEA,WAAW;EAEX,YACEC,SACA;AACA,UAAMF,OAAA;AACN,SAAK,WAAWA,SAAQ,YAAY,KAAK;AACzC,SAAK,eAAe,IAAI,sBAAsBA,OAAA;EAC/C;EAES,MACRG,MACAC,MACkC;AAClC,QAAI,CAAC,KACH,QAAO;AAET,UAAM,MAAM,QAAQ,QAAQ,CAAE,GAAE,IAAA;AAChC,WAAO;EACR;EAED,MAAM,mBACJC,aAC6B;AAC7B,UAAM,aAAa,YAAY,CAAA;AAC/B,QAAI,CAAC,WAAW,QACd,QAAO;AAET,UAAM,EAAE,QAAA,IAAY;AACpB,UAAM,eAAe,QAAQ,kBAAkB;AAC/C,QAAI,CAAC,aACH,QAAO;AAET,QAAI,KAAK,SACP,QAAO,iBAAiB,aAAa,SAAA;AAGvC,WAAO;MACL,GAAG;MACH,WAAW,iBAAiB,aAAa,SAAA;IAE1C;EACF;;;;;;;EAQD,MAAM,YACJJ,aACiB;AACjB,UAAM,SAAS,MAAM,KAAK,aAAa,YAAY,WAAA;AACnD,QAAI,CAAC,OACH,OAAM,IAAI,MACR,0CAA0C,KAAK,UAAU,WAAA,CAAY,EAAE;AAG3E,WAAO,KAAK,MAAM,MAAA;EACnB;EAED,MAAM,MAAMK,MAA+B;AACzC,UAAM,eAAe,KAAK,MAAM,IAAA;AAChC,QAAI,KAAK,SACP,QAAO;AAET,iBAAa,YAAY,KAAK,MAAM,aAAa,SAAA;AACjD,WAAO;EACR;EAED,wBAAgC;AAC9B,WAAO;EACR;AACF;AAOD,IAAa,+BAAb,cAGU,oBAAuB;EAC/B,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAa;IAAkB;EAAmB;EAElE,kBAAkB;EAElB,eAAe,IAAI,0BAAA;EAEnB;EAEA,IAAI,aAAa;AACf,WAAO,EACL,UAAU,WACX;EACF;EAED,YAAYC,QAA8B;AACxC,UAAM,MAAA;AACN,SAAK,WAAW,OAAO;EACxB;;;;;;;EAQD,MAAM,YAAYN,aAA0D;AAC1E,UAAM,SAAS,MAAM,KAAK,aAAa,YAAY,WAAA;AACnD,WAAO,OAAO,KAAK,QAAA;EACpB;AACF;;;AChND,IAAI,2BAA2B,CAAC;AAChCO,UAAS,0BAA0B;AAAA,EAClC,8BAA8B,MAAM;AAAA,EACpC,2BAA2B,MAAM;AAAA,EACjC,uBAAuB,MAAM;AAC9B,CAAC;;;ACoCD,SAAgB,cAEdC,aACAC,SACsB;AACtB,MAAI,YAAY,aAAa,OAC3B,QAAO;AAET,MAAI;AACJ,MAAI,SAAS,QACX,KAAI;AACF,mBAAe,iBAAiB,YAAY,SAAS,aAAa,IAAA;EACnE,QAAO;AACN,WAAO;EACR;MAED,KAAI;AACF,mBAAe,KAAK,MAAM,YAAY,SAAS,SAAA;EAEhD,SAAQC,GAAQ;AACf,UAAM,IAAI,sBACR;MACE,aAAa,YAAY,SAAS,IAAA;MAClC;MACA,YAAY,SAAS;MACrB;MACA;MACA,UAAU,EAAE,OAAA;IACb,EAAC,KAAK,IAAA,CAAK;EAEf;AAGH,QAAMC,iBAA2B;IAC/B,MAAM,YAAY,SAAS;IAC3B,MAAM;IACN,MAAM;EACP;AAED,MAAI,SAAS,SACX,gBAAe,KAAK,YAAY;AAGlC,SAAO;AACR;AAED,SAAgB,iCAAiCC,UAAoB;AACnE,MAAI,SAAS,OAAO,OAClB,OAAM,IAAI,MAAM,gDAAgD;AAElE,SAAO;IACL,IAAI,SAAS;IACb,MAAM;IACN,UAAU;MACR,MAAM,SAAS;MACf,WAAW,KAAK,UAAU,SAAS,IAAA;IACpC;EACF;AACF;AAED,SAAgB,oBAEdJ,aACAK,UACiB;AACjB,SAAO;IACL,MAAM,YAAY,UAAU;IAC5B,MAAM,YAAY,UAAU;IAC5B,IAAI,YAAY;IAChB,OAAO;IACP,MAAM;EACP;AACF;AAKD,IAAa,wBAAb,cAEU,oCAAuC;EAC/C,OAAO,UAAU;AACf,WAAO;EACR;EAED,WAAW;EAEX,eAAe;IAAC;IAAa;IAAkB;EAAe;EAE9D,kBAAkB;EAElB,YAAYC,QAAsC;AAChD,UAAM,MAAA;AACN,SAAK,WAAW,QAAQ,YAAY,KAAK;EAC1C;EAES,QAAQ;AAChB,UAAM,IAAI,MAAM,gBAAA;EACjB;EAED,MAAM,QAAoB;AACxB,UAAM,IAAI,MAAM,kBAAA;EACjB;EAED,MAAM,YAAYC,aAA2C;AAC3D,UAAM,SAAS,MAAM,KAAK,mBAAmB,aAAa,KAAA;AAC1D,WAAO;EACR;;;;;;;EAQD,MAAM,mBACJC,aACA,UAAU,MAEI;AACd,UAAM,UAAU,YAAY,CAAA,EAAG;AAC/B,QAAI;AACJ,QAAI,YAAY,OAAA,KAAY,QAAQ,YAAY,OAC9C,aAAY,QAAQ,WAAW,IAAI,CAAC,aAAa;AAC/C,YAAM,EAAE,IAAI,GAAG,KAAA,IAAS;AACxB,UAAI,CAAC,KAAK,SACR,QAAO;AAET,aAAO;QACL;QACA,GAAG;MACJ;IACF,CAAA;aACQ,QAAQ,kBAAkB,eAAe,QAAW;AAC7D,YAAM,eAAe,KAAK,MACxB,KAAK,UAAU,QAAQ,kBAAkB,UAAA,CAAW;AAEtD,kBAAY,aAAa,IAAI,CAACC,gBAAyC;AACrE,eAAO,cAAc,aAAa;UAAE,UAAU,KAAK;UAAU;QAAS,CAAA;MACvE,CAAA;IACF;AACD,QAAI,CAAC,UACH,QAAO,CAAE;AAEX,UAAM,kBAAkB,CAAE;AAC1B,eAAW,YAAY,UACrB,KAAI,aAAa,QAAW;AAC1B,YAAMC,8BAA8C;QAClD,MAAM,SAAS;QACf,MAAM,SAAS;QACf,IAAI,SAAS;MACd;AACD,sBAAgB,KAAK,2BAAA;IACtB;AAEH,WAAO;EACR;AACF;AAgCD,IAAa,2BAAb,cAGU,sBAAyB;EACjC,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAa;IAAkB;EAAe;EAE9D,kBAAkB;EAElB,WAAW;;EAGX;;EAGA,eAAe;EAEf;EAQA,YACEC,QAIA;AACA,UAAM,MAAA;AACN,SAAK,UAAU,OAAO;AACtB,SAAK,eAAe,OAAO,gBAAgB,KAAK;AAChD,SAAK,YAAY,OAAO;EACzB;EAED,MAAgB,gBAAgBC,QAA6B;AAC3D,QAAI,KAAK,cAAc,OACrB,QAAO;AAET,UAAM,kBAAkB,MAAM,sBAAsB,KAAK,WAAW,MAAA;AACpE,QAAI,gBAAgB,QAClB,QAAO,gBAAgB;QAEvB,OAAM,IAAI,sBACR,2BAA2B,KAAK,UAC9B,QACA,MACA,CAAA,CACD,aAAa,KAAK,UAAU,gBAAgB,OAAO,MAAA,CAAO,IAC3D,KAAK,UAAU,QAAQ,MAAM,CAAA,CAAE;EAGpC;EAGD,MAAM,mBAAmBL,aAA6C;AACpE,UAAM,UAAU,MAAM,MAAM,mBAAmB,WAAA;AAC/C,UAAM,kBAAkB,QAAQ,OAC9B,CAACM,WAA2B,OAAO,SAAS,KAAK,OAAA;AAGnD,QAAIC,iBACF;AACF,QAAI,CAAC,gBAAgB,OACnB,QAAO;AAET,QAAI,CAAC,KAAK,SACR,kBAAiB,gBAAgB,IAC/B,CAACD,WAA2B,OAAO,IAAA;AAGvC,QAAI,KAAK,aACP,QAAO,eAAe,CAAA;AAExB,WAAO;EACR;EAGD,MAAM,YAAYN,aAA6C;AAC7D,UAAM,UAAU,MAAM,MAAM,mBAAmB,aAAa,KAAA;AAC5D,UAAM,kBAAkB,QAAQ,OAC9B,CAACM,WAA2B,OAAO,SAAS,KAAK,OAAA;AAGnD,QAAIC,iBACF;AACF,QAAI,CAAC,gBAAgB,OACnB,QAAO;AAET,QAAI,CAAC,KAAK,SACR,kBAAiB,gBAAgB,IAC/B,CAACD,WAA2B,OAAO,IAAA;AAGvC,QAAI,KAAK,aACP,QAAO,KAAK,gBAAgB,eAAe,CAAA,CAAA;AAE7C,UAAM,kBAAkB,MAAM,QAAQ,IACpC,eAAe,IAAI,CAAC,UAAU,KAAK,gBAAgB,KAAA,CAAM,CAAC;AAE5D,WAAO;EACR;AACF;;;AChVD,IAAI,uBAAuB,CAAC;AAC5BE,UAAS,sBAAsB;AAAA,EAC9B,0BAA0B,MAAM;AAAA,EAChC,uBAAuB,MAAM;AAAA,EAC7B,kCAAkC,MAAM;AAAA,EACxC,qBAAqB,MAAM;AAAA,EAC3B,eAAe,MAAM;AACtB,CAAC;;;ACoCD,IAAsB,qBAAtB,cAOU,SAEV;EAGE,kBAAkB;EAElB,eAAe;IAAC;IAAkB;IAAW,KAAK,eAAA;EAAiB;EAEnE,IAAI,gBAA8C;AAChD,WAAO,EACL,kBAAkB,OACnB;EACF;EAED;EAEA;EAEA;;;;EAKA;;EAGA;EAEA,YAAYC,OAAgC;AAC1C,UAAM,KAAA;AACN,UAAM,EAAE,eAAA,IAAmB;AAC3B,QAAI,eAAe,SAAS,MAAA,EAC1B,OAAM,IAAI,MACR,sFAAA;AAGJ,WAAO,OAAO,MAAM,KAAA;EACrB;;;;;;EAWD,MAAM,6BACJC,eAGA;AACA,UAAM,mBAAmB,KAAK,oBAAoB,CAAE;AACpD,UAAMC,gBAAwC,CAAE;AAEhD,eAAW,CAAC,KAAK,KAAA,KAAU,OAAO,QAAQ,gBAAA,EACxC,KAAI,OAAO,UAAU,SACnB,eAAc,GAAA,IAAO;QAErB,eAAc,GAAA,IAAO,MAAO,MAAA;AAIhC,UAAM,YAAY;MAChB,GAAI;MACJ,GAAG;IACJ;AACD,WAAO;EACR;;;;;;;EAQD,MAAM,OACJC,OACAC,SACoB;AACpB,UAAM,WAAW;MACf,GAAG,KAAK;MACR,GAAG,SAAS;IACb;AACD,UAAM,OAAO,CAAC,GAAI,KAAK,QAAQ,CAAE,GAAG,GAAI,SAAS,QAAQ,CAAE,CAAE;AAC7D,WAAO,KAAK,gBACV,CAACD,YAAoB,KAAK,kBAAkBE,OAAAA,GAC5C,OACA;MAAE,GAAG;MAAS;MAAM;MAAU,SAAS;IAAU,CAAA;EAEpD;AA4BF;;;AC/JD,IAAsB,2BAAtB,cAKU,mBAIR;;;;;;;EAOA,MAAM,kBACJC,QACqC;AACrC,UAAM,kBAAkB,MAAM,KAAK,OAAO,MAAA;AAC1C,WAAO,IAAI,kBAAkB,eAAA;EAC9B;AACF;;;AChCD,IAAI,iBAAiB,OAAO,UAAU;AACtC,IAAI,UAAU,MAAM,WAAW,SAAS,gBAAiBC,SAAQ;AAC/D,SAAO,eAAe,KAAKA,OAAM,MAAM;AACzC;AAEA,SAAS,WAAYA,SAAQ;AAC3B,SAAO,OAAOA,YAAW;AAC3B;AAMA,SAAS,QAAS,KAAK;AACrB,SAAO,QAAQ,GAAG,IAAI,UAAU,OAAO;AACzC;AAEA,SAAS,aAAcC,SAAQ;AAC7B,SAAOA,QAAO,QAAQ,+BAA+B,MAAM;AAC7D;AAMA,SAAS,YAAa,KAAK,UAAU;AACnC,SAAO,OAAO,QAAQ,OAAO,QAAQ,YAAa,YAAY;AAChE;AAMA,SAAS,wBAAyB,WAAW,UAAU;AACrD,SACE,aAAa,QACV,OAAO,cAAc,YACrB,UAAU,kBACV,UAAU,eAAe,QAAQ;AAExC;AAIA,IAAI,aAAa,OAAO,UAAU;AAClC,SAAS,WAAY,IAAIA,SAAQ;AAC/B,SAAO,WAAW,KAAK,IAAIA,OAAM;AACnC;AAEA,IAAI,aAAa;AACjB,SAAS,aAAcA,SAAQ;AAC7B,SAAO,CAAC,WAAW,YAAYA,OAAM;AACvC;AAEA,IAAI,YAAY;AAAA,EACd,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACP;AAEA,SAAS,WAAYA,SAAQ;AAC3B,SAAO,OAAOA,OAAM,EAAE,QAAQ,gBAAgB,SAAS,cAAe,GAAG;AACvE,WAAO,UAAU,CAAC;AAAA,EACpB,CAAC;AACH;AAEA,IAAI,UAAU;AACd,IAAI,UAAU;AACd,IAAI,WAAW;AACf,IAAI,UAAU;AACd,IAAI,QAAQ;AA4BZ,SAAS,cAAe,UAAU,MAAM;AACtC,MAAI,CAAC;AACH,WAAO,CAAC;AACV,MAAI,kBAAkB;AACtB,MAAI,WAAW,CAAC;AAChB,MAAI,SAAS,CAAC;AACd,MAAI,SAAS,CAAC;AACd,MAAI,SAAS;AACb,MAAI,WAAW;AACf,MAAI,cAAc;AAClB,MAAI,WAAW;AAIf,WAAS,aAAc;AACrB,QAAI,UAAU,CAAC,UAAU;AACvB,aAAO,OAAO;AACZ,eAAO,OAAO,OAAO,IAAI,CAAC;AAAA,IAC9B,OAAO;AACL,eAAS,CAAC;AAAA,IACZ;AAEA,aAAS;AACT,eAAW;AAAA,EACb;AAEA,MAAI,cAAc,cAAc;AAChC,WAAS,YAAa,eAAe;AACnC,QAAI,OAAO,kBAAkB;AAC3B,sBAAgB,cAAc,MAAM,SAAS,CAAC;AAEhD,QAAI,CAAC,QAAQ,aAAa,KAAK,cAAc,WAAW;AACtD,YAAM,IAAI,MAAM,mBAAmB,aAAa;AAElD,mBAAe,IAAI,OAAO,aAAa,cAAc,CAAC,CAAC,IAAI,MAAM;AACjE,mBAAe,IAAI,OAAO,SAAS,aAAa,cAAc,CAAC,CAAC,CAAC;AACjE,qBAAiB,IAAI,OAAO,SAAS,aAAa,MAAM,cAAc,CAAC,CAAC,CAAC;AAAA,EAC3E;AAEA,cAAY,QAAQ,SAAS,IAAI;AAEjC,MAAI,UAAU,IAAI,QAAQ,QAAQ;AAElC,MAAI,OAAO,MAAM,OAAO,KAAK,OAAO;AACpC,SAAO,CAAC,QAAQ,IAAI,GAAG;AACrB,YAAQ,QAAQ;AAGhB,YAAQ,QAAQ,UAAU,YAAY;AAEtC,QAAI,OAAO;AACT,eAAS,IAAI,GAAG,cAAc,MAAM,QAAQ,IAAI,aAAa,EAAE,GAAG;AAChE,cAAM,MAAM,OAAO,CAAC;AAEpB,YAAI,aAAa,GAAG,GAAG;AACrB,iBAAO,KAAK,OAAO,MAAM;AACzB,yBAAe;AAAA,QACjB,OAAO;AACL,qBAAW;AACX,4BAAkB;AAClB,yBAAe;AAAA,QACjB;AAEA,eAAO,KAAK,CAAE,QAAQ,KAAK,OAAO,QAAQ,CAAE,CAAC;AAC7C,iBAAS;AAGT,YAAI,QAAQ,MAAM;AAChB,qBAAW;AACX,wBAAc;AACd,qBAAW;AACX,4BAAkB;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,CAAC,QAAQ,KAAK,YAAY;AAC5B;AAEF,aAAS;AAGT,WAAO,QAAQ,KAAK,KAAK,KAAK;AAC9B,YAAQ,KAAK,OAAO;AAGpB,QAAI,SAAS,KAAK;AAChB,cAAQ,QAAQ,UAAU,QAAQ;AAClC,cAAQ,KAAK,QAAQ;AACrB,cAAQ,UAAU,YAAY;AAAA,IAChC,WAAW,SAAS,KAAK;AACvB,cAAQ,QAAQ,UAAU,cAAc;AACxC,cAAQ,KAAK,OAAO;AACpB,cAAQ,UAAU,YAAY;AAC9B,aAAO;AAAA,IACT,OAAO;AACL,cAAQ,QAAQ,UAAU,YAAY;AAAA,IACxC;AAGA,QAAI,CAAC,QAAQ,KAAK,YAAY;AAC5B,YAAM,IAAI,MAAM,qBAAqB,QAAQ,GAAG;AAElD,QAAI,QAAQ,KAAK;AACf,cAAQ,CAAE,MAAM,OAAO,OAAO,QAAQ,KAAK,aAAa,UAAU,eAAgB;AAAA,IACpF,OAAO;AACL,cAAQ,CAAE,MAAM,OAAO,OAAO,QAAQ,GAAI;AAAA,IAC5C;AACA;AACA,WAAO,KAAK,KAAK;AAEjB,QAAI,SAAS,OAAO,SAAS,KAAK;AAChC,eAAS,KAAK,KAAK;AAAA,IACrB,WAAW,SAAS,KAAK;AAEvB,oBAAc,SAAS,IAAI;AAE3B,UAAI,CAAC;AACH,cAAM,IAAI,MAAM,uBAAuB,QAAQ,UAAU,KAAK;AAEhE,UAAI,YAAY,CAAC,MAAM;AACrB,cAAM,IAAI,MAAM,uBAAuB,YAAY,CAAC,IAAI,UAAU,KAAK;AAAA,IAC3E,WAAW,SAAS,UAAU,SAAS,OAAO,SAAS,KAAK;AAC1D,iBAAW;AAAA,IACb,WAAW,SAAS,KAAK;AAEvB,kBAAY,KAAK;AAAA,IACnB;AAAA,EACF;AAEA,aAAW;AAGX,gBAAc,SAAS,IAAI;AAE3B,MAAI;AACF,UAAM,IAAI,MAAM,uBAAuB,YAAY,CAAC,IAAI,UAAU,QAAQ,GAAG;AAE/E,SAAO,WAAW,aAAa,MAAM,CAAC;AACxC;AAMA,SAAS,aAAc,QAAQ;AAC7B,MAAI,iBAAiB,CAAC;AAEtB,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,YAAY,OAAO,QAAQ,IAAI,WAAW,EAAE,GAAG;AAC7D,YAAQ,OAAO,CAAC;AAEhB,QAAI,OAAO;AACT,UAAI,MAAM,CAAC,MAAM,UAAU,aAAa,UAAU,CAAC,MAAM,QAAQ;AAC/D,kBAAU,CAAC,KAAK,MAAM,CAAC;AACvB,kBAAU,CAAC,IAAI,MAAM,CAAC;AAAA,MACxB,OAAO;AACL,uBAAe,KAAK,KAAK;AACzB,oBAAY;AAAA,MACd;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAQA,SAAS,WAAY,QAAQ;AAC3B,MAAI,eAAe,CAAC;AACpB,MAAI,YAAY;AAChB,MAAI,WAAW,CAAC;AAEhB,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,YAAY,OAAO,QAAQ,IAAI,WAAW,EAAE,GAAG;AAC7D,YAAQ,OAAO,CAAC;AAEhB,YAAQ,MAAM,CAAC,GAAG;AAAA,MAChB,KAAK;AAAA,MACL,KAAK;AACH,kBAAU,KAAK,KAAK;AACpB,iBAAS,KAAK,KAAK;AACnB,oBAAY,MAAM,CAAC,IAAI,CAAC;AACxB;AAAA,MACF,KAAK;AACH,kBAAU,SAAS,IAAI;AACvB,gBAAQ,CAAC,IAAI,MAAM,CAAC;AACpB,oBAAY,SAAS,SAAS,IAAI,SAAS,SAAS,SAAS,CAAC,EAAE,CAAC,IAAI;AACrE;AAAA,MACF;AACE,kBAAU,KAAK,KAAK;AAAA,IACxB;AAAA,EACF;AAEA,SAAO;AACT;AAMA,SAAS,QAASA,SAAQ;AACxB,OAAK,SAASA;AACd,OAAK,OAAOA;AACZ,OAAK,MAAM;AACb;AAKA,QAAQ,UAAU,MAAM,SAAS,MAAO;AACtC,SAAO,KAAK,SAAS;AACvB;AAMA,QAAQ,UAAU,OAAO,SAAS,KAAM,IAAI;AAC1C,MAAI,QAAQ,KAAK,KAAK,MAAM,EAAE;AAE9B,MAAI,CAAC,SAAS,MAAM,UAAU;AAC5B,WAAO;AAET,MAAIA,UAAS,MAAM,CAAC;AAEpB,OAAK,OAAO,KAAK,KAAK,UAAUA,QAAO,MAAM;AAC7C,OAAK,OAAOA,QAAO;AAEnB,SAAOA;AACT;AAMA,QAAQ,UAAU,YAAY,SAAS,UAAW,IAAI;AACpD,MAAIC,SAAQ,KAAK,KAAK,OAAO,EAAE,GAAG;AAElC,UAAQA,QAAO;AAAA,IACb,KAAK;AACH,cAAQ,KAAK;AACb,WAAK,OAAO;AACZ;AAAA,IACF,KAAK;AACH,cAAQ;AACR;AAAA,IACF;AACE,cAAQ,KAAK,KAAK,UAAU,GAAGA,MAAK;AACpC,WAAK,OAAO,KAAK,KAAK,UAAUA,MAAK;AAAA,EACzC;AAEA,OAAK,OAAO,MAAM;AAElB,SAAO;AACT;AAMA,SAAS,QAASC,OAAM,eAAe;AACrC,OAAK,OAAOA;AACZ,OAAK,QAAQ,EAAE,KAAK,KAAK,KAAK;AAC9B,OAAK,SAAS;AAChB;AAMA,QAAQ,UAAU,OAAO,SAAS,KAAMA,OAAM;AAC5C,SAAO,IAAI,QAAQA,OAAM,IAAI;AAC/B;AAMA,QAAQ,UAAU,SAAS,SAAS,OAAQ,MAAM;AAChD,MAAI,QAAQ,KAAK;AAEjB,MAAI;AACJ,MAAI,MAAM,eAAe,IAAI,GAAG;AAC9B,YAAQ,MAAM,IAAI;AAAA,EACpB,OAAO;AACL,QAAIC,WAAU,MAAM,mBAAmB,OAAOF,QAAO,YAAY;AAEjE,WAAOE,UAAS;AACd,UAAI,KAAK,QAAQ,GAAG,IAAI,GAAG;AACzB,4BAAoBA,SAAQ;AAC5B,gBAAQ,KAAK,MAAM,GAAG;AACtB,QAAAF,SAAQ;AAmBR,eAAO,qBAAqB,QAAQA,SAAQ,MAAM,QAAQ;AACxD,cAAIA,WAAU,MAAM,SAAS;AAC3B,wBACE,YAAY,mBAAmB,MAAMA,MAAK,CAAC,KACxC,wBAAwB,mBAAmB,MAAMA,MAAK,CAAC;AAG9D,8BAAoB,kBAAkB,MAAMA,QAAO,CAAC;AAAA,QACtD;AAAA,MACF,OAAO;AACL,4BAAoBE,SAAQ,KAAK,IAAI;AAqBrC,oBAAY,YAAYA,SAAQ,MAAM,IAAI;AAAA,MAC5C;AAEA,UAAI,WAAW;AACb,gBAAQ;AACR;AAAA,MACF;AAEA,MAAAA,WAAUA,SAAQ;AAAA,IACpB;AAEA,UAAM,IAAI,IAAI;AAAA,EAChB;AAEA,MAAI,WAAW,KAAK;AAClB,YAAQ,MAAM,KAAK,KAAK,IAAI;AAE9B,SAAO;AACT;AAOA,SAAS,SAAU;AACjB,OAAK,gBAAgB;AAAA,IACnB,QAAQ,CAAC;AAAA,IACT,KAAK,SAASC,KAAK,KAAK,OAAO;AAC7B,WAAK,OAAO,GAAG,IAAI;AAAA,IACrB;AAAA,IACA,KAAK,SAAS,IAAK,KAAK;AACtB,aAAO,KAAK,OAAO,GAAG;AAAA,IACxB;AAAA,IACA,OAAO,SAAS,QAAS;AACvB,WAAK,SAAS,CAAC;AAAA,IACjB;AAAA,EACF;AACF;AAKA,OAAO,UAAU,aAAa,SAAS,aAAc;AACnD,MAAI,OAAO,KAAK,kBAAkB,aAAa;AAC7C,SAAK,cAAc,MAAM;AAAA,EAC3B;AACF;AAOA,OAAO,UAAU,QAAQ,SAAS,MAAO,UAAU,MAAM;AACvD,MAAI,QAAQ,KAAK;AACjB,MAAI,WAAW,WAAW,OAAO,QAAQ,SAAS,MAAM,KAAK,GAAG;AAChE,MAAI,iBAAiB,OAAO,UAAU;AACtC,MAAI,SAAS,iBAAiB,MAAM,IAAI,QAAQ,IAAI;AAEpD,MAAI,UAAU,QAAW;AACvB,aAAS,cAAc,UAAU,IAAI;AACrC,sBAAkB,MAAM,IAAI,UAAU,MAAM;AAAA,EAC9C;AACA,SAAO;AACT;AAyBA,OAAO,UAAU,SAAS,SAAS,OAAQ,UAAUF,OAAM,UAAUG,SAAQ;AAC3E,MAAI,OAAO,KAAK,cAAcA,OAAM;AACpC,MAAI,SAAS,KAAK,MAAM,UAAU,IAAI;AACtC,MAAIF,WAAWD,iBAAgB,UAAWA,QAAO,IAAI,QAAQA,OAAM,MAAS;AAC5E,SAAO,KAAK,aAAa,QAAQC,UAAS,UAAU,UAAUE,OAAM;AACtE;AAWA,OAAO,UAAU,eAAe,SAAS,aAAc,QAAQF,UAAS,UAAU,kBAAkBE,SAAQ;AAC1G,MAAI,SAAS;AAEb,MAAI,OAAOC,SAAQ;AACnB,WAAS,IAAI,GAAG,YAAY,OAAO,QAAQ,IAAI,WAAW,EAAE,GAAG;AAC7D,YAAQ;AACR,YAAQ,OAAO,CAAC;AAChB,IAAAA,UAAS,MAAM,CAAC;AAEhB,QAAIA,YAAW,IAAK,SAAQ,KAAK,cAAc,OAAOH,UAAS,UAAU,kBAAkBE,OAAM;AAAA,aACxFC,YAAW,IAAK,SAAQ,KAAK,eAAe,OAAOH,UAAS,UAAU,kBAAkBE,OAAM;AAAA,aAC9FC,YAAW,IAAK,SAAQ,KAAK,cAAc,OAAOH,UAAS,UAAUE,OAAM;AAAA,aAC3EC,YAAW,IAAK,SAAQ,KAAK,eAAe,OAAOH,QAAO;AAAA,aAC1DG,YAAW,OAAQ,SAAQ,KAAK,aAAa,OAAOH,UAASE,OAAM;AAAA,aACnEC,YAAW,OAAQ,SAAQ,KAAK,SAAS,KAAK;AAEvD,QAAI,UAAU;AACZ,gBAAU;AAAA,EACd;AAEA,SAAO;AACT;AAEA,OAAO,UAAU,gBAAgB,SAAS,cAAe,OAAOH,UAAS,UAAU,kBAAkBE,SAAQ;AAC3G,MAAI,OAAO;AACX,MAAI,SAAS;AACb,MAAI,QAAQF,SAAQ,OAAO,MAAM,CAAC,CAAC;AAInC,WAAS,UAAW,UAAU;AAC5B,WAAO,KAAK,OAAO,UAAUA,UAAS,UAAUE,OAAM;AAAA,EACxD;AAEA,MAAI,CAAC,MAAO;AAEZ,MAAI,QAAQ,KAAK,GAAG;AAClB,aAAS,IAAI,GAAG,cAAc,MAAM,QAAQ,IAAI,aAAa,EAAE,GAAG;AAChE,gBAAU,KAAK,aAAa,MAAM,CAAC,GAAGF,SAAQ,KAAK,MAAM,CAAC,CAAC,GAAG,UAAU,kBAAkBE,OAAM;AAAA,IAClG;AAAA,EACF,WAAW,OAAO,UAAU,YAAY,OAAO,UAAU,YAAY,OAAO,UAAU,UAAU;AAC9F,cAAU,KAAK,aAAa,MAAM,CAAC,GAAGF,SAAQ,KAAK,KAAK,GAAG,UAAU,kBAAkBE,OAAM;AAAA,EAC/F,WAAW,WAAW,KAAK,GAAG;AAC5B,QAAI,OAAO,qBAAqB;AAC9B,YAAM,IAAI,MAAM,gEAAgE;AAGlF,YAAQ,MAAM,KAAKF,SAAQ,MAAM,iBAAiB,MAAM,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,SAAS;AAEtF,QAAI,SAAS;AACX,gBAAU;AAAA,EACd,OAAO;AACL,cAAU,KAAK,aAAa,MAAM,CAAC,GAAGA,UAAS,UAAU,kBAAkBE,OAAM;AAAA,EACnF;AACA,SAAO;AACT;AAEA,OAAO,UAAU,iBAAiB,SAAS,eAAgB,OAAOF,UAAS,UAAU,kBAAkBE,SAAQ;AAC7G,MAAI,QAAQF,SAAQ,OAAO,MAAM,CAAC,CAAC;AAInC,MAAI,CAAC,SAAU,QAAQ,KAAK,KAAK,MAAM,WAAW;AAChD,WAAO,KAAK,aAAa,MAAM,CAAC,GAAGA,UAAS,UAAU,kBAAkBE,OAAM;AAClF;AAEA,OAAO,UAAU,gBAAgB,SAAS,cAAe,SAAS,aAAa,iBAAiB;AAC9F,MAAI,sBAAsB,YAAY,QAAQ,WAAW,EAAE;AAC3D,MAAI,cAAc,QAAQ,MAAM,IAAI;AACpC,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,QAAI,YAAY,CAAC,EAAE,WAAW,IAAI,KAAK,CAAC,kBAAkB;AACxD,kBAAY,CAAC,IAAI,sBAAsB,YAAY,CAAC;AAAA,IACtD;AAAA,EACF;AACA,SAAO,YAAY,KAAK,IAAI;AAC9B;AAEA,OAAO,UAAU,gBAAgB,SAAS,cAAe,OAAOF,UAAS,UAAUE,SAAQ;AACzF,MAAI,CAAC,SAAU;AACf,MAAI,OAAO,KAAK,cAAcA,OAAM;AAEpC,MAAI,QAAQ,WAAW,QAAQ,IAAI,SAAS,MAAM,CAAC,CAAC,IAAI,SAAS,MAAM,CAAC,CAAC;AACzE,MAAI,SAAS,MAAM;AACjB,QAAI,kBAAkB,MAAM,CAAC;AAC7B,QAAI,WAAW,MAAM,CAAC;AACtB,QAAI,cAAc,MAAM,CAAC;AACzB,QAAI,gBAAgB;AACpB,QAAI,YAAY,KAAK,aAAa;AAChC,sBAAgB,KAAK,cAAc,OAAO,aAAa,eAAe;AAAA,IACxE;AACA,QAAI,SAAS,KAAK,MAAM,eAAe,IAAI;AAC3C,WAAO,KAAK,aAAa,QAAQF,UAAS,UAAU,eAAeE,OAAM;AAAA,EAC3E;AACF;AAEA,OAAO,UAAU,iBAAiB,SAAS,eAAgB,OAAOF,UAAS;AACzE,MAAI,QAAQA,SAAQ,OAAO,MAAM,CAAC,CAAC;AACnC,MAAI,SAAS;AACX,WAAO;AACX;AAEA,OAAO,UAAU,eAAe,SAAS,aAAc,OAAOA,UAASE,SAAQ;AAC7E,MAAI,SAAS,KAAK,gBAAgBA,OAAM,KAAK,SAAS;AACtD,MAAI,QAAQF,SAAQ,OAAO,MAAM,CAAC,CAAC;AACnC,MAAI,SAAS;AACX,WAAQ,OAAO,UAAU,YAAY,WAAW,SAAS,SAAU,OAAO,KAAK,IAAI,OAAO,KAAK;AACnG;AAEA,OAAO,UAAU,WAAW,SAAS,SAAU,OAAO;AACpD,SAAO,MAAM,CAAC;AAChB;AAEA,OAAO,UAAU,gBAAgB,SAAS,cAAeE,SAAQ;AAC/D,MAAI,QAAQA,OAAM,GAAG;AACnB,WAAOA;AAAA,EACT,WACSA,WAAU,OAAOA,YAAW,UAAU;AAC7C,WAAOA,QAAO;AAAA,EAChB,OACK;AACH,WAAO;AAAA,EACT;AACF;AAEA,OAAO,UAAU,kBAAkB,SAAS,gBAAiBA,SAAQ;AACnE,MAAIA,WAAU,OAAOA,YAAW,YAAY,CAAC,QAAQA,OAAM,GAAG;AAC5D,WAAOA,QAAO;AAAA,EAChB,OACK;AACH,WAAO;AAAA,EACT;AACF;AAEA,IAAI,WAAW;AAAA,EACb,MAAM;AAAA,EACN,SAAS;AAAA,EACT,MAAM,CAAE,MAAM,IAAK;AAAA,EACnB,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,SAAS;AAAA,EACT,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMR,IAAI,cAAe,OAAO;AACxB,kBAAc,gBAAgB;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,gBAAiB;AACnB,WAAO,cAAc;AAAA,EACvB;AACF;AAGA,IAAI,gBAAgB,IAAI,OAAO;AAK/B,SAAS,aAAa,SAASE,cAAc;AAC3C,SAAO,cAAc,WAAW;AAClC;AAOA,SAAS,QAAQ,SAASC,OAAO,UAAU,MAAM;AAC/C,SAAO,cAAc,MAAM,UAAU,IAAI;AAC3C;AAMA,SAAS,SAAS,SAASC,QAAQ,UAAUP,OAAM,UAAUG,SAAQ;AACnE,MAAI,OAAO,aAAa,UAAU;AAChC,UAAM,IAAI,UAAU,0DACU,QAAQ,QAAQ,IAAI,iFAC0B;AAAA,EAC9E;AAEA,SAAO,cAAc,OAAO,UAAUH,OAAM,UAAUG,OAAM;AAC9D;AAIA,SAAS,SAAS;AAGlB,SAAS,UAAU;AACnB,SAAS,UAAU;AACnB,SAAS,SAAS;AAElB,IAAO,mBAAQ;;;ACtvBf,SAAS,oBAAoB;AAG3B,mBAAS,SAAS,CAAC,SAAS;AAC7B;AAqBD,IAAa,eAAe,CAACK,aAA2C;AAGtE,QAAM,QAAQ,SAAS,MAAM,EAAA;AAC7B,QAAMC,QAA8B,CAAE;AAEtC,QAAM,cAAc,CAACC,SAA2BC,UAAkB;AAChE,aAASC,MAAI,OAAOA,MAAI,MAAM,QAAQA,OAAK,EACzC,KAAI,QAAQ,SAAS,MAAMA,GAAAA,CAAAA,EACzB,QAAOA;AAGX,WAAO;EACR;AAED,MAAI,IAAI;AACR,SAAO,IAAI,MAAM,OACf,KAAI,MAAM,CAAA,MAAO,OAAO,IAAI,IAAI,MAAM,UAAU,MAAM,IAAI,CAAA,MAAO,KAAK;AACpE,UAAM,KAAK;MAAE,MAAM;MAAW,MAAM;IAAK,CAAA;AACzC,SAAK;EACN,WACC,MAAM,CAAA,MAAO,OACb,IAAI,IAAI,MAAM,UACd,MAAM,IAAI,CAAA,MAAO,KACjB;AACA,UAAM,KAAK;MAAE,MAAM;MAAW,MAAM;IAAK,CAAA;AACzC,SAAK;EACN,WAAU,MAAM,CAAA,MAAO,KAAK;AAC3B,UAAM,IAAI,YAAY,KAAK,CAAA;AAC3B,QAAI,IAAI,EACN,OAAM,IAAI,MAAM,2BAAA;AAGlB,UAAM,KAAK;MACT,MAAM;MACN,MAAM,MAAM,MAAM,IAAI,GAAG,CAAA,EAAG,KAAK,EAAA;IAClC,CAAA;AACD,QAAI,IAAI;EACT,WAAU,MAAM,CAAA,MAAO,IACtB,OAAM,IAAI,MAAM,yBAAA;OACX;AACL,UAAM,OAAO,YAAY,MAAM,CAAA;AAC/B,UAAM,QAAQ,OAAO,IAAI,MAAM,MAAM,CAAA,IAAK,MAAM,MAAM,GAAG,IAAA,GAAO,KAAK,EAAA;AACrE,UAAM,KAAK;MAAE,MAAM;MAAW;IAAM,CAAA;AACpC,QAAI,OAAO,IAAI,MAAM,SAAS;EAC/B;AAEH,SAAO;AACR;AAUD,IAAM,0BAA0B,CAC9BC,UACAC,WAAoB,CAAE,MACG;AACzB,QAAML,QAA8B,CAAE;AAEtC,aAAW,QAAQ,SACjB,KAAI,KAAK,CAAA,MAAO,QAAQ;AACtB,UAAM,OAAO,KAAK,CAAA,EAAG,SAAS,GAAA,IAAO,KAAK,CAAA,EAAG,MAAM,GAAA,EAAK,CAAA,IAAK,KAAK,CAAA;AAClE,UAAM,KAAK;MAAE,MAAM;MAAY;IAAM,CAAA;EACtC,WAAU;IAAC;IAAK;IAAK;IAAK;EAAI,EAAC,SAAS,KAAK,CAAA,CAAA,GAAK;AAGjD,UAAM,KAAK;MAAE,MAAM;MAAY,MAAM,KAAK,CAAA;IAAI,CAAA;AAG9C,QAAI,KAAK,CAAA,MAAO,OAAO,KAAK,SAAS,KAAK,MAAM,QAAQ,KAAK,CAAA,CAAA,GAAK;AAChE,YAAM,aAAa,CAAC,GAAGM,UAAS,KAAK,CAAA,CAAG;AACxC,YAAM,cAAc,wBAAwB,KAAK,CAAA,GAAI,UAAA;AACrD,YAAM,KAAK,GAAG,WAAA;IACf;EACF,MACC,OAAM,KAAK;IAAE,MAAM;IAAW,MAAM,KAAK,CAAA;EAAI,CAAA;AAIjD,SAAO;AACR;AAED,IAAa,gBAAgB,CAACP,aAAqB;AACjD,oBAAA;AACA,QAAM,SAAS,iBAAS,MAAM,QAAA;AAC9B,SAAO,wBAAwB,MAAA;AAChC;AAED,IAAa,qBAAqB,CAACA,UAAkBQ,WAAwB;AAC3E,SAAO,aAAa,QAAA,EAAU,OAAO,CAAC,KAAK,SAAS;AAClD,QAAI,KAAK,SAAS,YAAY;AAC5B,UAAI,KAAK,QAAQ,QAAQ;AACvB,cAAM,cACJ,OAAO,OAAO,KAAK,IAAA,MAAU,WACzB,OAAO,KAAK,IAAA,IACZ,KAAK,UAAU,OAAO,KAAK,IAAA,CAAA;AACjC,eAAO,MAAM;MACd;AACD,YAAM,IAAI,MAAM,sCAAsC,KAAK,IAAA,EAAM;IAClE;AAED,WAAO,MAAM,KAAK;EACnB,GAAE,EAAA;AACJ;AAED,IAAa,sBAAsB,CAACR,UAAkBQ,WAAwB;AAC5E,oBAAA;AACA,SAAO,iBAAS,OAAO,UAAU,MAAA;AAClC;AAeD,IAAaC,4BAAkE;EAC7E,YAAY;EACZ,UAAU;AACX;AAED,IAAaC,yBAAyD;EACpE,YAAY;EACZ,UAAU;AACX;AAED,IAAa,iBAAiB,CAC5BV,UACAW,gBACAC,gBACG;AACH,MAAI;AACF,WAAO,0BAA0B,cAAA,EAAgB,UAAU,WAAA;EAC5D,SAAQ,GAAG;AACV,UAAM,QAAQ,wBAAwB,GAAG,sBAAA;AACzC,UAAM;EACP;AACF;AAED,IAAaC,iBAAgB,CAC3Bb,UACAW,mBACG,uBAAuB,cAAA,EAAgB,QAAA;AAE5C,IAAa,qBAAqB,CAChCG,UACAH,gBACAI,mBACG;AACH,MAAI,EAAE,kBAAkB,4BAA4B;AAClD,UAAM,eAAe,OAAO,KAAK,yBAAA;AACjC,UAAM,IAAI,MAAM,kCAAkC,cAAA;4CACV,YAAA,EAAc;EACvD;AACD,MAAI;AAGF,UAAMC,cAA2B,OAAO,YACtC,eAAe,IAAI,CAAC,MAAM,CAAC,GAAG,KAAM,CAAA,CAAC;AAEvC,QAAI,MAAM,QAAQ,QAAA,EAChB,UAAS,QAAQ,CAAC,YAAY;AAC5B,UACE,QAAQ,SAAS,UACjB,UAAU,WACV,OAAO,QAAQ,SAAS,SAExB,gBAAe,QAAQ,MAAM,gBAAgB,WAAA;eACpC,QAAQ,SAAS,aAC1B;YAAI,OAAO,QAAQ,cAAc,SAC/B,gBAAe,QAAQ,WAAW,gBAAgB,WAAA;iBAElD,OAAO,QAAQ,cAAc,YAC7B,QAAQ,cAAc,QACtB,SAAS,QAAQ,aACjB,OAAO,QAAQ,UAAU,QAAQ,UACjC;AACA,gBAAM,WAAW,QAAQ,UAAU;AACnC,yBAAe,UAAU,gBAAgB,WAAA;QAC1C;YAED,OAAM,IAAI,MACR,sCAAsC,KAAK,UACzC,SACA,MACA,CAAA,CACD,EAAE;IAGR,CAAA;QAED,gBAAe,UAAU,gBAAgB,WAAA;EAG5C,SAAQC,GAAQ;AACf,UAAM,IAAI,MAAM,0BAA0B,EAAE,OAAA,EAAS;EACtD;AACF;;;AClID,IAAa,iBAAb,MAAaC,wBAMH,yBAEV;EACE,OAAO,UAAU;AACf,WAAO;EACR;EAED;EAEA,iBAAiC;EAEjC,mBAAmB;;;;;;EAOnB;EAEA,YAAYC,OAA2D;AACrE,UAAM,KAAA;AAEN,QACE,MAAM,mBAAmB,cACzB,MAAM,qBAAqB,OAE3B,MAAK,mBAAmB;AAE1B,WAAO,OAAO,MAAM,KAAA;AAEpB,QAAI,KAAK,kBAAkB;AACzB,UAAI,KAAK,mBAAmB,WAC1B,OAAM,IAAI,MAAM,yCAAA;AAElB,UAAIC,sBAAgC,KAAK;AACzC,UAAI,KAAK,iBACP,uBAAsB,oBAAoB,OACxC,OAAO,KAAK,KAAK,gBAAA,CAAiB;AAGtC,yBACE,KAAK,UACL,KAAK,gBACL,mBAAA;IAEH;EACF;EAED,iBAA2B;AACzB,WAAO;EACR;;;;;;EAOD,MAAM,OAAOC,QAA2D;AACtE,UAAM,YAAY,MAAM,KAAK,6BAA6B,MAAA;AAC1D,WAAO,eACL,KAAK,UACL,KAAK,gBACL,SAAA;EAEH;;;;;;;;;;;;;;EAeD,OAAO,aACLC,UACAC,QACAC,gBACA,mBAAmB,QACnB,SAAS,IACT;AACA,UAAM,WAAW;MAAC;MAAQ,GAAG;MAAU;IAAO,EAAC,KAAK,gBAAA;AACpD,WAAO,IAAIN,gBAAe;MACxB;MACA;IACD,CAAA;EACF;EAsCD,OAAO,aAILO,UACAC,SAImE;AACnE,UAAM,EAAE,iBAAiB,YAAY,GAAG,KAAA,IAAS,WAAW,CAAE;AAC9D,UAAM,QAAQ,oBAAI,IAAA;AAClB,IAAAC,eAAc,UAAU,cAAA,EAAgB,QAAQ,CAAC,SAAS;AACxD,UAAI,KAAK,SAAS,WAChB,OAAM,IAAI,KAAK,IAAA;IAElB,CAAA;AAED,WAAO,IAAIT,gBAAe;MAGxB,gBAAgB,CAAC,GAAG,KAAM;MAC1B;MACA;MACA,GAAG;IACJ,CAAA;EACF;;;;;;EAOD,MAAM,QACJU,QACA;AACA,UAAM,oBAAoB,KAAK,eAAe,OAC5C,CAAC,OAAO,EAAE,MAAM,OAAA;AAElB,UAAM,sBAAsB;MAC1B,GAAI,KAAK,oBAAoB,CAAE;MAC/B,GAAG;IACJ;AACD,UAAM,aAAa;MACjB,GAAG;MACH,gBAAgB;MAChB,kBAAkB;IACnB;AACD,WAAO,IAAIV,gBAIT,UAAA;EACH;EAED,YAAsC;AACpC,QAAI,KAAK,iBAAiB,OACxB,OAAM,IAAI,MACR,0DAAA;AAGJ,WAAO;MACL,OAAO,KAAK,eAAA;MACZ,iBAAiB,KAAK;MACtB,UAAU,KAAK;MACf,iBAAiB,KAAK;IACvB;EACF;EAED,aAAa,YACXW,MACyB;AACzB,QAAI,CAAC,KAAK,SACR,OAAM,IAAI,MAAM,sCAAA;AAElB,UAAM,MAAM,IAAIX,gBAAe;MAC7B,gBAAgB,KAAK;MACrB,UAAU,KAAK;MACf,gBAAgB,KAAK;IACtB,CAAA;AACD,WAAO;EACR;AAGF;;;ACnRD,IAAa,sBAAb,MAAaY,6BAKH,mBAAoE;EAC5E,OAAO,UAAU;AACf,WAAO;EACR;EAED,eAAe;IAAC;IAAkB;IAAW;EAAQ;EAErD;EAEA,iBAAiC;EAEjC,mBAAmB;;;;;;EAOnB;EAEA,YAAYC,OAAgE;AAC1E,UAAM,KAAA;AACN,SAAK,WAAW,MAAM;AACtB,SAAK,iBAAiB,MAAM,kBAAkB,KAAK;AACnD,SAAK,mBAAmB,MAAM,oBAAoB,KAAK;AACvD,SAAK,0BAA0B,MAAM;AAErC,QAAI,KAAK,kBAAkB;AACzB,UAAIC,sBAAgC,KAAK;AACzC,UAAI,KAAK,iBACP,uBAAsB,oBAAoB,OACxC,OAAO,KAAK,KAAK,gBAAA,CAAiB;AAGtC,yBACE,CACE;QAAE,MAAM;QAAa,WAAW,KAAK;MAAU,CAChD,GACD,KAAK,gBACL,mBAAA;IAEH;EACF;EAED,iBAA2B;AACzB,WAAO;EACR;;;;;;EAOD,MAAM,QACJC,QACA;AACA,UAAM,oBAAoB,KAAK,eAAe,OAC5C,CAAC,OAAO,EAAE,MAAM,OAAA;AAElB,UAAM,sBAAsB;MAC1B,GAAI,KAAK,oBAAoB,CAAE;MAC/B,GAAG;IACJ;AACD,UAAM,aAAa;MACjB,GAAG;MACH,gBAAgB;MAChB,kBAAkB;IACnB;AACD,WAAO,IAAIH,qBAIT,UAAA;EACH;;;;;;EAOD,MAAM,OACJI,QACuB;AAEvB,UAAMC,YAAiC,CAAE;AACzC,eAAW,CAAC,KAAK,KAAA,KAAU,OAAO,QAAQ,KAAK,QAAA,EAC7C,KAAI,OAAO,UAAU,SACnB,WAAU,GAAA,IAAO,eAAe,OAAO,KAAK,gBAAgB,MAAA;QAE5D,WAAU,GAAA,IAAO;AAGrB,UAAMC,OAAM,OAAO,OAAO,UAAU;AACpC,UAAM,SAAS,OAAO,UAAU,UAAU;AAC1C,QAAI,CAACA,KACH,OAAM,IAAI,MAAM,mCAAA;AAElB,QAAI,OAAOA,SAAQ,SACjB,OAAM,IAAI,MAAM,uBAAA;AAElB,UAAMC,SAAuB,EAAE,KAAAD,KAAK;AACpC,QAAI,OACF,QAAO,SAAS;AAElB,WAAO;EACR;;;;;;;EAQD,MAAM,kBACJF,QAC2B;AAC3B,UAAM,kBAAkB,MAAM,KAAK,OAAO,MAAA;AAC1C,WAAO,IAAI,iBAAiB,eAAA;EAC7B;AACF;;;AC7KD,IAAa,qBAAb,cAGU,SAAsD;EAC9D,eAAe;IAAC;IAAkB;IAAW;EAAO;EAEpD,kBAAkB;EAElB;EAEA;EAEA;EAEA,OAAO,UAAU;AACf,WAAO;EACR;EAED,YAAYI,QAGT;AACD,UAAM,iBAAiB,OAAO,kBAAkB;AAChD,UAAM,iBAAiB,mBACrB,OAAO,UACP,cAAA;AAEF,UAAM;MAAE;MAAgB,GAAG;IAAQ,CAAA;AACnC,SAAK,WAAW,OAAO;AACvB,SAAK,iBAAiB;AACtB,SAAK,iBAAiB;EACvB;EAED,MAAM,OAAOC,QAA8D;AACzE,WAAO,sBACL,KAAK,UACL,QACA,KAAK,cAAA;EAER;EAED,MAAM,OACJC,QACoB;AACpB,WAAO,MAAM,KAAK,gBAAgB,KAAK,OAAO,KAAK,IAAA,GAAO,QAAQ,EAChE,SAAS,SACV,CAAA;EACF;AACF;AAED,SAAS,mBACPC,UACAC,gBAC2C;AAC3C,QAAMC,iBAA4D,CAAE;AACpE,aAAW,KAAK,OAAO,OAAO,QAAA,EAC5B,KAAI,OAAO,MAAM,SACf,CAAAC,eAAc,GAAG,cAAA,EAAgB,QAAQ,CAAC,MAAM;AAC9C,QAAI,EAAE,SAAS,WACb,gBAAe,KAAK,EAAE,IAAA;EAEzB,CAAA;WACQ,MAAM,QAAQ,CAAA,GACvB;eAAW,KAAK,EACd,KAAI,OAAO,MAAM,SACf,CAAAA,eAAc,GAAG,cAAA,EAAgB,QAAQ,CAAC,MAAM;AAC9C,UAAI,EAAE,SAAS,WACb,gBAAe,KAAK,EAAE,IAAA;IAEzB,CAAA;aACQ,OAAO,MAAM,SACtB,gBAAe,KAAK,GAAG,mBAAmB,GAAG,cAAA,CAAe;EAE/D,WACQ,OAAO,MAAM,YAAY,MAAM,KACxC,gBAAe,KACb,GAAG,mBAAmB,GAA8B,cAAA,CAAe;AAIzE,SAAO,MAAM,KAAK,IAAI,IAAI,cAAA,CAAA;AAC3B;AAED,SAAS,sBACPH,UACAI,QACAH,gBACyB;AACzB,QAAMI,YAAqC,CAAE;AAC7C,aAAW,CAAC,GAAG,CAAA,KAAM,OAAO,QAAQ,QAAA,EAClC,KAAI,OAAO,MAAM,SACf,WAAU,CAAA,IAAK,eAAe,GAAG,gBAAgB,MAAA;WACxC,MAAM,QAAQ,CAAA,GAAI;AAC3B,UAAMC,aAA6B,CAAE;AACrC,eAAW,KAAK,EACd,KAAI,OAAO,MAAM,SACf,YAAW,KAAK,eAAe,GAAG,gBAAgB,MAAA,CAAO;aAChD,OAAO,MAAM,SACtB,YAAW,KAAK,sBAAsB,GAAG,QAAQ,cAAA,CAAe;AAGpE,cAAU,CAAA,IAAK;EAChB,WAAU,OAAO,MAAM,YAAY,MAAM,KACxC,WAAU,CAAA,IAAK,sBACb,GACA,QACA,cAAA;MAGF,WAAU,CAAA,IAAK;AAGnB,SAAO;AACR;;;ACrED,IAAsB,4BAAtB,cAIU,SAA8B;EACtC,eAAe;IAAC;IAAkB;IAAW;EAAO;EAEpD,kBAAkB;;;;;;;EAoBlB,MAAM,OACJC,OACAC,SACoB;AACpB,WAAO,KAAK,gBACV,CAACD,YAAoB,KAAK,eAAeE,OAAAA,GACzC,OACA;MAAE,GAAG;MAAS,SAAS;IAAU,CAAA;EAEpC;AACF;AAcD,IAAa,sBAAb,cAIU,0BAEV;EACE,OAAO,UAAU;AACf,WAAO;EACR;EAED;EAEA;EAQA,YACEC,QAGA;AACA,QAAI,OAAO,WAAW,SAEpB,UAAS,EAAE,cAAc,OAAQ;AAEnC,UAAM,MAAA;AACN,SAAK,eAAe,OAAO;AAC3B,SAAK,WAAW,OAAO,YAAY;EACpC;EAED,IAAI,iBAAiB;AACnB,WAAO,CAAC,KAAK,YAAa;EAC3B;EAED,MAAM,eACJC,QACwB;AACxB,UAAM,QAAQ,OAAO,KAAK,YAAA;AAC1B,QAAI,KAAK,YAAY,CAAC,MACpB,QAAO,CAAE;aACA,CAAC,OAAO;AACjB,YAAM,QAAQ,IAAI,MAChB,UAAU,KAAK,YAAA,uHAAmI;AAEpJ,YAAM,OAAO;AACb,YAAM;IACP;AAED,QAAI;AACJ,QAAI;AACF,UAAI,MAAM,QAAQ,KAAA,EAChB,qBAAoB,MAAM,IAAI,0BAAA;UAE9B,qBAAoB,CAAC,2BAA2B,KAAA,CAAO;IAG1D,SAAQC,GAAQ;AACf,YAAM,gBACJ,OAAO,UAAU,WAAW,QAAQ,KAAK,UAAU,OAAO,MAAM,CAAA;AAClE,YAAM,QAAQ,IAAI,MAChB;QACE,UAAU,KAAK,YAAA;QACf,mBAAmB,aAAA;QACnB,uBAAuB,EAAE,OAAA;MAC1B,EAAC,KAAK,MAAA,CAAO;AAEhB,YAAM,OAAO;AAEZ,YAAc,gBAAgB,EAAE;AACjC,YAAM;IACP;AAED,WAAO;EACR;AACF;AAgBD,IAAsB,kCAAtB,cAGU,0BAAoC;EAC5C;EAiBA,YACEC,QAQA;AACA,QAAI,EAAE,YAAY,QAEhB,UAAS,EAAE,QAAQ,OAAQ;AAE7B,UAAM,MAAA;AACN,SAAK,SAAS,OAAO;EACtB;EAED,IAAI,iBAAiB;AACnB,WAAO,KAAK,OAAO;EACpB;EAMD,MAAM,eACJF,QACwB;AACxB,WAAO,CAAC,MAAM,KAAK,OAAO,MAAA,CAAQ;EACnC;AACF;AAMD,IAAsB,yBAAtB,cAKU,mBAIR;EACA,YAAYG,OAA+D;AACzE,UAAM,KAAA;EACP;EAMD,MAAM,OAAOH,QAA2D;AACtE,YAAQ,MAAM,KAAK,kBAAkB,MAAA,GAAS,SAAA;EAC/C;EAED,MAAM,kBACJA,QACmC;AACnC,UAAM,iBAAiB,MAAM,KAAK,eAAe,MAAA;AACjD,WAAO,IAAI,gBAAgB,cAAA;EAC5B;AACF;AAeD,IAAa,4BAAb,cAGU,gCAA0C;EAClD,OAAO,UAAU;AACf,WAAO;EACR;EAED;EAeA,YACEI,QAKAC,MACA;AACA,QAAI,EAAE,YAAY,QAEhB,UAAS;MAAE,QAAQ;MAAc;IAAO;AAE1C,UAAM,MAAA;AACN,SAAK,OAAO,OAAO;EACpB;EAED,MAAM,OAAOC,QAAwC;AACnD,WAAO,IAAI,YAAY,MAAM,KAAK,OAAO,OAAO,MAAA,GAAS,KAAK,IAAA;EAC/D;EAED,OAAO,aAGLC,UAAaC,MAAcC,SAA+C;AAC1E,WAAO,IAAI,KACT,eAAe,aAA0B,UAAU,EACjD,gBAAgB,SAAS,eAC1B,CAAA,GACD,IAAA;EAEH;AACF;AAOD,SAAS,oBAAoBC,OAA6C;AACxE,MAAI,UAAU,QAAQ,OAAO,UAAU,YAAY,MAAM,QAAQ,KAAA,EAC/D,QAAO;AAET,SACE,OAAO,KAAK,KAAA,EAAO,WAAW,KAC9B,UAAU,SACV,OAAO,MAAM,SAAS;AAEzB;AAOD,SAAS,qBAAqBA,OAA8C;AAC1E,MAAI,UAAU,QAAQ,OAAO,UAAU,YAAY,MAAM,QAAQ,KAAA,EAC/D,QAAO;AAET,SACE,eAAe,UACd,OAAO,MAAM,cAAc,YACzB,OAAO,MAAM,cAAc,YAC1B,MAAM,cAAc,QACpB,SAAS,MAAM,aACf,OAAO,MAAM,UAAU,QAAQ;AAEtC;AAeD,IAAM,oCAAN,cAIU,0BAA+C;EACvD,eAAe;IAAC;IAAkB;IAAW;EAAO;EAEpD,kBAAkB;EAElB,iBAAyD,CAAE;EAE3D,oBAA8D,CAAE;EAEhE;EAoBU;EAEV,OAAO,gBAA8B;AACnC,UAAM,IAAI,MACR,4EAAA;EAEH;EAIS;EAEV,YAGEC,QACAC,mBACA;AACA,QAAI,EAAE,YAAY,QAEhB,UAAS,EAAE,QAAQ,OAAQ;AAE7B,UAAM,MAAA;AACN,SAAK,SAAS,OAAO;AACrB,QAAI,MAAM,QAAQ,KAAK,MAAA,GAAS;AAC9B,UAAIC,iBAAoD,CAAE;AAC1D,WAAK,OAAO,QAAQ,CAAC,WAAW;AAC9B,YAAI,oBAAoB,OACtB,kBAAiB,eAAe,OAAO,OAAO,cAAA;MAEjD,CAAA;AACD,WAAK,iBAAiB;IACvB,MACC,MAAK,iBAAiB,KAAK,OAAO;AAEpC,SAAK,oBAAoB,qBAAqB,KAAK;EACpD;EAED,cAAcC,SAAyB;AAErC,UAAM,cAAc,KAAK;AACzB,QAAI,YAAY,cAAA,GAAiB;AAC/B,YAAM,WAAW,YAAY,cAAA;AAC7B,aAAO,IAAI,SAAS,EAAE,QAAS,CAAA;IAChC,WAAU,YAAY,kBAAkB;AACvC,YAAM,WAAW,YAAY,iBAAA;AAE7B,aAAO,IAAI,SAAS;QAClB;QACA,MAAM,KAAK,wBAAwB,SAAS,QAAA,CAAS;MACtD,CAAA;IACF,MACC,OAAM,IAAI,MAAM,0BAAA;EAEnB;EAED,wBAAwBC,MAAc;AACpC,YAAQ,MAAR;MACE,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT;AACE,cAAM,IAAI,MAAM,4BAAA;IACnB;EACF;EAED,OAAO,aACLC,UAQAJ,mBACA;AACA,QAAI,OAAO,aAAa,SACtB,QAAO,IAAI,KAAK,eAAe,aAAa,UAAU,iBAAA,CAAkB;AAE1E,UAAMK,SAIF,CAAE;AACN,eAAW,QAAQ,SAEjB,KAAI,OAAO,SAAS,SAClB,QAAO,KAAK,eAAe,aAAa,MAAM,iBAAA,CAAkB;aACvD,SAAS,MAAM;IAEzB,WAAU,oBAAoB,IAAA,GAAO;AACpC,UAAI,OAAO;AACX,UAAI,OAAO,KAAK,SAAS,SACvB,QAAO,KAAK,QAAQ;AAGtB,YAAM,UAAU;QACd,GAAG;QACH,yBAAyB;MAC1B;AACD,aAAO,KAAK,eAAe,aAAa,MAAM,OAAA,CAAQ;IACvD,WAAU,qBAAqB,IAAA,GAAO;AACrC,UAAI,cAAc,KAAK,aAAa;AACpC,UAAIC;AACJ,UAAIC,iBAA2B,CAAE;AACjC,UAAI,OAAO,gBAAgB,UAAU;AACnC,YAAIC;AACJ,YAAI,mBAAmB,mBAAmB,WACxC,kBAAiB,cAAc,WAAA;YAE/B,kBAAiB,aAAa,WAAA;AAGhC,cAAM,YAAY,eAAe,QAAQ,CAACC,WACxCA,OAAK,SAAS,aAAa,CAACA,OAAK,IAAK,IAAG,CAAE,CAAA;AAG7C,aAAK,WAAW,UAAU,KAAK,GAAG;AAChC,cAAI,UAAU,SAAS,EACrB,OAAM,IAAI,MACR;OAA8D,SAAA;QAAoB,WAAA,EAAa;AAGnG,2BAAiB,CAAC,UAAU,CAAA,CAAG;QAChC,MACC,kBAAiB,CAAE;AAGrB,sBAAc,EAAE,KAAK,YAAa;AAClC,4BAAoB,IAAI,oBAAiC;UACvD,UAAU;UACV;UACA,gBAAgB,mBAAmB;UACnC,yBAAyB;QAC1B,CAAA;MACF,WAAU,OAAO,gBAAgB,UAAU;AAC1C,YAAI,SAAS,aAAa;AACxB,cAAID;AACJ,cAAI,mBAAmB,mBAAmB,WACxC,kBAAiB,cAAc,YAAY,GAAA;cAE3C,kBAAiB,aAAa,YAAY,GAAA;AAG5C,2BAAiB,eAAe,QAAQ,CAACC,WACvCA,OAAK,SAAS,aAAa,CAACA,OAAK,IAAK,IAAG,CAAE,CAAA;QAE9C,MACC,kBAAiB,CAAE;AAErB,4BAAoB,IAAI,oBAAiC;UACvD,UAAU;UACV;UACA,gBAAgB,mBAAmB;UACnC,yBAAyB;QAC1B,CAAA;MACF,MACC,OAAM,IAAI,MAAM,wBAAA;AAElB,aAAO,KAAK,iBAAA;IACb,WAAU,OAAO,SAAS,SACzB,QAAO,KACL,IAAI,mBAAmB;MACrB,UAAU;MACV,gBAAgB,mBAAmB;IACpC,CAAA,CAAA;AAIP,WAAO,IAAI,KAAK;MAAE;MAAQ;IAAmB,CAAA;EAC9C;EAED,MAAM,OAAOC,OAA+D;AAE1E,QAAI,KAAK,kBAAkB,0BAA0B;AACnD,YAAM,OAAO,MAAM,KAAK,OAAO,OAAO,KAAA;AAEtC,aAAO,KAAK,cAAc,IAAA;IAC3B,OAAM;AACL,YAAMR,UAA0B,CAAE;AAClC,iBAAW,UAAU,KAAK,QAAQ;AAEhC,YAAIS,SAA8B,CAAE;AACpC,YAAI,EAAE,oBAAoB,QACxB,OAAM,IAAI,MACR,UAAU,MAAA,wCAA8C;AAG5D,mBAAW,QAAQ,OAAO,gBAAgB;AACxC,cAAI,CAAC,OACH,UAAS,EAAA,CAAG,IAAA,GAAO,MAAM,IAAA,EAAO;AAElC,mBAAS;YAAE,GAAG;aAAS,IAAA,GAAO,MAAM,IAAA;UAAO;QAC5C;AAED,YAAI,kBAAkB,0BAA0B;AAC9C,gBAAM,YAAY,MAAM,OAAO,OAC7B,MAAA;AAEF,cAAIC;AACJ,cAAI,6BAA6B,OAE/B,2BAA0B,OAAO;AAEnC,cAAI,cAAc,GAChB,SAAQ,KAAK;YACX,GAAG;YACH,MAAM;YACN,MAAM;UACP,CAAA;QAIJ,WAAU,kBAAkB,qBAAqB;AAChD,gBAAM,YAAY,MAAM,OAAO,OAC7B,MAAA;AAEF,cAAIA;AACJ,cAAI,6BAA6B,OAE/B,2BAA0B,OAAO;AAEnC,kBAAQ,KAAK;YACX,GAAG;YACH,MAAM;YACN,WAAW;UACZ,CAAA;QAEF,WAAU,kBAAkB,oBAAoB;AAC/C,gBAAM,YAAY,MAAM,OAAO,OAC7B,MAAA;AAEF,cAAIA;AACJ,cAAI,6BAA6B,OAE/B,2BAA0B,OAAO;AAEnC,kBAAQ,KAAK;YACX,GAAG;YACH,GAAG;UACJ,CAAA;QACF;MACF;AACD,aAAO,KAAK,cAAc,OAAA;IAC3B;EACF;EAED,MAAM,eAAelB,QAAsC;AACzD,WAAO,CAAC,MAAM,KAAK,OAAO,MAAA,CAAQ;EACnC;AACF;AAgBD,IAAa,6BAAb,cAGU,kCAA4C;EACpD,OAAO,gBAAqC;AAC1C,WAAO;EACR;EAED,OAAO,UAAU;AACf,WAAO;EACR;AACF;AAMD,IAAa,0BAAb,cAGU,kCAA4C;EACpD,OAAO,gBAAkC;AACvC,WAAO;EACR;EAED,OAAO,UAAU;AACf,WAAO;EACR;AACF;AAgBD,IAAa,8BAAb,cAGU,kCAA4C;EACpD,OAAO,gBAAsC;AAC3C,WAAO;EACR;EAED,OAAO,UAAU;AACf,WAAO;EACR;AACF;AAkCD,SAAS,6BACPmB,+BAC4D;AAC5D,SACE,OAAQ,8BACL,mBAAmB;AAEzB;AAED,SAAS,iCAWPC,2BACAC,OACyC;AACzC,MACE,6BAA6B,yBAAA,KAC7B,cAAc,yBAAA,EAEd,QAAO;AAET,MACE,MAAM,QAAQ,yBAAA,KACd,0BAA0B,CAAA,MAAO,eACjC;AACA,UAAM,iBAAiB,0BAA0B,CAAA;AACjD,QACE,OAAO,mBAAmB,cAC1B,OAAO,mBAAmB,YAC1B,eAAe,MAAM,GAAG,CAAA,MAAO,QAC/B,eAAe,MAAM,EAAA,MAAQ,MAC7B;AACA,YAAM,eAAe,eAAe,MAAM,GAAG,EAAA;AAC7C,aAAO,IAAI,oBAAoB;QAAE;QAAc,UAAU;MAAM,CAAA;IAChE,WACC,OAAO,mBAAmB,YAC1B,eAAe,CAAA,MAAO,OACtB,eAAe,eAAe,SAAS,CAAA,MAAO,KAC9C;AACA,YAAM,eAAe,eAAe,MAAM,GAAG,EAAA;AAC7C,aAAO,IAAI,oBAAoB;QAAE;QAAc,UAAU;MAAM,CAAA;IAChE;AACD,UAAM,IAAI,MACR,2CACE,OAAO,kBAAkB,YAAY,MAErC,0BAA0B,CAAA,CAAA,6CAE1B,OAAO,mBAAmB,aAAa,WAAW,QAAA,gBACpC;EAEnB;AACD,QAAM,UAAU,2BAA2B,yBAAA;AAC3C,MAAIC;AAUJ,MAAI,OAAO,QAAQ,YAAY,SAC7B,gBAAe,QAAQ;MAGvB,gBAAe,QAAQ,QAAQ,IAAI,CAAC,SAAS;AAC3C,QAAI,UAAU,KACZ,QAAO;MAAE,GAAG;MAAM,MAAM,KAAK;IAAM;aAC1B,eAAe,KACxB,QAAO;MAAE,GAAG;MAAM,WAAW,KAAK;IAAW;QAE7C,QAAO;EAEV,CAAA;AAGH,MAAI,QAAQ,SAAA,MAAe,QACzB,QAAO,2BAA2B,aAAa,cAAc,KAAA;WACpD,QAAQ,SAAA,MAAe,KAChC,QAAO,wBAAwB,aAAa,cAAc,KAAA;WACjD,QAAQ,SAAA,MAAe,SAChC,QAAO,4BAA4B,aAAa,cAAc,KAAA;WACrD,YAAY,WAAW,OAAA,EAChC,QAAO,0BAA0B,aAC/B,QAAQ,SACR,QAAQ,MACR,KAAA;MAGF,OAAM,IAAI,MACR,gFAAgF,QAAQ,SAAA,CAAU,IAAI;AAG3G;AAED,SAAS,sBACPC,GAC0B;AAE1B,SAAQ,EAAE,YAAoB,QAAA,MAAc;AAC7C;AAkBD,IAAa,qBAAb,MAAaC,4BAMH,uBAEV;EACE,OAAO,UAAU;AACf,WAAO;EACR;EAED,IAAI,aAAqC;AACvC,WAAO,EACL,gBAAgB,WACjB;EACF;EAED;EAEA,mBAAmB;EAEnB,iBAAiC;EAEjC,YAAYC,OAA+D;AACzE,UAAM,KAAA;AAEN,QACE,MAAM,mBAAmB,cACzB,MAAM,qBAAqB,OAE3B,MAAK,mBAAmB;AAE1B,WAAO,OAAO,MAAM,KAAA;AAEpB,QAAI,KAAK,kBAAkB;AACzB,YAAM,yBAAyB,oBAAI,IAAA;AACnC,iBAAW,iBAAiB,KAAK,gBAAgB;AAE/C,YAAI,yBAAyB,YAAa;AAC1C,mBAAW,iBAAiB,cAAc,eACxC,wBAAuB,IAAI,aAAA;MAE9B;AAED,YAAM,sBAAsB,KAAK;AACjC,YAAM,yBAAyB,IAAI,IACjC,KAAK,mBACD,oBAAoB,OAAO,OAAO,KAAK,KAAK,gBAAA,CAAiB,IAC7D,mBAAA;AAEN,YAAM,aAAa,IAAI,IACrB,CAAC,GAAG,sBAAuB,EAAC,OAC1B,CAAC,MAAM,CAAC,uBAAuB,IAAI,CAAA,CAAE,CACtC;AAEH,UAAI,WAAW,OAAO,EACpB,OAAM,IAAI,MACR,qBAAqB,CACnB,GAAG,UACJ,CAAA,gDAAgD;AAGrD,YAAM,kBAAkB,IAAI,IAC1B,CAAC,GAAG,sBAAuB,EAAC,OAC1B,CAAC,MAAM,CAAC,uBAAuB,IAAI,CAAA,CAAE,CACtC;AAEH,UAAI,gBAAgB,OAAO,EACzB,OAAM,IAAI,MACR,qBAAqB,CACnB,GAAG,eACJ,CAAA,gEAAgE;IAGtE;EACF;EAED,iBAAyB;AACvB,WAAO;EACR;EAED,MAAc,mBACZC,SACAC,aAGsB;AACtB,QAAI,OAAO,QAAQ,YAAY,SAC7B,QAAO;AAET,UAAM,0BAA0B,MAAM,QAAQ,IAC5C,QAAQ,QAAQ,IAAI,OAAO,SAAS;AAClC,UAAI,KAAK,SAAS,YAChB,QAAO;AAGT,UAAI,WAAW;AACf,UAAI,OAAO,KAAK,cAAc,SAC5B,YAAW,KAAK;eAEhB,OAAO,KAAK,cAAc,YAC1B,KAAK,cAAc,QACnB,SAAS,KAAK,aACd,OAAO,KAAK,UAAU,QAAQ,SAE9B,YAAW,KAAK,UAAU;AAG5B,YAAM,4BAA4B,eAAe,aAC/C,UACA,EACE,gBAAgB,KAAK,eACtB,CAAA;AAEH,YAAM,eACJ,MAAM,0BAA0B,OAAO,WAAA;AAEzC,UACE,OAAO,KAAK,cAAc,YAC1B,KAAK,cAAc,QACnB,SAAS,KAAK,UAGd,MAAK,UAAU,MAAM;UAErB,MAAK,YAAY;AAEnB,aAAO;IACR,CAAA,CAAC;AAEJ,YAAQ,UAAU;AAClB,WAAO;EACR;EAED,MAAM,eACJjC,QACwB;AACxB,UAAM,YAAY,MAAM,KAAK,6BAA6B,MAAA;AAC1D,QAAIkC,iBAAgC,CAAE;AAEtC,eAAW,iBAAiB,KAAK,eAE/B,KAAI,yBAAyB,YAC3B,gBAAe,KACb,MAAM,KAAK,mBAAmB,eAAe,SAAA,CAAU;SAEpD;AACL,UAAIC;AAEJ,UAAI,KAAK,mBAAmB,WAC1B,eAAc,EAAE,GAAG,UAAW;UAE9B,eAAc,cAAc,eAAe,OACzC,CAAC,KAAK,kBAAkB;AACtB,YACE,EAAE,iBAAiB,cACnB,EACE,sBAAsB,aAAA,KAAkB,cAAc,WAExD;AACA,gBAAM,QAAQ,wBACZ,IAAI,MACF,sCAAsC,cAAc,SAAA,CAAU,IAAI,GAEpE,sBAAA;AAEF,gBAAM;QACP;AACD,YAAI,aAAA,IAAiB,UAAU,aAAA;AAC/B,eAAO;MACR,GACD,CAAE,CAAA;AAGN,YAAM,UAAU,MAAM,cAAc,eAAe,WAAA;AACnD,uBAAiB,eAAe,OAAO,OAAA;IACxC;AAEH,WAAO;EACR;EAED,MAAM,QACJC,QACA;AAGA,UAAM,oBAAoB,KAAK,eAAe,OAC5C,CAAC,OAAO,EAAE,MAAM,OAAA;AAElB,UAAM,sBAAsB;MAC1B,GAAI,KAAK,oBAAoB,CAAE;MAC/B,GAAG;IACJ;AACD,UAAM,aAAa;MACjB,GAAG;MACH,gBAAgB;MAChB,kBAAkB;IACnB;AACD,WAAO,IAAIN,oBAIT,UAAA;EACH;EAsCD,OAAO,aAILvB,UACA8B,SAIuE;AACvE,UAAM,SAAS,eAAe,aAAa,UAAU,OAAA;AACrD,UAAM,gBAAgB,IAAI,2BAA2B,EAAE,OAAQ,CAAA;AAC/D,WAAO,KAAK,aAEV,CAAC,aAAc,CAAA;EAClB;;;;;;;EAQD,OAAO,aAMLC,gBAIAC,OAI8B;AAC9B,UAAM,oBAAoB,eAAe,OACvC,CAACC,KAAqD,kBACpD,IAAI,OAEF,yBAAyBV,sBACrB,cAAc,iBACd,CACE,iCAME,eAAe,KAAA,CAClB,CAAA,GAET,CAAE,CAAA;AAEJ,UAAM,4BAA4B,eAAe,OAC/C,CAAC,KAAK,kBAEJ,yBAAyBA,sBACrB,OAAO,OAAO,KAAK,cAAc,gBAAA,IACjC,KACN,uBAAO,OAAO,IAAA,CAAK;AAErB,UAAM,iBAAiB,oBAAI,IAAA;AAC3B,eAAW,iBAAiB,mBAAmB;AAE7C,UAAI,yBAAyB,YAAa;AAC1C,iBAAW,iBAAiB,cAAc,gBAAgB;AACxD,YAAI,iBAAiB,0BACnB;AAEF,uBAAe,IAAI,aAAA;MACpB;IACF;AACD,WAAO,IAAI,KAAe;MACxB,GAAG;MACH,gBAAgB,CAAC,GAAG,cAAe;MACnC,gBAAgB;MAChB,kBAAkB;MAClB,gBAAgB,OAAO;IACxB,CAAA;EACF;AACF;;;ACtnCD,IAAa,wBAAb,MAAaW,+BACH,yBAEV;EACE,kBAAkB;EAElB;EAEA;EAEA;EAEA,SAAS;EAET,mBAAmB;EAEnB,SAAS;EAET,iBAAiC;EAEjC,mBAAmB;EAEnB,YAAYC,OAAmC;AAC7C,UAAM,KAAA;AACN,WAAO,OAAO,MAAM,KAAA;AAEpB,QAAI,KAAK,aAAa,UAAa,KAAK,oBAAoB,OAC1D,OAAM,IAAI,MACR,kEAAA;AAIJ,QAAI,KAAK,aAAa,UAAa,KAAK,oBAAoB,OAC1D,OAAM,IAAI,MACR,6DAAA;AAIJ,QAAI,KAAK,kBAAkB;AACzB,UAAIC,sBAAgC,KAAK;AACzC,UAAI,KAAK,iBACP,uBAAsB,oBAAoB,OACxC,OAAO,KAAK,KAAK,gBAAA,CAAiB;AAGtC,yBACE,KAAK,SAAS,KAAK,QACnB,KAAK,gBACL,mBAAA;IAEH;EACF;EAED,iBAA6B;AAC3B,WAAO;EACR;EAED,OAAO,UAAU;AACf,WAAO;EACR;EAED,MAAc,YACZC,gBACwB;AACxB,QAAI,KAAK,aAAa,OACpB,QAAO,KAAK;AAEd,QAAI,KAAK,oBAAoB,OAC3B,QAAO,KAAK,gBAAgB,eAAe,cAAA;AAG7C,UAAM,IAAI,MACR,6DAAA;EAEH;EAED,MAAM,QACJC,QACA;AACA,UAAM,oBAAoB,KAAK,eAAe,OAC5C,CAAC,OAAO,EAAE,MAAM,OAAA;AAElB,UAAM,sBAAsB;MAC1B,GAAI,KAAK,oBAAoB,CAAE;MAC/B,GAAG;IACJ;AACD,UAAM,aAAa;MACjB,GAAG;MACH,gBAAgB;MAChB,kBAAkB;IACnB;AACD,WAAO,IAAIJ,uBAAsB,UAAA;EAClC;;;;;;EAOD,MAAM,OAAOK,QAAsC;AACjD,UAAM,YAAY,MAAM,KAAK,6BAA6B,MAAA;AAC1D,UAAM,WAAW,MAAM,KAAK,YAAY,SAAA;AAExC,UAAM,iBAAiB,MAAM,QAAQ,IACnC,SAAS,IAAI,CAAC,YAAY,KAAK,cAAc,OAAO,OAAA,CAAQ,CAAC;AAE/D,UAAM,WAAW;MAAC,KAAK;MAAQ,GAAG;MAAgB,KAAK;IAAO,EAAC,KAC7D,KAAK,gBAAA;AAEP,WAAO,eAAe,UAAU,KAAK,gBAAgB,SAAA;EACtD;EAED,YAAuC;AACrC,QAAI,KAAK,mBAAmB,CAAC,KAAK,SAChC,OAAM,IAAI,MACR,4DAAA;AAGJ,QAAI,KAAK,iBAAiB,OACxB,OAAM,IAAI,MACR,yDAAA;AAGJ,WAAO;MACL,OAAO,KAAK,eAAA;MACZ,iBAAiB,KAAK;MACtB,gBAAgB,KAAK,cAAc,UAAA;MACnC,mBAAmB,KAAK;MACxB,QAAQ,KAAK;MACb,QAAQ,KAAK;MACb,iBAAiB,KAAK;MACtB,UAAU,KAAK;IAChB;EACF;EAED,aAAa,YACXC,MACgC;AAChC,UAAM,EAAE,eAAA,IAAmB;AAC3B,QAAI,CAAC,eACH,OAAM,IAAI,MAAM,wBAAA;AAElB,UAAM,gBAAgB,MAAM,eAAe,YAAY,cAAA;AAEvD,QAAIC;AAEJ,QAAI,MAAM,QAAQ,KAAK,QAAA,EACrB,YAAW,KAAK;QAEhB,OAAM,IAAI,MACR,6DAAA;AAIJ,WAAO,IAAIP,uBAAsB;MAC/B,gBAAgB,KAAK;MACrB;MACA;MACA,kBAAkB,KAAK;MACvB,QAAQ,KAAK;MACb,QAAQ,KAAK;MACb,gBAAgB,KAAK;IACtB,CAAA;EACF;AACF;AAgED,IAAa,mCAAb,MAAaQ,0CAMH,uBAEV;EACE,kBAAkB;EAElB;EAEA;EAEA;EAEA,SAAS;EAET,mBAAmB;EAEnB,SAAS;EAET,iBAAiC;EAEjC,mBAAmB;EAEnB,iBAAkC;AAChC,WAAO;EACR;EAED,OAAO,UAAU;AACf,WAAO;EACR;EAED,YAAYC,QAA+C;AACzD,UAAM,MAAA;AAEN,SAAK,WAAW,OAAO;AACvB,SAAK,gBAAgB,OAAO;AAC5B,SAAK,mBAAmB,OAAO,oBAAoB;AACnD,SAAK,kBAAkB,OAAO;AAC9B,SAAK,SAAS,OAAO,UAAU;AAC/B,SAAK,SAAS,OAAO,UAAU;AAC/B,SAAK,iBAAiB,OAAO,kBAAkB;AAC/C,SAAK,mBAAmB,OAAO,oBAAoB;AAEnD,QAAI,KAAK,aAAa,UAAa,KAAK,oBAAoB,OAC1D,OAAM,IAAI,MACR,kEAAA;AAIJ,QAAI,KAAK,aAAa,UAAa,KAAK,oBAAoB,OAC1D,OAAM,IAAI,MACR,6DAAA;AAIJ,QAAI,KAAK,kBAAkB;AACzB,UAAIP,sBAAgC,KAAK;AACzC,UAAI,KAAK,iBACP,uBAAsB,oBAAoB,OACxC,OAAO,KAAK,KAAK,gBAAA,CAAiB;AAGtC,yBACE,KAAK,SAAS,KAAK,QACnB,KAAK,gBACL,mBAAA;IAEH;EACF;EAED,MAAc,YACZC,gBACwB;AACxB,QAAI,KAAK,aAAa,OACpB,QAAO,KAAK;AAEd,QAAI,KAAK,oBAAoB,OAC3B,QAAO,KAAK,gBAAgB,eAAe,cAAA;AAG7C,UAAM,IAAI,MACR,6DAAA;EAEH;;;;;;EAOD,MAAM,eACJO,QACwB;AACxB,UAAM,YAAY,MAAM,KAAK,6BAA6B,MAAA;AAC1D,QAAI,WAAW,MAAM,KAAK,YAAY,SAAA;AAEtC,eAAW,SAAS,IAAI,CAAC,YAAY;AAEnC,YAAMC,SAA8B,CAAE;AACtC,WAAK,cAAc,eAAe,QAAQ,CAAC,kBAAkB;AAC3D,eAAO,aAAA,IAAiB,QAAQ,aAAA;MACjC,CAAA;AACD,aAAO;IACR,CAAA;AAED,UAAMC,WAA0B,CAAE;AAClC,eAAW,WAAW,UAAU;AAC9B,YAAM,kBAAkB,MAAM,KAAK,cAAc,eAAe,OAAA;AAChE,eAAS,KAAK,GAAG,eAAA;IAClB;AACD,WAAO;EACR;;;;;;EAOD,MAAM,OAAOF,QAA2D;AACtE,UAAM,YAAY,MAAM,KAAK,6BAA6B,MAAA;AAC1D,UAAM,WAAW,MAAM,KAAK,YAAY,SAAA;AACxC,UAAM,kBAAkB,MAAM,QAAQ,IACpC,SAAS,IAAI,CAAC,YAAY,KAAK,cAAc,eAAe,OAAA,CAAQ,CAAC;AAEvE,UAAM,iBAAiB,gBACpB,KAAA,EACA,IAAI,CAAC,YAAY,QAAQ,OAAA;AAC5B,UAAM,WAAW;MAAC,KAAK;MAAQ,GAAG;MAAgB,KAAK;IAAO,EAAC,KAC7D,KAAK,gBAAA;AAEP,WAAO,eAAe,UAAU,KAAK,gBAAgB,SAAA;EACtD;;;;;;EAOD,MAAM,QACJG,QAC0E;AAC1E,UAAM,oBAAoB,KAAK,eAAe,OAC5C,CAAC,aAAa,EAAE,YAAY,OAAA;AAE9B,UAAM,sBAAsB;MAC1B,GAAI,KAAK,oBAAoB,CAAE;MAC/B,GAAG;IACJ;AACD,UAAM,aAAa;MACjB,GAAG;MACH,gBAAgB;MAChB,kBAAkB;IACnB;AACD,WAAO,IAAIL,kCAET,UAAA;EACH;AACF;;;ACvaD,IAAa,yBAAb,MAAaM,gCAEH,mBAAmB;EAC3B,OAAO,UAAU;AACf,WAAO;EACR;EAED;EAEA;EAEA,YAAYC,OAAwD;AAClE,UAAM;MAAE,GAAG;MAAO,gBAAgB,CAAE;IAAE,CAAA;AACtC,SAAK,kBAAkB,MAAM;AAC7B,SAAK,cAAc,MAAM;AACzB,SAAK,iBAAiB,KAAK,mBAAA;EAC5B;;;;;EAMS,qBAAqB;AAC7B,UAAM,qBAAqB,KAAK,gBAAgB,IAC9C,CAAC,mBAAmB,eAAe,IAAA;AAErC,UAAM,cAAc,KAAK,gBACtB,IAAI,CAAC,mBACJ,eAAe,OAAO,eAAe,OACnC,CAAC,eAAe,CAAC,mBAAmB,SAAS,UAAA,CAAW,CACzD,EAEF,KAAA;AACH,WAAO,CAAC,GAAG,IAAI,IAAI,WAAA,CAAa;EACjC;EAED,OAAiB,2BACfC,WACAC,oBACA;AACA,WAAO,mBAAmB,OAAO,CAAC,gBAAgB,cAAc;AAC9D,qBAAe,SAAA,IAAa,UAAU,SAAA;AACtC,aAAO;IACR,GAAE,CAAE,CAAA;EACN;;;;;;EAOD,MAAgB,sBACdC,QACsB;AACtB,UAAM,YAAY,MAAM,KAAK,6BAA6B,MAAA;AAC1D,eAAW,EAAE,MAAM,oBAAoB,QAAQ,eAAA,KAAoB,KAChE,iBAAiB;AAClB,YAAM,4BACJJ,wBAAuB,2BACrB,WACA,eAAe,cAAA;AAGnB,UAAI,0BAA0B,mBAC5B,WAAU,kBAAA,IAAsB,MAAM,eAAe,eACnD,yBAAA;UAGF,WAAU,kBAAA,IAAsB,MAAM,eAAe,OACnD,yBAAA;IAGL;AACD,WAAOA,wBAAuB,2BAC5B,WACA,KAAK,YAAY,cAAA;EAEpB;;;;;;EAOD,MAAM,kBACJI,QACsD;AACtD,WAAO,KAAK,YAAY,kBACtB,MAAM,KAAK,sBAAsB,MAAA,CAAO;EAE3C;EAED,MAAM,OAAOA,QAAsC;AACjD,WAAO,KAAK,YAAY,OAAO,MAAM,KAAK,sBAAsB,MAAA,CAAO;EACxE;;;;;;;EAQD,MAAM,QACJC,QACqD;AACrD,UAAM,aAAa,EAAE,GAAG,KAAM;AAC9B,eAAW,iBAAiB,KAAK,eAAe,OAC9C,CAAC,OAAO,EAAE,MAAM,OAAA;AAElB,eAAW,mBAAmB;MAC5B,GAAI,KAAK,oBAAoB,CAAE;MAC/B,GAAG;IACJ;AACD,WAAO,IAAIL,wBAA2C,UAAA;EACvD;EAED,YAA0C;AACxC,UAAM,IAAI,MAAM,kBAAA;EACjB;EAED,iBAAyB;AACvB,WAAO;EACR;AACF;;;ACzLD,SAAS,uBAAuBM,GAE9B;AACA,SACE,OAAO,MAAM,YACb,KAAK,QACL,0BAA0B,KAC1B,OAAO,EAAE,yBAAyB;AAErC;AAED,SAAS,kBAAkBA,GAAoD;AAC7E,SACE,OAAO,MAAM,YACb,KAAK,QACL,WAAW,KACX,MAAM,QAAQ,EAAE,KAAA,KAChB,EAAE,MAAM,KAAK,GAAA,MAAS;AAEzB;AAgBD,IAAa,mBAAb,MAAaC,0BAMH,mBAEV;EAEE;EAEA;EAEA,eAAe;IAAC;IAAkB;IAAW;EAAa;EAE1D,IAAI,aAAqC;AACvC,WAAO;MACL,GAAG,MAAM;MACT,QAAQ;IACT;EACF;EAED,YAAYC,OAA6D;AACvE,UAAM,KAAA;AACN,SAAK,SAAS,MAAM;AACpB,SAAK,SAAS,MAAM;EACrB;EAED,KACEC,YACkE;AAClE,QAAI,uBAAuB,UAAA,EACzB,QAAO,MAAM,KAAK,WAAW,qBAAqB,KAAK,MAAA,CAAO;AAGhE,QACE,kBAAkB,UAAA,KAClB,uBAAuB,WAAW,KAAA,EAElC,QAAO,MAAM,KACX,IAAI,gBAAgB;MAClB,OAAO,WAAW,MAAM,qBACtB,KAAK,QACL,GAAI,KAAK,SAAS,CAAC,EAAE,QAAQ,KAAK,OAAQ,CAAC,IAAG,CAAE,CAAA;MAElD,QAAQ,WAAW,UAAU,CAAE;MAC/B,QAAQ,WAAW;MACnB,iBAAiB,WAAW;IAC7B,CAAA,CAAA;AAIL,UAAM,IAAI,MACR,4GAA4G;EAE/G;EAGD,OAAO,sBACLC,gBAIAC,QACAC,QAEmC;AACnC,WAAOL,kBAAiB,aAGtB,gBAAgB;MAAE;MAAQ;IAAQ,CAAA;EACrC;AACF;;;ACzGD,IAAI,kBAAkB,CAAC;AACvBM,UAAS,iBAAiB;AAAA,EACzB,yBAAyB,MAAM;AAAA,EAC/B,wBAAwB,MAAM;AAAA,EAC9B,2BAA2B,MAAM;AAAA,EACjC,iCAAiC,MAAM;AAAA,EACvC,oBAAoB,MAAM;AAAA,EAC1B,0BAA0B,MAAM;AAAA,EAChC,2BAA2B,MAAM;AAAA,EACjC,oBAAoB,MAAM;AAAA,EAC1B,2BAA2B,MAAM;AAAA,EACjC,wBAAwB,MAAM;AAAA,EAC9B,oBAAoB,MAAM;AAAA,EAC1B,kCAAkC,MAAM;AAAA,EACxC,uBAAuB,MAAM;AAAA,EAC7B,4BAA4B,MAAM;AAAA,EAClC,qBAAqB,MAAM;AAAA,EAC3B,qBAAqB,MAAM;AAAA,EAC3B,wBAAwB,MAAM;AAAA,EAC9B,gBAAgB,MAAM;AAAA,EACtB,kBAAkB,MAAM;AAAA,EACxB,6BAA6B,MAAM;AAAA,EACnC,oBAAoB,MAAM;AAAA,EAC1B,oBAAoB,MAAM;AAAA,EAC1B,qBAAqB,MAAM;AAAA,EAC3B,cAAc,MAAM;AAAA,EACpB,eAAe,MAAM;AAAA,EACrB,eAAe,MAAMC;AAAA,EACrB,gBAAgB,MAAM;AACvB,CAAC;;;;;ACpCD,IAAsB,yBAAtB,MAA6C;EAiB3C,OAAO,yBAAyBC,GAAqC;AACnE,WAAO,GAAG,sBAAsB;EACjC;AACF;;;ACyBD,IAAaC,YAAyC;EACpD,KAAK;EACL,IAAI;EACJ,KAAK;AACN;AAED,IAAaC,cAA6C;EACxD,IAAI;EACJ,IAAI;EACJ,IAAI;EACJ,IAAI;EACJ,KAAK;EACL,KAAK;AACN;AAmCD,IAAsB,UAAtB,MAAmE;AAoBlE;AAMD,IAAsB,aAAtB,MAAiC;EAG/B,OAAOC,SAAkB;AACvB,QAAI,KAAK,aAAa,YACpB,QAAO,QAAQ,eAAe,IAAA;aACrB,KAAK,aAAa,aAC3B,QAAO,QAAQ,gBAAgB,IAAA;aACtB,KAAK,aAAa,kBAC3B,QAAO,QAAQ,qBAAqB,IAAA;QAEpC,OAAM,IAAI,MAAM,yBAAA;EAEnB;AACF;AAMD,IAAsB,kBAAtB,cAA8C,WAAW;AAAE;AAM3D,IAAa,aAAb,cAA8D,gBAAgB;EAC5E,WAAW;EAEX,YACSC,YACAC,WACAC,OACP;AACA,UAAA;AAJO,SAAA,aAAA;AACA,SAAA,YAAA;AACA,SAAA,QAAA;EAGR;AACF;AAMD,IAAa,YAAb,cAA+B,gBAAgB;EAC7C,WAAW;EAEX,YACSC,UACAC,MACP;AACA,UAAA;AAHO,SAAA,WAAA;AACA,SAAA,OAAA;EAGR;AACF;AAMD,IAAa,kBAAb,cAAqC,WAAW;EAC9C,WAAW;EAEX,YACSC,OACAC,QACP;AACA,UAAA;AAHO,SAAA,QAAA;AACA,SAAA,SAAA;EAGR;AACF;;;AC3LD,SAAgB,SAASC,KAAyB;AAChD,SAAO,OAAO,OAAO,QAAQ,YAAY,CAAC,MAAM,QAAQ,GAAA;AACzD;AAMD,SAAgB,cAEdC,QACqB;AACrB,MAAI,CAAC,OAAQ,QAAO;AAEpB,MAAI,OAAO,WAAW,YAAY,OAAO,SAAS,EAChD,QAAO;AAET,MAAI,OAAO,WAAW,WACpB,QAAO;AAET,SAAO,SAAS,MAAA,KAAW,OAAO,KAAK,MAAA,EAAQ,WAAW;AAC3D;AAKD,SAAgB,MAAMC,OAAyB;AAC7C,MAAI,OAAO,UAAU,SACnB,QAAO,QAAQ,MAAM;WACZ,OAAO,UAAU,UAAU;AACpC,UAAM,cAAc,SAAS,OAAO,EAAA;AACpC,WACE,CAAC,OAAO,MAAM,WAAA,KACd,cAAc,MAAM,KACpB,YAAY,SAAA,MAAe;EAE9B;AAED,SAAO;AACR;AAKD,SAAgB,QAAQA,OAAyB;AAC/C,MAAI,OAAO,UAAU,SACnB,QAAO,QAAQ,MAAM;WACZ,OAAO,UAAU,UAAU;AACpC,UAAM,cAAc,WAAW,KAAA;AAC/B,WACE,CAAC,OAAO,MAAM,WAAA,KACd,cAAc,MAAM,KACpB,YAAY,SAAA,MAAe;EAE9B;AAED,SAAO;AACR;AAMD,SAAgB,SAASA,OAAyB;AAChD,SACE,OAAO,UAAU,aAChB,OAAO,MAAM,WAAW,KAAA,CAAM,KAAK,WAAW,KAAA,EAAO,SAAA,MAAe;AAExE;AAKD,SAAgB,UAAUA,OAAyB;AACjD,SAAO,OAAO,UAAU;AACzB;AAQD,SAAgB,UAAUC,OAA2C;AACnE,MAAI;AACJ,MAAI,SAAS,KAAA,EACX,SAAQ;WACC,MAAM,KAAA,EACf,SAAQ,SAAS,OAAiB,EAAA;WACzB,QAAQ,KAAA,EACjB,SAAQ,WAAW,KAAA;WACV,UAAU,KAAA,EACnB,SAAQ,QAAQ,KAAA;MAEhB,OAAM,IAAI,MAAM,wBAAA;AAGlB,SAAO;AACR;;;ACvED,IAAsB,iBAAtB,cAEU,QAAW;AAuBpB;AAUD,IAAa,kBAAb,cAEU,eAAkB;EAO1B;EAEA;EAEA,YAAYC,MAAuB;AACjC,UAAA;AACA,SAAK,mBAAmB,MAAM,oBAAoB,CAChD,UAAU,KACV,UAAU,EACX;AACD,SAAK,qBAAqB,MAAM,sBAAsB;MACpD,YAAY;MACZ,YAAY;MACZ,YAAY;MACZ,YAAY;MACZ,YAAY;MACZ,YAAY;IACb;EACF;EAED,eAAeC,MAAqC;AAClD,QAAI,QAAQ,aACV;UACE,KAAK,mBAAmB,SAAS,KACjC,KAAK,mBAAmB,QAAQ,IAAA,MAAwB,GAExD,OAAM,IAAI,MACR,cAAc,IAAA,sCAA0C,KAAK,mBAAmB,KAC9E,IAAA,CACD,EAAE;IAEN,WACQ,QAAQ,WACjB;UACE,KAAK,iBAAiB,SAAS,KAC/B,KAAK,iBAAiB,QAAQ,IAAA,MAAsB,GAEpD,OAAM,IAAI,MACR,YAAY,IAAA,oCAAwC,KAAK,iBAAiB,KACxE,IAAA,CACD,EAAE;IAEN,MAED,OAAM,IAAI,MAAM,gCAAA;AAElB,WAAO,IAAI,IAAA;EACZ;;;;;;EAOD,eAAeC,WAAoD;AACjE,UAAM,OAAO,UAAU,MAAM,IAAI,CAAC,QAChC,IAAI,OAAO,IAAA,CAAK;AAElB,WAAO,EAAA,CACJ,KAAK,eAAe,UAAU,QAAA,CAAS,GAAG,KAC5C;EACF;;;;;;EAOD,gBAAgBC,YAAuD;AACrE,WAAO,EAAA,CACJ,WAAW,SAAA,GAAY,EAAA,CACrB,KAAK,eAAe,WAAW,UAAA,CAAW,GAAG,UAC5C,WAAW,KAAA,EAEd,EACF;EACF;;;;;;EAOD,qBACEC,OACoC;AACpC,QAAI,UAAU,CAAE;AAChB,QAAI,MAAM,OACR,WAAU,EACR,QAAQ,MAAM,OAAO,OAAO,IAAA,EAC7B;AAEH,WAAO;EACR;EAED,aACEC,eACAC,iBACA,YAAY,OACZ,qBAAqB,OAC+B;AACpD,QAAI,cAAc,aAAA,KAAkB,cAAc,eAAA,EAChD,QAAO;AAET,QAAI,cAAc,aAAA,KAAkB,cAAc,WAAW;AAC3D,UAAI,cAAc,eAAA,EAChB,QAAO;AAET,aAAO;IACR;AACD,QAAI,cAAc,eAAA,GAAkB;AAClC,UAAI,mBACF,QAAO;AAET,UAAI,cAAc,MAChB,QAAO;AAET,aAAO;IACR;AACD,QAAI,cAAc,MAChB,QAAO,EACL,MAAM,CAAC,eAAe,eAAgB,EACvC;aACQ,cAAc,KACvB,QAAO,EACL,KAAK,CAAC,eAAe,eAAgB,EACtC;QAED,OAAM,IAAI,MAAM,oBAAA;EAEnB;AACF;;;AClKD,IAAa,uBAAb,cAA0C,eAAe;EASvD,mBAA+B,CAAC,UAAU,KAAK,UAAU,EAAG;EAE5D,qBAAmC;IACjC,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;EACb;EAED,iBAAyB;AACvB,UAAM,IAAI,MAAM,iBAAA;EACjB;;;;;;EAOD,6BAA6BC,WAAiC;AAC5D,YAAQ,WAAR;MACE,KAAK;AACH,eAAO;UACL,YAAY;UACZ,YAAY;UACZ,YAAY;UACZ,YAAY;UACZ,YAAY;UACZ,YAAY;QACb;MAEH,KAAK;AACH,eAAO;UACL,YAAY;UACZ,YAAY;UACZ,YAAY;UACZ,YAAY;UACZ,YAAY;UACZ,YAAY;QACb;MAEH,KAAK;AACH,eAAO,CAAC,YAAY,IAAI,YAAY,EAAG;MAEzC;AACE,cAAM,IAAI,MAAM,0BAA0B,SAAA,EAAW;IAExD;EACF;;;;;;;EAQD,sBACEC,YACkD;AAClD,YAAQ,YAAR;MACE,KAAK,YAAY;AACf,eAAO,CAACC,GAAoBC,MAAoB,MAAM;MAExD,KAAK,YAAY;AACf,eAAO,CAACD,GAAoBC,MAAoB,MAAM;MAExD,KAAK,YAAY;AACf,eAAO,CAACD,GAAoBC,MAAoB,IAAI;MAEtD,KAAK,YAAY;AACf,eAAO,CAACD,GAAoBC,MAAoB,KAAK;MAEvD,KAAK,YAAY;AACf,eAAO,CAACD,GAAoBC,MAAoB,IAAI;MAEtD,KAAK,YAAY;AACf,eAAO,CAACD,GAAoBC,MAAoB,KAAK;MAEvD;AACE,cAAM,IAAI,MAAM,oBAAA;IAEnB;EACF;;;;;;;EAQD,oBAAoBC,UAAyD;AAC3E,YAAQ,UAAR;MACE,KAAK,UAAU;AACb,eAAO,CAAC,GAAG,MAAM,KAAK;MAExB,KAAK,UAAU;AACb,eAAO,CAAC,GAAG,MAAM,KAAK;MAExB;AACE,cAAM,IAAI,MAAM,kBAAA;IAEnB;EACF;;;;;;;EAQD,eAAeC,WAAoD;AACjE,UAAM,EAAE,UAAU,KAAA,IAAS;AAC3B,QAAI,KAAK,iBAAiB,SAAS,QAAA,GAAW;AAC5C,YAAM,mBAAmB,KAAK,oBAAoB,QAAA;AAClD,aAAO,CAACC,aAAuB;AAC7B,YAAI,CAAC,KACH,QAAO;AAGT,eAAO,KAAK,OAAO,CAAC,KAAK,QAAQ;AAC/B,gBAAM,SAAS,IAAI,OAAO,IAAA;AAC1B,cAAI,OAAO,WAAW,WACpB,QAAO,iBAAiB,KAAK,OAAO,QAAA,CAAS;cAE7C,OAAM,IAAI,MAAM,0BAAA;QAEnB,GAAE,IAAA;MACJ;IACF,MACC,OAAM,IAAI,MAAM,sBAAA;EAEnB;;;;;;;EAQD,gBACEC,YAC+B;AAC/B,UAAM,EAAE,YAAY,WAAW,MAAA,IAAU;AACzC,UAAM,gBAAgB,CAAC,YAAY,EAAG;AACtC,QAAI,KAAK,mBAAmB,SAAS,UAAA,GAAa;AAChD,UACE,CAAC,KAAK,6BAA6B,OAAO,KAAA,EAAO,SAAS,UAAA,EAE1D,OAAM,IAAI,MACR,IAAI,UAAA,4CAAsD,OAAO,KAAA,EAAO;AAG5E,YAAM,qBAAqB,KAAK,sBAAsB,UAAA;AACtD,aAAO,CAACD,aAAuB;AAC7B,cAAM,gBAAgB,SAAS,SAAS,SAAA;AACxC,YAAI,kBAAkB,QAAW;AAC/B,cAAI,cAAc,SAAS,UAAA,EACzB,QAAO;AAET,iBAAO;QACR;AACD,eAAO,mBAAmB,eAAe,UAAU,KAAA,CAAM;MAC1D;IACF,MACC,OAAM,IAAI,MAAM,wBAAA;EAEnB;;;;;;EAOD,qBACEE,OACoC;AACpC,QAAI,CAAC,MAAM,OACT,QAAO,CAAE;AAEX,UAAM,iBAAiB,MAAM,QAAQ,OAAO,IAAA;AAC5C,QAAI,OAAO,mBAAmB,WAC5B,OAAM,IAAI,MAAM,2CAAA;AAElB,WAAO,EAAE,QAAQ,eAAkC;EACpD;;;;;;;;EASD,aACEC,eACAC,iBACA,YAAY,OACgB;AAC5B,QAAI,cAAc,aAAA,KAAkB,cAAc,eAAA,EAChD,QAAO;AAET,QAAI,cAAc,aAAA,KAAkB,cAAc,WAAW;AAC3D,UAAI,cAAc,eAAA,EAChB,QAAO;AAET,aAAO;IACR;AACD,QAAI,cAAc,eAAA,GAAkB;AAClC,UAAI,cAAc,MAChB,QAAO;AAET,aAAO;IACR;AAED,QAAI,cAAc,MAChB,QAAO,CAACJ,aACN,cAAc,QAAA,KAAa,gBAAgB,QAAA;aACpC,cAAc,KACvB,QAAO,CAACA,aACN,cAAc,QAAA,KAAa,gBAAgB,QAAA;QAE7C,OAAM,IAAI,MAAM,oBAAA;EAEnB;AACF;;;AC/QD,IAAI,2BAA2B,CAAC;AAChCK,UAAS,0BAA0B;AAAA,EAClC,gBAAgB,MAAM;AAAA,EACtB,iBAAiB,MAAM;AAAA,EACvB,aAAa,MAAM;AAAA,EACnB,YAAY,MAAM;AAAA,EAClB,YAAY,MAAM;AAAA,EAClB,iBAAiB,MAAM;AAAA,EACvB,sBAAsB,MAAM;AAAA,EAC5B,WAAW,MAAM;AAAA,EACjB,WAAW,MAAM;AAAA,EACjB,iBAAiB,MAAM;AAAA,EACvB,SAAS,MAAM;AAAA,EACf,WAAW,MAAM;AAAA,EACjB,WAAW,MAAM;AAAA,EACjB,eAAe,MAAM;AAAA,EACrB,SAAS,MAAM;AAAA,EACf,OAAO,MAAM;AAAA,EACb,UAAU,MAAM;AAAA,EAChB,UAAU,MAAM;AACjB,CAAC;;;AC+VD,SAAgB,iBACdC,OACiC;AACjC,SACEC,UAAS,UACT,MAAM,QAASA,MAAiC,YAAA;AAEnD;AAQD,SAAgB,mBAAmBC,OAA0C;AAC3E,SACED,UAAS,UACT,SAAS,WAAWA,KAAA,KACpB,aAAaA,MAAK,eAClB,OAAOA,MAAK,YAAY,YAAY,cACpCA,MAAK,YAAY,QAAA,MAAc;AAElC;AAQD,SAAgB,uBACdC,OAC8B;AAC9B,SACE,CAAC,CAACD,SACF,OAAOA,UAAS,YAChB,UAAUA,SACV,YAAYA,UAEX,mBAAmBA,MAAK,MAAA,KACtBA,MAAK,UAAU,QACd,OAAOA,MAAK,WAAW,YACvB,UAAUA,MAAK,UACf,OAAOA,MAAK,OAAO,SAAS,YAC5B;IAAC;IAAQ;IAAW;IAAU;IAAS;IAAU;EAAS,EAAC,SACzDA,MAAK,OAAO,IAAA;AAGrB;AAUD,SAAgB,gBAAgBC,OAA8C;AAC5E,SACE,uBAAuBD,KAAA,KACvB,mBAAmBA,KAAA,KAEnB,iBAAiBA,KAAA;AAEpB;;;AC5bD,IAAAE,oBAAA;AAAA,SAAAA,mBAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAAC;AAAA,EAAA;AAAA;AAAA,kBAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAAC;AAAA,EAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAAC;AAAA,EAAA,gBAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAAC;AAAA,EA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",
  "names": ["__export", "msg: BaseMessage", "types: MessageTypeOrClass[]", "messagesOrOptions?: BaseMessage[] | FilterMessagesFields", "options?: FilterMessagesFields", "input: BaseMessage[]", "messages: BaseMessage[]", "options: FilterMessagesFields", "filtered: BaseMessage[]", "messages?: BaseMessage[]", "merged: BaseMessage[]", "messagesOrOptions: BaseMessage[] | TrimMessagesFields", "options?: TrimMessagesFields", "options: TrimMessagesFields", "listTokenCounter: (msgs: BaseMessage[]) => Promise<number>", "msgs: BaseMessage[]", "textSplitterFunc: (text: string) => Promise<string[]>", "text: string", "options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    partialStrategy?: \"first\" | \"last\";\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }", "text: string | undefined", "options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    /**\n     * @default {false}\n     */\n    allowPartial?: boolean;\n    /**\n     * @default {false}\n     */\n    includeSystem?: boolean;\n    startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }", "_MSG_CHUNK_MAP: Record<\n  MessageType,\n  {\n    message: MessageUnion;\n    messageChunk: MessageChunkUnion;\n  }\n>", "messageType: MessageType", "fields: BaseMessageFields", "returnChunk?: boolean", "chunk: BaseMessageChunk | undefined", "msg: BaseMessage | undefined", "aiChunkFields: AIMessageChunkFields", "chunk: BaseMessageChunk", "KNOWN_BLOCK_TYPES", "KNOWN_BLOCK_TYPES", "KNOWN_TOOL_BLOCK_TYPES", "KNOWN_MULTIMODAL_BLOCK_TYPES", "__export", "value: string", "fields: BaseMessage[] | ChatPromptValueFields", "fields: ImageContent | ImagePromptValueFields", "index", "blocks", "hex", "arr", "__export", "defaultHashKeyEncoder: HashKeyEncoder", "storedGeneration: StoredGeneration", "generation: Generation", "serializedValue: StoredGeneration", "keyEncoderFn: HashKeyEncoder", "InMemoryCache", "map?: Map<string, T>", "map", "prompt: string", "llmKey: string", "value: T", "modelName: string", "modelName?: string", "tool: unknown", "tool", "params: BaseLangChainParams", "content: MessageContent", "textContent: string", "input: BaseLanguageModelInput", "config", "params: Record<string, any>", "_data: SerializedLLM", "fields?: { func?: RunnablePassthroughFunc<RunInput> }", "input: RunInput", "options?: Partial<RunnableConfig>", "config", "input", "generator: AsyncGenerator<RunInput>", "options: Partial<RunnableConfig>", "finalOutput: RunInput | undefined", "input: AsyncGenerator<RunInput>", "mapping: RunnableMapLike<RunInput, RunOutput>", "iife", "fn: () => T", "message: T", "messages: BaseMessage[]", "messagesToTrace: BaseMessage[]", "BaseChatModel", "fields: BaseChatModelParams", "iife", "options?: Partial<CallOptions>", "input: BaseLanguageModelInput", "options?: CallOptions", "_messages: BaseMessage[]", "_options: this[\"ParsedCallOptions\"]", "_runManager?: CallbackManagerForLLMRun", "generationChunk: ChatGenerationChunk | undefined", "llmOutput: Record<string, any> | undefined", "options: this[\"ParsedCallOptions\"]", "messages: BaseMessageLike[][]", "parsedOptions: this[\"ParsedCallOptions\"]", "handledOptions: RunnableConfig", "startedRunManagers?: CallbackManagerForLLMRun[]", "runManagers: CallbackManagerForLLMRun[] | undefined", "generations: ChatGeneration[][]", "llmOutputs: LLMResult[\"llmOutput\"][]", "output: LLMResult", "missingPromptIndices: number[]", "index", "generations: Generation[][]", "result", "options?: string[] | CallOptions", "callbacks?: Callbacks", "parsedOptions: CallOptions | undefined", "_options?: this[\"ParsedCallOptions\"]", "promptValues: BasePromptValueInterface[]", "promptMessages: BaseMessage[][]", "outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>", "config?: StructuredOutputMethodOptions<boolean>", "config", "schema: Record<string, any> | InteropZodType<RunOutput>", "tools: ToolDefinition[]", "input: BaseMessageChunk", "input: any", "runManager?: CallbackManagerForLLMRun", "fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }", "input: RunInput", "options?: Partial<RunnableConfig>", "inputs: RunInput[]", "options?: Partial<RunnableConfig> | Partial<RunnableConfig>[]", "batchOptions?: RunnableBatchOptions", "i", "fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }", "branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>,\n    ]", "coercedBranches: Branch<RunInput, RunOutput>[]", "input: RunInput", "config?: Partial<RunnableConfig>", "runManager?: CallbackManagerForChainRun", "config", "config: RunnableConfig", "fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>", "historyChain: Runnable", "config", "inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>", "outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>", "input: any", "kwargs?: RunnableConfig", "run: Run", "config: RunnableConfig", "__export", "className: string", "config", "e: unknown", "model: string", "modelProvider?: string", "params: Record<string, any>", "modelName: string", "ConfigurableModel", "fields: ConfigurableModelFields", "config?: RunnableConfig", "messages: BaseMessage[]", "options?: this[\"ParsedCallOptions\"]", "runManager?: CallbackManagerForLLMRun", "tools: BindToolsInput[]", "params?: Record<string, any>", "modelParams: Record<string, any>", "str: string", "prefix: string", "mergedConfig: RunnableConfig", "remainingConfig: RunnableConfig", "input: RunInput", "options?: CallOptions", "inputs: RunInput[]", "options?: Partial<CallOptions> | Partial<CallOptions>[]", "batchOptions?: RunnableBatchOptions", "generator: AsyncGenerator<RunInput>", "options: CallOptions", "options?: Partial<CallOptions>", "streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">", "options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    }", "streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">", "model?: string", "fields?: Partial<Record<string, any>> & {\n    modelProvider?: string;\n    configurableFields?: string[] | \"any\";\n    configPrefix?: string;\n    profile?: ModelProfile;\n  }", "paramsCopy: Record<string, any>", "configurableModel: ConfigurableModel<RunInput, CallOptions>", "ERROR", "optionalImportEntrypoints: string[]", "messages: BaseMessage[]", "message: string", "messages?: BaseMessage[]", "message: BaseMessage", "params: EmbeddingsParams", "values: InputValues | OutputValues", "key?: string", "inputValues: InputValues", "inputKey?: string", "outputValues: OutputValues", "outputKey?: string", "inputs: Record<string, unknown>", "memoryVariables: string[]", "keys: string[]", "keyValuePairs: [string, T][]", "prefix?: string | undefined", "fields?: BaseRetrieverInput", "_query: string", "_callbacks?: CallbackManagerForRetrieverRun", "input: string", "options?: RunnableConfig", "fields: VectorStoreRetrieverInput<V>", "query: string", "runManager?: CallbackManagerForRetrieverRun", "documents: DocumentInterface[]", "options?: AddDocumentOptions", "embeddings: EmbeddingsInterface", "dbConfig: Record<string, any>", "_params?: Record<string, any>", "filter: this[\"FilterType\"] | undefined", "_callbacks: Callbacks | undefined", "_texts: string[]", "_metadatas: object[] | object", "_embeddings: EmbeddingsInterface", "_dbConfig: Record<string, any>", "_docs: DocumentInterface[]", "kOrFields?: number | Partial<VectorStoreRetrieverInput<this>>", "filter?: this[\"FilterType\"]", "callbacks?: Callbacks", "tags?: string[]", "metadata?: Record<string, unknown>", "verbose?: boolean", "_directory: string", "fields: LangSmithLoaderFields", "documents: DocumentInterface[]", "metadata: KVMap", "x: string | KVMap", "llm: BaseLanguageModelInterface", "options?: BaseGetPromptAsyncOptions", "default_prompt: BasePromptTemplate", "conditionals: Array<\n      [\n        condition: (llm: BaseLanguageModelInterface) => boolean,\n        prompt: BasePromptTemplate,\n      ]\n    >", "text: string", "LengthBasedExampleSelector", "data: LengthBasedExampleSelectorInput", "example: Example", "v: number[]", "values: LengthBasedExampleSelector", "eg: Example", "eg: string", "inputVariables: Example", "examples: Example[]", "args: LengthBasedExampleSelectorInput", "values: Record<string, T>", "SemanticSimilarityExampleSelector", "data: SemanticSimilarityExampleSelectorInput<V>", "example: Example", "inputVariables: Record<string, T>", "examples: Record<string, string>[]", "embeddings: Embeddings", "vectorStoreCls: C", "options: {\n      k?: number;\n      inputKeys?: string[];\n    } & Parameters<C[\"fromTexts\"]>[3]", "__export", "fields: HashedDocumentArgs", "keyEncoderFn: HashKeyEncoder", "document: DocumentInterface", "uid?: string", "inputString: string", "uuidv5", "data: Record<string, unknown>", "size: number", "iterable: T[]", "batches: T[][]", "currentBatch: T[]", "hashedDocuments: HashedDocumentInterface[]", "deduplicated: HashedDocumentInterface[]", "sourceIdKey: StringOrDocFunc | null", "_doc: DocumentInterface", "doc: DocumentInterface", "arg: any", "args: IndexArgs", "index", "uids: string[]", "docsToIndex: DocumentInterface[]", "docsToUpdate: string[]", "__export", "BaseLLM", "input: BaseLanguageModelInput", "options?: CallOptions", "_input: string", "_options: this[\"ParsedCallOptions\"]", "_runManager?: CallbackManagerForLLMRun", "options?: Partial<CallOptions>", "promptValues: BasePromptValueInterface[]", "options?: string[] | CallOptions", "callbacks?: Callbacks", "prompts: string[]", "_options?: this[\"ParsedCallOptions\"]", "llmResult: LLMResult", "llmResults: LLMResult[]", "parsedOptions: this[\"ParsedCallOptions\"]", "handledOptions: BaseCallbackConfig", "startedRunManagers?: CallbackManagerForLLMRun[]", "runManagers: CallbackManagerForLLMRun[] | undefined", "output: LLMResult", "flattenedOutputs: LLMResult[]", "missingPromptIndices: number[]", "index", "generations: Generation[][]", "result", "parsedOptions: CallOptions | undefined", "options: this[\"ParsedCallOptions\"]", "runManager?: CallbackManagerForLLMRun", "__export", "generations: Generation[] | ChatGeneration[]", "_prompt: BasePromptValueInterface", "callbacks?: Callbacks", "message: BaseMessage", "content: ContentBlock[]", "input: string | BaseMessage", "options?: RunnableConfig", "input: string", "options", "input", "input: BaseMessage", "text: string", "message: string", "llmOutput?: string", "observation?: string", "inputGenerator: AsyncGenerator<string | BaseMessage>", "options: BaseCallbackConfig", "fields?: BaseCumulativeTransformOutputParserInput", "prevParsed: T | undefined", "accGen: GenerationChunk | undefined", "chunkGen: GenerationChunk", "text: string", "inputGenerator: AsyncGenerator<string | BaseMessage>", "text: string", "text: string", "content: ContentBlock.Text", "_content: ContentBlock.Data.URLContentBlock", "content: ContentBlock", "content: ContentBlock[]", "acc: string", "item: ContentBlock", "schema: T", "schemas: S", "text: string", "json", "options?: JsonMarkdownFormatInstructionsOptions", "schemaInput: JsonSchema7Type", "nullable", "type: string", "type", "description", "first: T", "second: T", "prev: unknown | undefined", "next: unknown", "generations: ChatGeneration[] | Generation[]", "text: string", "message: BaseMessage", "sax: any", "sax", "isWhitespace", "s", "n", "index", "fields?: XMLOutputParserFields", "prev: unknown | undefined", "next: unknown", "generations: ChatGeneration[] | Generation[]", "text: string", "input: ParsedResult", "result: XMLResult", "s: string", "parsedResult: ParsedResult", "elementStack: ParsedResult[]", "node: any", "text: any", "attr: any", "__export", "config?: { argsOnly?: boolean }", "config", "generations: Generation[] | ChatGeneration[]", "config?: { argsOnly?: boolean } & BaseCumulativeTransformOutputParserInput", "prev: unknown | undefined", "next: unknown", "generations: ChatGeneration[]", "text: string", "fields: { attrName: string }", "__export", "rawToolCall: Record<string, any>", "options?: { returnId?: boolean; partial?: boolean }", "e: any", "parsedToolCall: ToolCall", "toolCall: ToolCall", "errorMsg?: string", "fields?: JsonOutputToolsParserParams", "generations: ChatGeneration[]", "generations: ChatGenerationChunk[] | ChatGeneration[]", "rawToolCall: Record<string, unknown>", "backwardsCompatibleToolCall: ParsedToolCall", "params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>", "result: unknown", "result: ParsedToolCall", "returnedValues: ParsedToolCall[] | Record<string, any>[]", "__export", "input: BasePromptTemplateInput", "userVariables: TypedPromptInputValues<RunInput>", "partialValues: Record<string, string>", "input: RunInput", "options?: BaseCallbackConfig", "input", "values: TypedPromptInputValues<RunInput>", "object", "string", "index", "view", "context", "set", "config", "symbol", "clearCache", "parse", "render", "template: string", "nodes: ParsedTemplateNode[]", "bracket: \"}\" | \"{\" | \"{}\"", "start: number", "i", "template: mustache.TemplateSpans", "context: string[]", "context", "values: InputValues", "DEFAULT_FORMATTER_MAPPING: Record<TemplateFormat, Interpolator>", "DEFAULT_PARSER_MAPPING: Record<TemplateFormat, Parser>", "templateFormat: TemplateFormat", "inputValues: InputValues", "parseTemplate", "template: MessageContent", "inputVariables: string[]", "dummyInputs: InputValues", "e: any", "PromptTemplate", "input: PromptTemplateInput<RunInput, PartialVariableName>", "totalInputVariables: string[]", "values: TypedPromptInputValues<RunInput>", "examples: string[]", "suffix: string", "inputVariables: string[]", "template: T", "options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >", "parseTemplate", "values: PartialValues<NewPartialVariableName>", "data: SerializedPromptTemplate", "ImagePromptTemplate", "input: ImagePromptTemplateInput<RunInput, PartialVariableName>", "totalInputVariables: string[]", "values: PartialValues<NewPartialVariableName>", "values: TypedPromptInputValues<RunInput>", "formatted: Record<string, any>", "url", "output: ImageContent", "fields: {\n    template: Record<string, unknown>;\n    templateFormat?: TemplateFormat;\n  }", "values: TypedPromptInputValues<RunInput>", "values: TypedPromptInputValues<InputValues>", "template: Record<string, unknown>", "templateFormat: TemplateFormat", "inputVariables: Array<Extract<keyof InputValues, string>>", "parseTemplate", "inputs: TypedPromptInputValues<InputValues>", "formatted: Record<string, unknown>", "formattedV: Array<unknown>", "input: RunInput", "options?: BaseCallbackConfig", "input", "fields:\n      | Extract<keyof RunInput, string>\n      | MessagesPlaceholderFields<Extract<keyof RunInput, string>>", "values: TypedPromptInputValues<RunInput>", "e: any", "fields:\n      | MessageStringPromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<\n          InputValues<Extract<keyof RunInput, string>>,\n          string\n        >", "input: BasePromptTemplateInput<RunInput, PartialVariableName>", "fields:\n      | ChatMessagePromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<InputValues<Extract<keyof RunInput, string>>>", "role?: string", "values: RunInput", "template: T", "role: string", "options?: { templateFormat?: TemplateFormat }", "param: unknown", "fields: any", "additionalOptions?: _StringImageMessagePromptTemplateOptions", "inputVariables: Extract<keyof RunInput, string>[]", "content: MessageContent", "name: string", "template:\n      | string\n      | Array<\n          | string\n          | _TextTemplateParam\n          | _ImageTemplateParam\n          | Record<string, unknown>\n        >", "prompt: Array<\n      | PromptTemplate<InputValues>\n      | ImagePromptTemplate<InputValues>\n      | DictPromptTemplate\n    >", "imgTemplateObject: ImagePromptTemplate<InputValues>", "inputVariables: string[]", "parsedTemplate: ParsedTemplateNode[]", "item", "input: TypedPromptInputValues<RunInput>", "inputs: Record<string, any>", "additionalContentFields: ContentBlock | undefined", "baseMessagePromptTemplateLike: BaseMessagePromptTemplateLike", "messagePromptTemplateLike: BaseMessagePromptTemplateLike", "extra?: Extra", "templateData:\n    | string\n    | (\n        | string\n        | _TextTemplateParam\n        | _ImageTemplateParam\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        | Record<string, any>\n      )[]", "x: BaseMessagePromptTemplate | BaseMessage", "ChatPromptTemplate", "input: ChatPromptTemplateInput<RunInput, PartialVariableName>", "message: BaseMessage", "inputValues: InputValues<\n      PartialVariableName | Extract<keyof RunInput, string>\n    >", "resultMessages: BaseMessage[]", "inputValues: InputValues", "values: PartialValues<NewPartialVariableName>", "options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >", "promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[]", "extra?: Omit<\n      Extra,\n      \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n    >", "acc: Array<BaseMessagePromptTemplate | BaseMessage>", "FewShotPromptTemplate", "input: FewShotPromptTemplateInput", "totalInputVariables: string[]", "inputVariables: InputValues", "values: PartialValues<NewPartialVariableName>", "values: InputValues", "data: SerializedFewShotTemplate", "examples: Example[]", "FewShotChatMessagePromptTemplate", "fields: FewShotChatMessagePromptTemplateInput", "values: TypedPromptInputValues<RunInput>", "result: Record<string, any>", "messages: BaseMessage[]", "values: PartialValues<PartialVariableName>", "PipelinePromptTemplate", "input: PipelinePromptTemplateInput<PromptTemplateType>", "allValues: InputValues", "requiredValueNames: string[]", "values: InputValues", "values: PartialValues", "x: unknown", "StructuredPrompt", "input: StructuredPromptInput<RunInput, PartialVariableName>", "coerceable: RunnableLike<ChatPromptValueInterface, NewRunOutput>", "promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[]", "schema: StructuredPromptInput[\"schema\"]", "method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\"", "__export", "parseTemplate", "x: any", "Operators: { [key: string]: Operator }", "Comparators: { [key: string]: Comparator }", "visitor: Visitor", "comparator: Comparator", "attribute: string", "value: ValueTypes", "operator: Operator", "args?: FilterDirective[]", "query: string", "filter?: FilterDirective", "obj: any", "filter: ((q: any) => any) | object | string | undefined", "value: unknown", "input: unknown", "opts?: TranslatorOpts", "func: Operator | Comparator", "operation: Operation", "comparison: Comparison", "query: StructuredQuery", "defaultFilter: VisitorStructuredQueryResult[\"filter\"] | undefined", "generatedFilter: VisitorStructuredQueryResult[\"filter\"] | undefined", "inputType: string", "comparator: Comparator", "a: string | number", "b: ValueType[C]", "operator: Operator", "operation: Operation", "document: Document", "comparison: Comparison<string | number | boolean>", "query: StructuredQuery", "defaultFilter: FunctionFilter", "generatedFilter: FunctionFilter", "__export", "tool?: StructuredToolInterface | ToolDefinition | JSONSchema", "tool", "tool?: unknown", "external_exports", "date", "describe", "meta", "_null", "parse", "_undefined", "_void", "date", "describe", "meta", "_null", "_undefined", "_void", "issues", "parse", "def", "meta", "parse", "check", "json", "_undefined", "json", "_null", "json", "_void", "json", "date", "json", "output", "json", "json", "describe", "meta", "_null", "map", "ZodFirstPartyTypeKind", "zodSchema", "objectSchema", "bigint", "boolean", "date", "number", "string", "string", "number", "boolean", "bigint", "date", "fields?: ToolParams", "input: TInput", "config?: TConfig", "toolInput: Exclude<\n      StructuredToolCallInput<SchemaT, SchemaInputT>,\n      ToolCall\n    >", "enrichedConfig: ToolRunnableConfig", "config", "arg: TArg", "configArg?: TConfig", "tags?: string[]", "parsed: SchemaOutputT", "z4", "result", "toolCallId: string | undefined", "callbacks?: TConfig", "fields: DynamicToolInput<ToolOutputT>", "input: string", "runManager?: CallbackManagerForToolRun", "parentConfig?: ToolRunnableConfig", "fields: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT> & {\n      name: NameT;\n    }", "arg: Parameters<\n      DynamicStructuredToolInput<SchemaT, SchemaOutputT>[\"func\"]\n    >[0]", "parentConfig?: RunnableConfig", "func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>", "fields: ToolWrapperParams<SchemaT, NameT>", "listener: (() => void) | undefined", "params: {\n  content: TOutput;\n  name: string;\n  artifact?: unknown;\n  toolCallId?: string;\n  metadata?: Record<string, unknown>;\n}", "_stringify", "content: unknown", "run: BaseRun", "stream_exports", "arr: T[]", "chunkSize: number", "arr", "index", "strings: TemplateStringsArray", "value: unknown", "precedingText: string", "text: string", "minIndent: number | null", "stream: ReadableStream<Uint8Array> | AsyncIterable<any>", "onChunk: (arr: Uint8Array, flush?: boolean) => void", "e: any", "onLine: (line: Uint8Array, fieldLength: number, flush?: boolean) => void", "buffer: Uint8Array | undefined", "position: number", "fieldLength: number", "arr: Uint8Array", "flush?: boolean", "arr", "concat", "onMessage?: (msg: EventSourceMessage) => void", "onId?: (id: string) => void", "onRetry?: (retry: number) => void", "line: Uint8Array", "a: Uint8Array", "b: Uint8Array", "stream: ReadableStream", "onMetadataEvent?: (e: unknown) => unknown", "message: EventSourceMessage", "tool: StructuredToolInterface | RunnableToolLike | StructuredToolParams", "fields?:\n    | {\n        /**\n         * If `true`, model output is guaranteed to exactly match the JSON Schema\n         * provided in the function definition.\n         */\n        strict?: boolean;\n      }\n    | number", "tool", "tool: StructuredToolInterface | Record<string, any> | RunnableToolLike", "toolDef: ToolDefinition | undefined", "a: number[]", "b: number[]", "a: number[]", "b: number[]", "p: number[]", "q: number[]", "X: number[][]", "Y: number[][]", "func: VectorFunction", "M: number[][]", "innerProduct", "innerProductDistance", "queryEmbedding: number[] | number[][]", "embeddingList: number[][]", "array: number[]", "array", "arrays: number[][]", "messages: BaseMessage[]", "options?: this[\"ParsedCallOptions\"]", "runManager?: CallbackManagerForLLMRun", "FakeStreamingChatModel", "sleep", "tools: (StructuredTool | ToolSpec)[]", "_options: this[\"ParsedCallOptions\"]", "_runManager?: CallbackManagerForLLMRun", "generation: ChatResult", "_messages: BaseMessage[]", "options: this[\"ParsedCallOptions\"]", "FakeListChatModel", "params: FakeChatInput", "text: string", "generationInfo?: Record<string, any>", "_params:\n      | StructuredOutputMethodParams<RunOutput, boolean>\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>", "_config?: StructuredOutputMethodOptions<boolean>", "params?: SyntheticEmbeddingsParams", "documents: string[]", "document: string", "ret: number[]", "ret", "params?: EmbeddingsParams", "_: string", "fields: { response?: string; thrownErrorString?: string } & BaseLLMParams", "prompt: string", "_options: this[\"ParsedCallOptions\"]", "runManager?: CallbackManagerForLLMRun", "fields: {\n      sleep?: number;\n      responses?: string[];\n      thrownErrorString?: string;\n    } & BaseLLMParams", "input: string", "_options?: this[\"ParsedCallOptions\"]", "message: BaseMessage", "message: string", "run: Run", "text: string", "fields?: { output: Document[] }", "_query: string", "fields: { returnOptions?: boolean }", "input: string", "options?: Partial<BaseCallbackConfig>", "fields: FakeToolParams<T>", "arg: ToolInputSchemaOutputType<T>", "_runManager?: CallbackManagerForToolRun", "run: Run", "FakeVectorStore", "embeddings: EmbeddingsInterface", "documents: Document[]", "vectors: number[][]", "query: number[]", "k: number", "filter?: this[\"FilterType\"]", "memoryVector: MemoryVector", "index", "result: [Document, number][]", "texts: string[]", "metadatas: object[] | object", "dbConfig?: FakeVectorStoreArgs", "docs: Document[]", "__export", "__export", "__export", "base_exports", "stream_exports", "constructor: typeof Serializable", "aliases: { [key: string]: string }", "value: unknown", "record", "coreImportMap", "module:\n      | (typeof importMaps)[\"langchain_core\"][keyof (typeof importMaps)[\"langchain_core\"]]\n      | (typeof importMaps)[\"langchain\"][keyof (typeof importMaps)[\"langchain\"]]\n      | OptionalImportMap[keyof OptionalImportMap]\n      | null", "defaultOptionalImportEntrypoints", "optionalImportEntrypoints", "finalImportMap:\n        | (typeof importMaps)[\"langchain\"]\n        | (typeof importMaps)[\"langchain_core\"]", "importMapKey: string", "result: Record<string, unknown>", "text: string", "options?: LoadOptions", "json", "context: ReviverContext", "context", "revivedObj: any", "constructor: any", "_default", "WRITES_IDX_MAP: Record<string, number>", "ERROR", "BaseStore", "index", "matchConditions: MatchCondition[]", "BaseStore", "index", "BaseCache", "BinaryOperatorAggregate", "LastValue", "LastValueAfterFinish", "ERROR", "INTERRUPT", "RESUME", "TASKS", "index", "config", "n", "hex", "data", "config", "RESUME", "config", "ChannelWrite", "config", "TASKS", "ChannelRead", "config", "PregelNode", "candidate", "TASKS", "RESUME", "task", "ERROR", "INTERRUPT", "_coerceToDict", "patchConfigurable", "config", "config", "INTERRUPT", "task", "TASKS", "RESUME", "ERROR", "config", "call", "index", "config", "n", "INTERRUPT", "task", "ERROR", "rawValue", "config", "task", "BaseCache", "PregelLoop", "config", "patchConfigurable", "TASKS", "task", "ERROR", "INTERRUPT", "RESUME", "call", "meta", "config", "patchConfigurable", "writer", "task", "patchConfigurable", "call", "interrupt", "INTERRUPT", "RESUME", "ERROR", "INTERRUPT", "Topic", "TASKS", "config", "task", "ERROR", "INTERRUPT", "tasksWithWrites", "values", "nextConfig", "asNode", "tasks", "n", "context", "_coerceToDict", "EphemeralValue", "n", "writer", "config", "Graph", "args", "name", "interrupt", "DrawableGraph", "external_exports", "isUuid", "UntrackedValueChannel", "NamedBarrierValue", "NamedBarrierValueAfterFinish", "external_exports", "meta", "schema", "stateSchema", "args", "name", "config", "schema", "entrypoint", "toolNames: string[]", "toolName: string", "errors: string[]", "toolError: unknown", "toolCall: ToolCall", "MiddlewareError", "error: unknown", "middlewareName: string", "model: LanguageModelLike", "model: unknown", "ToolStrategy", "schema: Record<string, unknown>", "tool: {\n      type: \"function\";\n      function: FunctionDefinition;\n    }", "options?: ToolStrategyOptions", "tool", "schema: InteropZodObject | Record<string, unknown>", "outputOptions?: ToolStrategyOptions", "name?: string", "asJsonSchema", "functionDefinition: FunctionDefinition", "toolArgs: Record<string, unknown>", "ProviderStrategy", "schemaOrOptions:\n      | Record<string, unknown>\n      | { schema: Record<string, unknown>; strict?: boolean }", "strict?: boolean", "schema: InteropZodType<T> | Record<string, unknown>", "response: AIMessage", "textContent: string | undefined", "responseFormat?:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[]\n    | ResponseFormat\n    | ToolStrategy<any>[]\n    | ResponseFormatUndefined", "model?: LanguageModelLike | string", "responseFormat:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[]", "responseFormat:\n    | InteropZodType<unknown>\n    | JsonSchemaFormat\n    | { schema: InteropZodType<unknown> | JsonSchemaFormat; strict?: boolean }", "messages: BaseMessage[]", "textContent: string", "hook:\n    | BeforeAgentHook\n    | BeforeModelHook\n    | AfterAgentHook\n    | AfterModelHook\n    | undefined", "arg: BeforeAgentHook | BeforeModelHook | AfterAgentHook | AfterModelHook", "ms: number", "config: {\n    backoffFactor: number;\n    initialDelayMs: number;\n    maxDelayMs: number;\n    jitter: boolean;\n  }", "retryNumber: number", "config", "delay: number", "MIDDLEWARE_BRAND: unique symbol", "config: {\n  /**\n   * The name of the middleware\n   */\n  name: string;\n  /**\n   * The schema of the middleware state. Middleware state is persisted between multiple invocations. It can be either:\n   * - A Zod object (InteropZodObject)\n   * - A StateSchema from LangGraph (supports ReducedValue, UntrackedValue)\n   * - An AnnotationRoot\n   * - Undefined\n   */\n  stateSchema?: TSchema;\n  /**\n   * The schema of the middleware context. Middleware context is read-only and not persisted between multiple invocations. It can be either:\n   * - A Zod object\n   * - A Zod optional object\n   * - A Zod default object\n   * - Undefined\n   */\n  contextSchema?: TContextSchema;\n  /**\n   * Additional tools registered by the middleware.\n   */\n  tools?: TTools;\n  /**\n   * Wraps tool execution with custom logic. This allows you to:\n   * - Modify tool call parameters before execution\n   * - Handle errors and retry with different parameters\n   * - Post-process tool results\n   * - Implement caching, logging, authentication, or other cross-cutting concerns\n   * - Return Command objects for advanced control flow\n   *\n   * The handler receives a ToolCallRequest containing the tool call, state, and runtime,\n   * along with a handler function to execute the actual tool.\n   *\n   * @param request - The tool call request containing toolCall, state, and runtime.\n   * @param handler - The function that executes the tool. Call this with a ToolCallRequest to get the result.\n   * @returns The tool result as a ToolMessage or a Command for advanced control flow.\n   *\n   * @example\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   console.log(`Calling tool: ${request.tool.name}`);\n   *   console.log(`Tool description: ${request.tool.description}`);\n   *\n   *   try {\n   *     // Execute the tool\n   *     const result = await handler(request);\n   *     console.log(`Tool ${request.tool.name} succeeded`);\n   *     return result;\n   *   } catch (error) {\n   *     console.error(`Tool ${request.tool.name} failed:`, error);\n   *     // Could return a custom error message or retry\n   *     throw error;\n   *   }\n   * }\n   * ```\n   *\n   * @example Authentication\n   * ```ts\n   * wrapToolCall: async (request, handler) => {\n   *   // Check if user is authorized for this tool\n   *   if (!request.runtime.context.isAuthorized(request.tool.name)) {\n   *     return new ToolMessage({\n   *       content: \"Unauthorized to call this tool\",\n   *       tool_call_id: request.toolCall.id,\n   *     });\n   *   }\n   *   return handler(request);\n   * }\n   * ```\n   */\n  wrapToolCall?: WrapToolCallHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * Wraps the model invocation with custom logic. This allows you to:\n   * - Modify the request before calling the model\n   * - Handle errors and retry with different parameters\n   * - Post-process the response\n   * - Implement custom caching, logging, or other cross-cutting concerns\n   *\n   * The request parameter contains: model, messages, systemPrompt, tools, state, and runtime.\n   *\n   * @param request - The model request containing all the parameters needed.\n   * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response.\n   * @returns The response from the model (or a modified version).\n   *\n   * @example\n   * ```ts\n   * wrapModelCall: async (request, handler) => {\n   *   // Modify request before calling\n   *   const modifiedRequest = { ...request, systemPrompt: \"You are helpful\" };\n   *\n   *   try {\n   *     // Call the model\n   *     return await handler(modifiedRequest);\n   *   } catch (error) {\n   *     // Handle errors and retry with fallback\n   *     const fallbackRequest = { ...request, model: fallbackModel };\n   *     return await handler(fallbackRequest);\n   *   }\n   * }\n   * ```\n   */\n  wrapModelCall?: WrapModelCallHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n  /**\n   * The function to run before the agent execution starts. This function is called once at the start of the agent invocation.\n   * It allows to modify the state of the agent before any model calls or tool executions.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeAgent?: BeforeAgentHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * The function to run before the model call. This function is called before the model is invoked and before the `wrapModelCall` hook.\n   * It allows to modify the state of the agent.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  beforeModel?: BeforeModelHook<\n    TSchema,\n    NormalizeContextSchema<TContextSchema>\n  >;\n\n  /**\n   * The function to run after the model call. This function is called after the model is invoked and before any tools are called.\n   * It allows to modify the state of the agent after the model is invoked, e.g. to update tool call parameters.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterModel?: AfterModelHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n\n  /**\n   * The function to run after the agent execution completes. This function is called once at the end of the agent invocation.\n   * It allows to modify the final state of the agent after all model calls and tool executions are complete.\n   *\n   * @param state - The middleware state\n   * @param runtime - The middleware runtime\n   * @returns The modified middleware state or undefined to pass through\n   */\n  afterAgent?: AfterAgentHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n}", "middleware: AgentMiddleware<\n    TSchema,\n    TContextSchema,\n    NormalizeContextSchema<TContextSchema>,\n    TTools\n  >", "config", "FakeToolCallingModel", "index", "value: number", "tools: StructuredTool[]", "_schema: any", "messages: BaseMessage[]", "_options?: this[\"ParsedCallOptions\"]", "_runManager?: CallbackManagerForLLMRun", "z3", "z4", "registry", "stateSchema: TStateSchema", "middlewareList: TMiddleware", "stateFields: Record<string, any>", "inputFields: Record<string, any>", "outputFields: Record<string, any>", "schema: InteropZodObject | StateSchema<any>", "meta", "stateSchema", "stateSchema: unknown", "state: Record<string, unknown>", "stateSchema", "result: Record<string, unknown>", "message: T", "updatedContent: MessageContent", "updatedName: string | undefined", "tool: ClientTool | ServerTool", "tool", "llm: LanguageModelLike", "toolClasses: (ClientTool | ServerTool)[]", "options: Partial<BaseChatModelCallOptions>", "step: RunnableLike", "message?: BaseMessage", "systemPrompt?: string | SystemMessage", "model", "nextSteps: unknown[]", "handlers: WrapToolCallHook[]", "outer: WrapToolCallHook", "inner: WrapToolCallHook", "innerHandler: ToolCallHandler", "middleware: readonly AgentMiddleware<InteropZodObject | undefined>[]", "wrappedHandler: WrapToolCallHook", "wrappedInnerHandler: ToolCallHandler", "middlewareList: readonly AgentMiddleware[]", "state: unknown", "middlewareStates: Record<string, any>", "zodShape: Record<string, any>", "external_exports", "stateSchema?: z.ZodObject<z.ZodRawShape> | StateSchema<any>", "stateSchema", "shape: Record<string, any>", "privateShape: Record<string, any>", "schema: StateDefinitionInit", "partialShape: Record<string, any>", "fieldSchema: unknown", "target?: string", "RunnableCallable", "fields: RunnableCallableArgs<I, O>", "#state", "state: Awaited<O>", "input: I", "options?: Partial<RunnableConfig> | undefined", "model:\n    | LanguageModelLike\n    | Runnable<unknown, unknown, RunnableConfig<Record<string, unknown>>>", "agentNameMode: AgentNameMode", "processInputMessage: (message: BaseMessageLike) => BaseMessageLike", "processOutputMessage: (message: BaseMessage) => BaseMessage", "messages: BaseMessageLike[]", "response: unknown", "RunnableCallable", "options: AgentNodeOptions<StructuredResponseFormat, ContextSchema>", "config", "#run", "#options", "#systemMessage", "model: string | LanguageModelLike", "state: InternalAgentState<StructuredResponseFormat>", "config: RunnableConfig", "#invokeModel", "#areMoreStepsNeeded", "options: {\n      lastMessage?: string;\n    }", "#deriveModel", "request: ModelRequest", "#getResponseFormat", "#bindTools", "#currentSystemMessage", "call", "#handleMultipleStructuredOutputs", "toolStrategy", "#handleSingleStructuredOutput", "wrappedHandler: (\n      request: ModelRequest<\n        InternalAgentState<StructuredResponseFormat>,\n        unknown\n      >\n    ) => Promise<InternalModelResponse<StructuredResponseFormat>>", "request: ModelRequest<\n            InternalAgentState<StructuredResponseFormat>,\n            unknown\n          >", "context", "runtime: Runtime<unknown>", "requestWithStateAndRuntime: ModelRequest<\n            InternalAgentState<StructuredResponseFormat>,\n            unknown\n          >", "req: ModelRequest<\n              InternalAgentState<StructuredResponseFormat>,\n              unknown\n            >", "tool", "initialRequest: ModelRequest<\n      InternalAgentState<StructuredResponseFormat>,\n      unknown\n    >", "response: AIMessage", "toolCalls: ToolCall[]", "responseFormat: ToolResponseFormat", "#handleToolStrategyError", "toolCall: ToolCall", "lastMessage?: string", "error: ToolStrategyError", "response: BaseMessage", "model: LanguageModelLike", "preparedOptions: ModelRequest | undefined", "structuredResponseFormat: ResponseFormat | undefined", "options: Partial<BaseChatModelCallOptions>", "toolName: string", "availableTools: string[]", "input: unknown", "error: unknown", "toolCall: ToolCall", "RunnableCallable", "tools: (StructuredToolInterface | DynamicTool | RunnableToolLike)[]", "options?: ToolNodeOptions", "wrapToolCall", "config", "call: ToolCall", "isMiddlewareError: boolean", "call", "config: RunnableConfig", "state: AgentBuiltInState", "request: ToolCallRequest", "request", "tool", "e: unknown", "request: ToolCallRequest<AgentBuiltInState>", "#handleError", "state: ToAnnotationRoot<StateSchema>[\"State\"] & AgentBuiltInState", "outputs: (ToolMessage | Command)[]", "messages: BaseMessage[]", "toolMessageIds: Set<string>", "aiMessage: AIMessage | undefined", "combinedOutputs: (\n      | { messages: BaseMessage[] }\n      | BaseMessage[]\n      | Command\n    )[]", "parentCommand: Command | null", "x: unknown", "RunnableCallable", "fields: RunnableCallableArgs<TStateSchema, NodeOutput<TStateSchema>>", "options: MiddlewareNodeOptions", "#options", "invokeState: TStateSchema", "config?: LangGraphRunnableConfig", "relevantContext: Record<string, unknown>", "config", "state: TStateSchema", "runtime: Runtime<TContextSchema>", "jumpToConstraint: JumpToTarget[] | undefined", "constraint: string | undefined", "middleware: AgentMiddleware<\n      z.ZodObject<z.ZodRawShape>,\n      z.ZodObject<z.ZodRawShape>\n    >", "options: MiddlewareNodeOptions", "state: TStateSchema", "config?: RunnableConfig<TContextSchema>", "config", "runtime: Runtime<TContextSchema>", "middleware: AgentMiddleware<\n      z.ZodObject<z.ZodRawShape>,\n      z.ZodObject<z.ZodRawShape>\n    >", "options: MiddlewareNodeOptions", "state: TStateSchema", "config?: RunnableConfig<TContextSchema>", "config", "runtime: Runtime<TContextSchema>", "middleware: AgentMiddleware<\n      z.ZodObject<z.ZodRawShape>,\n      z.ZodObject<z.ZodRawShape>\n    >", "options: MiddlewareNodeOptions", "state: TStateSchema", "config?: RunnableConfig<TContextSchema>", "config", "runtime: Runtime<TContextSchema>", "middleware: AgentMiddleware<\n      z.ZodObject<z.ZodRawShape>,\n      z.ZodObject<z.ZodRawShape>\n    >", "options: MiddlewareNodeOptions", "state: TStateSchema", "config?: RunnableConfig<TContextSchema>", "config", "runtime: Runtime<TContextSchema>", "middleware: AgentMiddleware<InteropZodObject | undefined>", "node: AgentNode", "#nodes", "name: string", "options: CreateAgentParams<\n      Types[\"Response\"],\n      Types[\"State\"],\n      Types[\"Context\"]\n    >", "#toolBehaviorVersion", "tool", "beforeAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]", "beforeModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]", "afterModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]", "afterAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]", "wrapModelCallHookMiddleware: [\n      AgentMiddleware,\n      /**\n       * ToDo: better type to get the state of middleware\n       */\n      () => any,\n    ][]", "#agentNode", "beforeAgentNode: BeforeAgentNode | undefined", "beforeModelNode: BeforeModelNode | undefined", "afterModelNode: AfterModelNode | undefined", "afterAgentNode: AfterAgentNode | undefined", "#stateManager", "entryNode: string", "#createBeforeAgentRouter", "#createBeforeModelRouter", "#getModelPaths", "#createModelRouter", "#createAfterModelSequenceRouter", "#createAfterModelRouter", "#createToolsRouter", "#graph", "toolClasses: (ClientTool | ServerTool)[]", "includeModelRequest: boolean", "hasToolsAvailable: boolean", "paths: BaseGraphDestination[]", "shouldReturnDirect: Set<string>", "exitNode: string | typeof END", "state: Record<string, unknown>", "allowJump: boolean", "call", "allowed: string[]", "nextDefault: string", "#initializeMiddlewareStates", "state: InvokeStateParameter<Types>", "config: RunnableConfig", "config", "config?: InvokeConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>\n    >", "config?: StreamConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>,\n      TStreamMode,\n      TEncoding\n    >", "params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }", "config?: StreamConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>,\n      StreamMode | StreamMode[] | undefined,\n      \"text/event-stream\" | undefined\n    > & { version?: \"v1\" | \"v2\" }", "streamOptions?: Parameters<Runnable[\"streamEvents\"]>[2]", "config?: RunnableConfig", "options?: GetStateOptions", "options?: CheckpointListOptions", "namespace?: string", "recurse?: boolean", "inputConfig: LangGraphRunnableConfig", "values: Record<string, unknown> | unknown", "asNode?: string", "params: CreateAgentParams<\n    StructuredResponseFormat,\n    TStateSchema,\n    ContextSchema,\n    any\n  >", "options: NonNullable<HumanInTheLoopMiddlewareConfig>", "toolCall: ToolCall", "config: InterruptOnConfig", "state: AgentBuiltInState", "runtime: Runtime<unknown>", "config", "description: string", "actionRequest: ActionRequest", "reviewConfig: ReviewConfig", "decision: Decision", "resolvedConfigs: Record<string, InterruptOnConfig>", "interruptToolCalls: ToolCall[]", "autoApprovedToolCalls: ToolCall[]", "actionRequests: ActionRequest[]", "reviewConfigs: ReviewConfig[]", "hitlRequest: HITLRequest", "revisedToolCalls: ToolCall[]", "artificialToolMessages: ToolMessage[]", "jumpTo: JumpToTarget | undefined", "z", "contextSchema", "input: BaseLanguageModel", "options: SummarizationMiddlewareConfig", "z4", "trigger: ContextSize | ContextSize[] | undefined", "keep: ContextSize", "triggerConditions: ContextSize[]", "uuid", "messages: BaseMessage[]", "systemPrompt: SystemMessage | undefined", "conversationMessages: BaseMessage[]", "cutoffIndex: number", "totalTokens: number", "model: BaseLanguageModel", "tokenCounter: TokenCounter", "targetTokenCount: number", "messagesToKeep: number", "aiMessage: AIMessage", "aiMessageIndex: number", "toolCallIds: Set<string>", "messagesToSummarize: BaseMessage[]", "summaryPrompt: string", "trimTokensToSummarize: number | undefined", "runtime: Runtime<unknown>", "baseConfig: RunnableConfig", "config", "fn: DynamicSystemPromptMiddlewareConfig<TContextSchema>", "tools: StructuredToolInterface[]", "tool", "options: LLMToolSelectorConfig", "request: ModelRequest<TState, TContext>", "runtime: Runtime<LLMToolSelectorConfig>", "lastUserMessage: HumanMessage | undefined", "response: { tools: string[] }", "availableTools: StructuredToolInterface[]", "validToolNames: string[]", "selectedToolNames: string[]", "invalidToolSelections: string[]", "piiType: string", "matches: PIIMatch[]", "cardNumber: string", "match: RegExpMatchArray", "content: string", "match: RegExpMatchArray | null", "BUILT_IN_DETECTORS: Record<BuiltInPIIType, PIIDetector>", "config: RedactionRuleConfig", "detector: PIIDetector", "config", "masked: string", "hash", "strategy: PIIStrategy", "contextSchema", "rule: ResolvedRedactionRule", "piiType: BuiltInPIIType | string", "options: {\n    strategy?: PIIStrategy;\n    detector?: Detector;\n    applyToInput?: boolean;\n    applyToOutput?: boolean;\n    applyToToolResults?: boolean;\n  }", "lastUserIdx: number | null", "lastAiIdx: number | null", "lastAiMsg: AIMessage | null", "contextSchema", "text: string", "rules: Record<string, RegExp>", "redactionMap: RedactionMap", "message: BaseMessage", "config: ProcessHumanMessageConfig", "config", "newMessage", "options: PIIRedactionMiddlewareConfig", "structuredResponse: Record<string, unknown> | undefined", "call", "structuredResponse", "config: ClearToolUsesEditConfig", "trigger: ContextSize | ContextSize[] | undefined", "config", "keep: KeepSize | undefined", "#triggerConditions", "params: {\n    messages: BaseMessage[];\n    model: BaseLanguageModel;\n    countTokens: TokenCounter;\n  }", "orphanedIndices: number[]", "#findAIMessageForToolCall", "call", "#shouldEdit", "candidates: { idx: number; msg: ToolMessage }[]", "#determineKeepCount", "#buildClearedToolInputMessage", "messages: BaseMessage[]", "totalTokens: number", "model: BaseLanguageModel", "candidates: Array<{ idx: number; msg: ToolMessage }>", "countTokens: TokenCounter", "previousMessages: BaseMessage[]", "toolCallId: string", "message: AIMessage", "config: ContextEditingMiddlewareConfig", "toolName: string | undefined", "threadCount: number", "runCount: number", "threadLimit: number | undefined", "runLimit: number | undefined", "exceededLimits: string[]", "z", "options: ToolCallLimitConfig", "z4", "toolCall: { name?: string }", "toolCalls: ToolCall[]", "allowed: ToolCall[]", "blocked: ToolCall[]", "blocked", "allowed", "artificialMessages: Array<ToolMessage | AIMessage>", "otherTools: ToolCall[]", "stateSchema", "options?: TodoListMiddlewareOptions", "config", "DEFAULT_EXIT_BEHAVIOR", "contextSchema", "stateSchema", "exceededHint: string[]", "middlewareOptions?: ModelCallLimitMiddlewareConfig", "error: ZodError", "z4", "config: ModelRetryMiddlewareConfig", "success", "config", "error: Error", "error", "attemptsMade: number", "content: string", "config: ToolRetryMiddlewareConfig", "success", "config", "toolFilter: string[]", "tool", "toolName: string", "error: Error", "error", "attemptsMade: number", "toolCallId: string", "content: string", "options: ToolEmulatorOptions", "agentModel: BaseChatModel | undefined", "tool", "emulatorModel: BaseChatModel | undefined", "model: unknown", "options: OpenAIModerationMiddlewareOptions", "openaiModel: OpenAIModel | undefined", "message: BaseMessage", "messages: BaseMessage[]", "messageType: typeof AIMessage | typeof HumanMessage | typeof ToolMessage", "content: string", "result: ModerationResult", "categories: string[]", "input: string | string[]", "params?: { model?: ModerationModel; options?: unknown }", "moderationModel", "index: number | null", "stage: ViolationStage", "index", "contextSchema", "message: string", "middlewareOptions?: PromptCachingMiddlewareConfig", "src_exports", "__export"]
}
